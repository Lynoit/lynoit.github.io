<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>4× USB Webcam Recorder</title>
<style>
  /* ---- GitHub Dark (Primer-ish) tokens ---- */
  :root{
    /* Canvas / surfaces */
    --bg-canvas:   #0d1117;  /* page */
    --bg-subtle:   #161b22;  /* panels, toolbars */
    --bg-muted:    #0d1117;  /* inputs */
    --bg-inset:    #0d1117;

    /* Text */
    --fg-default:  #c9d1d9;
    --fg-muted:    #8b949e;

    /* Borders & overlays */
    --border:      #30363d;
    --shadow:      0 1px 0 rgba(1,4,9,.1), 0 8px 24px rgba(1,4,9,.2);

    /* Accents */
    --accent:      #58a6ff;
    --focus:       #1f6feb;

    /* Buttons */
    --btn-bg:          #21262d;
    --btn-bg-hover:    #30363d;
    --btn-border:      #30363d;
    --btn-fg:          #c9d1d9;

    --btn-primary-bg:        #238636;
    --btn-primary-bg-hover:  #2ea043;
    --btn-primary-border:    rgba(240,246,252,.1);
    --btn-primary-fg:        #fff;

    --btn-danger-bg:        #da3633;
    --btn-danger-bg-hover:  #b62324;
    --btn-danger-fg:        #fff;

    /* Misc */
    --radius: 6px;
    --gap: 12px;
  }

  /* ---- Base ---- */
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    background: var(--bg-canvas);
    color: var(--fg-default);
  }
  a { color: var(--accent); text-decoration: none; }
  a:hover { text-decoration: underline; }

  /* ---- Topbar / sections ---- */
  header.topbar {
    padding: 12px 16px;
    background: var(--bg-subtle);
    border-bottom: 1px solid var(--border);
  }
  h1 { margin: 0; font-size: 16px; font-weight: 600; letter-spacing: .2px; }

  #controls {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: var(--gap);
    padding: 12px 16px;
    background: var(--bg-subtle);
    border-bottom: 1px solid var(--border);
  }

  .camctl {
    background: var(--bg-canvas);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 12px;
    display: grid;
    gap: 8px;
    box-shadow: var(--shadow);
  }
  label { font-size: 12px; color: var(--fg-muted); }

  /* ---- Inputs & buttons ---- */
  select, button, input[type="range"] {
    width: 100%;
    border-radius: var(--radius);
    border: 1px solid var(--btn-border);
    background: var(--btn-bg);
    color: var(--btn-fg);
    padding: 8px 10px;
    transition: background-color .12s ease, border-color .12s ease, box-shadow .12s ease, transform .02s ease;
  }
  select:hover, button:hover { background: var(--btn-bg-hover); }
  select:focus, button:focus, input[type="range"]:focus {
    outline: 2px solid var(--focus);
    outline-offset: 2px;
  }

  button { cursor: pointer; }
  button:active { transform: translateY(1px); }
  button:disabled { opacity: .6; cursor: not-allowed; }

/* Primary now styled like neutral buttons */
button.primary {
  background: var(--btn-bg);
  border-color: var(--btn-border);
  color: var(--btn-fg);
}
button.primary:hover { background: var(--btn-bg-hover); }

  button.danger {
    background: var(--btn-danger-bg);
    border-color: var(--btn-danger-bg);
    color: var(--btn-danger-fg);
  }
  button.danger:hover { background: var(--btn-danger-bg-hover); }

  /* Toolbar */
  #global {
    display: flex;
    gap: var(--gap);
    padding: 10px 16px;
    align-items: center;
    background: var(--bg-subtle);
    border-bottom: 1px solid var(--border);
    flex-wrap: wrap;
  }
  .spacer { flex: 1 1 auto; }
  .badge { font-variant-numeric: tabular-nums; color: var(--fg-muted); }

  #fpsCtl { display:flex; align-items:center; gap:8px; }
  #fpsRange { width: 180px; }

  /* ---- Grid / panes ---- */
  #grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    grid-auto-rows: 1fr;
    gap: var(--gap);
    padding: var(--gap);
    height: calc(100vh - 230px);
  }
  .pane {
    position: relative;
    background: #000;
    border: 1px solid var(--border);
    border-radius: 10px;
    overflow: hidden;
    box-shadow: var(--shadow);
  }
  .pane header {
    position: absolute;
    inset: 0 auto auto 0;
    background: rgba(22,27,34,.75); /* #161b22 w/ alpha */
    color: var(--fg-default);
    border: 0;
    padding: 6px 10px;
    font-size: 12px;
    z-index: 2;
    backdrop-filter: blur(2px);
  }
  video { width: 100%; height: 100%; object-fit: cover; background: #000; }

  footer {
    padding: 10px 16px;
    font-size: 12px;
    color: var(--fg-muted);
    border-top: 1px solid var(--border);
    background: var(--bg-subtle);
  }

  /* ---- Mobile ---- */
  @media (max-width: 900px) {
    #controls { grid-template-columns: repeat(2, 1fr); }
    #grid { grid-template-columns: 1fr; height: auto; }
    .pane { aspect-ratio: 16/9; }
  }

</style>

</head>
<body>
  <header class="topbar">
    <h1>4× USB Webcam Viewer</h1>
  </header>

  <div id="controls">
    <div class="camctl" data-idx="0">
      <label for="sel-0">Front</label>
      <select id="sel-0"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Front</button>
        <button class="danger" data-action="stop" disabled>Stop Front</button>
      </div>
      <small class="badge" id="info-0">Idle</small>
    </div>
    <div class="camctl" data-idx="1">
      <label for="sel-1">Back</label>
      <select id="sel-1"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Back</button>
        <button class="danger" data-action="stop" disabled>Stop Back</button>
      </div>
      <small class="badge" id="info-1">Idle</small>
    </div>
    <div class="camctl" data-idx="2">
      <label for="sel-2">Left</label>
      <select id="sel-2"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Left</button>
        <button class="danger" data-action="stop" disabled>Stop Left</button>
      </div>
      <small class="badge" id="info-2">Idle</small>
    </div>
    <div class="camctl" data-idx="3">
      <label for="sel-3">Right</label>
      <select id="sel-3"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Right</button>
        <button class="danger" data-action="stop" disabled>Stop Right</button>
      </div>
      <small class="badge" id="info-3">Idle</small>
    </div>
  </div>

  <div id="global">
    <button id="startAll" class="primary">Start All</button>
    <button id="stopAll" class="danger" disabled>Stop All</button>

    <div id="fpsCtl">
      <label for="fpsRange" title="Capture FPS cap">FPS</label>
      <input id="fpsRange" type="range" min="1" max="30" value="8" step="1" />
      <output id="fpsOut" for="fpsRange">1</output>
    </div>

    <button id="saveBtn" title="Save streams to a folder">Save streams</button>

    <div class="spacer"></div>

    <button id="refreshList">Refresh Camera List</button>
    <button id="resetRemembered">Reset Remembered Choices</button>
  </div>

  <main id="grid">
    <div class="pane">
      <header id="label-0">Front</header>
      <video id="vid-0" autoplay playsinline muted></video>
    </div>
    <div class="pane">
      <header id="label-1">Back</header>
      <video id="vid-1" autoplay playsinline muted></video>
    </div>
    <div class="pane">
      <header id="label-2">Left</header>
      <video id="vid-2" autoplay playsinline muted></video>
    </div>
    <div class="pane">
      <header id="label-3">Right</header>
      <video id="vid-3" autoplay playsinline muted></video>
    </div>
  </main>

  <footer>
    Use HTTPS or <code>http://localhost</code>. Grant camera access when prompted. After permission, device labels appear.
    For 4 simultaneous webcams, keep resolution modest (640×360/480) and FPS low.
  </footer>

<script>
(async () => {
  // --- State ---
  const streams   = [null, null, null, null]; // MediaStream per pane
  const recorders = [null, null, null, null]; // MediaRecorder per pane
  const chunks    = [[], [], [], []];         // fallback download buffers (non-FSA browsers)
  const writers   = [null, null, null, null]; // FileSystemWritableFileStream per pane (FSA)
  const writeQ    = [[], [], [], []];         // per-pane write queues for FSA streaming
  const writing   = [false, false, false, false]; // per-pane writer loop flag
  let recording   = false;
  let usingFSA    = false;     // whether File System Access API is used
  let startStamp  = '';        // YYYYMMDD_HHMMSS taken when user presses "Save streams"

  const defaultNames = ['Front','Back','Left','Right'];
const nameSelects  = [null, null, null, null];
const nameStorageKey = 'quadcam-position-names-v1';
const positionOptions = ['Front','Back','Left','Right','DIM','DHU'];

function posName(i){
  return (nameSelects[i]?.value || defaultNames[i]);
}

  const rememberedKey = 'quadcam-deviceIds-v1';

  // >>> checkpoint: new globals for single-file commits
  let currentDirHandle = null;
  const segmentMs = 60_000; // commit interval (adjust as you like)
  const segmentTimers = [null, null, null, null];
  const fileHandles   = [null, null, null, null];

  // --- Elements ---
  const selects = [0,1,2,3].map(i => document.getElementById('sel-' + i));
  const infos   = [0,1,2,3].map(i => document.getElementById('info-' + i));
  const videos  = [0,1,2,3].map(i => document.getElementById('vid-' + i));
  const startAllBtn = document.getElementById('startAll');
  const stopAllBtn  = document.getElementById('stopAll');
  const refreshBtn  = document.getElementById('refreshList');
  const resetRememberedBtn = document.getElementById('resetRemembered');
  const saveBtn = document.getElementById('saveBtn');
  const fpsRange = document.getElementById('fpsRange');
  const fpsOut   = document.getElementById('fpsOut');

  // ensure default shown & used if HTML was cached
fpsRange.value = '8';
fpsOut.textContent = '8';

  function loadRememberedNames() {
  try {
    const raw = localStorage.getItem(nameStorageKey);
    const arr = JSON.parse(raw);
    if (Array.isArray(arr) && arr.length === 4) return arr;
  } catch {}
  return null;
}

function rememberNames() {
  try {
    const arr = [0,1,2,3].map(i => posName(i));
    localStorage.setItem(nameStorageKey, JSON.stringify(arr));
  } catch {}
}

function initPositionDropdowns() {
  const remembered = loadRememberedNames();

  document.querySelectorAll('.camctl').forEach((block, i) => {
    // Reuse the existing label spot to introduce a "Position" label
    const oldLabel = block.querySelector(`label[for="sel-${i}"]`);
    if (oldLabel) oldLabel.textContent = 'Position';

    // Create the new name <select>
    const nameSel = document.createElement('select');
    nameSel.id = `name-${i}`;
    positionOptions.forEach(n => {
      const opt = document.createElement('option');
      opt.value = n;
      opt.textContent = n;
      nameSel.appendChild(opt);
    });

    // Default to current fixed name, or remembered choice
    nameSel.value = remembered?.[i] || defaultNames[i];

    // Insert the new dropdown just before the device select
    const deviceSel = block.querySelector(`#sel-${i}`);
    block.insertBefore(nameSel, deviceSel);

    // Keep a handle to it
    nameSelects[i] = nameSel;

    // Wire: update pane header text on change
    const header = document.getElementById(`label-${i}`);
    const updateHeader = () => { if (header) header.textContent = posName(i); };
    nameSel.addEventListener('change', () => { updateHeader(); rememberNames(); });
    updateHeader();
  });
}

  // Current FPS target from GUI
  function getTargetFps() {
    return Math.max(1, parseInt(fpsRange.value || '1', 10));
  }

  // Debounced live-FPS listener
  let fpsDebounce;
  fpsRange.addEventListener('input', () => {
    fpsOut.textContent = fpsRange.value;
    clearTimeout(fpsDebounce);
    fpsDebounce = setTimeout(() => setLiveFpsForAll(getTargetFps()), 150);
  });

  // Attach button handlers per camera control block
  document.querySelectorAll('.camctl').forEach(block => {
    const idx = Number(block.dataset.idx);
    block.querySelector('[data-action="start"]').addEventListener('click', () => startOne(idx));
    block.querySelector('[data-action="stop"]').addEventListener('click', () => stopOne(idx));
  });

  startAllBtn.addEventListener('click', startAll);
  stopAllBtn.addEventListener('click', stopAll);
  refreshBtn.addEventListener('click', refreshDeviceList);
  resetRememberedBtn.addEventListener('click', () => {
    localStorage.removeItem(rememberedKey);
    alert('Saved camera choices cleared.');
  });

  saveBtn.addEventListener('click', toggleSavingAll);

  navigator.mediaDevices?.addEventListener?.('devicechange', refreshDeviceList);

  // --- Helpers ---
  function setButtonsEnabled(idx, running) {
    const block = document.querySelector(`.camctl[data-idx="${idx}"]`);
    const startBtn = block.querySelector('[data-action="start"]');
    const stopBtn = block.querySelector('[data-action="stop"]');
    startBtn.disabled = running;
    stopBtn.disabled  = !running;
    stopAllBtn.disabled = !streams.some(s => s);
  }

  // Force per-camera buttons to read just "Start" / "Stop"
function normalizeButtonLabels() {
  document.querySelectorAll('.camctl').forEach(block => {
    const startBtn = block.querySelector('[data-action="start"]');
    const stopBtn  = block.querySelector('[data-action="stop"]');
    if (startBtn) startBtn.textContent = 'Start';
    if (stopBtn)  stopBtn.textContent  = 'Stop';
  });
}

  // >>> UPDATED: include seconds in timestamp (YYYYMMDD_HHMMSS)
  function timestamp() {
    const d = new Date();
    const pad = n => String(n).padStart(2, '0');
    return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  }

  function pickSupportedMime() {
    const candidates = [
      'video/webm;codecs=vp9,opus',
      'video/webm;codecs=vp8,opus',
      'video/webm'
      // 'video/mp4' // some Safari builds; add if needed
    ];
    for (const m of candidates) {
      if (window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m;
    }
    return ''; // let browser decide
  }

  // ---------- File System Access helpers (continuous writing) ----------
  async function startWriterLoop(i) {
    if (writing[i]) return;
    writing[i] = true;
    while (writers[i]) {
      const chunk = writeQ[i].shift();
      if (!chunk) { await new Promise(r => setTimeout(r, 50)); continue; }
      try {
        await writers[i].write(chunk);
      } catch (e) {
        console.error(`Write error (${positionNames[i]}):`, e);
        infos[i].textContent = 'Write error';
      }
    }
    writing[i] = false;
  }

  // >>> checkpoint: create/open single file per pane and be ready to append
  async function setupFSAFiles(dirHandle, stamp) {
    usingFSA = !!(window.showDirectoryPicker && dirHandle);
    currentDirHandle = usingFSA ? dirHandle : null;
    if (!usingFSA) return;

    for (let i = 0; i < 4; i++) {
      if (!streams[i]) { writers[i] = null; fileHandles[i] = null; continue; }
      const fileName = `${stamp}_${posName(i)}.webm`;
      const fh = await currentDirHandle.getFileHandle(fileName, { create: true });
      fileHandles[i] = fh;

      // open writer in append mode (keepExistingData) and seek to end
      const writer = await fh.createWritable({ keepExistingData: true });
      const size = (await fh.getFile()).size;
      await writer.seek(size);
      writers[i] = writer;

      writeQ[i] = [];
      startWriterLoop(i);
      infos[i].textContent = 'Recording to folder…';
    }
  }

  // >>> checkpoint: periodic commit (close) & re-open same file to append
  async function checkpointCommit(i) {
    if (!writers[i] || !fileHandles[i]) return;
    try { await writers[i].close(); } catch {}
    writers[i] = null;

    const fh = fileHandles[i];
    const newWriter = await fh.createWritable({ keepExistingData: true });
    const size = (await fh.getFile()).size;
    await newWriter.seek(size);
    writers[i] = newWriter;
    startWriterLoop(i);
  }

  function startCheckpointing() {
    for (let i = 0; i < 4; i++) {
      if (!streams[i] || !fileHandles[i]) continue;
      if (segmentTimers[i]) clearInterval(segmentTimers[i]);
      segmentTimers[i] = setInterval(() => {
        checkpointCommit(i).catch(console.warn);
      }, segmentMs);
    }
  }

  function stopCheckpointing() {
    for (let i = 0; i < 4; i++) {
      if (segmentTimers[i]) { clearInterval(segmentTimers[i]); segmentTimers[i] = null; }
    }
  }

  async function closeFSAFiles() {
    // >>> checkpoint: stop timers before closing writers
    stopCheckpointing();
    for (let i = 0; i < 4; i++) {
      if (writers[i]) {
        try { await writers[i].close(); } catch {}
        writers[i] = null;
      }
      writeQ[i] = [];
      fileHandles[i] = null; // >>> checkpoint
    }
    currentDirHandle = null; // >>> checkpoint
  }

  // ---------- Save / Stop logic ----------
  async function toggleSavingAll() {
    if (!recording) {
      // START
      const anyLive = streams.some(Boolean);
      if (!anyLive) { alert('No active streams. Start at least one camera.'); return; }

      startStamp = timestamp(); // now includes seconds

      let dirHandle = null;
      if (window.showDirectoryPicker) {
        try {
          dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        } catch (e) {
          if (e?.name === 'AbortError') return; // user cancelled
          console.warn('Directory picker failed, falling back to download-on-stop:', e);
        }
      } else {
        console.warn('File System Access API not supported; falling back to download-on-stop.');
      }

      await setupFSAFiles(dirHandle, startStamp);

      const mime = pickSupportedMime();
      for (let i = 0; i < 4; i++) {
        if (!streams[i]) { infos[i].textContent ||= 'Not running'; continue; }
        try {
          chunks[i] = []; // keep memory copy as fallback
          const rec = new MediaRecorder(streams[i], mime ? { mimeType: mime } : undefined);
          recorders[i] = rec;

          rec.ondataavailable = (e) => {
            if (e.data && e.data.size) {
              chunks[i].push(e.data);
              if (writers[i]) writeQ[i].push(e.data);
            }
          };
          rec.start(1000); // 1s timeslices
          infos[i].textContent = writers[i] ? 'Recording to folder…' : 'Recording (buffering)…';
        } catch (e) {
          console.error(`Recorder ${posName(i)} error:`, e);
          infos[i].textContent = 'Recorder error';
        }
      }

      // >>> checkpoint: begin periodic commits only in FSA mode
      if (usingFSA) startCheckpointing();

      recording = true;
      saveBtn.textContent = 'Stop saving';
      saveBtn.classList.add('danger');

    } else {
      // STOP
      for (let i = 0; i < 4; i++) {
        if (recorders[i]) {
          try { if (recorders[i].state !== 'inactive') recorders[i].stop(); } catch {}
          recorders[i] = null;
        }
      }

      await closeFSAFiles();

      if (!window.showDirectoryPicker || !usingFSA) {
        for (let i = 0; i < 4; i++) {
          const blob = new Blob(chunks[i], { type: (chunks[i][0]?.type || 'video/webm') });
          if (blob.size > 0) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const stamp = startStamp || timestamp();
            a.download = `${stamp}_${posName(i)}.webm`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            infos[i].textContent = 'Saved';
          } else {
            infos[i].textContent = 'No data';
          }
          chunks[i] = [];
        }
      } else {
        for (let i = 0; i < 4; i++) {
          if (streams[i]) infos[i].textContent = 'Saved to folder';
        }
      }

      recording = false;
      saveBtn.textContent = 'Save streams';
      saveBtn.classList.remove('danger');
    }
  }

  // Live FPS adjuster for all running streams
  async function setLiveFpsForAll(fps) {
    const tasks = [];
    for (const s of streams) {
      if (!s) continue;
      const track = s.getVideoTracks()[0];
      if (!track) continue;
      const attempts = [
        { frameRate: fps },
        { frameRate: { ideal: fps, max: fps } },
        { frameRate: { max: fps } }
      ];
      tasks.push((async () => {
        let lastErr;
        for (const c of attempts) {
          try {
            await track.applyConstraints(c);
            const got = track.getSettings();
            console.log(`Live FPS set → ${got.frameRate ?? 'unknown'} fps`);
            return;
          } catch (e) { lastErr = e; }
        }
        console.warn('Live FPS change not supported by this camera/driver:', lastErr?.message || lastErr);
      })());
    }
    await Promise.all(tasks);
  }

  function rememberSelection(deviceIds) {
    try { localStorage.setItem(rememberedKey, JSON.stringify(deviceIds)); } catch {}
  }

  function loadRememberedSelection() {
    try {
      const raw = localStorage.getItem(rememberedKey);
      if (!raw) return null;
      const arr = JSON.parse(raw);
      if (Array.isArray(arr) && arr.length === 4) return arr;
    } catch {}
    return null;
  }

  async function ensurePermissionPrompted() {
    try {
      const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      s.getTracks().forEach(t => t.stop());
    } catch (e) {
      console.warn('Initial permission request failed:', e);
    }
  }

  async function refreshDeviceList() {
    try {
      await ensurePermissionPrompted();
      const devices = await navigator.mediaDevices.enumerateDevices();
      const vids = devices.filter(d => d.kind === 'videoinput');

      const currentSelections = selects.map(sel => sel.value || '');
      selects.forEach((sel, i) => {
        sel.innerHTML = '';
        vids.forEach((d, ix) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          const label = d.label || `Camera ${ix+1}`;
          opt.textContent = `${label} [${ix+1}]`;
          sel.appendChild(opt);
        });
        const candidate = currentSelections[i] && vids.some(v => v.deviceId === currentSelections[i])
          ? currentSelections[i]
          : (vids[0]?.deviceId || '');
        sel.value = candidate;
      });

      const remembered = loadRememberedSelection();
      if (remembered) {
        remembered.forEach((id, i) => {
          if (id && [...selects[i].options].some(o => o.value === id)) {
            selects[i].value = id;
          }
        });
      }
    } catch (e) {
      console.error('Failed to refresh device list', e);
      alert('Failed to list cameras: ' + e.message);
    }
  }

  // --- Open with FPS-aware fallbacks ---
  async function openWithFallbacks(deviceId, fpsCap) {
    const attempts = [
      { width: { exact: 640 },  height: { exact: 360 },  frameRate: { max: fpsCap } },
      { width: { exact: 640 },  height: { exact: 480 },  frameRate: { max: fpsCap } },
      { width: { max: 800 },    height: { max: 600 },    frameRate: { max: fpsCap } },
      { width: { max: 1280 },   height: { max: 720 },    frameRate: { max: fpsCap } },
    ];
    let lastErr;
    for (const video of attempts) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: deviceId }, ...video },
          audio: false
        });
        const track = stream.getVideoTracks()[0];
        const s = track.getSettings();
        console.log(`Negotiated ${s.width}×${s.height} @ ${s.frameRate} fps for ${deviceId}`);
        return stream;
      } catch (e) {
        lastErr = e;
        await new Promise(r => setTimeout(r, 200));
      }
    }
    throw lastErr || new Error('Could not start video source');
  }

  async function startOne(idx) {
    const deviceId = selects[idx].value;
    if (!deviceId) { alert(`Select a camera for ${positionNames[idx]}`); return; }
    stopOne(idx);
    try {
      infos[idx].textContent = 'Starting...';
      await new Promise(r => setTimeout(r, idx * 150)); // stagger
      const stream = await openWithFallbacks(deviceId, getTargetFps());
      streams[idx] = stream;
      videos[idx].srcObject = stream;
      setButtonsEnabled(idx, true);
      infos[idx].textContent = recording ? (writers[idx] ? 'Recording to folder…' : 'Recording (buffering)…') : 'Live';
      rememberSelection(selects.map(s => s.value));
    } catch (e) {
      infos[idx].textContent = 'Error';
      console.error(`Cam ${idx+1} start error:`, e);
      alert(`${posName(idx)} failed: ${e.name || 'Error'} — ${e.message || e}`);
      setButtonsEnabled(idx, false);
    }
  }

  function stopOne(idx) {
    if (recorders[idx]) {
      try { if (recorders[idx].state !== 'inactive') recorders[idx].stop(); } catch {}
      recorders[idx] = null;
    }
    if (writers[idx]) {
      writers[idx].close().catch(()=>{}).finally(()=>{ writers[idx]=null; writeQ[idx]=[]; });
    }
    const s = streams[idx];
    if (s) {
      s.getTracks().forEach(t => t.stop());
      streams[idx] = null;
    }
    videos[idx].srcObject = null;
    infos[idx].textContent = 'Stopped';
    setButtonsEnabled(idx, false);
  }

  async function startAll() {
    const chosen = new Set();
    for (let i = 0; i < 4; i++) {
      const id = selects[i].value;
      if (chosen.has(id)) {
        infos[i].textContent = 'Duplicate selection—pick a different camera.';
        continue;
      }
      chosen.add(id);
      await startOne(i); // serial
    }
    stopAllBtn.disabled = !streams.some(Boolean);
  }

  function stopAll() {
    for (let i = 0; i < 4; i++) stopOne(i);
    stopAllBtn.disabled = true;
    if (recording) {
      recording = false;
      saveBtn.textContent = 'Save streams';
      saveBtn.classList.remove('danger');
    }
  }

  selects.forEach((sel, i) => {
    sel.addEventListener('change', () => {
      infos[i].textContent = streams[i] ? (recording ? (writers[i] ? 'Recording to folder…' : 'Recording (buffering)…') : 'Live') : 'Idle';
    });
  });

  // Init
  if (!navigator.mediaDevices?.getUserMedia) {
    alert('getUserMedia not supported in this browser.');
  } else {
initPositionDropdowns();
normalizeButtonLabels(); 
await refreshDeviceList();
  }
})();
</script>
</body>
</html>
