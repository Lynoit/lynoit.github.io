<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Nearby Places Explorer (Top 10 + Radii)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { margin:0; font-family:Arial,sans-serif }
    #map { height:60vh; width:100% }
    table { width:100%; border-collapse:collapse; margin-top:1rem }
    th, td { border:1px solid #ccc; padding:0.5rem; vertical-align:top }
    th { background:#f4f4f4 }
    .num-label {
      display:inline-block;
      width:1.8em; height:1.8em;
      line-height:1.8em;
      text-align:center;
      color:#fff; font-weight:bold;
      border-radius:50%;
      margin-right:4px;
    }
    /* radius colors */
    .radius-100   { background:#F94144; }
    .radius-500   { background:#F3722C; }
    .radius-1000  { background:#F8961E; }
    .radius-5000  { background:#F9844A; }
    .radius-10000 { background:#F9C74F; }
    .radius-circle { fill:none; stroke-opacity:0.3; }
  </style>
</head>
<body>
  <div id="map"></div>
  <table id="places-table">
    <thead>
      <tr>
        <th>Radius</th>
        <th>Most Visited<br><small>1–10</small></th>
        <th>Most Reviewed<br><small>1–10</small></th>
        <th>Most Linked<br><small>1–10</small></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let map, userPos;
    const radii = [100, 500, 1000, 5000, 10000];
    const circleColors = ['#F94144','#F3722C','#F8961E','#F9844A','#F9C74F'];
    const TIMEOUT = 8000; // ms

    // simple timeout wrapper
    function fetchTimeout(url, opts={}, t=TIMEOUT) {
      return Promise.race([
        fetch(url, opts),
        new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), t))
      ]);
    }

    function init() {
      if (!navigator.geolocation) {
        alert('Geolocation not supported');
        return;
      }
      navigator.geolocation.getCurrentPosition(onPos, e => {
        alert('Could not get location: ' + e.message);
      });
    }

    function onPos(pos) {
      userPos = [pos.coords.latitude, pos.coords.longitude];
      map = L.map('map').setView(userPos, 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // draw concentric radii
      radii.forEach((r, i) => {
        L.circle(userPos, {
          radius: r,
          color: circleColors[i],
          weight: 1,
          className: 'radius-circle'
        }).addTo(map);
      });

      L.marker(userPos)
        .addTo(map)
        .bindPopup('You are here')
        .openPopup();

      processAllRadii();
    }

    async function processAllRadii() {
      const tbody = document.querySelector('#places-table tbody');
      tbody.innerHTML = '';
      for (let i = 0; i < radii.length; i++) {
        const r = radii[i];
        let visited = [], reviewed = [], linked = [];

        // fetch OSM places
        try {
          [visited, reviewed] = await getOSMPlaces(r);
        } catch (e) {
          console.warn(`OSM fetch failed @${r}m:`, e);
        }

        // fetch Wikipedia places
        try {
          linked = await getMostLinkedWiki(r);
        } catch (e) {
          console.warn(`Wiki fetch failed @${r}m:`, e);
        }

        // add markers: same color per radius, numbered 1–10
        [visited, reviewed, linked].forEach(list => {
          list.forEach((p, idx) => {
            L.marker([p.lat, p.lng], {
              icon: L.divIcon({
                className: `num-label radius-${r}`,
                html: String(idx + 1)
              })
            })
            .addTo(map)
            .bindPopup(`<strong>${idx + 1}. ${p.name || p.title}</strong>`);
          });
        });

        // construct table row
        const mkCell = arr =>
          arr.length
            ? arr.map((p, idx) => `${idx + 1}. ${p.name || p.title}`).join('<br>')
            : 'N/A';

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.toLocaleString()} m</td>
          <td>${mkCell(visited)}</td>
          <td>${mkCell(reviewed)}</td>
          <td>${mkCell(linked)}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    async function getOSMPlaces(radius) {
      const [lat, lon] = userPos;
      const query = `[out:json][timeout:8];
        node(around:${radius},${lat},${lon})[amenity];
        out body 100;`.replace(/\s+/g,' ');
      const res = await fetchTimeout(
        'https://overpass-api.de/api/interpreter',
        { method:'POST', body: query }
      );
      if (!res.ok) throw new Error(`OSM ${res.status}`);
      const elems = (await res.json()).elements.slice(0, 200);

      const visited = elems.slice(0, 10).map(n => ({
        name: n.tags?.name || n.tags?.amenity || 'Unknown',
        lat: n.lat,
        lng: n.lon
      }));

      const reviewed = elems
        .slice()
        .sort((a, b) =>
          ((b.tags ? Object.keys(b.tags).length : 0) -
           (a.tags ? Object.keys(a.tags).length : 0))
        )
        .slice(0, 10)
        .map(n => ({
          name: n.tags?.name || n.tags?.amenity || 'Unknown',
          lat: n.lat,
          lng: n.lon
        }));

      return [visited, reviewed];
    }

    async function getMostLinkedWiki(radius) {
      const [lat, lon] = userPos;
      // 1) fetch geosearch
      const geoUrl = [
        'https://en.wikipedia.org/w/api.php?origin=*&action=query',
        `&list=geosearch&gscoord=${lat}|${lon}`,
        `&gsradius=${radius}&gslimit=20&format=json`
      ].join('');
      const geoRes = await fetchTimeout(geoUrl);
      if (!geoRes.ok) throw new Error(`GeoSearch ${geoRes.status}`);
      const data = await geoRes.json();
      const pages = data.query?.geosearch || [];
      if (!pages.length) return [];

      // 2) combined linkshere fetch
      const titles = pages.map(p => p.title).join('|');
      const infoUrl = [
        'https://en.wikipedia.org/w/api.php?origin=*&action=query',
        `&prop=linkshere&titles=${encodeURIComponent(titles)}`,
        '&lhlimit=max&format=json'
      ].join('');
      const infoRes = await fetchTimeout(infoUrl);
      if (!infoRes.ok) throw new Error(`Linkshere ${infoRes.status}`);
      const infoData = await infoRes.json();
      const infoPages = infoData.query?.pages || {};

      // 3) tally and sort
      const counts = pages.map(p => {
        const pg = Object.values(infoPages).find(x => x.title === p.title) || {};
        const links = Array.isArray(pg.linkshere) ? pg.linkshere.length : 0;
        return { title: p.title, lat: p.lat, lng: p.lon, links };
      });

      return counts
        .sort((a, b) => b.links - a.links)
        .slice(0, 10)
        .map(p => ({ title: p.title, lat: p.lat, lng: p.lng }));
    }

    window.onload = init;
  </script>
</body>
</html>
