<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Nearby Places Explorer (Top 10 from Free Sources)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <style>
    body { margin:0; font-family:Arial,sans-serif }
    #map { height:60vh; width:100% }
    table { width:100%; border-collapse:collapse; margin-top:1rem }
    th, td { border:1px solid #ccc; padding:0.5rem; vertical-align:top }
    th { background:#f4f4f4 }
    .num-label {
      display:inline-block;
      width:1.8em; height:1.8em;
      line-height:1.8em; text-align:center;
      color:#fff; font-weight:bold; border-radius:50%;
      margin-right:4px;
    }
    /* radius colors */
    .radius-100   { background:#F94144; }
    .radius-500   { background:#F3722C; }
    .radius-1000  { background:#F8961E; }
    .radius-5000  { background:#F9844A; }
    .radius-10000 { background:#F9C74F; }
    .radius-circle {
      stroke-opacity:1!important; stroke-width:4!important;
      fill-opacity:0.1!important;
    }
    /* category borders */
    .cat-reviewed { border:2px solid #277da1; }
    .cat-visited  { border:2px solid #43aa8b; }
    .cat-linked   { border:2px solid #4d908e; }
    .cat-otm      { border:2px solid #90be6d; }
  </style>
</head>
<body>
  <div id="map"></div>
  <table id="places-table">
    <thead>
      <tr>
        <th>Radius</th>
        <th>Most Reviewed<br><small>1–10 (OSM tags)</small></th>
        <th>Most Visited<br><small>1–10 (Wiki pageviews)</small></th>
        <th>Most Linked<br><small>1–10 (Wiki incoming links)</small></th>
        <th>Most Popular<br><small>1–10 (OpenTripMap)</small></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // --- CONFIG ---
    const radii = [100, 500, 1000, 5000, 10000];
    const circleColors = ['#F94144','#F3722C','#F8961E','#F9844A','#F9C74F'];
    const TIMEOUT = 8000; // ms
    const OTM_API_KEY = 'YOUR_OPENTRIPMAP_API_KEY'; // get a free key at opentripmap.io

    // --- UTILS ---
    function fetchTimeout(url, opts={}, t=TIMEOUT) {
      return Promise.race([
        fetch(url, opts),
        new Promise((_, rej)=>setTimeout(()=>rej(new Error('Timeout')), t))
      ]);
    }
    function formatDate(d){ 
      return d.toISOString().slice(0,10).replace(/-/g,''); 
    }

    // --- INITIALIZATION ---
    let map, userPos;
    window.onload = () => {
      if (!navigator.geolocation) {
        alert('Geolocation not supported');
        return;
      }
      navigator.geolocation.getCurrentPosition(onPos, e=>{
        alert('Could not get location: '+e.message);
      });
    };

    function onPos(pos) {
      userPos = [pos.coords.latitude, pos.coords.longitude];
      map = L.map('map').setView(userPos, 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution:'&copy; OpenStreetMap contributors'
      }).addTo(map);

      // draw bold circles
      radii.forEach((r,i)=>{
        L.circle(userPos, {
          radius: r,
          color: circleColors[i],
          className: 'radius-circle',
          fill:true, fillColor:circleColors[i]
        }).addTo(map);
      });
      L.marker(userPos).addTo(map);

      processAllRadii();
    }

    // --- MAIN WORKFLOW ---
    async function processAllRadii() {
      const tbody = document.querySelector('#places-table tbody');
      tbody.innerHTML = '';
      for (let r of radii) {
        // Kick off all fetches in parallel
        const osmP     = getOSMReviewed(r);
        const wikiPgs  = wikiGeoSearch(r);
        const otmP     = getOTMPlaces(r);

        const [reviewed, pages, otm] = await Promise.all([osmP, wikiPgs, otmP]);
        // pages: array of { title, lat, lon }
        const visited = await getWikiVisited(pages);
        const linked  = await getWikiLinked(pages);

        // render markers
        renderMarkers(r, 'reviewed', reviewed);
        renderMarkers(r, 'visited',  visited);
        renderMarkers(r, 'linked',   linked);
        renderMarkers(r, 'otm',      otm);

        // append table row
        const mk = arr => arr.length
          ? arr.map((p,i)=>`${i+1}. ${p.name||p.title}`).join('<br>')
          : 'N/A';
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.toLocaleString()} m</td>
          <td>${mk(reviewed)}</td>
          <td>${mk(visited)}</td>
          <td>${mk(linked)}</td>
          <td>${mk(otm)}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    // --- RENDERING ---
    function renderMarkers(r, category, list) {
      list.forEach((p,i)=>{
        L.marker([p.lat,p.lng], {
          icon: L.divIcon({
            className:`num-label radius-${r} cat-${category}`,
            html:String(i+1)
          })
        }).addTo(map)
          .bindPopup(`<strong>${i+1}. ${p.name||p.title}</strong>`);
      });
    }

    // --- DATA FETCHERS ---

    // 1) OSM: most-reviewed by tag count
    async function getOSMReviewed(r) {
      const [lat,lon] = userPos;
      const q = `[out:json][timeout:8];
        node(around:${r},${lat},${lon})[amenity];
        out body 100;`.replace(/\s+/g,' ');
      const res = await fetchTimeout('https://overpass-api.de/api/interpreter',{
        method:'POST', body:q
      });
      if (!res.ok) throw new Error('OSM '+res.status);
      const elems = (await res.json()).elements;
      const sorted = elems.sort((a,b)=>
        ((b.tags?Object.keys(b.tags).length:0) -
         (a.tags?Object.keys(a.tags).length:0))
      );
      return sorted.slice(0,10).map(n=>({
        name: n.tags?.name||n.tags?.amenity||'Unknown',
        lat: n.lat, lng: n.lon
      }));
    }

    // 2) Wikimedia GeoSearch pool
    async function wikiGeoSearch(r) {
      const [lat,lon] = userPos;
      const url = [
        'https://en.wikipedia.org/w/api.php?origin=*&action=query',
        `&list=geosearch&gscoord=${lat}|${lon}`,
        `&gsradius=${r}&gslimit=20&format=json`
      ].join('');
      const res = await fetchTimeout(url);
      const data = await res.json();
      return (data.query?.geosearch||[]).map(p=>({
        title:p.title, lat:p.lat, lng:p.lon
      }));
    }

    // 2a) pageviews → most-visited
    async function getWikiVisited(pages) {
      const end = new Date();
      end.setDate(end.getDate()-1);
      const start = new Date(end);
      start.setDate(start.getDate()-30);
      const sd = formatDate(start), ed = formatDate(end);
      const counts = await Promise.all(pages.map(async p=>{
        const url = `https://wikimedia.org/api/rest_v1/metrics/pageviews/per-article/`+
          `en.wikipedia/all-access/user/${encodeURIComponent(p.title)}`+
          `/daily/${sd}/${ed}`;
        try {
          const res = await fetchTimeout(url);
          const body = await res.json();
          const views = (body.items||[]).reduce((sum,i)=>sum+i.views,0);
          return { ...p, views };
        } catch {
          return { ...p, views:0 };
        }
      }));
      return counts
        .sort((a,b)=>b.views - a.views)
        .slice(0,10)
        .map(p=>({ title:p.title, lat:p.lat, lng:p.lng }));
    }

    // 2b) linkshere → most-linked
    async function getWikiLinked(pages) {
      if (!pages.length) return [];
      const titles = pages.map(p=>p.title).join('|');
      const url = [
        'https://en.wikipedia.org/w/api.php?origin=*&action=query',
        `&prop=linkshere&titles=${encodeURIComponent(titles)}`,
        '&lhlimit=max&format=json'
      ].join('');
      const res = await fetchTimeout(url);
      const data = await res.json();
      const info = data.query?.pages||{};
      const counts = pages.map(p=>{
        const pg = Object.values(info).find(x=>x.title===p.title)||{};
        const links = Array.isArray(pg.linkshere)?pg.linkshere.length:0;
        return { ...p, links };
      });
      return counts
        .sort((a,b)=>b.links - a.links)
        .slice(0,10)
        .map(p=>({ title:p.title, lat:p.lat, lng:p.lng }));
    }

    // 3) OpenTripMap → most-popular
    async function getOTMPlaces(r) {
      const [lat,lon] = userPos;
      const list = await fetchTimeout(
        `https://api.opentripmap.com/0.1/en/places/radius`+
        `?radius=${r}&lon=${lon}&lat=${lat}&limit=50`+
        `&apikey=${OTM_API_KEY}`
      ).then(r=>r.json());
      // each has `rate` (0–7)
      const sorted = (list.features||[]).map(f=>({
        name: f.properties.name||'Unknown',
        lat: f.geometry.coordinates[1],
        lng: f.geometry.coordinates[0],
        rate: f.properties.rate||0
      })).sort((a,b)=>b.rate - a.rate);
      return sorted.slice(0,10).map(p=>({
        name:p.name, lat:p.lat, lng:p.lng
      }));
    }

  </script>
</body>
</html>
