<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nearby Places Explorer (Top 5 + Radii)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin:0; font-family:Arial,sans-serif }
    #map { height:60vh; width:100% }
    table { width:100%; border-collapse:collapse; margin-top:1rem }
    th, td { border:1px solid #ccc; padding:0.5rem; vertical-align:top }
    th { background:#f4f4f4 }
    .num-label {
      display:inline-block;
      width:1.8em; height:1.8em;
      line-height:1.8em;
      text-align:center;
      color:#fff; font-weight:bold;
      border-radius:50%;
      margin-right:4px;
    }
    /* radius colors */
    .radius-100   { background:#F94144; }
    .radius-500   { background:#F3722C; }
    .radius-1000  { background:#F8961E; }
    .radius-5000  { background:#F9844A; }
    .radius-10000 { background:#F9C74F; }
    .radius-50000 { background:#90BE6D; }
    .radius-circle { fill:none; stroke-opacity:0.3; }
  </style>
</head>
<body>
  <div id="map"></div>
  <table id="places-table">
    <thead>
      <tr>
        <th>Radius</th>
        <th>Most Visited<br><small>1–5</small></th>
        <th>Most Reviewed<br><small>1–5</small></th>
        <th>Most Linked<br><small>1–5</small></th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    let map, userPos;
    const radii = [100, 500, 1000, 5000, 10000, 50000];
    const circleColors = ['#F94144','#F3722C','#F8961E','#F9844A','#F9C74F','#90BE6D'];
    const TIMEOUT = 8000;

    function fetchTimeout(url, opts={}, t=TIMEOUT) {
      return Promise.race([
        fetch(url, opts),
        new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout')), t))
      ]);
    }

    function init() {
      if (!navigator.geolocation) return alert('Geolocation not supported');
      navigator.geolocation.getCurrentPosition(onPos, e => {
        alert('Could not get location: ' + e.message);
      });
    }

    function onPos(pos) {
      userPos = [pos.coords.latitude, pos.coords.longitude];
      map = L.map('map').setView(userPos, 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      radii.forEach((r,i) => {
        L.circle(userPos, {
          radius: r,
          color: circleColors[i],
          weight:1,
          className: 'radius-circle'
        }).addTo(map);
      });

      L.marker(userPos).addTo(map).bindPopup('You are here').openPopup();
      processAllRadii();
    }

    async function processAllRadii() {
      const tbody = document.querySelector('#places-table tbody');
      tbody.innerHTML = '';
      for (let idx=0; idx<radii.length; idx++) {
        const r = radii[idx];
        let visited = [], reviewed = [], linked = [];

        try {
          [visited, reviewed] = await getOSMPlaces(r);
        } catch(e) { console.warn('OSM failed @', r, e); }

        try {
          linked = await getMostLinkedWiki(r);
        } catch(e) { console.warn('Wiki failed @', r, e); }

        [visited, reviewed, linked].forEach(list => {
          list.forEach((p,i) => {
            L.marker([p.lat, p.lng], {
              icon: L.divIcon({
                className: `num-label radius-${r}`,
                html: String(i+1)
              })
            })
            .addTo(map)
            .bindPopup(`<strong>${i+1}. ${p.name||p.title}</strong>`);
          });
        });

        const mk = arr =>
          arr.length
            ? arr.map((p,i)=>`${i+1}. ${p.name||p.title}`).join('<br>')
            : 'N/A';

        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${r.toLocaleString()} m</td>
          <td>${mk(visited)}</td>
          <td>${mk(reviewed)}</td>
          <td>${mk(linked)}</td>
        `;
        tbody.appendChild(tr);
      }
    }

    async function getOSMPlaces(r) {
      const [lat,lon] = userPos;
      const q = `[out:json][timeout:8];
        node(around:${r},${lat},${lon})[amenity];
        out body 50;`.replace(/\s+/g,' ');
      const res = await fetchTimeout('https://overpass-api.de/api/interpreter', {
        method:'POST', body: q
      });
      if (!res.ok) throw new Error(res.status);
      const elems = (await res.json()).elements.slice(0,200);

      const visited = elems.slice(0,5).map(n=>({
        name: n.tags?.name||n.tags?.amenity||'?', lat:n.lat, lng:n.lon
      }));
      const reviewed = elems
        .slice()
        .sort((a,b)=>
          ((b.tags?Object.keys(b.tags).length:0) -
           (a.tags?Object.keys(a.tags).length:0))
        )
        .slice(0,5)
        .map(n=>({
          name: n.tags?.name||n.tags?.amenity||'?', lat:n.lat, lng:n.lon
        }));
      return [visited, reviewed];
    }

    // ←— robust version with safe checks
    async function getMostLinkedWiki(r) {
      try {
        const [lat, lon] = userPos;
        const geoUrl = [
          'https://en.wikipedia.org/w/api.php?origin=*&action=query',
          `&list=geosearch&gscoord=${lat}|${lon}`,
          `&gsradius=${r}&gslimit=10&format=json`
        ].join('');
        const geoRes = await fetchTimeout(geoUrl);
        if (!geoRes.ok) throw new Error(`GeoSearch ${geoRes.status}`);
        const geoJson = await geoRes.json();
        const pages = geoJson.query?.geosearch || [];
        if (!pages.length) return [];

        const titles = pages.map(p => p.title).join('|');
        const infoUrl = [
          'https://en.wikipedia.org/w/api.php?origin=*&action=query',
          `&prop=linkshere&titles=${encodeURIComponent(titles)}`,
          '&lhlimit=max&format=json'
        ].join('');
        const infoRes = await fetchTimeout(infoUrl);
        if (!infoRes.ok) throw new Error(`Linkshere ${infoRes.status}`);
        const infoJson = await infoRes.json();
        const infoPages = infoJson.query?.pages || {};

        const counts = pages.map(p => {
          const pg = Object.values(infoPages).find(x => x.title === p.title) || {};
          const links = Array.isArray(pg.linkshere) ? pg.linkshere.length : 0;
          return { title: p.title, lat: p.lat, lng: p.lon, links };
        });

        return counts
          .sort((a,b)=>b.links - a.links)
          .slice(0,5)
          .map(p=>({ title:p.title, lat:p.lat, lng:p.lng }));
      } catch (err) {
        console.warn('getMostLinkedWiki error @', r, err);
        return [];
      }
    }

    window.onload = init;
  </script>
</body>
</html>
