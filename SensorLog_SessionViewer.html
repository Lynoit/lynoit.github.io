<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sensor Sessions Viewer (ZIP ‚Üí Map + Plots)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- PolylineDecorator for direction arrow -->
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Papa Parse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root {
      --bg: #0e0f11;
      --card: #17181b;
      --muted: #a9b0bc;
      --fg: #e7eaf0;
      --accent: #4da3ff;
      --blue: #3a86ff;
      --red: #ff4d4d;
      --green: #38c172;
      --yellow: #ffcc00;
      --speedlimit: #ff8800;
      --border: #2a2d33;
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(14,15,17,0.95), rgba(14,15,17,0.85) 60%, transparent);
      backdrop-filter: blur(6px);
      padding: 16px 16px 8px;
      border-bottom: 1px solid var(--border);
    }
    h1 { margin: 0 0 8px; font-size: 18px; font-weight: 600; letter-spacing: .2px }
    #controls {
      display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
    }
    .btn {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--card); color: var(--fg);
      border: 1px solid var(--border);
      padding: 8px 12px; border-radius: 10px; cursor: pointer;
    }
    .btn:hover { border-color: #3b3f46 }
    .hint { color: var(--muted); font-size: 12px }
    .tiny { font-size: 11px; color: var(--muted) }

    /* Stack sessions vertically */
    .grid {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 16px;
    }

    .session {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      display: flex; flex-direction: column;
    }
    .session header {
      background: linear-gradient(180deg, #1b1d22, #17181b);
      padding: 12px 14px; border-bottom: 1px solid var(--border);
    }
    .session-title { margin: 0; font-size: 15px; font-weight: 600 }
    .session-body { padding: 12px; display: grid; gap: 12px }

    /* -------- Camera gallery -------- */
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 8px;
    }
    .thumb {
      width: 100%; aspect-ratio: 4/3; object-fit: cover;
      border-radius: 10px; border: 1px solid var(--border);
      background: #0a0b0d; cursor: pointer;
    }
    .thumb:hover { filter: brightness(1.05) }

    /* Lightbox */
    .lightbox {
      position: fixed; inset: 0; background: rgba(0,0,0,0.85);
      display: none; align-items: center; justify-content: center;
      z-index: 1000;
    }
    .lightbox.show { display: flex }
    .lightbox img {
      max-width: 95vw; max-height: 92vh; border-radius: 12px; border: 1px solid var(--border);
      box-shadow: 0 10px 32px rgba(0,0,0,0.5);
    }

    .map {
      width: 100%; height: 320px;
      border-radius: 12px; border: 1px solid var(--border); overflow: hidden;
    }
.charts {
  display: grid;
  grid-template-columns: 1fr; /* stack them */
  row-gap: 20px;              /* spacing between charts */
}

.charts canvas {
  display: block;
  width: 100% !important;
  height: 320px !important;   /* match the map height */
  background: #101215;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 4px;
}
    
    .status { font-size: 12px; color: var(--muted) }
    .row {
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px; flex-wrap: wrap;
    }
    .legend {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      font-size: 12px; color: var(--muted);
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block }
    .dot-blue   { background: var(--blue) }
    .dot-red    { background: var(--red) }
    .dot-yellow { background: var(--yellow) }
    .dot-green  { background: var(--green) }
    .dot-orange { background: var(--speedlimit) }

    /* Base tooltip style; background/border color set dynamically per-dot via JS */
    .leaflet-tooltip.feature-tag {
      background: rgba(0,0,0,0.75);
      color: #000;                  /* readable on colored backgrounds */
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 11px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    footer {
      text-align: center; padding: 16px; color: var(--muted);
      border-top: 1px solid var(--border);
    }
    a { color: var(--accent); text-decoration: none }
    a:hover { text-decoration: underline }
    input[type=file] { display:none }
    #openFolderLabel::before, #openFilesLabel::before {
      content: "üìÅ"; filter: grayscale(100%); margin-right: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Sessions Viewer</h1>
    <div id="controls">
      <label class="btn" id="openFolderLabel" title="Pick a folder with multiple ZIPs">
        <input id="folderInput" type="file" webkitdirectory directory multiple accept=".zip"/>
        Open folder of ZIPs
      </label>
      <label class="btn" id="openFilesLabel" title="Or pick several ZIP files">
        <input id="filesInput" type="file" multiple accept=".zip"/>
        Open ZIP files
      </label>
      <span class="hint">Each ZIP like your sample (Location.csv, Accelerometer.csv, TotalAcceleration.csv, Camera/*.jpg).</span>
      <span class="tiny">OSM features via Overpass; gentle throttling applied üïäÔ∏è</span>
    </div>
  </header>

  <main class="grid" id="sessions"></main>

  <!-- One global lightbox for all sessions -->
  <div id="lightbox" class="lightbox" tabindex="0" aria-label="Image viewer">
    <img id="lightboxImg" alt="Full size"/>
  </div>

  <footer>¬© Zeekr Tech EU 2025</footer>

<script>
/* ------------------- Overpass setup (mirrors + throttling) ------------------- */
const OVERPASS_ENDPOINTS = [
  'https://overpass.kumi.systems/api/interpreter',
  'https://overpass-api.de/api/interpreter',
  'https://overpass.nchc.org.tw/api/interpreter'
];
let overpassQueue = Promise.resolve();

  // Global Chart.js font defaults
Chart.defaults.color = '#b9c0cc';
Chart.defaults.font = {
  family: 'system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
  size: 14,             // base font size for everything
  weight: '400',
};

  // Read CSS variable color (fallback to provided default if missing)
function cssVar(name, fallback) {
  const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  return v || fallback;
}

  
function overpassFetch(query) {
  const run = async () => {
    for (const url of OVERPASS_ENDPOINTS) {
      try {
        const res = await fetch(url, { method: 'POST', body: query, headers: { 'Content-Type': 'text/plain' } });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return await res.json();
      } catch (e) { console.warn('Overpass failed on', url, e); }
    }
    throw new Error('All Overpass endpoints failed');
  };
  overpassQueue = overpassQueue.then(() => new Promise(r => setTimeout(r, 500))).then(run);
  return overpassQueue;
}

/* ------------------- Utilities ------------------- */
  function formatRelativeTime(ms) {
  // ms = elapsed milliseconds since session start
  const totalSec = Math.floor(ms / 1000);
  const mm = Math.floor(totalSec / 60);
  const ss = totalSec % 60;
  return mm > 0 ? `${mm}:${String(ss).padStart(2,'0')}` : `${ss}s`;
}

function slugWithoutExt(fileName) {
  const base = fileName.split('/').pop();
  return base.replace(/\.zip$/i, '');
}
function parseTime(v) {
  if (v == null || v === '') return null;
  if (typeof v === 'number') {
    if (v > 1e17) return new Date(v / 1e6);   // ns -> ms
    if (v > 1e14) return new Date(v / 1e3);   // ¬µs -> ms
    if (v > 1e12) return new Date(v);         // ms
    if (v > 1e9)  return new Date(v * 1000);  // s -> ms
    return null;
  }
  const num = Number(v);
  if (!Number.isNaN(num)) return parseTime(num);
  const d = new Date(v);
  return isNaN(d) ? null : d;
}
function formatHHMMSS(d) {
  const pad = n => String(n).padStart(2, '0');
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function pick(keys, obj) {
  for (const k of keys) {
    const found = Object.keys(obj).find(x => x.toLowerCase() === k.toLowerCase());
    if (found) return found;
  }
  return null;
}
function decimate(xs, max=2000) {
  if (xs.length <= max) return xs;
  const step = Math.ceil(xs.length / max);
  const out = [];
  for (let i=0; i<xs.length; i+=step) out.push(xs[i]);
  return out;
}

/* small vector helpers for route projection (meters) */
function toXY(lat, lon, lat0) {
  const R = 6371008.8;
  const x = (lon * Math.PI/180) * R * Math.cos(lat0 * Math.PI/180);
  const y = (lat * Math.PI/180) * R;
  return [x, y];
}
function distMeters(a, b) {
  const dx = a[0]-b[0], dy = a[1]-b[1];
  return Math.hypot(dx, dy);
}

  function computeAccelXYZSeries(accelRows) {
  if (!accelRows?.length) return null;

  // local helper: mm:ss or "Xs"
  function formatRelative(ms) {
    const totalSec = Math.floor(ms / 1000);
    const mm = Math.floor(totalSec / 60);
    const ss = totalSec % 60;
    return mm > 0 ? `${mm}:${String(ss).padStart(2,'0')}` : `${ss}s`;
  }

  const sample = accelRows[0];
  const xK = pick(['x','ax'], sample);
  const yK = pick(['y','ay'], sample);
  const zK = pick(['z','az'], sample);
  const tK = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], sample);
  if (!xK || !yK || !zK) return null;

  // collect rows with valid xyz + time (or index fallback)
  const raw = [];
  const idxFallback = []; // if no timestamp, use index
  for (let i = 0; i < accelRows.length; i++) {
    const r = accelRows[i];
    const ax = Number(r[xK]), ay = Number(r[yK]), az = Number(r[zK]);
    if (![ax, ay, az].every(Number.isFinite)) continue;

    let tms = null;
    if (tK) {
      if (String(tK).toLowerCase().includes('elapsed')) {
        const secs = Number(r[tK]);
        if (Number.isFinite(secs)) tms = secs * 1000;
      } else {
        const dt = parseTime(r[tK]);
        if (dt instanceof Date && !isNaN(dt)) tms = dt.getTime();
      }
    }

    if (tms != null) raw.push({ t: tms, ax, ay, az });
    else idxFallback.push({ i, ax, ay, az });
  }

  // Prefer timestamped series (relative to t0)
  if (raw.length) {
    const t0 = raw[0].t;
    const zipped = raw.map(p => ({
      l: formatRelative(p.t - t0),
      ax: p.ax, ay: p.ay, az: p.az
    }));
    const slim = decimate(zipped, 2000);
    return {
      labels: slim.map(x => x.l),
      ax:     slim.map(x => x.ax),
      ay:     slim.map(x => x.ay),
      az:     slim.map(x => x.az)
    };
  }

  // Fallback: index labels (no timestamps anywhere)
  if (idxFallback.length) {
    const zipped = idxFallback.map(p => ({ l: String(p.i), ax: p.ax, ay: p.ay, az: p.az }));
    const slim = decimate(zipped, 2000);
    return {
      labels: slim.map(x => x.l),
      ax:     slim.map(x => x.ax),
      ay:     slim.map(x => x.ay),
      az:     slim.map(x => x.az)
    };
  }

  return null;
}


/* ------------------- ZIP helpers ------------------- */
async function loadCsvFromZip(zip, namePattern) {
  const entries = Object.values(zip.files);
  const entry = entries.find(e => !e.dir && namePattern.test(e.name));
  if (!entry) return null;
  const text = await entry.async('string');
  const parse = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
  if (parse.errors?.length) console.warn('CSV parse issues', parse.errors.slice(0,3));
  return parse.data;
}
/* Load ALL images under Camera/ (case-insensitive) */
async function loadAllCameraImagesFromZip(zip) {
  const out = [];
  const entries = Object.values(zip.files)
    .filter(e => !e.dir && /\.(jpe?g|png|webp)$/i.test(e.name))
    .filter(e => /(^|\/)camera\//i.test(e.name));
  entries.sort((a,b) => a.name.localeCompare(b.name));
  for (const entry of entries) {
    const blob = await entry.async('blob');
    out.push({ url: URL.createObjectURL(blob), name: entry.name });
  }
  return out;
}

/* ------------------- Extraction / Computations ------------------- */
function extractTrack(locationRows) {
  if (!locationRows?.length) return null;
  const sample = locationRows[0];
  const latK  = pick(['lat','latitude','y'], sample);
  const lonK  = pick(['lon','long','longitude','x'], sample);
  const timeK = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], sample);
  if (!latK || !lonK) return null;

  const pts = [];
  for (const row of locationRows) {
    const lat = Number(row[latK]);
    const lon = Number(row[lonK]);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
    let t = null;
    if (timeK) {
      const raw = row[timeK];
      if (String(timeK).toLowerCase().includes('elapsed')) {
        const secs = Number(raw);
        if (Number.isFinite(secs)) t = new Date(secs * 1000);
      } else {
        t = parseTime(raw);
      }
    }
    pts.push({ lat, lon, t });
  }
  return pts.length ? pts : null;
}

function computeSpeedSeriesFromLocation(locationRows) {
  if (!locationRows?.length) return { labels: [], values: [] };
  const speedKey = pick(['speed','spd'], locationRows[0]);
  const timeKey  = pick(['time','timestamp','datetime','seconds_elapsed'], locationRows[0]);
  if (!speedKey || !timeKey) return { labels: [], values: [] };

  // Collect raw times + values
  const raw = [];
  for (const row of locationRows) {
    const t = String(timeKey).toLowerCase().includes('elapsed')
      ? Number(row[timeKey]) * 1000
      : parseTime(row[timeKey])?.getTime();
    const v = Number(row[speedKey]);
    if (Number.isFinite(t) && Number.isFinite(v)) raw.push({t,v: v*3.6});
  }
  if (!raw.length) return { labels: [], values: [] };

  // Normalize times to session start
  const t0 = raw[0].t;
  const zipped = raw.map(p => ({ l: formatRelativeTime(p.t - t0), v: p.v }));
  const slim = decimate(zipped, 2000);
  return { labels: slim.map(x=>x.l), values: slim.map(x=>x.v) };
}

/* Linear acceleration magnitude directly from Accelerometer.csv (already gravity-free) */
function computeLinearAccMagnitude(accelRows) {
  if (!accelRows?.length) return { labels: [], values: [] };

  // local helper (mm:ss or "Xs")
  function formatRelative(ms) {
    const totalSec = Math.floor(ms / 1000);
    const mm = Math.floor(totalSec / 60);
    const ss = totalSec % 60;
    return mm > 0 ? `${mm}:${String(ss).padStart(2, '0')}` : `${ss}s`;
  }

  const sample = accelRows[0];
  const xK = pick(['x','ax'], sample);
  const yK = pick(['y','ay'], sample);
  const zK = pick(['z','az'], sample);
  const tK = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], sample);
  if (!xK || !yK || !zK) return { labels: [], values: [] };

  const raw = [];
  const fallbackLabels = [];
  const fallbackValues = [];

  for (let i = 0; i < accelRows.length; i++) {
    const r = accelRows[i];
    const x = Number(r[xK]), y = Number(r[yK]), z = Number(r[zK]);
    if (![x, y, z].every(Number.isFinite)) continue;

    const mag = Math.sqrt(x*x + y*y + z*z);

    // Try to read time in ms
    let tms = null;
    if (tK) {
      if (String(tK).toLowerCase().includes('elapsed')) {
        const secs = Number(r[tK]);
        if (Number.isFinite(secs)) tms = secs * 1000;
      } else {
        const dt = parseTime(r[tK]); // uses your existing util
        if (dt instanceof Date && !isNaN(dt)) tms = dt.getTime();
      }
    }

    if (tms != null) {
      raw.push({ t: tms, v: mag });
    } else {
      // keep a fallback series with index labels if time is missing
      fallbackLabels.push(String(fallbackLabels.length));
      fallbackValues.push(mag);
    }
  }

  // Prefer relative-time labeling if we got any timestamps
  if (raw.length) {
    const t0 = raw[0].t;
    const zipped = raw.map(p => ({ l: formatRelative(p.t - t0), v: p.v }));
    const slim = decimate(zipped, 2000);
    return { labels: slim.map(x => x.l), values: slim.map(x => x.v) };
  }

  // Fallback: index-based labels (no timestamps available)
  const zipped = fallbackLabels.map((l, i) => ({ l, v: fallbackValues[i] }));
  const slim = decimate(zipped, 2000);
  return { labels: slim.map(x => x.l), values: slim.map(x => x.v) };
}

/* ------------------- Map + OSM features ------------------- */
function bboxForTrack(track, padMeters = 80) {
  let minLat=  90, minLon= 180, maxLat= -90, maxLon= -180;
  for (const p of track) {
    if (p.lat<minLat) minLat=p.lat;
    if (p.lat>maxLat) maxLat=p.lat;
    if (p.lon<minLon) minLon=p.lon;
    if (p.lon>maxLon) maxLon=p.lon;
  }
  const padLat = padMeters / 111320;
  const midLat = (minLat+maxLat)/2;
  const padLon = padMeters / (111320 * Math.cos(midLat*Math.PI/180));
  return [minLat-padLat, minLon-padLon, maxLat+padLat, maxLon+padLon];
}

function overpassQueryForBBox(bbox) {
  const [s,w,n,e] = bbox;
  return `
[out:json][timeout:25];
(
  node["highway"="traffic_signals"](${s},${w},${n},${e});
  node["highway"="stop"](${s},${w},${n},${e});
  node["highway"="motorway_junction"](${s},${w},${n},${e});
  way["junction"="roundabout"](${s},${w},${n},${e});
  relation["type"="multipolygon"]["junction"="roundabout"](${s},${w},${n},${e});
  way["maxspeed"](${s},${w},${n},${e});  /* speed limits */
);
out center tags;
  `.trim();
}

function getSpeedColor(maxspeedTagOrNumber) {
  let num;
  if (typeof maxspeedTagOrNumber === 'number') num = maxspeedTagOrNumber;
  else {
    const str = String(maxspeedTagOrNumber || '').toLowerCase();
    const mph = str.match(/(\d+(?:\.\d+)?)\s*mph/);
    if (mph) num = parseFloat(mph[1]) * 1.60934;
    else {
      const kmh = str.match(/(\d+(?:\.\d+)?)/);
      num = kmh ? parseFloat(kmh[1]) : NaN;
    }
  }
  if (!isFinite(num)) return '#ff8800';
  if (num <= 30) return '#ff8800';
  if (num <= 50) return '#ffaa33';
  if (num <= 70) return '#ffcc00';
  if (num <= 90) return '#c8d400';
  if (num <= 110) return '#89dd00';
  return '#38c172';
}
function parseMaxspeedToKmh(tag) {
  if (!tag) return null;
  const s = String(tag).toLowerCase().trim();
  if (s === 'signals' || s === 'variable' || s === 'none') return null;
  const mph = s.match(/(\d+(?:\.\d+)?)\s*mph/);
  if (mph) return Math.round(parseFloat(mph[1]) * 1.60934);
  const kmh = s.match(/(\d+(?:\.\d+)?)/);
  return kmh ? Math.round(parseFloat(kmh[1])) : null;
}

/* make tooltip bg/border match marker color */
function colorizeTooltip(marker, color) {
  setTimeout(() => {
    const el = marker.getTooltip && marker.getTooltip() && marker.getTooltip().getElement
      ? marker.getTooltip().getElement()
      : null;
    if (el) {
      el.style.background = color;
      el.style.borderColor = color;
      el.style.color = '#000'; // readable on bright colors
    }
  }, 0);
}

/* project a point to polyline to get chainage (meters from start) */
function toXYChain(latlngs) {
  const lat0 = (latlngs[0][0] + latlngs[latlngs.length-1][0]) / 2;
  const xy = latlngs.map(([lat,lon]) => toXY(lat, lon, lat0));
  const cum = [0];
  for (let i=1;i<xy.length;i++) cum[i] = cum[i-1] + distMeters(xy[i], xy[i-1]);
  return { xy, cum, lat0 };
}
function projectChainage({xy, cum}, lat0, lat, lon) {
  const p = toXY(lat, lon, lat0);
  let best = { d: Infinity, s: 0 };
  for (let i=0; i<xy.length-1; i++) {
    const a = xy[i], b = xy[i+1];
    const abx = b[0]-a[0], aby = b[1]-a[1];
    const apx = p[0]-a[0], apy = p[1]-a[1];
    const ab2 = abx*abx + aby*aby;
    let t = ab2 ? (abx*apx + aby*apy) / ab2 : 0;
    t = Math.max(0, Math.min(1, t));
    const proj = [a[0] + abx*t, a[1] + aby*t];
    const d = distMeters(p, proj);
    if (d < best.d) best = { d, s: cum[i] + Math.hypot((proj[0]-a[0]), (proj[1]-a[1])) };
  }
  return best.s;
}

/* Add OSM features; speed-limit labels only on change along the route */
function addOsmFeaturesToMap(map, geojson, groupLayer, latlngs) {
  const els = geojson?.elements || [];
  const others = [];
  const speedWays = [];

  for (const el of els) {
    let lat=null, lon=null;
    if (el.type === 'node') { lat = el.lat; lon = el.lon; }
    else if ((el.type === 'way' || el.type === 'relation') && el.center) {
      lat = el.center.lat; lon = el.center.lon;
    }
    if (lat==null || lon==null) continue;

    const tags = el.tags || {};
    if (tags.maxspeed) {
      speedWays.push({ lat, lon, tags });
    } else {
      let label='', color='#4da3ff';
      if (tags.highway === 'traffic_signals') { label = 'Traffic light'; color = '#ffcc00'; }
      else if (tags.highway === 'stop')       { label = 'Stop sign';     color = '#ff4d4d'; }
      else if (tags.highway === 'motorway_junction' || tags.junction === 'yes') { label = 'Junction'; }
      else if (tags.junction === 'roundabout') { label = 'Roundabout'; color = '#38c172'; }
      if (label) others.push({ lat, lon, label, color });
    }
  }

  /* draw non-speed features (always labeled) */
  for (const f of others) {
    const m = L.circleMarker([f.lat, f.lon], {
      radius: 6, color: f.color, weight: 2, fillColor: f.color, fillOpacity: 0.25
    }).addTo(groupLayer);
    m.bindTooltip(f.label, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
    colorizeTooltip(m, f.color);
  }

  /* handle speed limits: only label when value changes along route */
  if (speedWays.length && latlngs?.length >= 2) {
    const chain = toXYChain(latlngs);
    const pts = speedWays.map(sw => {
      const v = parseMaxspeedToKmh(sw.tags.maxspeed);
      const color = getSpeedColor(v ?? sw.tags.maxspeed);
      const s = projectChainage(chain, chain.lat0, sw.lat, sw.lon);
      return { lat: sw.lat, lon: sw.lon, v, color, s };
    }).sort((a,b)=>a.s-b.s);

    let prev = null;
    for (const f of pts) {
      const m = L.circleMarker([f.lat, f.lon], {
        radius: 6, color: f.color, weight: 2, fillColor: f.color, fillOpacity: 0.25
      }).addTo(groupLayer);
      const changed = (f.v != null) ? (prev === null || f.v !== prev) : false;
      if (changed) {
        m.bindTooltip(`Speed limit: ${f.v}`, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
        colorizeTooltip(m, f.color);
        prev = f.v;
      }
      // if not changed, keep ring without label
    }
  } else {
    // Fallback: no route context ‚Äî label them all
    for (const sw of speedWays) {
      const v = parseMaxspeedToKmh(sw.tags.maxspeed);
      const color = getSpeedColor(v ?? sw.tags.maxspeed);
      const m = L.circleMarker([sw.lat, sw.lon], {
        radius: 6, color, weight: 2, fillColor: color, fillOpacity: 0.25
      }).addTo(groupLayer);
      if (v != null) {
        m.bindTooltip(`Speed limit: ${v}`, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
        colorizeTooltip(m, color);
      }
    }
  }
}

/* ------------------- Charts ------------------- */
function makeLineChart(canvas, opts) {
  const ctx = canvas.getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: { labels: opts.labels, datasets: [{ ... }] },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,                   // <- add
      devicePixelRatio: window.devicePixelRatio || 1, // <- add
      scales: { /* as you have */ },
      plugins: { legend: { display: false } }
    }
  });
}

function makeMultiLineChart(canvas, { labels, datasets, yTitle, min, max }) {
  const ctx = canvas.getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,                   // <- add
      devicePixelRatio: window.devicePixelRatio || 1, // <- add
      scales: { /* as you have */ },
      plugins: { legend: { display: true } }
    }
  });
}

/* ------------------- Session UI ------------------- */
function createSessionCard(sessionName) {
  const wrap = document.createElement('section');
  wrap.className = 'session';

  const head = document.createElement('header');
  const h = document.createElement('h2');
  h.className = 'session-title';
  h.textContent = sessionName;
  head.appendChild(h);

  const body = document.createElement('div');
  body.className = 'session-body';

  const gallery = document.createElement('div');
  gallery.className = 'gallery';

  const map = document.createElement('div'); map.className='map';

  const row = document.createElement('div'); row.className='row';
  const legend = document.createElement('div'); legend.className='legend';
  legend.innerHTML = `
    <span><span class="dot dot-blue"></span> Trace</span>
    <span><span class="dot dot-yellow"></span> Traffic light</span>
    <span><span class="dot dot-red"></span> Stop sign</span>
    <span><span class="dot dot-green"></span> Roundabout</span>
    <span><span class="dot" style="background:#4da3ff"></span> Junction</span>
    <span><span class="dot dot-orange"></span> Speed limit</span>
  `;
  const status = document.createElement('div'); status.className='status'; text = 'Loading‚Ä¶'; status.textContent = text;
  row.append(legend, status);

  const charts = document.createElement('div'); charts.className='charts';
  const speedCanvas = document.createElement('canvas');
  const accCanvas = document.createElement('canvas');
  speedCanvas.height = 220;   // explicit pixel height
  accCanvas.height   = 220;
  
  charts.append(speedCanvas, accCanvas);

  body.append(gallery, map, row, charts);
  wrap.append(head, body);
  return { wrap, gallery, map, status, speedCanvas, accCanvas };
}

/* ------------------- Lightbox ------------------- */
const lightbox = document.getElementById('lightbox');
const lightboxImg = document.getElementById('lightboxImg');
function openLightbox(src) {
  lightboxImg.src = src;
  lightbox.classList.add('show');
  lightbox.focus();
}
lightbox.addEventListener('click', () => lightbox.classList.remove('show'));
lightbox.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') lightbox.classList.remove('show');
});

/* ------------------- Main processing ------------------- */
async function processZipFile(file) {
  const sessionName = slugWithoutExt(file.name);
  const ui = createSessionCard(sessionName);
  document.getElementById('sessions').appendChild(ui.wrap);

  // local helper for relative time labels (mm:ss or "Xs")
  function fmtRel(ms) {
    const totalSec = Math.floor(ms / 1000);
    const mm = Math.floor(totalSec / 60);
    const ss = totalSec % 60;
    return mm > 0 ? `${mm}:${String(ss).padStart(2,'0')}` : `${ss}s`;
  }

  try {
    ui.status.textContent = 'Reading ZIP‚Ä¶';
    const zip = await JSZip.loadAsync(file);

    /* Camera gallery */
    ui.status.textContent = 'Loading photos‚Ä¶';
    const images = await loadAllCameraImagesFromZip(zip);
    if (images.length) {
      for (const img of images) {
        const t = document.createElement('img');
        t.className = 'thumb';
        t.src = img.url;
        t.alt = img.name;
        t.addEventListener('click', () => openLightbox(img.url));
        ui.gallery.appendChild(t);
      }
    }

    // CSVs
    ui.status.textContent = 'Parsing CSVs‚Ä¶';
    const [locationRows, totalAccRows, accelRows] = await Promise.all([
      loadCsvFromZip(zip, /(^|\/)Location\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)TotalAcceleration\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)Accelerometer\.csv$/i)
    ]);

    // Track & map
    ui.status.textContent = 'Rendering map‚Ä¶';
    const map = L.map(ui.map);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '¬© OpenStreetMap'
    }).addTo(map);

    const track = extractTrack(locationRows);
    if (track?.length) {
      const latlngs = track.map(p => [p.lat, p.lon]);
      const poly = L.polyline(latlngs, { color: '#3a86ff', weight: 3 }).addTo(map);
      map.fitBounds(poly.getBounds(), { padding: [16,16] });

      /* Start marker + label */
      const startColor = '#00e676';
      const startLatLng = latlngs[0];
      const start = L.circleMarker(startLatLng, {
        radius: 6, color: startColor, weight: 2, fillColor: startColor, fillOpacity: 0.6
      }).addTo(map);
      start.bindTooltip('Start', {
        permanent: true, direction: 'right', offset: [8,0], className: 'feature-tag'
      });
      colorizeTooltip(start, startColor);

      /* Direction arrow */
      try {
        L.polylineDecorator(poly, {
          patterns: [{
            offset: '85%',
            repeat: 0,
            symbol: L.Symbol.arrowHead({
              pixelSize: 14,
              headAngle: 60,
              pathOptions: { color: '#3a86ff', weight: 2, opacity: 0.9 }
            })
          }]
        }).addTo(map);
      } catch (e) {
        console.warn('PolylineDecorator unavailable; skipping arrow.', e);
      }

      // OSM features via Overpass
      ui.status.textContent = 'Fetching OSM features‚Ä¶';
      const bbox = bboxForTrack(track, 80);
      const query = overpassQueryForBBox(bbox);
      try {
        const osm = await overpassFetch(query);
        const layer = L.layerGroup().addTo(map);
        addOsmFeaturesToMap(map, osm, layer, latlngs);
        ui.status.textContent = 'Map ready.';
      } catch (e) {
        console.warn('Overpass failed:', e);
        ui.status.textContent = 'Trace rendered. Features unavailable (Overpass error).';
      }
    } else {
      // fallback view if no coords
      map.setView([59.3293, 18.0686], 10);
      ui.status.textContent = 'No coordinates found.';
    }

    // Speed chart
    ui.status.textContent = 'Preparing speed‚Ä¶';
    const { labels: speedLabels, values: speedValues } = computeSpeedSeriesFromLocation(locationRows || []);
    const finiteSpeeds = speedValues.filter(v => Number.isFinite(v));
    let yMin, yMax;
    if (finiteSpeeds.length) {
      yMin = Math.min(...finiteSpeeds) - 5;
      yMax = Math.max(...finiteSpeeds) + 5;
    }
    makeLineChart(ui.speedCanvas, {
      labels: speedLabels,
      values: speedValues,
      label: 'Speed (km/h)',
      yTitle: 'km/h',
      min: yMin,
      max: yMax
    });

    // Acceleration: prefer Ax, Ay, Az from Accelerometer.csv; fallback to magnitude
    ui.status.textContent = 'Preparing acceleration‚Ä¶';

    const accelXYZ = computeAccelXYZSeries(accelRows);
    if (accelXYZ && accelXYZ.labels.length) {
      const cBlue  = cssVar('--blue',  '#3a86ff');
      const cGreen = cssVar('--green', '#38c172');
      const cRed   = cssVar('--red',   '#ff4d4d');

      // Symmetric Y range around zero with a small padding
      const all = [...accelXYZ.ax, ...accelXYZ.ay, ...accelXYZ.az].filter(Number.isFinite);
      let ymin, ymax;
      if (all.length) {
        ymin = Math.min(...all);
        ymax = Math.max(...all);
        const pad = Math.max(0.3, (ymax - ymin) * 0.05);
        ymin -= pad; ymax += pad;
        if (ymin > 0) ymin = 0;
        if (ymax < 0) ymax = 0;
      }

      makeMultiLineChart(ui.accCanvas, {
        labels: accelXYZ.labels,
        yTitle: 'm/s¬≤',
        min: ymin,
        max: ymax,
        datasets: [
          { label: 'Ax', data: accelXYZ.ax, borderColor: cBlue,  pointRadius: 0, borderWidth: 1.2, tension: 0.12 },
          { label: 'Ay', data: accelXYZ.ay, borderColor: cGreen, pointRadius: 0, borderWidth: 1.2, tension: 0.12 },
          { label: 'Az', data: accelXYZ.az, borderColor: cRed,   pointRadius: 0, borderWidth: 1.2, tension: 0.12 },
        ]
      });

    } else {
      // Fallback: magnitude from Accelerometer.csv (if available) else from TotalAcceleration.csv
      let { labels: accLabels, values: accValues } = computeLinearAccMagnitude(accelRows);

      if ((!accValues || !accValues.length) && totalAccRows?.length) {
        const tk = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], totalAccRows[0]);
        const ak = pick(['total','magnitude','acc','accel','a_total'], totalAccRows[0]);

        // Build relative-time labels for total acceleration as well
        const raw = [];
        for (const r of totalAccRows) {
          let tms = null;
          if (tk) {
            if (String(tk).toLowerCase().includes('elapsed')) {
              const secs = Number(r[tk]);
              if (Number.isFinite(secs)) tms = secs * 1000;
            } else {
              const dt = parseTime(r[tk]);
              if (dt instanceof Date && !isNaN(dt)) tms = dt.getTime();
            }
          }
          const a = Number(r[ak]);
          if (tms != null && Number.isFinite(a)) {
            raw.push({ t: tms, v: Math.max(0, a - 9.81) });
          }
        }
        if (raw.length) {
          const t0 = raw[0].t;
          const zipped = raw.map(p => ({ l: fmtRel(p.t - t0), v: p.v }));
          const slim = decimate(zipped, 2000);
          accLabels = slim.map(x=>x.l);
          accValues = slim.map(x=>x.v);
        } else {
          accLabels = []; accValues = [];
        }
      }

      makeLineChart(ui.accCanvas, {
        labels: accLabels || [],
        values: accValues || [],
        label: 'Linear acceleration |a| (m/s¬≤)',
        yTitle: 'm/s¬≤'
      });
    }

    ui.status.textContent = 'Ready.';
  } catch (err) {
    console.error(err);
    ui.status.textContent = 'Failed: ' + (err?.message || err);
  }
}

/* ------------------- Inputs ------------------- */
const folderInput = document.getElementById('folderInput');
const filesInput  = document.getElementById('filesInput');

function uniqueZipFilesFromFileList(fileList) {
  const out = [];
  const seen = new Set();
  for (const f of fileList) {
    if (!/\.zip$/i.test(f.name)) continue;
    const key = f.webkitRelativePath || f.name;
    if (!seen.has(key)) { seen.add(key); out.push(f); }
  }
  return out;
}

folderInput.addEventListener('change', async (e) => {
  const files = uniqueZipFilesFromFileList(e.target.files);
  if (!files.length) return;
  document.getElementById('sessions').innerHTML = '';
  for (const f of files) await processZipFile(f);
  folderInput.value = '';
});

filesInput.addEventListener('change', async (e) => {
  const files = uniqueZipFilesFromFileList(e.target.files);
  if (!files.length) return;
  document.getElementById('sessions').innerHTML = '';
  for (const f of files) await processZipFile(f);
  filesInput.value = '';
});
</script>
</body>
</html>
