<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sensor Sessions Viewer (ZIP ‚Üí Map + Plots)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- PolylineDecorator for direction arrow -->
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Papa Parse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root {
      --bg: #0e0f11;
      --card: #17181b;
      --muted: #a9b0bc;
      --fg: #e7eaf0;
      --accent: #4da3ff;
      --blue: #3a86ff;
      --red: #ff4d4d;
      --green: #38c172;
      --yellow: #ffcc00;
      --speedlimit: #ff8800;
      --border: #2a2d33;
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(14,15,17,0.95), rgba(14,15,17,0.85) 60%, transparent);
      backdrop-filter: blur(6px);
      padding: 16px 16px 8px;
      border-bottom: 1px solid var(--border);
    }
    h1 { margin: 0 0 8px; font-size: 18px; font-weight: 600; letter-spacing: .2px }
    #controls {
      display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
    }
    .btn {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--card); color: var(--fg);
      border: 1px solid var(--border);
      padding: 8px 12px; border-radius: 10px; cursor: pointer;
    }
    .btn:hover { border-color: #3b3f46 }
    .hint { color: var(--muted); font-size: 12px }
    .tiny { font-size: 11px; color: var(--muted) }

    /* Stack sessions vertically */
    .grid {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 16px;
    }

    .session {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      display: flex; flex-direction: column;
    }
    .session header {
      background: linear-gradient(180deg, #1b1d22, #17181b);
      padding: 12px 14px; border-bottom: 1px solid var(--border);
    }
    .session-title { margin: 0; font-size: 15px; font-weight: 600 }
    .session-body { padding: 12px; display: grid; gap: 12px }

    /* -------- Camera gallery -------- */
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 8px;
    }
    .thumb {
      width: 100%; aspect-ratio: 4/3; object-fit: cover;
      border-radius: 10px; border: 1px solid var(--border);
      background: #0a0b0d; cursor: pointer;
    }
    .thumb:hover { filter: brightness(1.05) }

    /* Lightbox */
    .lightbox {
      position: fixed; inset: 0; background: rgba(0,0,0,0.85);
      display: none; align-items: center; justify-content: center;
      z-index: 1000;
    }
    .lightbox.show { display: flex }
    .lightbox img {
      max-width: 95vw; max-height: 92vh; border-radius: 12px; border: 1px solid var(--border);
      box-shadow: 0 10px 32px rgba(0,0,0,0.5);
    }

    .map {
      width: 100%; height: 320px;
      border-radius: 12px; border: 1px solid var(--border); overflow: hidden;
    }
.charts {
  display: grid;
  grid-template-columns: 1fr; /* always stacked */
  row-gap: 24px;              /* bigger vertical spacing */
}

.charts canvas {
  display: block;             /* avoid inline overlap/layout oddities */
  width: 100%;
  background: #101215;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 4px;
}
    
    .status { font-size: 12px; color: var(--muted) }
    .row {
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px; flex-wrap: wrap;
    }
    .legend {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      font-size: 12px; color: var(--muted);
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block }
    .dot-blue   { background: var(--blue) }
    .dot-red    { background: var(--red) }
    .dot-yellow { background: var(--yellow) }
    .dot-green  { background: var(--green) }
    .dot-orange { background: var(--speedlimit) }

    /* Base tooltip style; background/border color set dynamically per-dot via JS */
    .leaflet-tooltip.feature-tag {
      background: rgba(0,0,0,0.75);
      color: #000;                  /* readable on colored backgrounds */
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 11px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    footer {
      text-align: center; padding: 16px; color: var(--muted);
      border-top: 1px solid var(--border);
    }
    a { color: var(--accent); text-decoration: none }
    a:hover { text-decoration: underline }
    input[type=file] { display:none }
    #openFolderLabel::before, #openFilesLabel::before {
      content: "üìÅ"; filter: grayscale(100%); margin-right: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Sessions Viewer</h1>
    <div id="controls">
      <label class="btn" id="openFolderLabel" title="Pick a folder with multiple ZIPs">
        <input id="folderInput" type="file" webkitdirectory directory multiple accept=".zip"/>
        Open folder of ZIPs
      </label>
      <label class="btn" id="openFilesLabel" title="Or pick several ZIP files">
        <input id="filesInput" type="file" multiple accept=".zip"/>
        Open ZIP files
      </label>
      <span class="hint">Each ZIP like your sample (Location.csv, Accelerometer.csv, TotalAcceleration.csv, Camera/*.jpg).</span>
      <span class="tiny">OSM features via Overpass; gentle throttling applied üïäÔ∏è</span>
    </div>
  </header>

  <main class="grid" id="sessions"></main>

  <!-- One global lightbox for all sessions -->
  <div id="lightbox" class="lightbox" tabindex="0" aria-label="Image viewer">
    <img id="lightboxImg" alt="Full size"/>
  </div>

  <footer>¬© Lynoit 2025</footer>

<script>
/* ------------------- Overpass setup (mirrors + throttling) ------------------- */
const OVERPASS_ENDPOINTS = [
  'https://overpass.kumi.systems/api/interpreter',
  'https://overpass-api.de/api/interpreter',
  'https://overpass.nchc.org.tw/api/interpreter'
];
let overpassQueue = Promise.resolve();
function overpassFetch(query) {
  const run = async () => {
    for (const url of OVERPASS_ENDPOINTS) {
      try {
        const res = await fetch(url, { method: 'POST', body: query, headers: { 'Content-Type': 'text/plain' } });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return await res.json();
      } catch (e) { console.warn('Overpass failed on', url, e); }
    }
    throw new Error('All Overpass endpoints failed');
  };
  overpassQueue = overpassQueue.then(() => new Promise(r => setTimeout(r, 500))).then(run);
  return overpassQueue;
}

/* ------------------- Utilities ------------------- */
function slugWithoutExt(fileName) {
  const base = fileName.split('/').pop();
  return base.replace(/\.zip$/i, '');
}
function parseTime(v) {
  if (v == null || v === '') return null;
  if (typeof v === 'number') {
    if (v > 1e17) return new Date(v / 1e6);   // ns -> ms
    if (v > 1e14) return new Date(v / 1e3);   // ¬µs -> ms
    if (v > 1e12) return new Date(v);         // ms
    if (v > 1e9)  return new Date(v * 1000);  // s -> ms
    return null;
  }
  const num = Number(v);
  if (!Number.isNaN(num)) return parseTime(num);
  const d = new Date(v);
  return isNaN(d) ? null : d;
}
function formatHHMMSS(d) {
  const pad = n => String(n).padStart(2, '0');
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function pick(keys, obj) {
  for (const k of keys) {
    const found = Object.keys(obj).find(x => x.toLowerCase() === k.toLowerCase());
    if (found) return found;
  }
  return null;
}
function decimate(xs, max=2000) {
  if (xs.length <= max) return xs;
  const step = Math.ceil(xs.length / max);
  const out = [];
  for (let i=0; i<xs.length; i+=step) out.push(xs[i]);
  return out;
}

/* small vector helpers for route projection (meters) */
function toXY(lat, lon, lat0) {
  const R = 6371008.8;
  const x = (lon * Math.PI/180) * R * Math.cos(lat0 * Math.PI/180);
  const y = (lat * Math.PI/180) * R;
  return [x, y];
}
function distMeters(a, b) {
  const dx = a[0]-b[0], dy = a[1]-b[1];
  return Math.hypot(dx, dy);
}

/* ------------------- ZIP helpers ------------------- */
async function loadCsvFromZip(zip, namePattern) {
  const entries = Object.values(zip.files);
  const entry = entries.find(e => !e.dir && namePattern.test(e.name));
  if (!entry) return null;
  const text = await entry.async('string');
  const parse = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
  if (parse.errors?.length) console.warn('CSV parse issues', parse.errors.slice(0,3));
  return parse.data;
}
/* Load ALL images under Camera/ (case-insensitive) */
async function loadAllCameraImagesFromZip(zip) {
  const out = [];
  const entries = Object.values(zip.files)
    .filter(e => !e.dir && /\.(jpe?g|png|webp)$/i.test(e.name))
    .filter(e => /(^|\/)camera\//i.test(e.name));
  entries.sort((a,b) => a.name.localeCompare(b.name));
  for (const entry of entries) {
    const blob = await entry.async('blob');
    out.push({ url: URL.createObjectURL(blob), name: entry.name });
  }
  return out;
}

/* ------------------- Extraction / Computations ------------------- */
function extractTrack(locationRows) {
  if (!locationRows?.length) return null;
  const sample = locationRows[0];
  const latK  = pick(['lat','latitude','y'], sample);
  const lonK  = pick(['lon','long','longitude','x'], sample);
  const timeK = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], sample);
  if (!latK || !lonK) return null;

  const pts = [];
  for (const row of locationRows) {
    const lat = Number(row[latK]);
    const lon = Number(row[lonK]);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
    let t = null;
    if (timeK) {
      const raw = row[timeK];
      if (String(timeK).toLowerCase().includes('elapsed')) {
        const secs = Number(raw);
        if (Number.isFinite(secs)) t = new Date(secs * 1000);
      } else {
        t = parseTime(raw);
      }
    }
    pts.push({ lat, lon, t });
  }
  return pts.length ? pts : null;
}

function computeSpeedSeriesFromLocation(locationRows) {
  if (!locationRows?.length) return { labels: [], values: [] };
  const speedKey = pick(['speed','spd'], locationRows[0]);
  if (!speedKey) return { labels: [], values: [] };

  const labels = [];
  const values = [];
  for (const row of locationRows) {
    const t = parseTime(row.time) || (row.seconds_elapsed != null ? new Date(row.seconds_elapsed * 1000) : null);
    const v = Number(row[speedKey]);
    if (Number.isFinite(v)) {
      labels.push(t ? formatHHMMSS(t) : String(labels.length));
      values.push(v * 3.6); // m/s ‚Üí km/h
    }
  }
  const zipped = labels.map((l,i) => ({ l, v: values[i] }));
  const slim = decimate(zipped, 2000);
  return { labels: slim.map(x=>x.l), values: slim.map(x=>x.v) };
}

/* Linear acceleration magnitude directly from Accelerometer.csv (already gravity-free) */
function computeLinearAccMagnitude(accelRows) {
  if (!accelRows?.length) return { labels: [], values: [] };
  const sample = accelRows[0];
  const xK = pick(['x','ax'], sample);
  const yK = pick(['y','ay'], sample);
  const zK = pick(['z','az'], sample);
  const tK = pick(['time','timestamp','datetime','seconds_elapsed'], sample);
  if (!xK || !yK || !zK) return { labels: [], values: [] };

  const labels = [], values = [];
  for (const r of accelRows) {
    const x = Number(r[xK]), y = Number(r[yK]), z = Number(r[zK]);
    if ([x,y,z].every(Number.isFinite)) {
      let t = null;
      if (tK) {
        t = String(tK).toLowerCase().includes('elapsed')
          ? new Date(Number(r[tK]) * 1000)
          : parseTime(r[tK]);
      }
      labels.push(t ? formatHHMMSS(t) : String(labels.length));
      values.push(Math.sqrt(x*x + y*y + z*z)); // |linear a|
    }
  }
  const zipped = labels.map((l,i) => ({ l, v: values[i] }));
  const slim = decimate(zipped, 2000);
  return { labels: slim.map(x=>x.l), values: slim.map(x=>x.v) };
}

/* ------------------- Map + OSM features ------------------- */
function bboxForTrack(track, padMeters = 80) {
  let minLat=  90, minLon= 180, maxLat= -90, maxLon= -180;
  for (const p of track) {
    if (p.lat<minLat) minLat=p.lat;
    if (p.lat>maxLat) maxLat=p.lat;
    if (p.lon<minLon) minLon=p.lon;
    if (p.lon>maxLon) maxLon=p.lon;
  }
  const padLat = padMeters / 111320;
  const midLat = (minLat+maxLat)/2;
  const padLon = padMeters / (111320 * Math.cos(midLat*Math.PI/180));
  return [minLat-padLat, minLon-padLon, maxLat+padLat, maxLon+padLon];
}

function overpassQueryForBBox(bbox) {
  const [s,w,n,e] = bbox;
  return `
[out:json][timeout:25];
(
  node["highway"="traffic_signals"](${s},${w},${n},${e});
  node["highway"="stop"](${s},${w},${n},${e});
  node["highway"="motorway_junction"](${s},${w},${n},${e});
  way["junction"="roundabout"](${s},${w},${n},${e});
  relation["type"="multipolygon"]["junction"="roundabout"](${s},${w},${n},${e});
  way["maxspeed"](${s},${w},${n},${e});  /* speed limits */
);
out center tags;
  `.trim();
}

function getSpeedColor(maxspeedTagOrNumber) {
  let num;
  if (typeof maxspeedTagOrNumber === 'number') num = maxspeedTagOrNumber;
  else {
    const str = String(maxspeedTagOrNumber || '').toLowerCase();
    const mph = str.match(/(\d+(?:\.\d+)?)\s*mph/);
    if (mph) num = parseFloat(mph[1]) * 1.60934;
    else {
      const kmh = str.match(/(\d+(?:\.\d+)?)/);
      num = kmh ? parseFloat(kmh[1]) : NaN;
    }
  }
  if (!isFinite(num)) return '#ff8800';
  if (num <= 30) return '#ff8800';
  if (num <= 50) return '#ffaa33';
  if (num <= 70) return '#ffcc00';
  if (num <= 90) return '#c8d400';
  if (num <= 110) return '#89dd00';
  return '#38c172';
}
function parseMaxspeedToKmh(tag) {
  if (!tag) return null;
  const s = String(tag).toLowerCase().trim();
  if (s === 'signals' || s === 'variable' || s === 'none') return null;
  const mph = s.match(/(\d+(?:\.\d+)?)\s*mph/);
  if (mph) return Math.round(parseFloat(mph[1]) * 1.60934);
  const kmh = s.match(/(\d+(?:\.\d+)?)/);
  return kmh ? Math.round(parseFloat(kmh[1])) : null;
}

/* make tooltip bg/border match marker color */
function colorizeTooltip(marker, color) {
  setTimeout(() => {
    const el = marker.getTooltip && marker.getTooltip() && marker.getTooltip().getElement
      ? marker.getTooltip().getElement()
      : null;
    if (el) {
      el.style.background = color;
      el.style.borderColor = color;
      el.style.color = '#000'; // readable on bright colors
    }
  }, 0);
}

/* project a point to polyline to get chainage (meters from start) */
function toXYChain(latlngs) {
  const lat0 = (latlngs[0][0] + latlngs[latlngs.length-1][0]) / 2;
  const xy = latlngs.map(([lat,lon]) => toXY(lat, lon, lat0));
  const cum = [0];
  for (let i=1;i<xy.length;i++) cum[i] = cum[i-1] + distMeters(xy[i], xy[i-1]);
  return { xy, cum, lat0 };
}
function projectChainage({xy, cum}, lat0, lat, lon) {
  const p = toXY(lat, lon, lat0);
  let best = { d: Infinity, s: 0 };
  for (let i=0; i<xy.length-1; i++) {
    const a = xy[i], b = xy[i+1];
    const abx = b[0]-a[0], aby = b[1]-a[1];
    const apx = p[0]-a[0], apy = p[1]-a[1];
    const ab2 = abx*abx + aby*aby;
    let t = ab2 ? (abx*apx + aby*apy) / ab2 : 0;
    t = Math.max(0, Math.min(1, t));
    const proj = [a[0] + abx*t, a[1] + aby*t];
    const d = distMeters(p, proj);
    if (d < best.d) best = { d, s: cum[i] + Math.hypot((proj[0]-a[0]), (proj[1]-a[1])) };
  }
  return best.s;
}

/* Add OSM features; speed-limit labels only on change along the route */
function addOsmFeaturesToMap(map, geojson, groupLayer, latlngs) {
  const els = geojson?.elements || [];
  const others = [];
  const speedWays = [];

  for (const el of els) {
    let lat=null, lon=null;
    if (el.type === 'node') { lat = el.lat; lon = el.lon; }
    else if ((el.type === 'way' || el.type === 'relation') && el.center) {
      lat = el.center.lat; lon = el.center.lon;
    }
    if (lat==null || lon==null) continue;

    const tags = el.tags || {};
    if (tags.maxspeed) {
      speedWays.push({ lat, lon, tags });
    } else {
      let label='', color='#4da3ff';
      if (tags.highway === 'traffic_signals') { label = 'Traffic light'; color = '#ffcc00'; }
      else if (tags.highway === 'stop')       { label = 'Stop sign';     color = '#ff4d4d'; }
      else if (tags.highway === 'motorway_junction' || tags.junction === 'yes') { label = 'Junction'; }
      else if (tags.junction === 'roundabout') { label = 'Roundabout'; color = '#38c172'; }
      if (label) others.push({ lat, lon, label, color });
    }
  }

  /* draw non-speed features (always labeled) */
  for (const f of others) {
    const m = L.circleMarker([f.lat, f.lon], {
      radius: 6, color: f.color, weight: 2, fillColor: f.color, fillOpacity: 0.25
    }).addTo(groupLayer);
    m.bindTooltip(f.label, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
    colorizeTooltip(m, f.color);
  }

  /* handle speed limits: only label when value changes along route */
  if (speedWays.length && latlngs?.length >= 2) {
    const chain = toXYChain(latlngs);
    const pts = speedWays.map(sw => {
      const v = parseMaxspeedToKmh(sw.tags.maxspeed);
      const color = getSpeedColor(v ?? sw.tags.maxspeed);
      const s = projectChainage(chain, chain.lat0, sw.lat, sw.lon);
      return { lat: sw.lat, lon: sw.lon, v, color, s };
    }).sort((a,b)=>a.s-b.s);

    let prev = null;
    for (const f of pts) {
      const m = L.circleMarker([f.lat, f.lon], {
        radius: 6, color: f.color, weight: 2, fillColor: f.color, fillOpacity: 0.25
      }).addTo(groupLayer);
      const changed = (f.v != null) ? (prev === null || f.v !== prev) : false;
      if (changed) {
        m.bindTooltip(`Speed limit: ${f.v}`, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
        colorizeTooltip(m, f.color);
        prev = f.v;
      }
      // if not changed, keep ring without label
    }
  } else {
    // Fallback: no route context ‚Äî label them all
    for (const sw of speedWays) {
      const v = parseMaxspeedToKmh(sw.tags.maxspeed);
      const color = getSpeedColor(v ?? sw.tags.maxspeed);
      const m = L.circleMarker([sw.lat, sw.lon], {
        radius: 6, color, weight: 2, fillColor: color, fillOpacity: 0.25
      }).addTo(groupLayer);
      if (v != null) {
        m.bindTooltip(`Speed limit: ${v}`, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
        colorizeTooltip(m, color);
      }
    }
  }
}

/* ------------------- Charts ------------------- */
function makeLineChart(canvas, {labels, values, label, yTitle, min, max, suggestedMin, suggestedMax, beginAtZero}) {
  const y = {
    ticks: { color: '#b9c0cc' },
    title: { display: true, text: yTitle, color: '#b9c0cc' }
  };
  if (beginAtZero === true) y.beginAtZero = true;
  if (Number.isFinite(min)) y.min = min;
  if (Number.isFinite(max)) y.max = max;
  if (!Number.isFinite(min) && Number.isFinite(suggestedMin)) y.suggestedMin = suggestedMin;
  if (!Number.isFinite(max) && Number.isFinite(suggestedMax)) y.suggestedMax = suggestedMax;

  const ctx = canvas.getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{
        label,
        data: values,
        borderWidth: 1.2,
        tension: 0.12,
        pointRadius: 0,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: { ticks: { color: '#b9c0cc', maxTicksLimit: 6 }},
        y
      },
      plugins: { legend: { display: false } }
    }
  });
}

/* ------------------- Session UI ------------------- */
function createSessionCard(sessionName) {
  const wrap = document.createElement('section');
  wrap.className = 'session';

  const head = document.createElement('header');
  const h = document.createElement('h2');
  h.className = 'session-title';
  h.textContent = sessionName;
  head.appendChild(h);

  const body = document.createElement('div');
  body.className = 'session-body';

  const gallery = document.createElement('div');
  gallery.className = 'gallery';

  const map = document.createElement('div'); map.className='map';

  const row = document.createElement('div'); row.className='row';
  const legend = document.createElement('div'); legend.className='legend';
  legend.innerHTML = `
    <span><span class="dot dot-blue"></span> Trace</span>
    <span><span class="dot dot-yellow"></span> Traffic light</span>
    <span><span class="dot dot-red"></span> Stop sign</span>
    <span><span class="dot dot-green"></span> Roundabout</span>
    <span><span class="dot" style="background:#4da3ff"></span> Junction</span>
    <span><span class="dot dot-orange"></span> Speed limit</span>
  `;
  const status = document.createElement('div'); status.className='status'; text = 'Loading‚Ä¶'; status.textContent = text;
  row.append(legend, status);

  const charts = document.createElement('div'); charts.className='charts';
  const speedCanvas = document.createElement('canvas');
  const accCanvas = document.createElement('canvas');
  speedCanvas.height = 220;   // explicit pixel height
  accCanvas.height   = 220;
  
  charts.append(speedCanvas, accCanvas);

  body.append(gallery, map, row, charts);
  wrap.append(head, body);
  return { wrap, gallery, map, status, speedCanvas, accCanvas };
}

/* ------------------- Lightbox ------------------- */
const lightbox = document.getElementById('lightbox');
const lightboxImg = document.getElementById('lightboxImg');
function openLightbox(src) {
  lightboxImg.src = src;
  lightbox.classList.add('show');
  lightbox.focus();
}
lightbox.addEventListener('click', () => lightbox.classList.remove('show'));
lightbox.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') lightbox.classList.remove('show');
});

/* ------------------- Main processing ------------------- */
async function processZipFile(file) {
  const sessionName = slugWithoutExt(file.name);
  const ui = createSessionCard(sessionName);
  document.getElementById('sessions').appendChild(ui.wrap);

  try {
    ui.status.textContent = 'Reading ZIP‚Ä¶';
    const zip = await JSZip.loadAsync(file);

    /* Camera gallery */
    ui.status.textContent = 'Loading photos‚Ä¶';
    const images = await loadAllCameraImagesFromZip(zip);
    if (images.length) {
      for (const img of images) {
        const t = document.createElement('img');
        t.className = 'thumb';
        t.src = img.url;
        t.alt = img.name;
        t.addEventListener('click', () => openLightbox(img.url));
        ui.gallery.appendChild(t);
      }
    }

    // CSVs
    ui.status.textContent = 'Parsing CSVs‚Ä¶';
    const [locationRows, totalAccRows, accelRows] = await Promise.all([
      loadCsvFromZip(zip, /(^|\/)Location\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)TotalAcceleration\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)Accelerometer\.csv$/i)
    ]);

    // Track & map
    const track = extractTrack(locationRows);
    ui.status.textContent = 'Rendering map‚Ä¶';
    const map = L.map(ui.map);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19, attribution: '&copy; OpenStreetMap'
    }).addTo(map);

    if (track?.length) {
      const latlngs = track.map(p => [p.lat, p.lon]);
      const poly = L.polyline(latlngs, { color: '#3a86ff', weight: 3 }).addTo(map);
      map.fitBounds(poly.getBounds(), { padding: [16,16] });

      /* Start marker + label (label matches marker color) */
      const startColor = '#00e676';
      const startLatLng = latlngs[0];
      const start = L.circleMarker(startLatLng, {
        radius: 6, color: startColor, weight: 2, fillColor: startColor, fillOpacity: 0.6
      }).addTo(map);
      start.bindTooltip('Start', {
        permanent: true, direction: 'right', offset: [8,0], className: 'feature-tag'
      });
      colorizeTooltip(start, startColor);

      /* Direction arrow along the path (one arrow near the end) */
      try {
        L.polylineDecorator(poly, {
          patterns: [
            {
              offset: '85%',
              repeat: 0,
              symbol: L.Symbol.arrowHead({
                pixelSize: 14,
                headAngle: 60,
                pathOptions: { color: '#3a86ff', weight: 2, opacity: 0.9 }
              })
            }
          ]
        }).addTo(map);
      } catch (e) {
        console.warn('PolylineDecorator unavailable; skipping arrow.', e);
      }

      // OSM features via Overpass
      ui.status.textContent = 'Fetching OSM features‚Ä¶';
      const bbox = bboxForTrack(track, 80);
      const query = overpassQueryForBBox(bbox);
      try {
        const osm = await overpassFetch(query);
        const layer = L.layerGroup().addTo(map);
        addOsmFeaturesToMap(map, osm, layer, latlngs);
        ui.status.textContent = 'Map ready.';
      } catch (e) {
        console.warn('Overpass failed:', e);
        ui.status.textContent = 'Trace rendered. Features unavailable (Overpass error).';
      }
    } else {
      // fallback view (Stockholm) if no coords
      map.setView([59.3293, 18.0686], 10);
      ui.status.textContent = 'No coordinates found.';
    }

    // Speed: per-session axis => [min(speed)-5, max(speed)+5]
    ui.status.textContent = 'Preparing speed‚Ä¶';
    const { labels: speedLabels, values: speedValues } = computeSpeedSeriesFromLocation(locationRows || []);
    const finiteSpeeds = speedValues.filter(v => Number.isFinite(v));
    let yMin, yMax;
    if (finiteSpeeds.length) {
      yMin = Math.min(...finiteSpeeds) - 5;
      yMax = Math.max(...finiteSpeeds) + 5;
    }
    makeLineChart(ui.speedCanvas, {
      labels: speedLabels,
      values: speedValues,
      label: 'Speed (km/h)',
      yTitle: 'km/h',
      min: yMin,
      max: yMax
    });

    // Acceleration: linear (already gravity-free) from Accelerometer.csv; fallback to TotalAcceleration - 9.81
    ui.status.textContent = 'Preparing acceleration‚Ä¶';
    let { labels: accLabels, values: accValues } = computeLinearAccMagnitude(accelRows);
    if ((!accValues || !accValues.length) && totalAccRows?.length) {
      const tk = pick(['time','timestamp','datetime','seconds_elapsed'], totalAccRows[0]);
      const ak = pick(['total','magnitude','acc','accel','a_total'], totalAccRows[0]);
      const lbl = [], val = [];
      for (const r of totalAccRows) {
        const t = tk
          ? (String(tk).toLowerCase().includes('elapsed') ? new Date(Number(r[tk])*1000) : parseTime(r[tk]))
          : null;
        const a = Number(r[ak]);
        if (Number.isFinite(a)) {
          lbl.push(t ? formatHHMMSS(t) : String(lbl.length));
          val.push(Math.max(0, a - 9.81));
        }
      }
      const zipped = lbl.map((l,i)=>({l, v: val[i]}));
      const slim = decimate(zipped, 2000);
      accLabels = slim.map(x=>x.l);
      accValues = slim.map(x=>x.v);
    }
    makeLineChart(ui.accCanvas, {
      labels: accLabels || [],
      values: accValues || [],
      label: 'Linear acceleration |a| (m/s¬≤)',
      yTitle: 'm/s¬≤',
      beginAtZero: true
    });

    ui.status.textContent = 'Ready.';
  } catch (err) {
    console.error(err);
    ui.status.textContent = 'Failed: ' + (err?.message || err);
  }
}

/* ------------------- Inputs ------------------- */
const folderInput = document.getElementById('folderInput');
const filesInput  = document.getElementById('filesInput');

function uniqueZipFilesFromFileList(fileList) {
  const out = [];
  const seen = new Set();
  for (const f of fileList) {
    if (!/\.zip$/i.test(f.name)) continue;
    const key = f.webkitRelativePath || f.name;
    if (!seen.has(key)) { seen.add(key); out.push(f); }
  }
  return out;
}

folderInput.addEventListener('change', async (e) => {
  const files = uniqueZipFilesFromFileList(e.target.files);
  if (!files.length) return;
  document.getElementById('sessions').innerHTML = '';
  for (const f of files) await processZipFile(f);
  folderInput.value = '';
});

filesInput.addEventListener('change', async (e) => {
  const files = uniqueZipFilesFromFileList(e.target.files);
  if (!files.length) return;
  document.getElementById('sessions').innerHTML = '';
  for (const f of files) await processZipFile(f);
  filesInput.value = '';
});
</script>
</body>
</html>
