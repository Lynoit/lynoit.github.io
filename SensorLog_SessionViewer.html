<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sensor Sessions Viewer (ZIP ‚Üí Map + Plots)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- PolylineDecorator for direction arrow -->
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Papa Parse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root {
      --bg: #0e0f11;
      --card: #17181b;
      --muted: #a9b0bc;
      --fg: #e7eaf0;
      --accent: #4da3ff;
      --blue: #3a86ff;
      --red: #ff4d4d;
      --green: #38c172;
      --yellow: #ffcc00;
      --speedlimit: #ff8800;
      --border: #2a2d33;
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(14,15,17,0.95), rgba(14,15,17,0.85) 60%, transparent);
      backdrop-filter: blur(6px);
      padding: 16px 16px 8px;
      border-bottom: 1px solid var(--border);
    }
    h1 { margin: 0 0 8px; font-size: 18px; font-weight: 600; letter-spacing: .2px }
    #controls {
      display: flex; flex-wrap: wrap; gap: 10px; align-items: center;
    }
    .btn {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--card); color: var(--fg);
      border: 1px solid var(--border);
      padding: 8px 12px; border-radius: 10px; cursor: pointer;
    }
    .btn:hover { border-color: #3b3f46 }
    .hint { color: var(--muted); font-size: 12px }
    .tiny { font-size: 11px; color: var(--muted) }

    /* Stack sessions vertically */
    .grid {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 16px;
    }

    .session {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      display: flex; flex-direction: column;
    }
    .session header {
      background: linear-gradient(180deg, #1b1d22, #17181b);
      padding: 12px 14px; border-bottom: 1px solid var(--border);
    }
    .session-title { margin: 0; font-size: 15px; font-weight: 600 }
    .session-body { padding: 12px; display: grid; gap: 12px }

    /* -------- Camera gallery -------- */
    .gallery {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
      gap: 8px;
    }
    .thumb {
      width: 100%; aspect-ratio: 4/3; object-fit: cover;
      border-radius: 10px; border: 1px solid var(--border);
      background: #0a0b0d; cursor: pointer;
    }
    .thumb:hover { filter: brightness(1.05) }

    /* Lightbox */
    .lightbox {
      position: fixed; inset: 0; background: rgba(0,0,0,0.85);
      display: none; align-items: center; justify-content: center;
      z-index: 1000;
    }
    .lightbox.show { display: flex }
    .lightbox img {
      max-width: 95vw; max-height: 92vh; border-radius: 12px; border: 1px solid var(--border);
      box-shadow: 0 10px 32px rgba(0,0,0,0.5);
    }

    .map {
      width: 100%; height: 320px;
      border-radius: 12px; border: 1px solid var(--border); overflow: hidden;
    }
    .charts {
      display: grid;
      grid-template-columns: 1fr;
      row-gap: 20px;
    }
    .charts canvas {
      display: block;
      width: 100% !important;
      height: 320px !important;
      background: #101215;
      border: 1px solid var(--border);
      border-radius: 12px;
    }
    .status { font-size: 12px; color: var(--muted) }
    .row {
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px; flex-wrap: wrap;
    }
    .legend {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap;
      font-size: 12px; color: var(--muted);
    }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block }
    .dot-blue   { background: var(--blue) }
    .dot-red    { background: var(--red) }
    .dot-yellow { background: var(--yellow) }
    .dot-green  { background: var(--green) }
    .dot-orange { background: var(--speedlimit) }

    .leaflet-tooltip.feature-tag {
      background: rgba(0,0,0,0.75);
      color: #000;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 11px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    footer {
      text-align: center; padding: 16px; color: var(--muted);
      border-top: 1px solid var(--border);
    }
    a { color: var(--accent); text-decoration: none }
    a:hover { text-decoration: underline }
    input[type=file] { display:none }
    #openFolderLabel::before, #openFilesLabel::before {
      content: "üìÅ"; filter: grayscale(100%); margin-right: 6px;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Sessions Viewer</h1>
    <div id="controls">
      <label class="btn" id="openFolderLabel" title="Pick a folder with multiple ZIPs">
        <input id="folderInput" type="file" webkitdirectory directory multiple accept=".zip"/>
        Open folder of ZIPs
      </label>
      <label class="btn" id="openFilesLabel" title="Or pick several ZIP files">
        <input id="filesInput" type="file" multiple accept=".zip"/>
        Open ZIP files
      </label>
      <span class="hint">Each ZIP like your sample (Location.csv, Accelerometer.csv, TotalAcceleration.csv, Camera/*.jpg).</span>
      <span class="tiny">OSM features via Overpass; gentle throttling applied üïäÔ∏è</span>
    </div>
  </header>

  <main class="grid" id="sessions"></main>

  <!-- One global lightbox for all sessions -->
  <div id="lightbox" class="lightbox" tabindex="0" aria-label="Image viewer">
    <img id="lightboxImg" alt="Full size"/>
  </div>

  <footer>¬© Zeekr Tech EU 2025</footer>

<script>
/* ------------------- Overpass setup (mirrors + throttling) ------------------- */
const OVERPASS_ENDPOINTS = [
  'https://overpass.kumi.systems/api/interpreter',
  'https://overpass-api.de/api/interpreter',
  'https://overpass.nchc.org.tw/api/interpreter'
];
let overpassQueue = Promise.resolve();

/* ------------------- Chart.js defaults ------------------- */
Chart.defaults.color = '#b9c0cc';
Chart.defaults.font = {
  family: 'system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
  size: 14,
  weight: '400',
};

/* ------------------- Utilities ------------------- */
function cssVar(name, fallback) {
  const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
  return v || fallback;
}
Chart.defaults.responsive = true;
Chart.defaults.maintainAspectRatio = false;
// Cap DPR a bit so very high-DPI screens don‚Äôt make fonts look tiny
Chart.defaults.devicePixelRatio = Math.min(window.devicePixelRatio || 1, 2);

function overpassFetch(query) {
  const run = async () => {
    for (const url of OVERPASS_ENDPOINTS) {
      try {
        const res = await fetch(url, { method: 'POST', body: query, headers: { 'Content-Type': 'text/plain' } });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return await res.json();
      } catch (e) { console.warn('Overpass failed on', url, e); }
    }
    throw new Error('All Overpass endpoints failed');
  };
  overpassQueue = overpassQueue.then(() => new Promise(r => setTimeout(r, 500))).then(run);
  return overpassQueue;
}

function formatRelativeTime(ms) {
  const totalSec = Math.floor(ms / 1000);
  const mm = Math.floor(totalSec / 60);
  const ss = totalSec % 60;
  return mm > 0 ? `${mm}:${String(ss).padStart(2,'0')}` : `${ss}s`;
}

function slugWithoutExt(fileName) {
  const base = fileName.split('/').pop();
  return base.replace(/\.zip$/i, '');
}
function parseTime(v) {
  if (v == null || v === '') return null;
  if (typeof v === 'number') {
    if (v > 1e17) return new Date(v / 1e6);   // ns -> ms
    if (v > 1e14) return new Date(v / 1e3);   // ¬µs -> ms
    if (v > 1e12) return new Date(v);         // ms
    if (v > 1e9)  return new Date(v * 1000);  // s -> ms
    return null;
  }
  const num = Number(v);
  if (!Number.isNaN(num)) return parseTime(num);
  const d = new Date(v);
  return isNaN(d) ? null : d;
}
function formatHHMMSS(d) {
  const pad = n => String(n).padStart(2, '0');
  return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
}
function pick(keys, obj) {
  for (const k of keys) {
    const found = Object.keys(obj).find(x => x.toLowerCase() === k.toLowerCase());
    if (found) return found;
  }
  return null;
}
function decimate(xs, max=2000) {
  if (xs.length <= max) return xs;
  const step = Math.ceil(xs.length / max);
  const out = [];
  for (let i=0; i<xs.length; i+=step) out.push(xs[i]);
  return out;
}

/* small vector helpers for route projection (meters) */
function toXY(lat, lon, lat0) {
  const R = 6371008.8;
  const x = (lon * Math.PI/180) * R * Math.cos(lat0 * Math.PI/180);
  const y = (lat * Math.PI/180) * R;
  return [x, y];
}
function distMeters(a, b) {
  const dx = a[0]-b[0], dy = a[1]-b[1];
  return Math.hypot(dx, dy);
}

/* Build a speed-limit profile along the route (chainage s in meters). */
function extractMaxspeedProfile(geojson, latlngs) {
  const els = geojson?.elements || [];
  if (!latlngs || latlngs.length < 2) return [];
  const chain = toXYChain(latlngs);
  const pts = [];
  for (const el of els) {
    const tags = el.tags || {};
    if (!('maxspeed' in tags)) continue;
    let lat = null, lon = null;
    if (el.type === 'node') { lat = el.lat; lon = el.lon; }
    else if ((el.type === 'way' || el.type === 'relation') && el.center) {
      lat = el.center.lat; lon = el.center.lon;
    }
    if (lat == null || lon == null) continue;
    const v = parseMaxspeedToKmh(tags.maxspeed);
    if (v == null) continue;
    const s = projectChainage(chain, chain.lat0, lat, lon);
    pts.push({ s, v });
  }
  pts.sort((a,b)=>a.s-b.s);
  const profile = [];
  let lastV = null;
  for (const p of pts) {
    if (p.v !== lastV) { profile.push(p); lastV = p.v; }
  }
  return profile; // [{s, v}] at change points
}

/* For each location sample, map chainage -> speed limit (km/h). */
function computeMaxspeedSeriesAligned(latlngs, profile) {
  if (!latlngs?.length || !profile?.length) return new Array(latlngs.length).fill(null);
  const chain = toXYChain(latlngs);
  function atS(s) {
    let lo = 0, hi = profile.length - 1, ans = -1;
    while (lo <= hi) {
      const mid = (lo + hi) >> 1;
      if (profile[mid].s <= s) { ans = mid; lo = mid + 1; }
      else hi = mid - 1;
    }
    return ans >= 0 ? profile[ans].v : null;
  }
  const out = new Array(latlngs.length);
  for (let i=0; i<latlngs.length; i++) {
    const [lat, lon] = latlngs[i];
    const s = projectChainage(chain, chain.lat0, lat, lon);
    out[i] = atS(s);
  }
  return out;
}

/* project a point to polyline to get chainage (meters from start) */
function toXYChain(latlngs) {
  const lat0 = (latlngs[0][0] + latlngs[latlngs.length-1][0]) / 2;
  const xy = latlngs.map(([lat,lon]) => toXY(lat, lon, lat0));
  const cum = [0];
  for (let i=1;i<xy.length;i++) cum[i] = cum[i-1] + distMeters(xy[i], xy[i-1]);
  return { xy, cum, lat0 };
}
function projectChainage({xy, cum}, lat0, lat, lon) {
  const p = toXY(lat, lon, lat0);
  let best = { d: Infinity, s: 0 };
  for (let i=0; i<xy.length-1; i++) {
    const a = xy[i], b = xy[i+1];
    const abx = b[0]-a[0], aby = b[1]-a[1];
    const apx = p[0]-a[0], apy = p[1]-a[1];
    const ab2 = abx*abx + aby*aby;
    let t = ab2 ? (abx*apx + aby*apy) / ab2 : 0;
    t = Math.max(0, Math.min(1, t));
    const proj = [a[0] + abx*t, a[1] + aby*t];
    const d = distMeters(p, proj);
    if (d < best.d) best = { d, s: cum[i] + Math.hypot((proj[0]-a[0]), (proj[1]-a[1])) };
  }
  return best.s;
}

function getSpeedColor(maxspeedTagOrNumber) {
  let num;
  if (typeof maxspeedTagOrNumber === 'number') num = maxspeedTagOrNumber;
  else {
    const str = String(maxspeedTagOrNumber || '').toLowerCase();
    const mph = str.match(/(\d+(?:\.\d+)?)\s*mph/);
    if (mph) num = parseFloat(mph[1]) * 1.60934;
    else {
      const kmh = str.match(/(\d+(?:\.\d+)?)/);
      num = kmh ? parseFloat(kmh[1]) : NaN;
    }
  }
  if (!isFinite(num)) return '#ff8800';
  if (num <= 30) return '#ff8800';
  if (num <= 50) return '#ffaa33';
  if (num <= 70) return '#ffcc00';
  if (num <= 90) return '#c8d400';
  if (num <= 110) return '#89dd00';
  return '#38c172';
}
function parseMaxspeedToKmh(tag) {
  if (!tag) return null;
  const s = String(tag).toLowerCase().trim();
  if (s === 'signals' || s === 'variable' || s === 'none') return null;
  const mph = s.match(/(\d+(?:\.\d+)?)\s*mph/);
  if (mph) return Math.round(parseFloat(mph[1]) * 1.60934);
  const kmh = s.match(/(\d+(?:\.\d+)?)/);
  return kmh ? Math.round(parseFloat(kmh[1])) : null;
}

/* Tooltip color sync */
function colorizeTooltip(marker, color) {
  setTimeout(() => {
    const el = marker.getTooltip && marker.getTooltip() && marker.getTooltip().getElement
      ? marker.getTooltip().getElement()
      : null;
    if (el) {
      el.style.background = color;
      el.style.borderColor = color;
      el.style.color = '#000';
    }
  }, 0);
}

/* ------------------- OSM features on map ------------------- */
function bboxForTrack(track, padMeters = 80) {
  let minLat=  90, minLon= 180, maxLat= -90, maxLon= -180;
  for (const p of track) {
    if (p.lat<minLat) minLat=p.lat;
    if (p.lat>maxLat) maxLat=p.lat;
    if (p.lon<minLon) minLon=p.lon;
    if (p.lon>maxLon) maxLon=p.lon;
  }
  const padLat = padMeters / 111320;
  const midLat = (minLat+maxLat)/2;
  const padLon = padMeters / (111320 * Math.cos(midLat*Math.PI/180));
  return [minLat-padLat, minLon-padLon, maxLat+padLat, maxLon+padLon];
}
function overpassQueryForBBox(bbox) {
  const [s,w,n,e] = bbox;
  return `
[out:json][timeout:25];
(
  node["highway"="traffic_signals"](${s},${w},${n},${e});
  node["highway"="stop"](${s},${w},${n},${e});
  node["highway"="motorway_junction"](${s},${w},${n},${e});
  way["junction"="roundabout"](${s},${w},${n},${e});
  relation["type"="multipolygon"]["junction"="roundabout"](${s},${w},${n},${e});
  way["maxspeed"](${s},${w},${n},${e});
);
out center tags;`.trim();
}

/* ------------------- Marker plugin (A, B, and A‚ÜîB bubble) ------------------- */
const MarkerPlugin = {
  id: 'twoMarkers',
  afterDatasetsDraw(chart) {
    const markers = chart.$markers;
    if (!markers) return;

    const { ctx, chartArea, scales } = chart;
    const xScale = scales.x, yScale = scales.y;
    const labels = chart.data.labels;
    const speedDataset = chart.data.datasets[0]; // dataset[0] = vehicle speed

    function drawOne(i, color, tag) {
      if (i == null || i < 0 || i >= labels.length) return;
      const yVal = speedDataset.data[i];
      if (!Number.isFinite(yVal)) return;
      const x = xScale.getPixelForValue(i);
      const y = yScale.getPixelForValue(yVal);

      ctx.save();
      // hairline
      ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.setLineDash([4,3]);
      ctx.beginPath(); ctx.moveTo(x, chartArea.top); ctx.lineTo(x, chartArea.bottom); ctx.stroke();
      ctx.setLineDash([]);
      // dot
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();

      // bubble (time ‚Ä¢ speed)
      const text = `${labels[i]} ‚Ä¢ ${yVal.toFixed(1)} km/h`;
      ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      const pad = 6, r = 6, tw = ctx.measureText(text).width;
      const bw = tw + pad*2 + 16, bh = 24;
      let bx = Math.min(Math.max(x - bw/2, chartArea.left+2), chartArea.right - bw - 2);
      let by = y - 10 - bh; if (by < chartArea.top + 2) by = y + 12;

      ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.strokeStyle = color; ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(bx+r,by); ctx.lineTo(bx+bw-r,by); ctx.quadraticCurveTo(bx+bw,by,bx+bw,by+r);
      ctx.lineTo(bx+bw,by+bh-r); ctx.quadraticCurveTo(bx+bw,by+bh,bx+bw-r,by+bh);
      ctx.lineTo(bx+r,by+bh); ctx.quadraticCurveTo(bx,by+bh,bx,by+bh-r);
      ctx.lineTo(bx,by+r); ctx.quadraticCurveTo(bx,by,bx+r,by); ctx.closePath(); ctx.fill(); ctx.stroke();

      // tag
      const tagR = 7, tagCx = bx + pad + tagR, tagCy = by + bh/2;
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(tagCx, tagCy, tagR, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.font = 'bold 10px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(tag, tagCx, tagCy);

      // text
      ctx.fillStyle = '#e7eaf0'; ctx.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
      ctx.fillText(text, bx + pad + 2*tagR + 6, by + bh/2);
      ctx.restore();
    }

    // draw A and B
    drawOne(markers.A, markers.colorA || '#00e5ff', 'A');
    drawOne(markers.B, markers.colorB || '#ff5ec4', 'B');

    // draw A‚ÜîB acceleration bubble at midpoint
    if (markers.A != null && markers.B != null && markers.A !== markers.B) {
      const iA = markers.A, iB = markers.B;
      const vAkph = speedDataset.data[iA], vBkph = speedDataset.data[iB];
      const tAms = chart.$series?.relMs?.[iA], tBms = chart.$series?.relMs?.[iB];
      if ([vAkph,vBkph,tAms,tBms].every(Number.isFinite) && tAms !== tBms) {
        const a = ((vBkph/3.6) - (vAkph/3.6)) / ((tBms - tAms)/1000); // m/s¬≤
        const xA = xScale.getPixelForValue(iA), yA = yScale.getPixelForValue(vAkph);
        const xB = xScale.getPixelForValue(iB), yB = yScale.getPixelForValue(vBkph);
        const mx = (xA + xB)/2, my = (yA + yB)/2 - 30;

        const text = `a = ${a.toFixed(3)} m/s¬≤`;
        const pad = 6, r = 6, bh = 20;
        const tw = chart.ctx.measureText(text).width, bw = tw + pad*2;
        let bx = mx - bw/2, by = my - bh/2;

        chart.ctx.save();
        chart.ctx.fillStyle = 'rgba(0,0,0,0.85)'; chart.ctx.strokeStyle = '#ffd166'; chart.ctx.lineWidth = 1;
        chart.ctx.beginPath();
        chart.ctx.moveTo(bx+r,by); chart.ctx.lineTo(bx+bw-r,by);
        chart.ctx.quadraticCurveTo(bx+bw,by,bx+bw,by+r);
        chart.ctx.lineTo(bx+bw,by+bh-r); chart.ctx.quadraticCurveTo(bx+bw,by+bh,bx+bw-r,by+bh);
        chart.ctx.lineTo(bx+r,by+bh); chart.ctx.quadraticCurveTo(bx,by+bh,bx,by+bh-r);
        chart.ctx.lineTo(bx,by+r); chart.ctx.quadraticCurveTo(bx,by,bx+r,by);
        chart.ctx.closePath(); chart.ctx.fill(); chart.ctx.stroke();
        chart.ctx.fillStyle = '#fff'; chart.ctx.textAlign = 'center'; chart.ctx.textBaseline = 'middle';
        chart.ctx.fillText(text, bx + bw/2, by + bh/2);
        chart.ctx.restore();
      }
    }
  }
};
Chart.register(MarkerPlugin);

/* ------------------- Chart helpers ------------------- */
function prepareCrispCanvas(canvas) {
  // Match backing store size to CSS size
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const rect = canvas.getBoundingClientRect();
  // Only set if changed to avoid flicker
  const w = Math.round(rect.width * dpr);
  const h = Math.round(rect.height * dpr);
  if (canvas.width !== w) canvas.width = w;
  if (canvas.height !== h) canvas.height = h;
}
  
function makeMultiLineChart(canvas, { labels, datasets, yTitle, min, max }) {
  prepareCrispCanvas(canvas);   // <--- add
  const ctx = canvas.getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,                        // add
      devicePixelRatio: Math.min(window.devicePixelRatio || 1, 2), // add
      scales: {
        x: { ticks: { color: '#b9c0cc', maxTicksLimit: 6 } },
        y: {
          ticks: { color: '#b9c0cc' },
          title: { display: true, text: yTitle, color: '#b9c0cc' },
          ...(Number.isFinite(min) ? { min } : {}),
          ...(Number.isFinite(max) ? { max } : {})
        }
      },
      plugins: { legend: { display: true } }
    }
  });
}
function makeLineChart(canvas, {labels, values, label, yTitle, min, max, suggestedMin, suggestedMax, beginAtZero}) {
  const y = {
    ticks: { color: '#b9c0cc', font: { size: 15 } },
    title: { display: true, text: yTitle, color: '#b9c0cc', font: { size: 14, weight: '600' } }
  };
  if (beginAtZero === true) y.beginAtZero = true;
  if (Number.isFinite(min)) y.min = min;
  if (Number.isFinite(max)) y.max = max;
  if (!Number.isFinite(min) && Number.isFinite(suggestedMin)) y.suggestedMin = suggestedMin;
  if (!Number.isFinite(max) && Number.isFinite(suggestedMax)) y.suggestedMax = suggestedMax;

  prepareCrispCanvas(canvas);   // <--- add
  const ctx = canvas.getContext('2d');
  return new Chart(ctx, {
    type: 'line',
    data: {
      labels,
      datasets: [{ label, data: values, borderWidth: 1.4, tension: 0.12, pointRadius: 0 }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      devicePixelRatio: window.devicePixelRatio || 1,
      scales: {
        x: { ticks: { color: '#b9c0cc', font: { size: 13 }, maxTicksLimit: 6 } },
        y
      },
      plugins: { legend: { display: false } }
    }
  });
}

  /* ------------------- Acceleration helpers ------------------- */
function computeAccelXYZSeries(accelRows) {
  if (!accelRows?.length) return null;

  // mm:ss or "Xs"
  function formatRelative(ms) {
    const totalSec = Math.floor(ms / 1000);
    const mm = Math.floor(totalSec / 60);
    const ss = totalSec % 60;
    return mm > 0 ? `${mm}:${String(ss).padStart(2,'0')}` : `${ss}s`;
  }

  const sample = accelRows[0];
  const xK = pick(['x','ax'], sample);
  const yK = pick(['y','ay'], sample);
  const zK = pick(['z','az'], sample);
  const tK = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], sample);
  if (!xK || !yK || !zK) return null;

  const raw = [];
  const idxFallback = [];
  for (let i = 0; i < accelRows.length; i++) {
    const r = accelRows[i];
    const ax = Number(r[xK]), ay = Number(r[yK]), az = Number(r[zK]);
    if (![ax, ay, az].every(Number.isFinite)) continue;

    let tms = null;
    if (tK) {
      if (String(tK).toLowerCase().includes('elapsed')) {
        const secs = Number(r[tK]);
        if (Number.isFinite(secs)) tms = secs * 1000;
      } else {
        const dt = parseTime(r[tK]);
        if (dt instanceof Date && !isNaN(dt)) tms = dt.getTime();
      }
    }

    if (tms != null) raw.push({ t: tms, ax, ay, az });
    else idxFallback.push({ i, ax, ay, az });
  }

  if (raw.length) {
    const t0 = raw[0].t;
    const zipped = raw.map(p => ({
      l: formatRelative(p.t - t0),
      ax: p.ax, ay: p.ay, az: p.az
    }));
    const slim = decimate(zipped, 2000);
    return {
      labels: slim.map(x => x.l),
      ax:     slim.map(x => x.ax),
      ay:     slim.map(x => x.ay),
      az:     slim.map(x => x.az)
    };
  }

  if (idxFallback.length) {
    const zipped = idxFallback.map(p => ({ l: String(p.i), ax: p.ax, ay: p.ay, az: p.az }));
    const slim = decimate(zipped, 2000);
    return {
      labels: slim.map(x => x.l),
      ax:     slim.map(x => x.ax),
      ay:     slim.map(x => x.ay),
      az:     slim.map(x => x.az)
    };
  }

  return null;
}

/* Linear acceleration magnitude (fallback) */
function computeLinearAccMagnitude(accelRows) {
  if (!accelRows?.length) return { labels: [], values: [] };

  function formatRelative(ms) {
    const totalSec = Math.floor(ms / 1000);
    const mm = Math.floor(totalSec / 60);
    const ss = totalSec % 60;
    return mm > 0 ? `${mm}:${String(ss).padStart(2, '0')}` : `${ss}s`;
  }

  const sample = accelRows[0];
  const xK = pick(['x','ax'], sample);
  const yK = pick(['y','ay'], sample);
  const zK = pick(['z','az'], sample);
  const tK = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], sample);
  if (!xK || !yK || !zK) return { labels: [], values: [] };

  const raw = [];
  const fallbackLabels = [];
  const fallbackValues = [];

  for (let i = 0; i < accelRows.length; i++) {
    const r = accelRows[i];
    const x = Number(r[xK]), y = Number(r[yK]), z = Number(r[zK]);
    if (![x, y, z].every(Number.isFinite)) continue;

    const mag = Math.sqrt(x*x + y*y + z*z);

    let tms = null;
    if (tK) {
      if (String(tK).toLowerCase().includes('elapsed')) {
        const secs = Number(r[tK]);
        if (Number.isFinite(secs)) tms = secs * 1000;
      } else {
        const dt = parseTime(r[tK]);
        if (dt instanceof Date && !isNaN(dt)) tms = dt.getTime();
      }
    }

    if (tms != null) raw.push({ t: tms, v: mag });
    else {
      fallbackLabels.push(String(fallbackLabels.length));
      fallbackValues.push(mag);
    }
  }

  if (raw.length) {
    const t0 = raw[0].t;
    const zipped = raw.map(p => ({ l: formatRelative(p.t - t0), v: p.v }));
    const slim = decimate(zipped, 2000);
    return { labels: slim.map(x => x.l), values: slim.map(x => x.v) };
  }

  const zipped = fallbackLabels.map((l, i) => ({ l, v: fallbackValues[i] }));
  const slim = decimate(zipped, 2000);
  return { labels: slim.map(x => x.l), values: slim.map(x => x.v) };
}

/* ------------------- ZIP helpers ------------------- */
async function loadCsvFromZip(zip, namePattern) {
  const entries = Object.values(zip.files);
  const entry = entries.find(e => !e.dir && namePattern.test(e.name));
  if (!entry) return null;
  const text = await entry.async('string');
  const parse = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
  if (parse.errors?.length) console.warn('CSV parse issues', parse.errors.slice(0,3));
  return parse.data;
}
async function loadAllCameraImagesFromZip(zip) {
  const out = [];
  const entries = Object.values(zip.files)
    .filter(e => !e.dir && /\.(jpe?g|png|webp)$/i.test(e.name))
    .filter(e => /(^|\/)camera\//i.test(e.name));
  entries.sort((a,b) => a.name.localeCompare(b.name));
  for (const entry of entries) {
    const blob = await entry.async('blob');
    out.push({ url: URL.createObjectURL(blob), name: entry.name });
  }
  return out;
}

/* ------------------- Extraction / Computations ------------------- */
function extractTrack(locationRows) {
  if (!locationRows?.length) return null;
  const sample = locationRows[0];
  const latK  = pick(['lat','latitude','y'], sample);
  const lonK  = pick(['lon','long','longitude','x'], sample);
  const timeK = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], sample);
  if (!latK || !lonK) return null;

  const pts = [];
  for (const row of locationRows) {
    const lat = Number(row[latK]);
    const lon = Number(row[lonK]);
    if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
    let t = null;
    if (timeK) {
      const raw = row[timeK];
      if (String(timeK).toLowerCase().includes('elapsed')) {
        const secs = Number(raw);
        if (Number.isFinite(secs)) t = new Date(secs * 1000);
      } else {
        t = parseTime(raw);
      }
    }
    pts.push({ lat, lon, t });
  }
  return pts.length ? pts : null;
}

function computeSpeedSeriesFromLocation(locationRows) {
  if (!locationRows?.length) return { labels: [], values: [], relMs: [], idx: [] };
  const speedKey = pick(['speed','spd'], locationRows[0]);
  const timeKey  = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], locationRows[0]);
  if (!speedKey || !timeKey) return { labels: [], values: [], relMs: [], idx: [] };

  const raw = [];
  for (let i=0;i<locationRows.length;i++) {
    const row = locationRows[i];
    const t = String(timeKey).toLowerCase().includes('elapsed')
      ? Number(row[timeKey]) * 1000
      : parseTime(row[timeKey])?.getTime();
    const v = Number(row[speedKey]);
    if (Number.isFinite(t) && Number.isFinite(v)) raw.push({i, t, v: v*3.6});
  }
  if (!raw.length) return { labels: [], values: [], relMs: [], idx: [] };

  const t0 = raw[0].t;
  const zipped = raw.map(p => ({ l: formatRelativeTime(p.t - t0), ms: (p.t - t0), v: p.v, i: p.i }));
  const slim = decimate(zipped, 2000);

  return {
    labels: slim.map(x=>x.l),
    values: slim.map(x=>x.v),
    relMs:  slim.map(x=>x.ms),
    idx:    slim.map(x=>x.i)
  };
}

/* ------------------- Map + OSM features ------------------- */
function addOsmFeaturesToMap(map, geojson, groupLayer, latlngs) {
  const els = geojson?.elements || [];
  const others = [];
  const speedWays = [];

  for (const el of els) {
    let lat=null, lon=null;
    if (el.type === 'node') { lat = el.lat; lon = el.lon; }
    else if ((el.type === 'way' || el.type === 'relation') && el.center) {
      lat = el.center.lat; lon = el.center.lon;
    }
    if (lat==null || lon==null) continue;

    const tags = el.tags || {};
    if (tags.maxspeed) {
      speedWays.push({ lat, lon, tags });
    } else {
      let label='', color='#4da3ff';
      if (tags.highway === 'traffic_signals') { label = 'Traffic light'; color = '#ffcc00'; }
      else if (tags.highway === 'stop')       { label = 'Stop sign';     color = '#ff4d4d'; }
      else if (tags.highway === 'motorway_junction' || tags.junction === 'yes') { label = 'Junction'; }
      else if (tags.junction === 'roundabout') { label = 'Roundabout'; color = '#38c172'; }
      if (label) others.push({ lat, lon, label, color });
    }
  }

  for (const f of others) {
    const m = L.circleMarker([f.lat, f.lon], {
      radius: 6, color: f.color, weight: 2, fillColor: f.color, fillOpacity: 0.25
    }).addTo(groupLayer);
    m.bindTooltip(f.label, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
    colorizeTooltip(m, f.color);
  }

  if (speedWays.length && latlngs?.length >= 2) {
    const chain = toXYChain(latlngs);
    const pts = speedWays.map(sw => {
      const v = parseMaxspeedToKmh(sw.tags.maxspeed);
      const color = getSpeedColor(v ?? sw.tags.maxspeed);
      const s = projectChainage(chain, chain.lat0, sw.lat, sw.lon);
      return { lat: sw.lat, lon: sw.lon, v, color, s };
    }).sort((a,b)=>a.s-b.s);

    let prev = null;
    for (const f of pts) {
      const m = L.circleMarker([f.lat, f.lon], {
        radius: 6, color: f.color, weight: 2, fillColor: f.color, fillOpacity: 0.25
      }).addTo(groupLayer);
      const changed = (f.v != null) ? (prev === null || f.v !== prev) : false;
      if (changed) {
        m.bindTooltip(`Speed limit: ${f.v}`, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
        colorizeTooltip(m, f.color);
        prev = f.v;
      }
    }
  } else {
    for (const sw of speedWays) {
      const v = parseMaxspeedToKmh(sw.tags.maxspeed);
      const color = getSpeedColor(v ?? sw.tags.maxspeed);
      const m = L.circleMarker([sw.lat, sw.lon], {
        radius: 6, color, weight: 2, fillColor: color, fillOpacity: 0.25
      }).addTo(groupLayer);
      if (v != null) {
        m.bindTooltip(`Speed limit: ${v}`, { permanent: true, direction:'right', offset:[8,0], className:'feature-tag' });
        colorizeTooltip(m, color);
      }
    }
  }
}

/* ------------------- Session UI ------------------- */
function createSessionCard(sessionName) {
  const wrap = document.createElement('section');
  wrap.className = 'session';

  const head = document.createElement('header');
  const h = document.createElement('h2');
  h.className = 'session-title';
  h.textContent = sessionName;
  head.appendChild(h);

  const body = document.createElement('div');
  body.className = 'session-body';

  const gallery = document.createElement('div');
  gallery.className = 'gallery';

  const map = document.createElement('div'); map.className='map';

  const row = document.createElement('div'); row.className='row';
  const legend = document.createElement('div'); legend.className='legend';
  legend.innerHTML = `
    <span><span class="dot dot-blue"></span> Trace</span>
    <span><span class="dot dot-yellow"></span> Traffic light</span>
    <span><span class="dot dot-red"></span> Stop sign</span>
    <span><span class="dot dot-green"></span> Roundabout</span>
    <span><span class="dot" style="background:#4da3ff"></span> Junction</span>
    <span><span class="dot dot-orange"></span> Speed limit</span>
  `;
  const status = document.createElement('div'); status.className='status'; status.textContent = 'Loading‚Ä¶';
  row.append(legend, status);

  const charts = document.createElement('div'); charts.className='charts';
  const speedCanvas = document.createElement('canvas');
  const accCanvas = document.createElement('canvas');

  const markerControls = document.createElement('div');
  markerControls.style.display = 'flex'; markerControls.style.gap = '8px'; markerControls.style.alignItems = 'center';
  const btnSetA = document.createElement('button'); btnSetA.className='btn'; btnSetA.textContent='Set A';
  const btnSetB = document.createElement('button'); btnSetB.className='btn'; btnSetB.textContent='Set B';
  const btnClear = document.createElement('button'); btnClear.className='btn'; btnClear.textContent='Clear';
  const tip = document.createElement('span'); tip.className='tiny'; tip.textContent='Click the speed plot after choosing A/B.';
  markerControls.append(btnSetA, btnSetB, btnClear, tip);

  charts.append(speedCanvas, markerControls, accCanvas);

  body.append(gallery, map, row, charts);
  wrap.append(head, body);
  return { wrap, gallery, map, status, speedCanvas, accCanvas, btnSetA, btnSetB, btnClear };
}

/* ------------------- Lightbox ------------------- */
const lightbox = document.getElementById('lightbox');
const lightboxImg = document.getElementById('lightboxImg');
function openLightbox(src) {
  lightboxImg.src = src;
  lightbox.classList.add('show');
  lightbox.focus();
}
lightbox.addEventListener('click', () => lightbox.classList.remove('show'));
lightbox.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') lightbox.classList.remove('show');
});

/* ------------------- Main processing ------------------- */
async function processZipFile(file) {
  const sessionName = slugWithoutExt(file.name);
  const ui = createSessionCard(sessionName);
  document.getElementById('sessions').appendChild(ui.wrap);

  // helper
  function fmtRel(ms) {
    const totalSec = Math.floor(ms / 1000);
    const mm = Math.floor(totalSec / 60);
    const ss = totalSec % 60;
    return mm > 0 ? `${mm}:${String(ss).padStart(2,'0')}` : `${ss}s`;
  }

  let latlngs = null;
  let maxspeedProfile = [];

  try {
    ui.status.textContent = 'Reading ZIP‚Ä¶';
    const zip = await JSZip.loadAsync(file);

    /* Camera gallery */
    ui.status.textContent = 'Loading photos‚Ä¶';
    const images = await loadAllCameraImagesFromZip(zip);
    if (images.length) {
      for (const img of images) {
        const t = document.createElement('img');
        t.className = 'thumb';
        t.src = img.url; t.alt = img.name;
        t.addEventListener('click', () => openLightbox(img.url));
        ui.gallery.appendChild(t);
      }
    }

    // CSVs
    ui.status.textContent = 'Parsing CSVs‚Ä¶';
    const [locationRows, totalAccRows, accelRows] = await Promise.all([
      loadCsvFromZip(zip, /(^|\/)Location\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)TotalAcceleration\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)Accelerometer\.csv$/i)
    ]);

    // Map
    ui.status.textContent = 'Rendering map‚Ä¶';
    const map = L.map(ui.map);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '¬© OpenStreetMap' }).addTo(map);

    const track = extractTrack(locationRows);
    if (track?.length) {
      latlngs = track.map(p => [p.lat, p.lon]);
      const poly = L.polyline(latlngs, { color: '#3a86ff', weight: 3 }).addTo(map);
      map.fitBounds(poly.getBounds(), { padding: [16,16] });

      /* Start marker */
      const startColor = '#00e676';
      const startLatLng = latlngs[0];
      const start = L.circleMarker(startLatLng, {
        radius: 6, color: startColor, weight: 2, fillColor: startColor, fillOpacity: 0.6
      }).addTo(map);
      start.bindTooltip('Start', { permanent: true, direction: 'right', offset: [8,0], className: 'feature-tag' });
      colorizeTooltip(start, startColor);

      /* Direction arrow */
      try {
        L.polylineDecorator(poly, {
          patterns: [{
            offset: '85%', repeat: 0,
            symbol: L.Symbol.arrowHead({ pixelSize: 14, headAngle: 60, pathOptions: { color: '#3a86ff', weight: 2, opacity: 0.9 } })
          }]
        }).addTo(map);
      } catch (e) { console.warn('PolylineDecorator unavailable; skipping arrow.', e); }

      // OSM features
      ui.status.textContent = 'Fetching OSM features‚Ä¶';
      const bbox = bboxForTrack(track, 80);
      const query = overpassQueryForBBox(bbox);
      try {
        const osm = await overpassFetch(query);
        const layer = L.layerGroup().addTo(map);
        addOsmFeaturesToMap(map, osm, layer, latlngs);
        maxspeedProfile = extractMaxspeedProfile(osm, latlngs);
        ui.status.textContent = 'Map ready.';
      } catch (e) {
        console.warn('Overpass failed:', e);
        ui.status.textContent = 'Trace rendered. Features unavailable (Overpass error).';
      }
    } else {
      map.setView([59.3293, 18.0686], 10);
      ui.status.textContent = 'No coordinates found.';
    }

    // -------- Speed chart (+ maxspeed) --------
    ui.status.textContent = 'Preparing speed‚Ä¶';
    const speedSeries = computeSpeedSeriesFromLocation(locationRows || []);
    const speedLabels = speedSeries.labels;
    const speedValues = speedSeries.values;

    let maxspeedValues = [];
    if (latlngs?.length && maxspeedProfile?.length && speedSeries.idx?.length) {
      const perSampleMax = computeMaxspeedSeriesAligned(latlngs, maxspeedProfile);
      maxspeedValues = speedSeries.idx.map(i => perSampleMax[i] ?? null);
    } else {
      maxspeedValues = new Array(speedLabels.length).fill(null);
    }

    const finiteSpeeds = [...speedValues, ...maxspeedValues].filter(Number.isFinite);
    let yMin, yMax;
    if (finiteSpeeds.length) {
      yMin = Math.min(...finiteSpeeds) - 5;
      yMax = Math.max(...finiteSpeeds) + 5;
    }

    const speedChart = makeMultiLineChart(ui.speedCanvas, {
      labels: speedLabels,
      yTitle: 'km/h',
      min: yMin, max: yMax,
      datasets: [
        { label: 'Speed',    data: speedValues,    borderColor: cssVar('--blue', '#3a86ff'), pointRadius: 0, borderWidth: 1.6, tension: 0.12 },
        { label: 'Maxspeed', data: maxspeedValues, borderColor: cssVar('--speedlimit', '#ff8800'), pointRadius: 0, borderWidth: 1.6, tension: 0, borderDash: [6,3] }
      ]
    });

    // Provide marker + series data for the plugin
    speedChart.$markers = { A: null, B: null, active: 'A', colorA:'#00e5ff', colorB:'#ff5ec4' };
    speedChart.$series  = { relMs: speedSeries.relMs, speedKmH: speedValues };

    // --- Marker controls (per-session) ---
    ui.btnSetA.addEventListener('click', () => { speedChart.$markers.active = 'A'; });
    ui.btnSetB.addEventListener('click', () => { speedChart.$markers.active = 'B'; });
    ui.btnClear.addEventListener('click', () => {
      speedChart.$markers.A = null;
      speedChart.$markers.B = null;
      speedChart.update();
    });
    ui.speedCanvas.addEventListener('click', (evt) => {
      const i = nearestIndexFromEvent(speedChart, evt);
      const which = speedChart.$markers.active || 'A';
      speedChart.$markers[which] = i;
      speedChart.update(); // plugin redraws A, B, and A‚ÜîB bubble
    });

    // -------- Acceleration chart --------
    ui.status.textContent = 'Preparing acceleration‚Ä¶';
    const accelXYZ = computeAccelXYZSeries(accelRows);
    if (accelXYZ && accelXYZ.labels.length) {
      const cBlue  = cssVar('--blue',  '#3a86ff');
      const cGreen = cssVar('--green', '#38c172');
      const cRed   = cssVar('--red',   '#ff4d4d');
      const all = [...accelXYZ.ax, ...accelXYZ.ay, ...accelXYZ.az].filter(Number.isFinite);
      let ymin, ymax;
      if (all.length) {
        ymin = Math.min(...all); ymax = Math.max(...all);
        const pad = Math.max(0.3, (ymax - ymin) * 0.05);
        ymin -= pad; ymax += pad;
        if (ymin > 0) ymin = 0;
        if (ymax < 0) ymax = 0;
      }
      makeMultiLineChart(ui.accCanvas, {
        labels: accelXYZ.labels,
        yTitle: 'm/s¬≤',
        min: ymin, max: ymax,
        datasets: [
          { label: 'Ax', data: accelXYZ.ax, borderColor: cBlue,  pointRadius: 0, borderWidth: 1.2, tension: 0.12 },
          { label: 'Ay', data: accelXYZ.ay, borderColor: cGreen, pointRadius: 0, borderWidth: 1.2, tension: 0.12 },
          { label: 'Az', data: accelXYZ.az, borderColor: cRed,   pointRadius: 0, borderWidth: 1.2, tension: 0.12 },
        ]
      });
    } else {
      let { labels: accLabels, values: accValues } = computeLinearAccMagnitude(accelRows);
      if ((!accValues || !accValues.length) && totalAccRows?.length) {
        const tk = pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'], totalAccRows[0]);
        const ak = pick(['total','magnitude','acc','accel','a_total'], totalAccRows[0]);
        const raw = [];
        for (const r of totalAccRows) {
          let tms = null;
          if (tk) {
            if (String(tk).toLowerCase().includes('elapsed')) {
              const secs = Number(r[tk]);
              if (Number.isFinite(secs)) tms = secs * 1000;
            } else {
              const dt = parseTime(r[tk]);
              if (dt instanceof Date && !isNaN(dt)) tms = dt.getTime();
            }
          }
          const a = Number(r[ak]);
          if (tms != null && Number.isFinite(a)) raw.push({ t: tms, v: Math.max(0, a - 9.81) });
        }
        if (raw.length) {
          const t0 = raw[0].t;
          const zipped = raw.map(p => ({ l: fmtRel(p.t - t0), v: p.v }));
          const slim = decimate(zipped, 2000);
          accLabels = slim.map(x=>x.l);
          accValues = slim.map(x=>x.v);
        } else {
          accLabels = []; accValues = [];
        }
      }
      makeLineChart(ui.accCanvas, {
        labels: accLabels || [],
        values: accValues || [],
        label: 'Linear acceleration |a| (m/s¬≤)',
        yTitle: 'm/s¬≤'
      });
    }

    ui.status.textContent = 'Ready.';
  } catch (err) {
    console.error(err);
    ui.status.textContent = 'Failed: ' + (err?.message || err);
  }
}

/* ---- interaction helper to map click ‚Üí nearest label index ---- */
function nearestIndexFromEvent(chart, evt) {
  const rect = chart.canvas.getBoundingClientRect();
  const xPix = evt.clientX - rect.left;
  const xScale = chart.scales.x;
  let bestI = 0, bestD = Infinity;
  for (let i=0;i<chart.data.labels.length;i++) {
    const px = xScale.getPixelForValue(i);
    const d = Math.abs(px - xPix);
    if (d < bestD) { bestD = d; bestI = i; }
  }
  return bestI;
}

/* ------------------- Inputs ------------------- */
const folderInput = document.getElementById('folderInput');
const filesInput  = document.getElementById('filesInput');

function uniqueZipFilesFromFileList(fileList) {
  const out = [];
  const seen = new Set();
  for (const f of fileList) {
    if (!/\.zip$/i.test(f.name)) continue;
    const key = f.webkitRelativePath || f.name;
    if (!seen.has(key)) { seen.add(key); out.push(f); }
  }
  return out;
}

folderInput.addEventListener('change', async (e) => {
  const files = uniqueZipFilesFromFileList(e.target.files);
  if (!files.length) return;
  document.getElementById('sessions').innerHTML = '';
  for (const f of files) await processZipFile(f);
  folderInput.value = '';
});

filesInput.addEventListener('change', async (e) => {
  const files = uniqueZipFilesFromFileList(e.target.files);
  if (!files.length) return;
  document.getElementById('sessions').innerHTML = '';
  for (const f of files) await processZipFile(f);
  filesInput.value = '';
});
</script>
</body>
</html>
