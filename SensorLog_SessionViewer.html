<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sensor Sessions Viewer (ZIP ‚Üí Map + Plots)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- PolylineDecorator for direction arrow -->
  <script src="https://unpkg.com/leaflet-polylinedecorator@1.7.0/dist/leaflet.polylineDecorator.min.js"></script>

  <!-- JSZip -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <!-- Papa Parse -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root {
      --bg: #0e0f11;
      --card: #17181b;
      --muted: #a9b0bc;
      --fg: #e7eaf0;
      --accent: #4da3ff;
      --blue: #3a86ff;
      --red: #ff4d4d;
      --green: #38c172;
      --yellow: #ffcc00;
      --speedlimit: #ff8800;
      --border: #2a2d33;
    }
    * { box-sizing: border-box }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
    }
    header {
      position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(14,15,17,0.95), rgba(14,15,17,0.85) 60%, transparent);
      backdrop-filter: blur(6px);
      padding: 16px 16px 8px;
      border-bottom: 1px solid var(--border);
    }
    h1 { margin: 0 0 8px; font-size: 18px; font-weight: 600; letter-spacing: .2px }
    #controls { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .btn {
      display: inline-flex; align-items: center; gap: 8px;
      background: var(--card); color: var(--fg);
      border: 1px solid var(--border);
      padding: 8px 12px; border-radius: 10px; cursor: pointer;
    }
    .btn:hover { border-color: #3b3f46 }
    .hint { color: var(--muted); font-size: 12px }
    .tiny { font-size: 11px; color: var(--muted) }

    .grid { display: flex; flex-direction: column; gap: 20px; padding: 16px; }
    .session { background: var(--card); border: 1px solid var(--border); border-radius: 16px; overflow: hidden; display: flex; flex-direction: column; }
    .session header { background: linear-gradient(180deg, #1b1d22, #17181b); padding: 12px 14px; border-bottom: 1px solid var(--border); }
    .session-title { margin: 0; font-size: 15px; font-weight: 600 }
    .session-body { padding: 12px; display: grid; gap: 12px }

    .gallery { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px, 1fr)); gap: 8px; }
    .thumb { width: 100%; aspect-ratio: 4/3; object-fit: cover; border-radius: 10px; border: 1px solid var(--border); background: #0a0b0d; cursor: pointer; }
    .thumb:hover { filter: brightness(1.05) }

    .lightbox { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; align-items: center; justify-content: center; z-index: 1000; }
    .lightbox.show { display: flex }
    .lightbox img { max-width: 95vw; max-height: 92vh; border-radius: 12px; border: 1px solid var(--border); box-shadow: 0 10px 32px rgba(0,0,0,0.5); }

    .map { width: 100%; height: 320px; border-radius: 12px; border: 1px solid var(--border); overflow: hidden; }

    .charts { display: grid; grid-template-columns: 1fr; row-gap: 20px; }

    .chart-frame {
      background: #101215;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 4px;
      overflow: hidden;
    }
    .chart-frame > canvas {
      display: block;
      height: 320px;
      width: 100%;
    }

    .status { font-size: 12px; color: var(--muted) }
    .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .legend { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; font-size: 12px; color: var(--muted); }
    .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block }
    .dot-blue{ background: var(--blue) } .dot-red{ background: var(--red) } .dot-yellow{ background: var(--yellow) } .dot-green{ background: var(--green) } .dot-orange{ background: var(--speedlimit) }

    .leaflet-tooltip.feature-tag {
      background: rgba(0,0,0,0.85);
      color: #fff;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 2px 6px;
      font-size: 11px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }
    .leaflet-tooltip.distance-tag {
      background: rgba(0,0,0,0.7);
      color: #eaeef5;
      border: 1px solid #333a44;
      border-radius: 6px;
      padding: 1px 5px;
      font-size: 10px;
    }

    footer { text-align: center; padding: 16px; color: var(--muted); border-top: 1px solid var(--border); }
    a { color: var(--accent); text-decoration: none } a:hover { text-decoration: underline }
    input[type=file] { display:none }
    #openFolderLabel::before, #openFilesLabel::before { content: "üìÅ"; filter: grayscale(100%); margin-right: 6px; }
  </style>
</head>
<body>
  <header>
    <h1>Sensor Sessions Viewer</h1>
    <div id="controls">
      <label class="btn" id="openFolderLabel" title="Pick a folder with multiple ZIPs">
        <input id="folderInput" type="file" webkitdirectory directory multiple accept=".zip"/>
        Open folder of ZIPs
      </label>
      <label class="btn" id="openFilesLabel" title="Or pick several ZIP files">
        <input id="filesInput" type="file" multiple accept=".zip"/>
        Open ZIP files
      </label>

      <!-- ONE master toggle (default OFF) for ALL OSM lookups -->
      <label class="btn" title="Enable/disable ALL OSM lookups (features, speed limits, road names)">
        <input id="chkOSMLookups" type="checkbox" style="margin-right:8px" />
        OSM lookups (features & road names)
      </label>

      <span class="hint">ZIP layout: Location.csv, Accelerometer.csv, TotalAcceleration.csv, Camera/*.jpg.</span>
      <span class="tiny">Master toggle controls Overpass + Nominatim. Default OFF.</span>
    </div>
  </header>

  <main class="grid" id="sessions"></main>

  <div id="lightbox" class="lightbox" tabindex="0" aria-label="Image viewer">
    <img id="lightboxImg" alt="Full size"/>
  </div>

  <footer>¬© Zeekr Tech EU 2025</footer>

<script>
/* ======================== Master OSM toggle (default OFF) ======================== */
let osmlEnabled = false;
const chkOSM = document.getElementById('chkOSMLookups');
chkOSM.checked = false;
const sessionControllers = []; // each: { enable(), disable() }

/* =========================== Overpass setup (queue) ============================= */
const OVERPASS_ENDPOINTS = [
  'https://overpass.kumi.systems/api/interpreter',
  'https://overpass-api.de/api/interpreter',
  'https://overpass.nchc.org.tw/api/interpreter'
];
let overpassQueue = Promise.resolve();

/* ============================== Chart.js defaults ============================== */
Chart.defaults.color = '#d6dbe4';
Chart.defaults.font = {
  family: 'system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", sans-serif',
  size: 15,
  weight: '500',
};
Chart.defaults.devicePixelRatio = () => Math.max(1, window.devicePixelRatio || 1);

/* ---------- CRISP CANVAS SIZER ---------- */
const crispObservers = new WeakMap();
function attachCrispSizer(frame, canvas, chartRefGetter) {
  const apply = () => {
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = Math.max(0, Math.round(frame.clientWidth));
    const cssH = Math.max(0, Math.round(canvas.clientHeight));
    canvas.style.width  = cssW + 'px';
    canvas.style.height = cssH + 'px';
    const wantW = Math.round(cssW * dpr);
    const wantH = Math.round(cssH * dpr);
    if (canvas.width !== wantW)  canvas.width  = wantW;
    if (canvas.height !== wantH) canvas.height = wantH;
    const chart = chartRefGetter?.();
    if (chart && chart.resize) chart.resize(0);
  };
  apply();
  const ro = new ResizeObserver(apply); ro.observe(frame); crispObservers.set(canvas, ro);
  window.addEventListener('resize', apply);
}

/* ================================== Utilities ================================== */
function cssVar(name, fallback) { const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim(); return v || fallback; }
function formatRelativeTime(ms){ const s=Math.floor(ms/1000),m=Math.floor(s/60),r=s%60; return m>0?`${m}:${String(r).padStart(2,'0')}`:`${r}s`; }
function slugWithoutExt(fileName){ const base=fileName.split('/').pop(); return base.replace(/\.zip$/i,''); }
function parseTime(v){ if(v==null||v==='')return null; if(typeof v==='number'){ if(v>1e17)return new Date(v/1e6); if(v>1e14)return new Date(v/1e3); if(v>1e12)return new Date(v); if(v>1e9)return new Date(v*1000); return null;} const n=Number(v); if(!Number.isNaN(n))return parseTime(n); const d=new Date(v); return isNaN(d)?null:d; }
function pick(keys,obj){ for(const k of keys){ const f=Object.keys(obj).find(x=>x.toLowerCase()===k.toLowerCase()); if(f)return f;} return null; }
function decimate(xs,max=2000){ if(xs.length<=max)return xs; const step=Math.ceil(xs.length/max); const out=[]; for(let i=0;i<xs.length;i+=step) out.push(xs[i]); return out; }

/* Geometry helpers */
function toXY(lat,lon,lat0){ const R=6371008.8; const x=(lon*Math.PI/180)*R*Math.cos(lat0*Math.PI/180); const y=(lat*Math.PI/180)*R; return [x,y]; }
function distMeters(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1]; return Math.hypot(dx,dy); }
function toXYChain(latlngs){ const lat0=(latlngs[0][0]+latlngs[latlngs.length-1][0])/2; const xy=latlngs.map(([lat,lon])=>toXY(lat,lon,lat0)); const cum=[0]; for(let i=1;i<xy.length;i++) cum[i]=cum[i-1]+distMeters(xy[i],xy[i-1]); return {xy,cum,lat0}; }
function projectChainage({xy,cum},lat0,lat,lon){ const p=toXY(lat,lon,lat0); let best={d:Infinity,s:0}; for(let i=0;i<xy.length-1;i++){ const a=xy[i], b=xy[i+1]; const abx=b[0]-a[0], aby=b[1]-a[1]; const apx=p[0]-a[0], apy=p[1]-a[1]; const ab2=abx*abx+aby*aby; let t=ab2?(abx*apx+aby*apy)/ab2:0; t=Math.max(0,Math.min(1,t)); const proj=[a[0]+abx*t,a[1]+aby*t]; const d=distMeters(p,proj); if(d<best.d) best={d,s:cum[i]+Math.hypot((proj[0]-a[0]),(proj[1]-a[1]))}; } return best.s; }

/* Interpolate lat/lon at a given chainage s (meters) */
function latlngAtS(latlngs, chain, s){
  const cum = chain.cum;
  let i = 0, j = cum.length - 1;
  while (i < j) { const mid = (i + j) >> 1; if (cum[mid] < s) i = mid + 1; else j = mid; }
  const k = Math.max(1, i);
  const s0 = cum[k-1], s1 = cum[k];
  const t = s1 > s0 ? (s - s0) / (s1 - s0) : 0;
  const [lat0, lon0] = latlngs[k-1], [lat1, lon1] = latlngs[k];
  return [lat0 + (lat1-lat0)*t, lon0 + (lon1-lon0)*t, k-1, k];
}

/* ================= Speed-limit helpers (OSM) ================= */
function parseMaxspeedToKmh(tag){ if(!tag)return null; const s=String(tag).toLowerCase().trim(); if(s==='signals'||s==='variable'||s==='none')return null; const mph=s.match(/(\d+(?:\.\d+)?)\s*mph/); if(mph)return Math.round(parseFloat(mph[1])*1.60934); const kmh=s.match(/(\d+(?:\.\d+)?)/); return kmh?Math.round(parseFloat(kmh[1])):null; }
function getSpeedColor(vOrTag){ let num; if(typeof vOrTag==='number') num=vOrTag; else { const s=String(vOrTag||'').toLowerCase(); const mph=s.match(/(\d+(?:\.\d+)?)\s*mph/); if(mph) num=parseFloat(mph[1])*1.60934; else { const kmh=s.match(/(\d+(?:\.\d+)?)/); num=kmh?parseFloat(kmh[1]):NaN; } } if(!isFinite(num)) return '#ff8800'; if(num<=30)return'#ff8800'; if(num<=50)return'#ffaa33'; if(num<=70)return'#ffcc00'; if(num<=90)return'#c8d400'; if(num<=110)return'#89dd00'; return '#38c172'; }
function extractMaxspeedProfile(geojson, latlngs){
  const els=geojson?.elements||[]; if(!latlngs||latlngs.length<2) return [];
  const chain=toXYChain(latlngs); const pts=[];
  for(const el of els){
    const tags=el.tags||{}; if(!('maxspeed' in tags)) continue;
    let lat=null,lon=null;
    if(el.type==='node'){lat=el.lat;lon=el.lon;}
    else if((el.type==='way'||el.type==='relation')&&el.center){lat=el.center.lat;lon=el.center.lon;}
    if(lat==null||lon==null) continue;
    const v=parseMaxspeedToKmh(tags.maxspeed); if(v==null) continue;
    const s=projectChainage(chain,chain.lat0,lat,lon); pts.push({s,v});
  }
  pts.sort((a,b)=>a.s-b.s);
  const profile=[]; let lastV=null;
  for(const p of pts){ if(p.v!==lastV){ profile.push(p); lastV=p.v; } }
  return profile;
}
function computeMaxspeedSeriesAligned(latlngs, profile){
  if(!latlngs?.length || !profile?.length) return new Array(latlngs.length).fill(null);
  const chain=toXYChain(latlngs);
  function atS(s){ let lo=0,hi=profile.length-1,ans=-1; while(lo<=hi){ const mid=(lo+hi)>>1; if(profile[mid].s<=s){ ans=mid; lo=mid+1; } else hi=mid-1; } return ans>=0?profile[ans].v:null; }
  const out=new Array(latlngs.length);
  for(let i=0;i<latlngs.length;i++){ const [lat,lon]=latlngs[i]; const s=projectChainage(chain,chain.lat0,lat,lon); out[i]=atS(s); }
  return out;
}

/* ================= OSM fetch, reverse geocode, etc. ================= */
function bboxForTrack(track,padMeters=80){
  let minLat=90,minLon=180,maxLat=-90,maxLon=-180;
  for(const p of track){ if(p.lat<minLat)minLat=p.lat; if(p.lat>maxLat)maxLat=p.lat; if(p.lon<minLon)minLon=p.lon; if(p.lon>maxLon)maxLon=p.lon; }
  const padLat=padMeters/111320; const midLat=(minLat+maxLat)/2; const padLon=padMeters/(111320*Math.cos(midLat*Math.PI/180));
  return [minLat-padLat, minLon-padLon, maxLat+padLat, maxLon+padLon];
}
function overpassQueryForBBox([s,w,n,e]){
  return `
[out:json][timeout:25];
(
  node["highway"="traffic_signals"](${s},${w},${n},${e});
  node["highway"="stop"](${s},${w},${n},${e});
  node["highway"="motorway_junction"](${s},${w},${n},${e});
  way["junction"="roundabout"](${s},${w},${n},${e});
  relation["type"="multipolygon"]["junction"="roundabout"](${s},${w},${n},${e});
  way["maxspeed"](${s},${w},${n},${e});
);
out center tags;`.trim();
}
function overpassFetch(query){
  if(!osmlEnabled) return Promise.reject(new Error('OSM lookups disabled'));
  const run=async()=>{ for(const url of OVERPASS_ENDPOINTS){ try{ const res=await fetch(url,{method:'POST',body:query,headers:{'Content-Type':'text/plain'}}); if(!res.ok) throw new Error('HTTP '+res.status); return await res.json(); }catch(e){ console.warn('Overpass failed on',url,e); } } throw new Error('All Overpass endpoints failed'); };
  overpassQueue = overpassQueue.then(()=>new Promise(r=>setTimeout(r,500))).then(run);
  return overpassQueue;
}
function colorizeTooltip(marker,color){ setTimeout(()=>{ const el=marker.getTooltip&&marker.getTooltip()&&marker.getTooltip().getElement?marker.getTooltip().getElement():null; if(el){ el.style.background=color; el.style.borderColor=color; el.style.color='#000'; } },0); }

const revGeoCache=new Map(); let revGeoQueue=Promise.resolve();
function reverseGeocode(lat,lon){
  if(!osmlEnabled) return Promise.resolve('');
  const key=`${lat.toFixed(5)},${lon.toFixed(5)}`; if(revGeoCache.has(key)) return revGeoCache.get(key);
  const run=async()=>{ const url=`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}&zoom=17&addressdetails=1`; const res=await fetch(url,{headers:{'Accept-Language':'en'}}); if(!res.ok) throw new Error('HTTP '+res.status); const j=await res.json(); return j?.address?.road || j?.name || j?.display_name || ''; };
  const p=revGeoQueue.then(()=>new Promise(r=>setTimeout(r,300))).then(run).catch(()=> ''); revGeoCache.set(key,p); return p;
}

function addOsmFeaturesToMap(geojson, groupLayer, latlngs){
  const els=geojson?.elements||[]; const others=[]; const speedWays=[]; const markerMeta=[];
  for(const el of els){
    let lat=null,lon=null;
    if(el.type==='node'){lat=el.lat;lon=el.lon;}
    else if((el.type==='way'||el.type==='relation')&&el.center){lat=el.center.lat;lon=el.center.lon;}
    if(lat==null||lon==null) continue;
    const tags=el.tags||{};
    if(tags.maxspeed){ speedWays.push({lat,lon,tags}); }
    else{
      let label='', color='#4da3ff';
      if(tags.highway==='traffic_signals'){ label='Traffic light'; color='#ffcc00'; }
      else if(tags.highway==='stop'){ label='Stop sign'; color='#ff4d4d'; }
      else if(tags.highway==='motorway_junction'||tags.junction==='yes'){ label='Junction'; }
      else if(tags.junction==='roundabout'){ label='Roundabout'; color='#38c172'; }
      if(label){
        const m=L.circleMarker([lat,lon],{radius:6,color,weight:2,fillColor:color,fillOpacity:0.25}).addTo(groupLayer);
        m.bindTooltip(label,{permanent:true,direction:'right',offset:[8,0],className:'feature-tag'}); colorizeTooltip(m,color);
        markerMeta.push({marker:m, base:label, lat, lon, color});
      }
    }
  }
  if(speedWays.length && latlngs?.length>=2){
    const chain=toXYChain(latlngs);
    const pts=speedWays.map(sw=>{ const v=parseMaxspeedToKmh(sw.tags.maxspeed); const color=getSpeedColor(v??sw.tags.maxspeed); const s=projectChainage(chain,chain.lat0,sw.lat,sw.lon); return {lat:sw.lat,lon:sw.lon,v,color,s}; }).sort((a,b)=>a.s-b.s);
    let prev=null;
    for(const f of pts){
      const m=L.circleMarker([f.lat,f.lon],{radius:6,color:f.color,weight:2,fillColor:f.color,fillOpacity:0.25}).addTo(groupLayer);
      const changed=(f.v!=null)?(prev===null||f.v!==prev):false;
      const label=changed && f.v!=null?`Speed limit: ${f.v}`:'Speed limit';
      m.bindTooltip(label,{permanent:true,direction:'right',offset:[8,0],className:'feature-tag'}); colorizeTooltip(m,f.color);
      markerMeta.push({marker:m, base:label, lat:f.lat, lon:f.lon, color:f.color});
      if(changed && f.v!=null) prev=f.v;
    }
  } else {
    for(const sw of speedWays){
      const v=parseMaxspeedToKmh(sw.tags.maxspeed); const color=getSpeedColor(v??sw.tags.maxspeed);
      const m=L.circleMarker([sw.lat,sw.lon],{radius:6,color,weight:2,fillColor:color,fillOpacity:0.25}).addTo(groupLayer);
      const label=v!=null?`Speed limit: ${v}`:'Speed limit';
      m.bindTooltip(label,{permanent:true,direction:'right',offset:[8,0],className:'feature-tag'}); colorizeTooltip(m,color);
      markerMeta.push({marker:m, base:label, lat:sw.lat, lon:sw.lon, color});
    }
  }
  return markerMeta;
}

/* ===================== Chart plugin: markers + 100m ticks ===================== */
const MarkerPlugin={ id:'twoMarkers', afterDatasetsDraw(chart){
  const markers=chart.$markers; const distTicks=chart.$distTicks || [];
  const speedDataset=chart.data.datasets?.[0]; if(!speedDataset) return;
  const {ctx,chartArea,scales}=chart; const xScale=scales.x, yScale=scales.y; const labels=chart.data.labels;

  /* 100 m vertical ticks */
  ctx.save();
  ctx.strokeStyle = 'rgba(200, 210, 225, 0.35)';
  ctx.fillStyle   = 'rgba(220, 230, 245, 0.85)';
  ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  for(const t of distTicks){
    const i = t.i;
    if(i==null || i<0 || i>=labels.length) continue;
    const x = xScale.getPixelForValue(i);
    ctx.setLineDash([3,3]); ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(x, chartArea.top); ctx.lineTo(x, chartArea.bottom); ctx.stroke();
    ctx.setLineDash([]);
    // Label near the top
    const pad = 3;
    const text = t.label;
    const tw = ctx.measureText(text).width + 6;
    const th = 16;
    let bx = Math.min(Math.max(x - tw/2, chartArea.left+2), chartArea.right - tw - 2);
    let by = chartArea.top + 4;
    ctx.fillStyle = 'rgba(0,0,0,0.65)';
    ctx.strokeStyle = 'rgba(160,170,185,0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(bx, by, tw, th, 4);
    ctx.fill();
    ctx.stroke();
    ctx.fillStyle = '#e9eef7';
    ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(text, bx + tw/2, by + th/2 + 0.5);
  }
  ctx.restore();

  if(!markers) return;

  /* A/B markers + accel bubble */
  function drawOne(i,color,tag){
    if(i==null||i<0||i>=labels.length) return;
    const yVal=speedDataset.data[i]; if(!Number.isFinite(yVal)) return;
    const x=xScale.getPixelForValue(i), y=yScale.getPixelForValue(yVal);
    ctx.save();
    ctx.strokeStyle=color; ctx.lineWidth=1; ctx.setLineDash([4,3]); ctx.beginPath(); ctx.moveTo(x,chartArea.top); ctx.lineTo(x,chartArea.bottom); ctx.stroke(); ctx.setLineDash([]);
    ctx.fillStyle=color; ctx.beginPath(); ctx.arc(x,y,4,0,Math.PI*2); ctx.fill();
    const text=`${labels[i]} ‚Ä¢ ${yVal.toFixed(1)} km/h`; ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    const pad=6,r=6, tw=ctx.measureText(text).width; const bw=tw+pad*2+16, bh=24;
    let bx=Math.min(Math.max(x-bw/2, chartArea.left+2), chartArea.right-bw-2); let by=y-10-bh; if(by<chartArea.top+2) by=y+12;
    ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.strokeStyle=color; ctx.lineWidth=1;
    ctx.beginPath(); ctx.moveTo(bx+r,by); ctx.lineTo(bx+bw-r,by); ctx.quadraticCurveTo(bx+bw,by,bx+bw,by+r);
    ctx.lineTo(bx+bw,by+bh-r); ctx.quadraticCurveTo(bx+bw,by+bh,bx+bw-r,by+bh);
    ctx.lineTo(bx+r,by+bh); ctx.quadraticCurveTo(bx,by+bh,bx,by+bh-r);
    ctx.lineTo(bx,by+r); ctx.quadraticCurveTo(bx,by,bx+r,by); ctx.closePath(); ctx.fill(); ctx.stroke();
    const tagR=7, tx=bx+pad+tagR, ty=by+bh/2; ctx.fillStyle=color; ctx.beginPath(); ctx.arc(tx,ty,tagR,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#000'; ctx.font='bold 10px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(tag,tx,ty);
    ctx.fillStyle='#e7eaf0'; ctx.font='12px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='left'; ctx.textBaseline='middle'; ctx.fillText(text, bx+pad+2*tagR+6, by+bh/2);
    ctx.restore();
  }
  drawOne(markers.A, markers.colorA||'#00e5ff','A');
  drawOne(markers.B, markers.colorB||'#ff5ec4','B');

  if(markers.A!=null && markers.B!=null && markers.A!==markers.B){
    const iA=markers.A, iB=markers.B; const vAkph=speedDataset.data[iA], vBkph=speedDataset.data[iB];
    const tAms=chart.$series?.relMs?.[iA], tBms=chart.$series?.relMs?.[iB];
    if([vAkph,vBkph,tAms,tBms].every(Number.isFinite) && tAms!==tBms){
      const a=((vBkph/3.6)-(vAkph/3.6))/((tBms-tAms)/1000);
      const xA=xScale.getPixelForValue(iA), yA=yScale.getPixelForValue(vAkph);
      const xB=xScale.getPixelForValue(iB), yB=yScale.getPixelForValue(vBkph);
      const mx=(xA+xB)/2, my=(yA+yB)/2-30; const text=`a = ${a.toFixed(3)} m/s¬≤`;
      const pad=6,r=6,bh=20; const tw=ctx.measureText(text).width, bw=tw+pad*2; let bx=mx-bw/2, by=my-bh/2;
      ctx.save(); ctx.fillStyle='rgba(0,0,0,0.85)'; ctx.strokeStyle='#ffd166'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(bx+r,by); ctx.lineTo(bx+bw-r,by); ctx.quadraticCurveTo(bx+bw,by,bx+bw,by+r);
      ctx.lineTo(bx+bw,by+bh-r); ctx.quadraticCurveTo(bx+bw,by+bh,bx+bw-r,by+bh);
      ctx.lineTo(bx+r,by+bh); ctx.quadraticCurveTo(bx,by+bh,bx,by+bh-r);
      ctx.lineTo(bx,by+r); ctx.quadraticCurveTo(bx,by,bx+r,by); ctx.closePath(); ctx.fill(); ctx.stroke();
      ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text, bx+bw/2, by+bh/2); ctx.restore();
    }
  }
}};
Chart.register(MarkerPlugin);

/* ============================== Chart helpers ============================== */
function makeMultiLineChart(canvas,{labels,datasets,yTitle,min,max}){
  const ctx=canvas.getContext('2d');
  return new Chart(ctx,{
    type:'line',
    data:{labels,datasets},
    options:{
      responsive:true, maintainAspectRatio:false, animation:false,
      scales:{
        x:{ ticks:{ color:'#d6dbe4', maxTicksLimit:6 } },
        y:{ ticks:{ color:'#d6dbe4' }, title:{ display:true, text:yTitle, color:'#d6dbe4' },
            ...(Number.isFinite(min)?{min}:{}) , ...(Number.isFinite(max)?{max}:{}) }
      },
      plugins:{ legend:{ display:true, labels:{ usePointStyle:true } } }
    }
  });
}
function makeLineChart(canvas,{labels,values,label,yTitle,min,max,suggestedMin,suggestedMax,beginAtZero}){
  const y={ ticks:{color:'#d6dbe4',font:{size:15}}, title:{display:true,text:yTitle,color:'#d6dbe4',font:{size:14,weight:'600'}} };
  if(beginAtZero===true)y.beginAtZero=true; if(Number.isFinite(min))y.min=min; if(Number.isFinite(max))y.max=max;
  if(!Number.isFinite(min)&&Number.isFinite(suggestedMin))y.suggestedMin=suggestedMin;
  if(!Number.isFinite(max)&&Number.isFinite(suggestedMax))y.suggestedMax=suggestedMax;
  const ctx=canvas.getContext('2d');
  return new Chart(ctx,{
    type:'line',
    data:{ labels, datasets:[{label, data:values, borderWidth:1.4, tension:0.12, pointRadius:0}] },
    options:{ responsive:true, maintainAspectRatio:false, animation:false,
      scales:{ x:{ticks:{color:'#d6dbe4',font:{size:13},maxTicksLimit:6}}, y }, plugins:{legend:{display:false}} }
  });
}

/* ============================ Acceleration helpers ============================ */
function computeAccelXYZSeries(accelRows){
  if(!accelRows?.length) return null;
  const sample=accelRows[0];
  const xK=pick(['x','ax'],sample), yK=pick(['y','ay'],sample), zK=pick(['z','az'],sample);
  const tK=pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'],sample);
  if(!xK||!yK||!zK) return null;
  const raw=[], idxFallback=[];
  for(let i=0;i<accelRows.length;i++){
    const r=accelRows[i]; const ax=Number(r[xK]), ay=Number(r[yK]), az=Number(r[zK]); if(![ax,ay,az].every(Number.isFinite)) continue;
    let tms=null;
    if(tK){ if(String(tK).toLowerCase().includes('elapsed')){ const s=Number(r[tK]); if(Number.isFinite(s)) tms=s*1000; }
            else { const dt=parseTime(r[tK]); if(dt instanceof Date && !isNaN(dt)) tms=dt.getTime(); } }
    if(tms!=null) raw.push({t:tms, ax, ay, az}); else idxFallback.push({i,ax,ay,az});
  }
  if(raw.length){
    const t0=raw[0].t; const zipped=raw.map(p=>({l:formatRelativeTime(p.t-t0), ax:p.ax, ay:p.ay, az:p.az})); const slim=decimate(zipped,2000);
    return { labels:slim.map(x=>x.l), ax:slim.map(x=>x.ax), ay:slim.map(x=>x.ay), az:slim.map(x=>x.az) };
  }
  if(idxFallback.length){
    const zipped=idxFallback.map(p=>({l:String(p.i), ax:p.ax, ay:p.ay, az:p.az})); const slim=decimate(zipped,2000);
    return { labels:slim.map(x=>x.l), ax:slim.map(x=>x.ax), ay:slim.map(x=>x.ay), az:slim.map(x=>x.az) };
  }
  return null;
}
function computeLinearAccMagnitude(accelRows){
  if(!accelRows?.length) return {labels:[], values:[]};
  const sample=accelRows[0]; const xK=pick(['x','ax'],sample), yK=pick(['y','ay'],sample), zK=pick(['z','az'],sample);
  const tK=pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'],sample);
  if(!xK||!yK||!zK) return {labels:[], values:[]};
  const raw=[], fbL=[], fbV=[];
  for(let i=0;i<accelRows.length;i++){
    const r=accelRows[i]; const x=Number(r[xK]), y=Number(r[yK]), z=Number(r[zK]); if(![x,y,z].every(Number.isFinite)) continue;
    const mag=Math.sqrt(x*x+y*y+z*z); let tms=null;
    if(tK){ if(String(tK).toLowerCase().includes('elapsed')){ const s=Number(r[tK]); if(Number.isFinite(s)) tms=s*1000; }
            else { const dt=parseTime(r[tK]); if(dt instanceof Date && !isNaN(dt)) tms=dt.getTime(); } }
    if(tms!=null) raw.push({t:tms,v:mag-9.81}); else { fbL.push(String(fbL.length)); fbV.push(mag-9.81); }
  }
  if(raw.length){ const t0=raw[0].t; const zip=raw.map(p=>({l:formatRelativeTime(p.t-t0), v:p.v})); const slim=decimate(zip,2000);
    return {labels:slim.map(x=>x.l), values:slim.map(x=>x.v)}; }
  const zip=fbL.map((l,i)=>({l, v:fbV[i]})); const slim=decimate(zip,2000); return {labels:slim.map(x=>x.l), values:slim.map(x=>x.v)};
}

/* ================================ ZIP helpers ================================ */
async function loadCsvFromZip(zip, namePattern){
  const entries=Object.values(zip.files); const entry=entries.find(e=>!e.dir && namePattern.test(e.name)); if(!entry) return null;
  const text=await entry.async('string'); const parse=Papa.parse(text,{header:true,dynamicTyping:true,skipEmptyLines:true});
  if(parse.errors?.length) console.warn('CSV parse issues', parse.errors.slice(0,3)); return parse.data;
}
async function loadAllCameraImagesFromZip(zip){
  const out=[]; const entries=Object.values(zip.files).filter(e=>!e.dir && /\.(jpe?g|png|webp)$/i.test(e.name)).filter(e=>/(^|\/)camera\//i.test(e.name));
  entries.sort((a,b)=>a.name.localeCompare(b.name));
  for(const entry of entries){ const blob=await entry.async('blob'); out.push({url:URL.createObjectURL(blob), name:entry.name}); }
  return out;
}

/* ====================== Location & speed extraction ====================== */
function extractTrack(locationRows){
  if(!locationRows?.length) return null;
  const sample=locationRows[0];
  const latK=pick(['lat','latitude','y'],sample);
  const lonK=pick(['lon','long','longitude','x'],sample);
  const timeK=pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'],sample);
  if(!latK||!lonK) return null;
  const pts=[];
  for(const row of locationRows){
    const lat=Number(row[latK]), lon=Number(row[lonK]); if(!Number.isFinite(lat)||!Number.isFinite(lon)) continue;
    let t=null;
    if(timeK){
      const raw=row[timeK];
      if(String(timeK).toLowerCase().includes('elapsed')){ const secs=Number(raw); if(Number.isFinite(secs)) t=new Date(secs*1000); }
      else t=parseTime(raw);
    }
    pts.push({lat,lon,t});
  }
  return pts.length?pts:null;
}
function computeSpeedSeriesFromLocation(locationRows){
  if(!locationRows?.length) return {labels:[],values:[],relMs:[],idx:[]};
  const speedKey=pick(['speed','spd'],locationRows[0]); const timeKey=pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'],locationRows[0]);
  if(!speedKey||!timeKey) return {labels:[],values:[],relMs:[],idx:[]};
  const raw=[];
  for(let i=0;i<locationRows.length;i++){
    const row=locationRows[i];
    const t=String(timeKey).toLowerCase().includes('elapsed')? Number(row[timeKey])*1000 : parseTime(row[timeKey])?.getTime();
    const v=Number(row[speedKey]);
    if(Number.isFinite(t)&&Number.isFinite(v)) raw.push({i,t,v:v*3.6});
  }
  if(!raw.length) return {labels:[],values:[],relMs:[],idx:[]};
  const t0=raw[0].t; const zipped=raw.map(p=>({l:formatRelativeTime(p.t-t0), ms:(p.t-t0), v:p.v, i:p.i})); const slim=decimate(zipped,2000);
  return { labels:slim.map(x=>x.l), values:slim.map(x=>x.v), relMs:slim.map(x=>x.ms), idx:slim.map(x=>x.i) };
}

/* ============================= Session UI builder ============================= */
function createSessionCard(sessionName){
  const wrap=document.createElement('section'); wrap.className='session';
  const head=document.createElement('header'); const h=document.createElement('h2'); h.className='session-title'; h.textContent=sessionName; head.appendChild(h);
  const body=document.createElement('div'); body.className='session-body';
  const gallery=document.createElement('div'); gallery.className='gallery';
  const map=document.createElement('div'); map.className='map';

  const row=document.createElement('div'); row.className='row';
  const legend=document.createElement('div'); legend.className='legend';
  legend.innerHTML=`
    <span><span class="dot" style="background:var(--blue)"></span> Trace</span>
    <span><span class="dot" style="background:var(--yellow)"></span> Traffic light</span>
    <span><span class="dot" style="background:var(--red)"></span> Stop sign</span>
    <span><span class="dot" style="background:var(--green)"></span> Roundabout</span>
    <span><span class="dot" style="background:#4da3ff)"></span> Junction</span>
    <span><span class="dot" style="background:var(--speedlimit)"></span> Speed limit</span>`;
  const status=document.createElement('div'); status.className='status'; status.textContent='Loading‚Ä¶';
  row.append(legend,status);

  const charts=document.createElement('div'); charts.className='charts';
  const speedFrame=document.createElement('div'); speedFrame.className='chart-frame';
  const speedCanvas=document.createElement('canvas'); speedFrame.appendChild(speedCanvas);
  const markerControls=document.createElement('div'); markerControls.style.display='flex'; markerControls.style.gap='8px'; markerControls.style.alignItems='center';
  const btnExport=document.createElement('button'); btnExport.className='btn'; btnExport.textContent='Export Speed CSV';
  const btnSetA=document.createElement('button'); btnSetA.className='btn'; btnSetA.textContent='Set A';
  const btnSetB=document.createElement('button'); btnSetB.className='btn'; btnSetB.textContent='Set B';
  const btnClear=document.createElement('button'); btnClear.className='btn'; btnClear.textContent='Clear';
  const tip=document.createElement('span'); tip.className='tiny'; tip.textContent='Click the speed plot after choosing A/B.';
  markerControls.append(btnExport,btnSetA,btnSetB,btnClear,tip);
  const accFrame=document.createElement('div'); accFrame.className='chart-frame';
  const accCanvas=document.createElement('canvas'); accFrame.appendChild(accCanvas);

  charts.append(speedFrame, markerControls, accFrame);
  body.append(gallery,map,row,charts); wrap.append(head,body);
  return { wrap, gallery, map, status, speedFrame, speedCanvas, accFrame, accCanvas, btnSetA, btnSetB, btnClear, btnExport };
}

/* =============================== Lightbox ================================= */
const lightbox=document.getElementById('lightbox'); const lightboxImg=document.getElementById('lightboxImg');
function openLightbox(src){ lightboxImg.src=src; lightbox.classList.add('show'); lightbox.focus(); }
function closeLightbox(){ const src=lightboxImg.src; lightbox.classList.remove('show'); lightboxImg.src=''; if(src.startsWith('blob:')) URL.revokeObjectURL(src); }
lightbox.addEventListener('click',closeLightbox); lightbox.addEventListener('keydown',e=>{ if(e.key==='Escape') closeLightbox(); });

/* ============================== Main per-ZIP ============================== */
async function processZipFile(file){
  const sessionName=slugWithoutExt(file.name);
  const ui=createSessionCard(sessionName);
  document.getElementById('sessions').appendChild(ui.wrap);

  function fmtRel(ms){ const s=Math.floor(ms/1000),m=Math.floor(s/60),r=s%60; return m>0?`${m}:${String(r).padStart(2,'0')}`:`${r}s`; }

  let latlngs=null, maxspeedProfile=[], featureLayer=null, markersMeta=[], speedChartRef=null;
  let chain=null, totalMeters=0;

  try{
    ui.status.textContent='Reading ZIP‚Ä¶';
    const zip=await JSZip.loadAsync(file);

    ui.status.textContent='Loading photos‚Ä¶';
    const images=await loadAllCameraImagesFromZip(zip);
    if(images.length){
      for(const img of images){
        const t=document.createElement('img'); t.className='thumb'; t.loading='lazy'; t.src=img.url; t.alt=img.name;
        t.addEventListener('click',()=>openLightbox(img.url)); ui.gallery.appendChild(t);
      }
    }

    ui.status.textContent='Parsing CSVs‚Ä¶';
    const [locationRows, totalAccRows, accelRows] = await Promise.all([
      loadCsvFromZip(zip, /(^|\/)Location\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)TotalAcceleration\.csv$/i),
      loadCsvFromZip(zip, /(^|\/)Accelerometer\.csv$/i)
    ]);

    ui.status.textContent='Rendering map‚Ä¶';
    const map=L.map(ui.map);
    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'¬© OpenStreetMap'}).addTo(map);

    const track=extractTrack(locationRows);
    if(track?.length){
      latlngs=track.map(p=>[p.lat,p.lon]);
      chain = toXYChain(latlngs);
      totalMeters = chain.cum[chain.cum.length-1] || 0;

      const poly=L.polyline(latlngs,{color:'#3a86ff',weight:3}).addTo(map);
      map.fitBounds(poly.getBounds(),{padding:[16,16]});

      const startColor='#00e676';
      const start=L.circleMarker(latlngs[0],{radius:6,color:startColor,weight:2,fillColor:startColor,fillOpacity:0.6}).addTo(map);
      start.bindTooltip('Start',{permanent:true,direction:'right',offset:[8,0],className:'feature-tag'}); colorizeTooltip(start,startColor);

      try{
        L.polylineDecorator(poly,{patterns:[{offset:'85%',repeat:0,symbol:L.Symbol.arrowHead({pixelSize:14,headAngle:60,pathOptions:{color:'#3a86ff',weight:2,opacity:0.9}})}]}).addTo(map);
      }catch(e){ console.warn('PolylineDecorator unavailable; skipping arrow.', e); }

      /* ---- Distance ticks every 100 m on the map ---- */
      const distLayer = L.layerGroup().addTo(map);
      for(let s=100; s <= totalMeters - 1; s += 100){
        const [lat,lon] = latlngAtS(latlngs, chain, s);
        const m = L.circleMarker([lat,lon], { radius:4, color:'#cfd6e3', fillColor:'#cfd6e3', fillOpacity:0.9, weight:1 })
          .addTo(distLayer);
        const label = `${(s/1000).toFixed(1)} km`;
        m.bindTooltip(label, { permanent:true, direction:'top', offset:[0,-6], className:'distance-tag' });
      }

      /* Session controller reacting to master toggle */
      async function enableOSM(){
        if(featureLayer){ try{ featureLayer.clearLayers(); }catch{} }
        featureLayer=L.layerGroup().addTo(map);
        ui.status.textContent='Fetching OSM features‚Ä¶';
        try{
          const bbox=bboxForTrack(track,80);
          const query=overpassQueryForBBox(bbox);
          const osm=await overpassFetch(query);
          markersMeta=addOsmFeaturesToMap(osm, featureLayer, latlngs);
          maxspeedProfile=extractMaxspeedProfile(osm, latlngs);
          for(const m of markersMeta){
            const tt=m.marker.getTooltip?.(); const set=t=>{ if(tt) tt.setContent(t); colorizeTooltip(m.marker,m.color); };
            reverseGeocode(m.lat,m.lon).then(street=>{ set(street?`${m.base} ‚Äî ${street}`:m.base); }).catch(()=>set(m.base));
          }
          ui.status.textContent='Map ready.';
          if(speedChartRef){
            const perSampleMax=computeMaxspeedSeriesAligned(latlngs,maxspeedProfile);
            speedChartRef.$maxspeedValues = speedChartRef.$speedIdx.map(i=>perSampleMax[i]??null);
            speedChartRef.data.datasets[1].data = speedChartRef.$maxspeedValues;
            speedChartRef.update();
          }
        }catch(e){
          console.warn('Overpass error',e);
          ui.status.textContent='Trace rendered. Features unavailable.';
        }
      }
      function disableOSM(){
        if(featureLayer){ try{ featureLayer.clearLayers(); }catch{} }
        markersMeta=[]; maxspeedProfile=[];
        ui.status.textContent='Trace rendered (OSM lookups off).';
        if(speedChartRef){
          const len=speedChartRef.data.labels.length;
          speedChartRef.$maxspeedValues = new Array(len).fill(null);
          speedChartRef.data.datasets[1].data = speedChartRef.$maxspeedValues;
          speedChartRef.update();
        }
      }
      sessionControllers.push({ enable: enableOSM, disable: disableOSM });
      if(osmlEnabled) enableOSM(); else disableOSM();

      // Report total distance
      const km = (totalMeters/1000);
      ui.status.textContent = `${ui.status.textContent}  ‚Ä¢  Distance: ${km.toFixed(2)} km`;

    } else {
      map.setView([59.3293,18.0686],10);
      ui.status.textContent='No coordinates found.';
    }

    /* -------- Speed chart -------- */
    ui.status.textContent += osmlEnabled ? '  ‚Ä¢  Preparing speed‚Ä¶' : '  ‚Ä¢  Preparing speed (no OSM)‚Ä¶';
    const speedSeries=computeSpeedSeriesFromLocation(locationRows||[]);
    const speedLabels=speedSeries.labels, speedValues=speedSeries.values;

    attachCrispSizer(ui.speedFrame, ui.speedCanvas, () => speedChartRef);

    /* Build distance ticks for the speed chart (map every 100 m -> nearest plotted point) */
    let distTicks = [];
    if (latlngs?.length && speedSeries.idx?.length) {
      // For each 100 m, find approximate location index, then nearest displayed point index
      for (let s=100; s <= totalMeters - 1; s += 100) {
        const [, , k0] = latlngAtS(latlngs, chain, s); // segment starts at k0
        // Find nearest index in speedSeries.idx (those are original row indices) to k0
        const idxArr = speedSeries.idx;
        // binary search
        let lo=0, hi=idxArr.length-1, best=0, bestD=Infinity;
        while (lo <= hi) {
          const mid = (lo+hi)>>1;
          const d = Math.abs(idxArr[mid] - k0);
          if (d < bestD) { bestD = d; best = mid; }
          if (idxArr[mid] < k0) lo = mid + 1; else hi = mid - 1;
        }
        distTicks.push({ i: best, label: `${(s/1000).toFixed(1)} km` });
      }
    }

    let maxspeedValues = new Array(speedLabels.length).fill(null);
    if(osmlEnabled && latlngs?.length && maxspeedProfile?.length && speedSeries.idx?.length){
      const perSampleMax=computeMaxspeedSeriesAligned(latlngs,maxspeedProfile);
      maxspeedValues=speedSeries.idx.map(i=>perSampleMax[i]??null);
    }

    let yMin,yMax; const finite=[...speedValues, ...maxspeedValues].filter(Number.isFinite);
    if(finite.length){ yMin=Math.min(...finite)-5; yMax=Math.max(...finite)+5; }

    const speedChart=makeMultiLineChart(ui.speedCanvas,{
      labels:speedLabels, yTitle:'km/h', min:yMin, max:yMax,
      datasets:[
        { label:'Speed',    data:speedValues,    borderColor:cssVar('--blue','#3a86ff'), pointRadius:0, borderWidth:1.6, tension:0.12 },
        { label:'Maxspeed', data:maxspeedValues, borderColor:cssVar('--speedlimit','#ff8800'), pointRadius:0, borderWidth:1.6, tension:0, borderDash:[6,3], stepped:true, spanGaps:true }
      ]
    });
    speedChart.options.plugins.tooltip={ enabled:true, callbacks:{ label:ctx=>` ${ctx.dataset.label}: ${Number.isFinite(ctx.parsed.y)?ctx.parsed.y.toFixed(1):'‚Äì'} km/h` } };
    speedChart.$markers={A:null,B:null,active:'A',colorA:'#00e5ff',colorB:'#ff5ec4'};
    speedChart.$series={relMs:speedSeries.relMs, speedKmH:speedValues};
    speedChart.$speedIdx = speedSeries.idx || speedLabels.map((_,i)=>i);
    speedChart.$maxspeedValues = maxspeedValues;
    speedChart.$distTicks = distTicks;     // <-- feed the 100 m ticks to the plugin
    speedChartRef=speedChart;
    speedChart.update();

    // Marker controls
    ui.btnSetA.addEventListener('click',()=>{ speedChart.$markers.active='A'; });
    ui.btnSetB.addEventListener('click',()=>{ speedChart.$markers.active='B'; });
    ui.btnClear.addEventListener('click',()=>{ speedChart.$markers.A=null; speedChart.$markers.B=null; speedChart.update(); });
    ui.speedCanvas.addEventListener('click',(evt)=>{ const i=nearestIndexFromEvent(speedChart,evt); const which=speedChart.$markers.active||'A'; speedChart.$markers[which]=i; speedChart.update(); });

    // Export CSV
    ui.btnExport.addEventListener('click',()=>{
      const rows=[['t','speed_kmh','maxspeed_kmh']];
      for(let i=0;i<speedLabels.length;i++){
        const t=speedLabels[i]??''; const v=Number.isFinite(speedValues[i])?speedValues[i]:''; const vm=Number.isFinite(speedChartRef.$maxspeedValues[i])?speedChartRef.$maxspeedValues[i]:'';
        rows.push([t,v,vm]);
      }
      const csv=rows.map(r=>r.join(',')).join('\n'); const blob=new Blob([csv],{type:'text/csv'});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`${sessionName}_speed_vs_maxspeed.csv`; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),2000);
    });

    /* -------- Acceleration chart -------- */
    ui.status.textContent+='  ‚Ä¢  Preparing acceleration‚Ä¶';
    attachCrispSizer(ui.accFrame, ui.accCanvas, () => null);

    const accelXYZ=computeAccelXYZSeries(accelRows);
    if(accelXYZ && accelXYZ.labels.length){
      const cBlue=cssVar('--blue','#3a86ff'), cGreen=cssVar('--green','#38c172'), cRed=cssVar('--red','#ff4d4d');
      const all=[...accelXYZ.ax,...accelXYZ.ay,...accelXYZ.az].filter(Number.isFinite);
      let ymin,ymax; if(all.length){ ymin=Math.min(...all); ymax=Math.max(...all); const pad=Math.max(0.3,(ymax-ymin)*0.05); ymin-=pad; ymax+=pad; if(ymin>0)ymin=0; if(ymax<0)ymax=0; }
      makeMultiLineChart(ui.accCanvas,{ labels:accelXYZ.labels, yTitle:'m/s¬≤', min:ymin, max:ymax,
        datasets:[ {label:'Ax',data:accelXYZ.ax,borderColor:cBlue,pointRadius:0,borderWidth:1.2,tension:0.12},
                   {label:'Ay',data:accelXYZ.ay,borderColor:cGreen,pointRadius:0,borderWidth:1.2,tension:0.12},
                   {label:'Az',data:accelXYZ.az,borderColor:cRed,pointRadius:0,borderWidth:1.2,tension:0.12} ] });
    } else {
      let {labels:accLabels,values:accValues}=computeLinearAccMagnitude(accelRows);
      if((!accValues||!accValues.length) && totalAccRows?.length){
        const tk=pick(['time','timestamp','datetime','seconds_elapsed','elapsed','elapsed_seconds'],totalAccRows[0]);
        const ak=pick(['total','magnitude','acc','accel','a_total'],totalAccRows[0]);
        const raw=[]; for(const r of totalAccRows){
          let tms=null; if(tk){ if(String(tk).toLowerCase().includes('elapsed')){ const s=Number(r[tk]); if(Number.isFinite(s)) tms=s*1000; }
                               else { const dt=parseTime(r[tk]); if(dt instanceof Date && !isNaN(dt)) tms=dt.getTime(); } }
          const a=Number(r[ak]); if(tms!=null && Number.isFinite(a)) raw.push({t:tms, v:a-9.81});
        }
        if(raw.length){ const t0=raw[0].t; const zipped=raw.map(p=>({l:fmtRel(p.t-t0), v:p.v})); const slim=decimate(zipped,2000); accLabels=slim.map(x=>x.l); accValues=slim.map(x=>x.v); }
        else { accLabels=[]; accValues=[]; }
      }
      makeLineChart(ui.accCanvas,{ labels:accLabels||[], values:accValues||[], label:'Linear acceleration |a| (m/s¬≤)', yTitle:'m/s¬≤' });
    }

    ui.status.textContent+='  ‚Ä¢  Ready.';
  }catch(err){
    console.error(err); ui.status.textContent='Failed: '+(err?.message||err);
  }
}

/* ---- helper for click->nearest index ---- */
function nearestIndexFromEvent(chart,evt){
  const rect=chart.canvas.getBoundingClientRect(); const xPix=evt.clientX-rect.left; const xScale=chart.scales.x; let bestI=0,bestD=Infinity;
  for(let i=0;i<chart.data.labels.length;i++){ const px=xScale.getPixelForValue(i); const d=Math.abs(px-xPix); if(d<bestD){bestD=d; bestI=i;} }
  return bestI;
}

/* Inputs */
const folderInput=document.getElementById('folderInput'); const filesInput=document.getElementById('filesInput');
function uniqueZipFilesFromFileList(fileList){ const out=[]; const seen=new Set(); for(const f of fileList){ if(!/\.zip$/i.test(f.name)) continue; const key=f.webkitRelativePath||f.name; if(!seen.has(key)){ seen.add(key); out.push(f);} } return out; }

folderInput.addEventListener('change', async (e)=>{ const files=uniqueZipFilesFromFileList(e.target.files); if(!files.length) return; document.getElementById('sessions').innerHTML=''; for(const f of files) await processZipFile(f); folderInput.value=''; });
filesInput.addEventListener('change', async (e)=>{ const files=uniqueZipFilesFromFileList(e.target.files); if(!files.length) return; document.getElementById('sessions').innerHTML=''; for(const f of files) await processZipFile(f); filesInput.value=''; });

/* Master toggle -> existing sessions */
chkOSM.addEventListener('change', async ()=>{
  osmlEnabled = chkOSM.checked;
  for(const ctl of sessionControllers){
    try { osmlEnabled ? await ctl.enable() : ctl.disable(); } catch(e){ console.warn('toggle session failed', e); }
  }
});

/* Lightbox cleanup */
window.addEventListener('beforeunload', ()=>{
  const imgs=document.querySelectorAll('.thumb');
  imgs.forEach(img=>{ try{ if(img.src && img.src.startsWith('blob:')) URL.revokeObjectURL(img.src);}catch{} });
});
</script>
</body>
</html>
