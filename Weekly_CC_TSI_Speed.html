#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
import time
import threading
import queue
from typing import Optional, Tuple, Dict, List

import pandas as pd
import requests

import tkinter as tk
from tkinter import filedialog, messagebox
from tkinter import ttk

# ----------------------- Config -----------------------
OVERPASS_URL = "https://overpass-api.de/api/interpreter"
SEARCH_RADIUS_M = 40           # meters around the point
REQUEST_SLEEP_S = 0.8          # polite throttling between requests
USER_AGENT = "SpeedLookupScript/1.2 (contact: you@example.com)"
RESULT_COL_NAME = "LegalSpeed_kph"  # inserted as column D (index 3)
# ------------------------------------------------------

_speed_num_re = re.compile(r"^\s*(\d+(?:\.\d+)?)\s*(mph|km/h|kph|kmh)?\s*$", re.IGNORECASE)

def parse_maxspeed_to_kph(val: str) -> Optional[float]:
    if not val:
        return None
    val = str(val).strip()
    m = _speed_num_re.match(val)
    if not m:
        return None
    num = float(m.group(1))
    unit = m.group(2).lower() if m.group(2) else "kph"
    if unit == "mph":
        return round(num * 1.60934, 1)
    return round(num, 1)

def pick_best_speed(tags: Dict[str, str]) -> Optional[float]:
    # Prefer explicit forward/backward if present; fall back to maxspeed
    for key in ("maxspeed:forward", "maxspeed:backward", "maxspeed"):
        if key in tags:
            sp = parse_maxspeed_to_kph(tags.get(key))
            if sp is not None:
                return sp
    return None

def build_overpass_query(lat: float, lon: float, radius_m: int) -> str:
    return f"""
[out:json][timeout:25];
way[highway](around:{radius_m},{lat},{lon});
out tags geom;
"""

def haversine(lat1, lon1, lat2, lon2):
    R = 6371000.0
    from math import radians, sin, cos, atan2, sqrt
    phi1, phi2 = radians(lat1), radians(lat2)
    dphi = radians(lat2 - lat1)
    dlmb = radians(lon2 - lon1)
    a = sin(dphi/2)**2 + cos(phi1)*cos(phi2)*sin(dlmb/2)**2
    return 2*R*atan2(sqrt(a), sqrt(1-a))

def nearest_way_with_speed(resp_json: dict, lat: float, lon: float):
    elements = resp_json.get("elements", [])
    if not elements:
        return None, None
    best = None
    for el in elements:
        if el.get("type") != "way":
            continue
        tags = el.get("tags", {})
        geom = el.get("geometry", [])
        if not geom:
            continue
        dmin = min(haversine(lat, lon, n["lat"], n["lon"]) for n in geom)
        sp = pick_best_speed(tags)
        if best is None or dmin < best[0]:
            best = (dmin, el, sp)
    if best is None:
        return None, None
    _, way, speed = best
    return way.get("id"), speed

def find_lat_lon_columns(df: pd.DataFrame) -> Tuple[str, str]:
    """
    Detect latitude/longitude columns robustly.
    Handles 'Latitude'/'Longitude' and common aliases.
    Falls back to the first two columns if nothing matched.
    """
    cols_norm = [str(c).strip().lower() for c in df.columns]
    lat_alias = ["latitude", "lat", "y"]
    lon_alias = ["longitude", "long", "lon", "x"]

    lat_col = None
    lon_col = None
    for i, c in enumerate(cols_norm):
        if lat_col is None and any(c == a or c.startswith(a) for a in lat_alias):
            lat_col = df.columns[i]
        if lon_col is None and any(c == a or c.startswith(a) for a in lon_alias):
            lon_col = df.columns[i]

    if not lat_col or not lon_col:
        if df.shape[1] >= 2:
            lat_col = lat_col or df.columns[0]
            lon_col = lon_col or df.columns[1]
        else:
            raise ValueError("Could not determine latitude/longitude columns.")
    return lat_col, lon_col

class ProgressDialog:
    def __init__(self, parent, total: int):
        self.top = tk.Toplevel(parent)
        self.top.title("Fetching OSM maxspeeds")
        self.top.resizable(False, False)
        self.top.grab_set()
        self.cancelled = False

        pad = 12
        frm = ttk.Frame(self.top, padding=pad)
        frm.grid(row=0, column=0, sticky="nsew")

        self.msg_var = tk.StringVar(value="Starting…")
        self.pct_var = tk.StringVar(value="0%")
        self.eta_var = tk.StringVar(value="ETA —")
        self.status_var = tk.StringVar(value="")

        ttk.Label(frm, textvariable=self.msg_var).grid(row=0, column=0, sticky="w", padx=2, pady=(0,6))
        self.bar = ttk.Progressbar(frm, orient="horizontal", mode="determinate", length=420, maximum=total)
        self.bar.grid(row=1, column=0, sticky="ew", padx=2)

        row2 = ttk.Frame(frm); row2.grid(row=2, column=0, sticky="ew")
        ttk.Label(row2, textvariable=self.pct_var, width=8).pack(side="left")
        ttk.Label(row2, textvariable=self.eta_var).pack(side="left", padx=(8,0))

        ttk.Label(frm, textvariable=self.status_var, foreground="#555").grid(row=3, column=0, sticky="w", padx=2, pady=(6,2))

        btns = ttk.Frame(frm); btns.grid(row=4, column=0, sticky="e", pady=(8,0))
        self.cancel_btn = ttk.Button(btns, text="Cancel", command=self._cancel)
        self.cancel_btn.pack(side="right")

        self.start_time = time.time()
        self.total = total
        self.done = 0
        self.top.protocol("WM_DELETE_WINDOW", self._cancel)

    def _cancel(self):
        self.cancelled = True
        self.msg_var.set("Cancelling…")
        self.cancel_btn.config(state="disabled")

    def update(self, done: int, status: str):
        self.done = done
        self.bar["value"] = done
        pct = 0 if self.total == 0 else int((done / self.total) * 100)
        self.pct_var.set(f"{pct}%")

        elapsed = max(0.0, time.time() - self.start_time)
        if done > 0:
            per_item = elapsed / done
            remaining = max(0.0, (self.total - done) * per_item)
            self.eta_var.set(f"ETA {int(remaining//60)}m {int(remaining%60)}s")
        else:
            self.eta_var.set("ETA —")

        self.status_var.set(status)
        self.msg_var.set(f"Processed {done} of {self.total}")

    def close(self):
        try:
            self.top.grab_release()
        except Exception:
            pass
        self.top.destroy()

def worker_thread(df: pd.DataFrame, lat_col: str, lon_col: str,
                  out_path: str, total: int, q: queue.Queue,
                  stop_evt: threading.Event):
    """
    Runs in background thread; posts progress via queue.
    - Inserts 'LegalSpeed_kph' at column D (index 3).
    - Uses both coordinate cache and way-id cache to reduce Overpass calls.
    """
    # Prepare result storage
    if RESULT_COL_NAME in df.columns:
        df.drop(columns=[RESULT_COL_NAME], inplace=True)

    results: List[Optional[float]] = []

    way_speed_cache: Dict[int, Optional[float]] = {}
    coord_speed_cache: Dict[Tuple[float, float], Optional[float]] = {}

    session = requests.Session()
    session.headers.update({"User-Agent": USER_AGENT})

    def polite_post(query: str, backoff_state: dict):
        try:
            r = session.post(OVERPASS_URL, data={"data": query}, timeout=40)
            if r.status_code in (429, 503):
                backoff_state["wait"] = min(backoff_state["wait"] * 2, 30)
                time.sleep(backoff_state["wait"])
                r = session.post(OVERPASS_URL, data={"data": query}, timeout=40)
            r.raise_for_status()
            backoff_state["wait"] = 1.0
            return r.json()
        except Exception as e:
            return {"__error__": str(e)}

    backoff = {"wait": 1.0}

    for i, row in df.iterrows():
        if stop_evt.is_set():
            break

        # Parse coordinates
        try:
            lat = float(row[lat_col]); lon = float(row[lon_col])
            coord_ok = True
        except Exception:
            lat = lon = None
            coord_ok = False

        sp = None
        status = ""

        if coord_ok:
            key = (round(lat, 5), round(lon, 5))
            if key in coord_speed_cache:
                sp = coord_speed_cache[key]
                status = f"(cached) ({lat:.6f}, {lon:.6f}) → {'—' if sp is None else f'{sp} kph'}"
            else:
                qstr = build_overpass_query(lat, lon, SEARCH_RADIUS_M)
                data = polite_post(qstr, backoff)
                if "__error__" not in data:
                    way_id, sp_candidate = nearest_way_with_speed(data, lat, lon)
                    if way_id is not None:
                        if way_id in way_speed_cache and sp_candidate is None:
                            sp = way_speed_cache[way_id]
                        else:
                            sp = sp_candidate
                            way_speed_cache[way_id] = sp
                    else:
                        sp = sp_candidate
                    coord_speed_cache[key] = sp
                    status = f"({lat:.6f}, {lon:.6f}) → {'—' if sp is None else f'{sp} kph'}"
                else:
                    status = "Overpass error; leaving blank"
        else:
            status = "Invalid lat/lon; leaving blank"

        results.append(sp)
        q.put(("progress", i + 1, status))

        # Throttle politely
        slept = 0.0
        while slept < REQUEST_SLEEP_S:
            if stop_evt.is_set():
                break
            time.sleep(0.05)
            slept += 0.05
        if stop_evt.is_set():
            break

    # Finalize: pad if cancelled early
    if len(results) < len(df):
        results += [None] * (len(df) - len(results))

    # Insert as column D (index 3)
    insert_at = 3 if df.shape[1] >= 3 else df.shape[1]
    df.insert(insert_at, RESULT_COL_NAME, results)

    try:
        df.to_excel(out_path, index=False)
        q.put(("done", len(results), out_path))
    except Exception as e:
        q.put(("error", f"Failed to write Excel: {e}"))

def main():
    root = tk.Tk()
    root.withdraw()

    # Excel-only picker (no CSV)
    in_path = filedialog.askopenfilename(
        title="Choose input Excel with coordinates",
        defaultextension=".xlsx",
        filetypes=[("Excel files", "*.xlsx *.xls")],
    )
    if not in_path:
        return
    if not in_path.lower().endswith((".xlsx", ".xls")):
        messagebox.showerror("Error", "Please select an Excel file (.xlsx or .xls).")
        return

    out_path = filedialog.asksaveasfilename(
        title="Save output Excel (with speeds)",
        defaultextension=".xlsx",
        initialfile="with_speeds.xlsx",
        filetypes=[("Excel files", "*.xlsx")],
    )
    if not out_path:
        return

    # Read Excel (requires openpyxl for .xlsx)
    try:
        df = pd.read_excel(in_path)
    except Exception as e:
        messagebox.showerror("Error", f"Failed to read Excel:\n{e}\n\nTip: pip install openpyxl")
        return

    # Locate lat/lon columns
    try:
        lat_col, lon_col = find_lat_lon_columns(df)
    except Exception as e:
        messagebox.showerror("Error", str(e))
        return

    total = len(df)
    prog = ProgressDialog(root, total)

    q_updates: queue.Queue = queue.Queue()
    stop_evt = threading.Event()

    def pump_queue():
        """Process updates from worker; reschedule itself via after()."""
        try:
            while True:
                kind, *payload = q_updates.get_nowait()
                if kind == "progress":
                    done, status = payload
                    prog.update(done, status)
                elif kind == "done":
                    _count, path = payload
                    prog.close()
                    if stop_evt.is_set():
                        messagebox.showinfo("Cancelled", f"Stopped early. Saved partial results:\n{path}")
                    else:
                        messagebox.showinfo("Done", f"Saved:\n{path}")
                    return
                elif kind == "error":
                    prog.close()
                    messagebox.showerror("Error", payload[0])
                    return
        except queue.Empty:
            pass

        if prog.cancelled and not stop_evt.is_set():
            stop_evt.set()
        root.after(80, pump_queue)

    # Start worker
    t = threading.Thread(
        target=worker_thread,
        args=(df.copy(), lat_col, lon_col, out_path, total, q_updates, stop_evt),
        daemon=True
    )
    t.start()

    # Start pumping
    root.after(80, pump_queue)
    try:
        root.mainloop()
    except KeyboardInterrupt:
        stop_evt.set()

if __name__ == "__main__":
    main()
