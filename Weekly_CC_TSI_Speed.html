<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Speed Checker ‚Äî CSV/XLSX Map & Plots</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Leaflet (OSM) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Plotly for charts -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <!-- PapaParse for CSV -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- SheetJS for Excel -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    :root { --ink:#111; --muted:#666; --bg:#fff; --card:#f7f7f9; --accent:#0b5; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Arial, sans-serif; color: var(--ink); background: var(--bg); }
    header {
      position: sticky; top: 0; z-index: 10; background: white; border-bottom: 1px solid #eee;
      padding: 12px 16px; display: flex; gap: 12px; align-items: center; justify-content: space-between;
    }
    .title { font-weight: 700; }
    .picker {
      display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border: 1px dashed #aaa; border-radius: 10px;
      background: #fafafa;
    }
    input[type="file"] { display: none; }
    .container { max-width: 1200px; margin: 18px auto; padding: 0 16px 80px; }
    .fileCard {
      background: var(--card); border: 1px solid #ececf1; border-radius: 14px; margin: 18px 0; padding: 12px 12px 18px;
      box-shadow: 0 1px 2px rgba(0,0,0,.03);
    }
    .fileHead { display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; }
    .badges { display:flex; gap:8px; flex-wrap:wrap; }
    .badge { font-size: 12px; padding: 4px 8px; border-radius: 999px; border: 1px solid #ddd; background:#fff; }
    .map { width: 100%; height: 360px; border-radius: 12px; border: 1px solid #e6e6ea; overflow: hidden; }
    .sectionTitle { margin: 12px 0 8px; font-weight: 700; }
    .chart { width: 100%; height: 280px; border: 1px solid #e6e6ea; border-radius: 12px; background: #fff; }
    .legend { font-size: 13px; color: var(--muted); }
    .hl { color: var(--accent); font-weight: 700; }
    .hr { height: 1px; background: #eee; margin: 10px 0 14px; }
    .note { font-size: 12px; color: #777; padding: 0 2px; }
  </style>
</head>
<body>
  <header>
    <div class="title">Speed Checker ‚Äî CSV/XLSX Map & Plots</div>
    <label class="picker">
      <span>üìÅ Pick folder‚Ä¶</span>
      <!-- Accept CSV and Excel; folder picker -->
      <input id="folder" type="file" webkitdirectory directory multiple accept=".csv,.xlsx,.xls" />
    </label>
  </header>

  <div class="container" id="app">
    <p class="note">
      Expected columns per file (first sheet for Excel): <b>A: lat</b>, <b>B: lon</b>, <b>C: SpdLimFirst</b>, <b>D: MaxSpeed_kph</b>.<br/>
      This tool creates <b>E: distance_m</b> (between consecutive points) and <b>F: true_positive_distance_m</b> (cumulative distance where <b>C == D</b>).<br/>
      Filename is parsed as <code>car_software_testdate.ext</code>.
    </p>
  </div>

<script>
/** ---- Helpers ---- **/

function parseMetaFromFilename(name) {
  const base = name.replace(/\.[^/.]+$/, "");
  const parts = base.split("_");
  if (parts.length >= 3) {
    const testdate = parts.pop();
    const software = parts.pop();
    const car = parts.join("_");
    return { car, software, testdate };
  }
  return { car: base, software: "n/a", testdate: "n/a" };
}

// Haversine distance in meters
function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function numOrNull(v) {
  if (v === null || v === undefined) return null;
  const s = String(v).trim();
  if (s === "") return null;
  const n = Number(s);
  return Number.isFinite(n) ? n : null;
}

function extractRowABCD(row) {
  // row is an array; we expect A,B,C,D at indices 0..3
  const lat = numOrNull(row[0]);
  const lon = numOrNull(row[1]);
  const C = numOrNull(row[2]); // SpdLimFirst
  const D = numOrNull(row[3]); // MaxSpeed_kph
  return [lat, lon, C, D];
}

/** ---- File parsing (CSV or Excel) -> rows (array of arrays) ---- **/

async function readFileToRows(file) {
  const name = file.name.toLowerCase();
  if (name.endsWith(".csv")) {
    const text = await file.text();
    const parsed = Papa.parse(text, { skipEmptyLines: true });
    return parsed.data; // array of arrays
  }
  // Excel path
  const buf = await file.arrayBuffer();
  const wb = XLSX.read(buf, { type: "array" });
  // Choose the first non-empty sheet
  const sheetName = wb.SheetNames.find(n => {
    const ws = wb.Sheets[n];
    const range = ws['!ref'];
    return !!range;
  }) || wb.SheetNames[0];
  const ws = wb.Sheets[sheetName];
  // Get as 2D array without headers
  const rows = XLSX.utils.sheet_to_json(ws, { header: 1, raw: true, blankrows: false });
  return rows;
}

/** ---- Core processing per file ---- **/
async function processFile(file, container) {
  const filename = file.name;
  const meta = parseMetaFromFilename(filename);

  // UI card
  const card = document.createElement("div");
  card.className = "fileCard";
  card.innerHTML = `
    <div class="fileHead">
      <div>
        <div><strong>${filename}</strong></div>
        <div class="legend">Parsed as <span class="hl">${meta.car}</span> ‚Ä¢ ${meta.software} ‚Ä¢ ${meta.testdate}</div>
      </div>
      <div class="badges">
        <span class="badge">Car: ${meta.car}</span>
        <span class="badge">SW: ${meta.software}</span>
        <span class="badge">Date: ${meta.testdate}</span>
        <span class="badge">${filename.split('.').pop().toUpperCase()}</span>
      </div>
    </div>
    <div class="hr"></div>
    <div class="sectionTitle">Map</div>
    <div class="map" id="map_${crypto.randomUUID()}"></div>
    <div class="sectionTitle">SpdLimFirst (C) vs MaxSpeed_kph (D)</div>
    <div class="chart" id="chart1_${crypto.randomUUID()}"></div>
    <div class="sectionTitle">True Positive Distance (F)</div>
    <div class="chart" id="chart2_${crypto.randomUUID()}"></div>
  `;
  container.appendChild(card);

  const mapEl = card.querySelector(".map");
  const chart1El = card.querySelectorAll(".chart")[0];
  const chart2El = card.querySelectorAll(".chart")[1];

  // Read rows
  const rows = await readFileToRows(file);

  // Tolerate one header row (non-numeric); otherwise take all rows that look numeric
  const data = [];
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    if (!row || row.length < 2) continue; // need at least lat/lon
    const [lat, lon, C, D] = extractRowABCD(row);
    if (lat === null || lon === null) continue; // skip non-numeric / header rows
    data.push({ lat, lon, C, D });
  }

  if (data.length === 0) {
    chart1El.innerHTML = "<div style='padding:1rem;color:#a00'>No valid rows with numeric lat/lon found.</div>";
    return;
  }

  // Forward-fill D (MaxSpeed_kph) for missing cells
  let lastD = null;
  for (let i = 0; i < data.length; i++) {
    if (data[i].D === null) {
      data[i].D = lastD;
    } else {
      lastD = data[i].D;
    }
  }

  // Compute E (distance) and F (true positive distance)
  let cumulativeF = 0;
  data[0].E = 0;
  data[0].F = 0;
  for (let i = 1; i < data.length; i++) {
    const p0 = data[i-1];
    const p1 = data[i];
    const dist = haversine(p0.lat, p0.lon, p1.lat, p1.lon);
    p1.E = dist;
    if (p1.C !== null && p1.D !== null && p1.C === p1.D) {
      cumulativeF += dist;
    }
    p1.F = cumulativeF;
  }

  // Map
  const map = L.map(mapEl, { zoomControl: true, preferCanvas: true });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap contributors"
  }).addTo(map);

  const latlngs = data.map(p => [p.lat, p.lon]);
  const bounds = L.latLngBounds(latlngs);
  map.fitBounds(bounds, { padding: [20, 20] });

  const layer = L.layerGroup().addTo(map);
  for (let i = 0; i < data.length; i++) {
    const p = data[i];
    const match = (p.C !== null && p.D !== null && p.C === p.D);
    const color = match ? "#000000" : "#d40000";
    const m = L.circleMarker([p.lat, p.lon], {
      radius: 3,
      stroke: false,
      fillColor: color,
      fillOpacity: 0.9
    });
    m.bindTooltip(
      `idx ${i}<br>lat: ${p.lat.toFixed(6)}<br>lon: ${p.lon.toFixed(6)}`
      + `<br>C (SpdLimFirst): ${p.C ?? "NA"}`
      + `<br>D (MaxSpeed_kph): ${p.D ?? "NA"}`
      + `<br>E (dist m): ${p.E?.toFixed(1) ?? "0"}`
      + `<br>F (TP m): ${p.F?.toFixed(1) ?? "0"}`,
      { sticky: true }
    );
    m.addTo(layer);
  }

  // Plot 1: C vs D
  {
    const x = data.map((_, i) => i);
    const cSeries = { x, y: data.map(p => p.C), mode: "lines", name: "SpdLimFirst (C)" };
    const dSeries = { x, y: data.map(p => p.D), mode: "lines", name: "MaxSpeed_kph (D)" };
    Plotly.newPlot(chart1El, [cSeries, dSeries], {
      margin: { l: 50, r: 20, t: 20, b: 40 },
      xaxis: { title: "Sample index" },
      yaxis: { title: "Speed (kph)" },
      showlegend: true
    }, { responsive: true, displaylogo: false });
  }

  // Plot 2: F (true positive distance)
  {
    const x = data.map((_, i) => i);
    const fSeries = { x, y: data.map(p => p.F), mode: "lines", name: "True positive distance (F)" };
    Plotly.newPlot(chart2El, [fSeries], {
      margin: { l: 50, r: 20, t: 20, b: 40 },
      xaxis: { title: "Sample index" },
      yaxis: { title: "Distance (m)" },
      showlegend: true
    }, { responsive: true, displaylogo: false });
  }
}

/** ---- Folder handling ---- **/
document.getElementById("folder").addEventListener("change", async (e) => {
  const files = Array.from(e.target.files).filter(f =>
    /\.(csv|xlsx|xls)$/i.test(f.name)
  );
  const app = document.getElementById("app");
  app.innerHTML = ""; // clear

  if (files.length === 0) {
    app.innerHTML = "<p class='note'>No CSV/XLSX files found in the selected folder.</p>";
    return;
  }

  files.sort((a,b) => a.name.localeCompare(b.name));
  for (const file of files) {
    await processFile(file, app);
  }
});
</script>
</body>
</html>
