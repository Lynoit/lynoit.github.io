<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion, Speed & Energy Visualizer</title>
  <style>
    body { margin: 0; font-family: sans-serif; background: #121212; color: #fff; display: flex; flex-direction: column; align-items: center; }
    #displayRow { width: 90%; max-width: 600px; display: flex; justify-content: space-between; margin: 16px 0; }
    #controls { width: 90%; max-width: 600px; display: flex; align-items: center; gap: 8px; margin-bottom: 24px; }
    #speedValue, #limitValue, #optimalValue, #accValue { font-size: 1.5rem; }
    .graph { border: 1px solid #444; background: #1e1e1e; width: 90%; max-width: 600px; height: 200px; margin-bottom: 24px; }
  </style>
</head>
<body>
  <div id="displayRow">
    <div id="speedValue">Speed: 0.00 km/h</div>
    <div id="limitValue">Limit: N/A</div>
    <div id="optimalValue">Optimal: N/A</div>
    <div id="accValue">Accel: 0.00 m/s²</div>
  </div>
  <div id="controls">
    <label for="alphaSlider">Filter α:</label>
    <input type="range" id="alphaSlider" min="0" max="1" step="0.01" value="0.04">
    <input type="text" id="alphaValue" value="0.04" readonly>
  </div>
  <canvas id="accGraph" class="graph"></canvas>
  <canvas id="speedGraph" class="graph"></canvas>
  <canvas id="gpsAccGraph" class="graph"></canvas>
  <canvas id="scatterGraph" class="graph"></canvas>
  <canvas id="energyGraph" class="graph"></canvas>

  <script>
    const mass = 1500; // vehicle mass in kg
    const speedValueEl = document.getElementById('speedValue');
    const limitValueEl = document.getElementById('limitValue');
    const optimalValueEl = document.getElementById('optimalValue');
    const accValueEl = document.getElementById('accValue');
    const alphaSlider = document.getElementById('alphaSlider');
    const alphaValueEl = document.getElementById('alphaValue');
    const accCanvas = document.getElementById('accGraph');
    const speedCanvas = document.getElementById('speedGraph');
    const gpsAccCanvas = document.getElementById('gpsAccGraph');
    const scatterCanvas = document.getElementById('scatterGraph');
    const energyCanvas = document.getElementById('energyGraph');
    const accCtx = accCanvas.getContext('2d');
    const speedCtx = speedCanvas.getContext('2d');
    const gpsAccCtx = gpsAccCanvas.getContext('2d');
    const scatterCtx = scatterCanvas.getContext('2d');
    const energyCtx = energyCanvas.getContext('2d');

    const margin = { left: 50, bottom: 30 };
    const maxAccel = 20;
    const maxScatterSpeed = 100;
    const accTicks = 5;
    const speedTicks = 5;
    const maxPoints = 100;

    let rawAcc = [], lpfAcc = [];
    let speedPoints = [], limitPoints = [], optimalPoints = [];
    let gpsAccPoints = [];
    let power1 = [], power2 = [];
    let prevMagLPF = 0, prevSpeedLPF = 0, prevGpsAccLPF = 0;
    let prevLimit = 0, prevSpeedMps = 0;
    let prevPos = null;

    function resizeAll() {
      [accCanvas, speedCanvas, gpsAccCanvas, scatterCanvas, energyCanvas].forEach((canvas, i) => {
        const ctx = [accCtx, speedCtx, gpsAccCtx, scatterCtx, energyCtx][i];
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      });
      drawAcc(); drawSpeed(); drawGpsAcc(); drawScatter(); drawEnergy();
    }
    window.addEventListener('resize', resizeAll);
    resizeAll();

    function drawAxes(ctx, w, h, maxValue, ticks) {
      ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(margin.left, 0); ctx.lineTo(margin.left, h - margin.bottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin.left, h - margin.bottom); ctx.lineTo(w, h - margin.bottom); ctx.stroke();
      ctx.fillStyle = '#ccc'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      const graphH = h - margin.bottom;
      for (let i = 0; i <= ticks; i++) {
        const val = (maxValue / ticks) * i;
        const y = graphH - (val / maxValue) * graphH;
        ctx.beginPath(); ctx.moveTo(margin.left - 5, y); ctx.lineTo(margin.left, y); ctx.stroke();
        ctx.fillText(val.toFixed(0), margin.left - 10, y);
      }
    }

    function drawAcc() {
      const w = accCanvas.clientWidth, h = accCanvas.clientHeight;
      // legend
      accCtx.font = '12px sans-serif';
      accCtx.fillStyle = '#4caf50'; accCtx.fillRect(margin.left + 10, 10, 10, 10);
      accCtx.fillStyle = '#fff'; accCtx.fillText('Raw Acc', margin.left + 25, 20);
      accCtx.fillStyle = '#ff9800'; accCtx.fillRect(margin.left + 100, 10, 10, 10);
      accCtx.fillStyle = '#fff'; accCtx.fillText('Filtered Acc', margin.left + 115, 20);
      accCtx.clearRect(0,0,w,h);
      const w = accCanvas.clientWidth, h = accCanvas.clientHeight;
      accCtx.clearRect(0,0,w,h);
      drawAxes(accCtx,w,h,maxAccel,accTicks);
      const gw=w-margin.left, gh=h-margin.bottom;
      accCtx.beginPath(); accCtx.strokeStyle='#4caf50'; accCtx.lineWidth=2;
      rawAcc.forEach((v,i)=>{ const x=margin.left+(gw/(maxPoints-1))*i; const y=gh-(v/maxAccel)*gh; i===0?accCtx.moveTo(x,y):accCtx.lineTo(x,y); }); accCtx.stroke();
      accCtx.beginPath(); accCtx.strokeStyle='#ff9800'; accCtx.lineWidth=2;
      lpfAcc.forEach((v,i)=>{ const x=margin.left+(gw/(maxPoints-1))*i; const y=gh-(v/maxAccel)*gh; i===0?accCtx.moveTo(x,y):accCtx.lineTo(x,y); }); accCtx.stroke();
    }

    function drawSpeed() {
      const w = speedCanvas.clientWidth, h = speedCanvas.clientHeight;
      // legend
      speedCtx.font = '12px sans-serif';
      speedCtx.fillStyle = '#03a9f4'; speedCtx.fillRect(margin.left + 10, 10, 10, 10);
      speedCtx.fillStyle = '#fff'; speedCtx.fillText('GPS Speed', margin.left + 25, 20);
      speedCtx.fillStyle = '#ffff00'; speedCtx.fillRect(margin.left + 110, 10, 10, 10);
      speedCtx.fillStyle = '#fff'; speedCtx.fillText('Speed Limit', margin.left + 125, 20);
      speedCtx.fillStyle = '#4caf50'; speedCtx.fillRect(margin.left + 220, 10, 10, 10);
      speedCtx.fillStyle = '#fff'; speedCtx.fillText('Optimal Speed', margin.left + 235, 20);
      speedCtx.clearRect(0,0,w,h);
      const w=speedCanvas.clientWidth,h=speedCanvas.clientHeight;
      speedCtx.clearRect(0,0,w,h);
      const maxVal=Math.max(...speedPoints,...limitPoints,...optimalPoints,10);
      const axisMax=Math.min(Math.ceil(maxVal/10)*10,150);
      drawAxes(speedCtx,w,h,axisMax,speedTicks);
      const gw=w-margin.left,gh=h-margin.bottom;
      // speed
      speedCtx.beginPath(); speedCtx.strokeStyle='#03a9f4'; speedCtx.lineWidth=2;
      speedPoints.forEach((v,i)=>{ const x=margin.left+(gw/(maxPoints-1))*i; const y=gh-(v/axisMax)*gh; i===0?speedCtx.moveTo(x,y):speedCtx.lineTo(x,y); }); speedCtx.stroke();
      // limit
      speedCtx.beginPath(); speedCtx.setLineDash([5,5]); speedCtx.strokeStyle='#ffff00'; speedCtx.lineWidth=2;
      limitPoints.forEach((v,i)=>{ const x=margin.left+(gw/(maxPoints-1))*i; const y=gh-(v/axisMax)*gh; i===0?speedCtx.moveTo(x,y):speedCtx.lineTo(x,y); }); speedCtx.stroke(); speedCtx.setLineDash([]);
      // optimal
      speedCtx.beginPath(); speedCtx.strokeStyle='#4caf50'; speedCtx.lineWidth=2;
      optimalPoints.forEach((v,i)=>{ const x=margin.left+(gw/(maxPoints-1))*i; const y=gh-(v/axisMax)*gh; i===0?speedCtx.moveTo(x,y):speedCtx.lineTo(x,y); }); speedCtx.stroke();
    }

    function drawGpsAcc() {
      const w = gpsAccCanvas.clientWidth, h = gpsAccCanvas.clientHeight;
      // legend
      gpsAccCtx.font = '12px sans-serif';
      gpsAccCtx.fillStyle = '#e91e63'; gpsAccCtx.fillRect(margin.left + 10, 10, 10, 10);
      gpsAccCtx.fillStyle = '#fff'; gpsAccCtx.fillText('GPS Accel', margin.left + 25, 20);
      gpsAccCtx.clearRect(0,0,w,h); {
      const w=gpsAccCanvas.clientWidth,h=gpsAccCanvas.clientHeight;
      gpsAccCtx.clearRect(0,0,w,h);
      const axisMax=5; const gh=h-margin.bottom,gw=w-margin.left; const zeroY=gh/2;
      gpsAccCtx.strokeStyle='#888';gpsAccCtx.lineWidth=1;
      gpsAccCtx.beginPath();gpsAccCtx.moveTo(margin.left,0);gpsAccCtx.lineTo(margin.left,gh);gpsAccCtx.stroke();
      gpsAccCtx.beginPath();gpsAccCtx.moveTo(margin.left,zeroY);gpsAccCtx.lineTo(w,zeroY);gpsAccCtx.stroke();
      gpsAccCtx.fillStyle='#ccc';gpsAccCtx.textAlign='right';gpsAccCtx.textBaseline='middle';
      for(let i=-accTicks;i<=accTicks;i++){const val=axisMax*(i/accTicks);const y=zeroY-(val/axisMax)*(gh/2);gpsAccCtx.beginPath();gpsAccCtx.moveTo(margin.left-5,y);gpsAccCtx.lineTo(margin.left,y);gpsAccCtx.stroke();gpsAccCtx.fillText(val.toFixed(1),margin.left-10,y);}      
      gpsAccCtx.beginPath();gpsAccCtx.strokeStyle='#e91e63';gpsAccCtx.lineWidth=2;
      gpsAccPoints.forEach((v,i)=>{const x=margin.left+(gw/(maxPoints-1))*i;const y=zeroY-(v/axisMax)*(gh/2);i===0?gpsAccCtx.moveTo(x,y):gpsAccCtx.lineTo(x,y);}  );gpsAccCtx.stroke();
    }

    function drawScatter() {
      const w = scatterCanvas.clientWidth, h = scatterCanvas.clientHeight;
      // legend
      scatterCtx.font = '12px sans-serif';
      scatterCtx.fillStyle = 'red'; scatterCtx.fillRect(margin.left + 10, 10, 10, 10);
      scatterCtx.fillStyle = '#fff'; scatterCtx.fillText('Accel vs Speed', margin.left + 25, 20);
      scatterCtx.clearRect(0, 0, w, h); {
      const w=scatterCanvas.clientWidth,h=scatterCanvas.clientHeight; scatterCtx.clearRect(0,0,w,h);
      scatterCtx.strokeStyle='#888';scatterCtx.lineWidth=1;
      scatterCtx.beginPath();scatterCtx.moveTo(margin.left,0);scatterCtx.lineTo(margin.left,h-margin.bottom);scatterCtx.stroke();
      scatterCtx.beginPath();scatterCtx.moveTo(margin.left,h-margin.bottom);scatterCtx.lineTo(w,h-margin.bottom);scatterCtx.stroke();
      scatterCtx.fillStyle='#ccc';scatterCtx.textAlign='right';scatterCtx.textBaseline='middle';
      const gh2=h-margin.bottom,gw2=w-margin.left;
      for(let i=0;i<=accTicks;i++){const val=(maxAccel/accTicks)*i;const y=gh2-(val/maxAccel)*gh2;scatterCtx.beginPath();scatterCtx.moveTo(margin.left-5,y);scatterCtx.lineTo(margin.left,y);scatterCtx.stroke();scatterCtx.fillText(val.toFixed(0),margin.left-10,y);}      
      scatterCtx.textAlign='center';scatterCtx.textBaseline='top';
      for(let i=0;i<=speedTicks;i++){const val=(maxScatterSpeed/speedTicks)*i;const x=margin.left+(gw2/speedTicks)*i;scatterCtx.beginPath();scatterCtx.moveTo(x,h-margin.bottom);scatterCtx.lineTo(x,h-margin.bottom+5);scatterCtx.stroke();scatterCtx.fillText(val.toFixed(0),x,h-margin.bottom+8);}      
      scatterCtx.fillStyle='red';const len=Math.min(lpfAcc.length,speedPoints.length);
      for(let i=0;i<len;i++){const sx=margin.left+(speedPoints[i]/maxScatterSpeed)*gw2;const sy=gh2-(lpfAcc[i]/maxAccel)*gh2;scatterCtx.beginPath();scatterCtx.arc(sx,sy,2,0,2*Math.PI);scatterCtx.fill();}
    }

    function drawEnergy() {
      const w = energyCanvas.clientWidth, h = energyCanvas.clientHeight;
      // legend
      energyCtx.font = '12px sans-serif';
      energyCtx.fillStyle = '#03a9f4'; energyCtx.fillRect(margin.left + 10, 10, 10, 10);
      energyCtx.fillStyle = '#fff'; energyCtx.fillText('Energy1', margin.left + 25, 20);
      energyCtx.fillStyle = '#4caf50'; energyCtx.fillRect(margin.left + 100, 10, 10, 10);
      energyCtx.fillStyle = '#fff'; energyCtx.fillText('Energy2', margin.left + 115, 20);
      energyCtx.clearRect(0, 0, w, h); {
      const w=energyCanvas.clientWidth,h=energyCanvas.clientHeight;
      energyCtx.clearRect(0,0,w,h);
      const maxP=Math.max(...power1,...power2,0.1);
      const axisMax=Math.ceil(maxP);
      drawAxes(energyCtx,w,h,axisMax,5);
      const gw=w-margin.left,gh=h-margin.bottom;
      // power1
      energyCtx.beginPath();energyCtx.strokeStyle='#03a9f4';energyCtx.lineWidth=2;
      power1.forEach((v,i)=>{const x=margin.left+(gw/(maxPoints-1))*i;const y=gh-(v/axisMax)*gh;i===0?energyCtx.moveTo(x,y):energyCtx.lineTo(x,y);} );energyCtx.stroke();
      // power2
      energyCtx.beginPath();energyCtx.strokeStyle='#4caf50';energyCtx.lineWidth=2;
      power2.forEach((v,i)=>{const x=margin.left+(gw/(maxPoints-1))*i;const y=gh-(v/axisMax)*gh;i===0?energyCtx.moveTo(x,y):energyCtx.lineTo(x,y);} );energyCtx.stroke();
    }

    function handleMotion(e) {
      let mag=0;
      if(e.acceleration.x!==null) mag=Math.hypot(e.acceleration.x,e.acceleration.y,e.acceleration.z);
      else{const ax=e.accelerationIncludingGravity.x,ay=e.accelerationIncludingGravity.y,az=e.accelerationIncludingGravity.z-9.80665;mag=Math.hypot(ax,ay,az);}      
      accValueEl.textContent=`Accel: ${mag.toFixed(2)} m/s²`;
      rawAcc.push(mag);if(rawAcc.length>maxPoints)rawAcc.shift();
      const alpha=parseFloat(alphaSlider.value);
      const magFilt=alpha*mag+(1-alpha)*prevMagLPF;prevMagLPF=magFilt;
      lpfAcc.push(magFilt);if(lpfAcc.length>maxPoints)lpfAcc.shift();
      drawAcc();drawScatter();
    }

    function onGeo(pos){
      const{latitude:lat,longitude:lon}=pos.coords;const t=pos.timestamp;const alpha=parseFloat(alphaSlider.value);
      if(prevPos){
        const dLat=(lat-prevPos.lat)*Math.PI/180,dLon=(lon-prevPos.lon)*Math.PI/180;
        const a=Math.sin(dLat/2)**2+Math.cos(prevPos.lat*Math.PI/180)*Math.cos(lat*Math.PI/180)*Math.sin(dLon/2)**2;
        const dist=6371000*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));const dt=(t-prevPos.time)/1000;
        if(dt>0){
          const mps=dist/dt;let kph=mps*3.6;kph=Math.min(kph,150);
          const speedFilt=alpha*kph+(1-alpha)*prevSpeedLPF;prevSpeedLPF=speedFilt;
          speedValueEl.textContent=`Speed: ${speedFilt.toFixed(2)} km/h`;
          speedPoints.push(speedFilt);if(speedPoints.length>maxPoints)speedPoints.shift();
          const query=`[out:json];way(around:50,${lat},${lon})["highway"]["maxspeed"];out tags;`;
          fetch('https://overpass-api.de/api/interpreter',{method:'POST',body:query})
            .then(r=>r.json()).then(data=>{
              let limit=prevLimit;
              if(data.elements&&data.elements.length){const ms=data.elements[0].tags.maxspeed;if(ms)limit=ms.includes('mph')?parseFloat(ms)*1.60934:parseFloat(ms);} prevLimit=limit;
              limitValueEl.textContent=`Limit: ${limit.toFixed(0)} km/h`;
              limitPoints.push(limit);if(limitPoints.length>maxPoints)limitPoints.shift();
              const opt=Math.min(speedFilt,limit);
              optimalValueEl.textContent=`Optimal: ${opt.toFixed(2)} km/h`;
              optimalPoints.push(opt);if(optimalPoints.length>maxPoints)optimalPoints.shift();
              drawSpeed();
                            // energy model
              // use latest filtered acceleration
              const accelValue = lpfAcc[lpfAcc.length - 1] || 0;
              const powerAccel = mass * accelValue * (speedFilt / 3.6) / 1000; // kW
              const powerOpt = mass * accelValue * (opt / 3.6) / 1000; // kW
              power1.push(powerAccel);
              power2.push(powerOpt);
              if (power1.length > maxPoints) power1.shift();
              if (power2.length > maxPoints) power2.shift();
              drawEnergy();
            }).catch(console.error);
          const rawGpsAcc=(mps-prevSpeedMps)/dt;prevSpeedMps=mps;
          const gpsAccFilt=alpha*rawGpsAcc+(1-alpha)*prevGpsAccLPF;prevGpsAccLPF=gpsAccFilt;
          gpsAccPoints.push(gpsAccFilt);if(gpsAccPoints.length>maxPoints)gpsAccPoints.shift();
          drawGpsAcc();drawScatter();
        }
      }else prevSpeedMps=0;
      prevPos={lat,lon,time:t};
    }

    alphaSlider.addEventListener('input',()=>{alphaValueEl.value=alphaSlider.value;});
    function init(){
      if(typeof DeviceMotionEvent.requestPermission==='function'){
        DeviceMotionEvent.requestPermission().then(s=>{if(s==='granted')window.addEventListener('devicemotion',handleMotion);}).catch(console.error);
      }else window.addEventListener('devicemotion',handleMotion);
      if(navigator.geolocation)navigator.geolocation.watchPosition(onGeo,console.error,{enableHighAccuracy:true,maximumAge:1000});
    }
    init();
  </script>
</body>
</html>
