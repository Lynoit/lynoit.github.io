<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion & Speed Visualizer</title>
  <style>
    body { margin: 0; font-family: sans-serif; background: #121212; color: #fff; display: flex; flex-direction: column; align-items: center; }
    #displayRow { width: 90%; max-width: 600px; display: flex; justify-content: space-between; margin: 16px 0; }
    #controls { width: 90%; max-width: 600px; display: flex; align-items: center; gap: 8px; margin-bottom: 24px; }
    #speedValue, #limitValue, #optimalValue, #accValue { font-size: 1.5rem; }
    .graph { border: 1px solid #444; background: #1e1e1e; width: 90%; max-width: 600px; height: 200px; margin-bottom: 24px; }
  </style>
</head>
<body>
  <div id="displayRow">
    <div id="speedValue">Speed: 0.00 km/h</div>
    <div id="limitValue">Limit: N/A</div>
    <div id="optimalValue">Optimal: N/A</div>
    <div id="accValue">Accel: 0.00 m/s²</div>
  </div>
  <div id="controls">
    <label for="alphaSlider">Filter α:</label>
    <input type="range" id="alphaSlider" min="0" max="1" step="0.01" value="0.04">
    <input type="text" id="alphaValue" value="0.04" readonly>
  </div>
  <canvas id="accGraph" class="graph"></canvas>
  <canvas id="speedGraph" class="graph"></canvas>
  <canvas id="gpsAccGraph" class="graph"></canvas>
  <canvas id="scatterGraph" class="graph"></canvas>

  <script>
    // DOM elements
    const speedValueEl = document.getElementById('speedValue');
    const limitValueEl = document.getElementById('limitValue');
    const optimalValueEl = document.getElementById('optimalValue');
    const accValueEl = document.getElementById('accValue');
    const alphaSlider = document.getElementById('alphaSlider');
    const alphaValueEl = document.getElementById('alphaValue');
    const accCanvas = document.getElementById('accGraph');
    const speedCanvas = document.getElementById('speedGraph');
    const gpsAccCanvas = document.getElementById('gpsAccGraph');
    const scatterCanvas = document.getElementById('scatterGraph');
    const accCtx = accCanvas.getContext('2d');
    const speedCtx = speedCanvas.getContext('2d');
    const gpsAccCtx = gpsAccCanvas.getContext('2d');
    const scatterCtx = scatterCanvas.getContext('2d');

    // Settings
    const margin = { left: 50, bottom: 30 };
    const maxAccel = 20;
    const maxScatterSpeed = 100;
    const accTicks = 5;
    const speedTicks = 5;
    const maxPoints = 100;

    // Data buffers
    let rawAcc = [], lpfAcc = [];
    let speedPoints = [], limitPoints = [], optimalPoints = [];
    let gpsAccPoints = [];
    let prevMagLPF = 0, prevSpeedLPF = 0, prevGpsAccLPF = 0;
    let prevLimit = 0, prevSpeedMps = 0;
    let prevPos = null;

    // Resize canvases
    function resizeAll() {
      [accCanvas, speedCanvas, gpsAccCanvas, scatterCanvas].forEach((canvas, i) => {
        const ctx = [accCtx, speedCtx, gpsAccCtx, scatterCtx][i];
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      });
      drawAcc(); drawSpeed(); drawGpsAcc(); drawScatter();
    }
    window.addEventListener('resize', resizeAll);
    resizeAll();

    // Generic axes
    function drawAxes(ctx, w, h, maxValue, ticks) {
      ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(margin.left, 0); ctx.lineTo(margin.left, h - margin.bottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin.left, h - margin.bottom); ctx.lineTo(w, h - margin.bottom); ctx.stroke();
      ctx.fillStyle = '#ccc'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      const graphH = h - margin.bottom;
      for (let i = 0; i <= ticks; i++) {
        const val = (maxValue / ticks) * i;
        const y = graphH - (val / maxValue) * graphH;
        ctx.beginPath(); ctx.moveTo(margin.left - 5, y); ctx.lineTo(margin.left, y); ctx.stroke();
        ctx.fillText(val.toFixed(0), margin.left - 10, y);
      }
    }

    // Acceleration plot
    function drawAcc() {
      const w = accCanvas.clientWidth, h = accCanvas.clientHeight;
      accCtx.clearRect(0, 0, w, h);
      drawAxes(accCtx, w, h, maxAccel, accTicks);
      const gw = w - margin.left, gh = h - margin.bottom;
      accCtx.beginPath(); accCtx.strokeStyle = '#4caf50'; accCtx.lineWidth = 2;
      rawAcc.forEach((v, i) => {
        const x = margin.left + (gw / (maxPoints - 1)) * i;
        const y = gh - (v / maxAccel) * gh;
        i === 0 ? accCtx.moveTo(x, y) : accCtx.lineTo(x, y);
      }); accCtx.stroke();
      accCtx.beginPath(); accCtx.strokeStyle = '#ff9800'; accCtx.lineWidth = 2;
      lpfAcc.forEach((v, i) => {
        const x = margin.left + (gw / (maxPoints - 1)) * i;
        const y = gh - (v / maxAccel) * gh;
        i === 0 ? accCtx.moveTo(x, y) : accCtx.lineTo(x, y);
      }); accCtx.stroke();
    }

    // Speed & limit & optimal plot
    function drawSpeed() {
      const w = speedCanvas.clientWidth, h = speedCanvas.clientHeight;
      speedCtx.clearRect(0, 0, w, h);
      const maxVal = Math.max(...speedPoints, ...limitPoints, ...optimalPoints, 10);
      const axisMax = Math.min(Math.ceil(maxVal / 10) * 10, 150);
      drawAxes(speedCtx, w, h, axisMax, speedTicks);
      const gw = w - margin.left, gh = h - margin.bottom;
      // GPS speed
      speedCtx.beginPath(); speedCtx.strokeStyle = '#03a9f4'; speedCtx.lineWidth = 2;
      speedPoints.forEach((v, i) => {
        const x = margin.left + (gw / (maxPoints - 1)) * i;
        const y = gh - (v / axisMax) * gh;
        i === 0 ? speedCtx.moveTo(x, y) : speedCtx.lineTo(x, y);
      }); speedCtx.stroke();
      // Speed limit
      speedCtx.beginPath(); speedCtx.setLineDash([5, 5]); speedCtx.strokeStyle = '#ffff00'; speedCtx.lineWidth = 2;
      limitPoints.forEach((v, i) => {
        const x = margin.left + (gw / (maxPoints - 1)) * i;
        const y = gh - (v / axisMax) * gh;
        i === 0 ? speedCtx.moveTo(x, y) : speedCtx.lineTo(x, y);
      }); speedCtx.stroke(); speedCtx.setLineDash([]);
      // Optimal speed
      speedCtx.beginPath(); speedCtx.strokeStyle = '#4caf50'; speedCtx.lineWidth = 2;
      optimalPoints.forEach((v, i) => {
        const x = margin.left + (gw / (maxPoints - 1)) * i;
        const y = gh - (v / axisMax) * gh;
        i === 0 ? speedCtx.moveTo(x, y) : speedCtx.lineTo(x, y);
      }); speedCtx.stroke();
    }

    // GPS acceleration plot (signed)
    function drawGpsAcc() {
      const w = gpsAccCanvas.clientWidth, h = gpsAccCanvas.clientHeight;
      gpsAccCtx.clearRect(0, 0, w, h);
      const axisMax = 5;
      const graphH = h - margin.bottom, graphW = w - margin.left;
      gpsAccCtx.strokeStyle = '#888'; gpsAccCtx.lineWidth = 1;
      gpsAccCtx.beginPath(); gpsAccCtx.moveTo(margin.left, 0); gpsAccCtx.lineTo(margin.left, graphH); gpsAccCtx.stroke();
      const zeroY = graphH / 2;
      gpsAccCtx.beginPath(); gpsAccCtx.moveTo(margin.left, zeroY); gpsAccCtx.lineTo(w, zeroY); gpsAccCtx.stroke();
      gpsAccCtx.fillStyle = '#ccc'; gpsAccCtx.textAlign = 'right'; gpsAccCtx.textBaseline = 'middle';
      for (let i = -accTicks; i <= accTicks; i++) {
        const val = axisMax * (i / accTicks);
        const y = zeroY - (val / axisMax) * (graphH / 2);
        gpsAccCtx.beginPath(); gpsAccCtx.moveTo(margin.left - 5, y); gpsAccCtx.lineTo(margin.left, y); gpsAccCtx.stroke();
        gpsAccCtx.fillText(val.toFixed(1), margin.left - 10, y);
      }
      gpsAccCtx.beginPath(); gpsAccCtx.strokeStyle = '#e91e63'; gpsAccCtx.lineWidth = 2;
      gpsAccPoints.forEach((v, i) => {
        const x = margin.left + (graphW / (maxPoints - 1)) * i;
        const y = zeroY - (v / axisMax) * (graphH / 2);
        i === 0 ? gpsAccCtx.moveTo(x, y) : gpsAccCtx.lineTo(x, y);
      }); gpsAccCtx.stroke();
    }

    // Scatter plot accel vs speed
    function drawScatter() {
      const w = scatterCanvas.clientWidth, h = scatterCanvas.clientHeight;
      scatterCtx.clearRect(0, 0, w, h);
      scatterCtx.strokeStyle = '#888'; scatterCtx.lineWidth = 1;
      scatterCtx.beginPath(); scatterCtx.moveTo(margin.left, 0); scatterCtx.lineTo(margin.left, h - margin.bottom); scatterCtx.stroke();
      scatterCtx.beginPath(); scatterCtx.moveTo(margin.left, h - margin.bottom); scatterCtx.lineTo(w, h - margin.bottom); scatterCtx.stroke();
      scatterCtx.fillStyle = '#ccc'; scatterCtx.textAlign = 'right'; scatterCtx.textBaseline = 'middle';
      const gh = h - margin.bottom, gw = w - margin.left;
      for (let i = 0; i <= accTicks; i++) {
        const val = (maxAccel / accTicks) * i;
        const y = gh - (val / maxAccel) * gh;
        scatterCtx.beginPath(); scatterCtx.moveTo(margin.left - 5, y); scatterCtx.lineTo(margin.left, y); scatterCtx.stroke();
        scatterCtx.fillText(val.toFixed(0), margin.left - 10, y);
      }
      scatterCtx.textAlign = 'center'; scatterCtx.textBaseline = 'top';
      for (let i = 0; i <= speedTicks; i++) {
        const val = (maxScatterSpeed / speedTicks) * i;
        const x = margin.left + (gw / speedTicks) * i;
        scatterCtx.beginPath(); scatterCtx.moveTo(x, h - margin.bottom); scatterCtx.lineTo(x, h - margin.bottom + 5); scatterCtx.stroke();
        scatterCtx.fillText(val.toFixed(0), x, h - margin.bottom + 8);
      }
      scatterCtx.fillStyle = 'red';
      const len = Math.min(lpfAcc.length, speedPoints.length);
      for (let i = 0; i < len; i++) {
        const sx = margin.left + (speedPoints[i] / maxScatterSpeed) * gw;
        const sy = gh - (lpfAcc[i] / maxAccel) * gh;
        scatterCtx.beginPath(); scatterCtx.arc(sx, sy, 2, 0, 2 * Math.PI); scatterCtx.fill();
      }
    }

    // Device motion
    function handleMotion(e) {
      let mag = 0;
      if (e.acceleration.x !== null) {
        mag = Math.hypot(e.acceleration.x, e.acceleration.y, e.acceleration.z);
      } else {
        const ax = e.accelerationIncludingGravity.x;
        const ay = e.accelerationIncludingGravity.y;
        const az = e.accelerationIncludingGravity.z - 9.80665;
        mag = Math.hypot(ax, ay, az);
      }
      accValueEl.textContent = `Accel: ${mag.toFixed(2)} m/s²`;
      rawAcc.push(mag); if (rawAcc.length > maxPoints) rawAcc.shift();
      const alpha = parseFloat(alphaSlider.value);
      const magFilt = alpha * mag + (1 - alpha) * prevMagLPF; prevMagLPF = magFilt;
      lpfAcc.push(magFilt); if (lpfAcc.length > maxPoints) lpfAcc.shift();
      drawAcc(); drawScatter();
    }

    // Geolocation
    function onGeo(pos) {
      const { latitude: lat, longitude: lon } = pos.coords;
      const t = pos.timestamp;
      const alpha = parseFloat(alphaSlider.value);
      if (prevPos) {
        const dLat = (lat - prevPos.lat) * Math.PI / 180;
        const dLon = (lon - prevPos.lon) * Math.PI / 180;
        const a = Math.sin(dLat/2)**2 + Math.cos(prevPos.lat*Math.PI/180) * Math.cos(lat*Math.PI/180) * Math.sin(dLon/2)**2;
        const dist = 6371000 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const dt = (t - prevPos.time) / 1000;
        if (dt > 0) {
          // speed
          const mps = dist / dt;
          let kph = mps * 3.6; kph = Math.min(kph, 150);
          const speedFilt = alpha * kph + (1 - alpha) * prevSpeedLPF; prevSpeedLPF = speedFilt;
          speedValueEl.textContent = `Speed: ${speedFilt.toFixed(2)} km/h`;
          speedPoints.push(speedFilt); if (speedPoints.length > maxPoints) speedPoints.shift();
          // fetch limit
          const query = `[out:json];way(around:50,${lat},${lon})["highway"]["maxspeed"];out tags;`;
          fetch('https://overpass-api.de/api/interpreter', { method: 'POST', body: query })
            .then(r => r.json())
            .then(data => {
              let limit = prevLimit;
              if (data.elements && data.elements.length) {
                const ms = data.elements[0].tags.maxspeed;
                if (ms) limit = ms.includes('mph') ? parseFloat(ms)*1.60934 : parseFloat(ms);
              }
              prevLimit = limit;
              limitValueEl.textContent = `Limit: ${limit.toFixed(0)} km/h`;
              limitPoints.push(limit); if (limitPoints.length > maxPoints) limitPoints.shift();
              // optimal
              const opt = Math.min(speedFilt, limit);
              optimalValueEl.textContent = `Optimal: ${opt.toFixed(2)} km/h`;
              optimalPoints.push(opt); if (optimalPoints.length > maxPoints) optimalPoints.shift();
              drawSpeed();
            }).catch(console.error);
          // GPS accel
          const rawGpsAcc = (mps - prevSpeedMps) / dt; prevSpeedMps = mps;
          const gpsAccFilt = alpha * rawGpsAcc + (1 - alpha) * prevGpsAccLPF; prevGpsAccLPF = gpsAccFilt;
          gpsAccPoints.push(gpsAccFilt); if (gpsAccPoints.length > maxPoints) gpsAccPoints.shift();
          drawGpsAcc(); drawScatter();
        }
      } else {
        prevSpeedMps = 0;
      }
      prevPos = { lat, lon, time: t };
    }

    // Slider
    alphaSlider.addEventListener('input', () => { alphaValueEl.value = alphaSlider.value; });

    // Init
    function init() {
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(s => { if (s === 'granted') window.addEventListener('devicemotion', handleMotion); }).catch(console.error);
      } else window.addEventListener('devicemotion', handleMotion);
      if (navigator.geolocation) navigator.geolocation.watchPosition(onGeo, console.error, { enableHighAccuracy: true, maximumAge: 1000 });
    }
    init();
  </script>
</body>
</html>
