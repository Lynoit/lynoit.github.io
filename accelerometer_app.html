<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion & Speed Visualizer</title>
  <style>
    /* Dark mode styling */
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background-color: #121212;
      color: #ffffff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
    }
    #displayRow {
      width: 90%;
      max-width: 600px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 16px 0 8px;
    }
    #controls {
      width: 90%;
      max-width: 600px;
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 24px;
    }
    #speedValue, #accValue {
      font-size: 1.5rem;
    }
    #alphaLabel {
      font-size: 1.2rem;
    }
    #alphaValue {
      font-size: 1.2rem;
      width: 50px;
      text-align: right;
    }
    .graph {
      border: 1px solid #444;
      background-color: #1e1e1e;
      width: 90%;
      max-width: 600px;
      height: 200px;
      margin-bottom: 24px;
    }
  </style>
</head>
<body>
  <!-- Numeric displays row -->
  <div id="displayRow">
    <div id="speedValue">Speed: 0.00 km/h</div>
    <div id="accValue">Accel: 0.00 m/s²</div>
  </div>
  <!-- Slider controls row -->
  <div id="controls">
    <label id="alphaLabel" for="alphaSlider">Filter α:</label>
    <input type="range" id="alphaSlider" min="0" max="1" step="0.01" value="0.1">
    <input type="text" id="alphaValue" value="0.10" readonly>
  </div>
  <!-- Graphs -->
  <canvas id="accGraph" class="graph"></canvas>
  <canvas id="speedGraph" class="graph"></canvas>

  <script>
    const speedValueEl = document.getElementById('speedValue');
    const accValueEl = document.getElementById('accValue');
    const alphaSlider = document.getElementById('alphaSlider');
    const alphaValueEl = document.getElementById('alphaValue');
    const accCanvas = document.getElementById('accGraph');
    const speedCanvas = document.getElementById('speedGraph');
    const accCtx = accCanvas.getContext('2d');
    const speedCtx = speedCanvas.getContext('2d');

    const margin = { left: 50, bottom: 30 };
    const maxAccel = 20;
    const accTicks = 5;
    const speedTicks = 5;
    const maxPoints = 100;

    let rawAcc = [], lpfAcc = [], prevMagLPF = 0;
    let speedPoints = [], prevSpeedLPF = 0;
    let gravity = { x: 0, y: 0, z: 0 };
    let prevPos = null;

    function resizeAll() {
      [accCanvas, speedCanvas].forEach((canvas, i) => {
        const ctx = i === 0 ? accCtx : speedCtx;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.scale(dpr, dpr);
      });
      drawAcc(); drawSpeed();
    }
    window.addEventListener('resize', resizeAll);
    resizeAll();

    function drawAxes(ctx, width, height, maxValue, ticks) {
      ctx.beginPath(); ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
      ctx.moveTo(margin.left, 0); ctx.lineTo(margin.left, height - margin.bottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin.left, height - margin.bottom); ctx.lineTo(width, height - margin.bottom); ctx.stroke();
      ctx.fillStyle = '#ccc'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      const graphH = height - margin.bottom;
      for (let i = 0; i <= ticks; i++) {
        const val = (maxValue / ticks) * i;
        const y = graphH - (val / maxValue) * graphH;
        ctx.beginPath(); ctx.moveTo(margin.left - 5, y); ctx.lineTo(margin.left, y); ctx.stroke();
        ctx.fillText(val.toFixed(0), margin.left - 10, y);
      }
    }

    function drawAcc() {
      const w = accCanvas.clientWidth, h = accCanvas.clientHeight;
      accCtx.clearRect(0, 0, w, h);
      drawAxes(accCtx, w, h, maxAccel, accTicks);
      const graphW = w - margin.left, graphH = h - margin.bottom;
      accCtx.beginPath(); accCtx.strokeStyle = '#4caf50'; accCtx.lineWidth = 2;
      rawAcc.forEach((v, i) => {
        const x = margin.left + (graphW / (maxPoints - 1)) * i;
        const y = graphH - (v / maxAccel) * graphH;
        i === 0 ? accCtx.moveTo(x, y) : accCtx.lineTo(x, y);
      }); accCtx.stroke();
      accCtx.beginPath(); accCtx.strokeStyle = '#ff9800'; accCtx.lineWidth = 2;
      lpfAcc.forEach((v, i) => {
        const x = margin.left + (graphW / (maxPoints - 1)) * i;
        const y = graphH - (v / maxAccel) * graphH;
        i === 0 ? accCtx.moveTo(x, y) : accCtx.lineTo(x, y);
      }); accCtx.stroke();
    }

    function drawSpeed() {
      const w = speedCanvas.clientWidth, h = speedCanvas.clientHeight;
      speedCtx.clearRect(0, 0, w, h);
      const maxVal = Math.max(...speedPoints, 10);
      const axisMax = Math.ceil(maxVal / 10) * 10;
      drawAxes(speedCtx, w, h, axisMax, speedTicks);
      const graphW = w - margin.left, graphH = h - margin.bottom;
      speedCtx.beginPath(); speedCtx.strokeStyle = '#03a9f4'; speedCtx.lineWidth = 2;
      speedPoints.forEach((v, i) => {
        const x = margin.left + (graphW / (maxPoints - 1)) * i;
        const y = graphH - (v / axisMax) * graphH;
        i === 0 ? speedCtx.moveTo(x, y) : speedCtx.lineTo(x, y);
      }); speedCtx.stroke();
    }

    function handleMotion(e) {
      let ax = e.acceleration.x;
      let ay = e.acceleration.y;
      let az = e.acceleration.z;
      let magnitude;
      // Use acceleration excluding gravity if available
      if (ax !== null && ay !== null && az !== null) {
        magnitude = Math.sqrt(ax * ax + ay * ay + az * az);
      } else {
        // Estimate gravity with low-pass on accelerationIncludingGravity
        const aX = e.accelerationIncludingGravity.x;
        const aY = e.accelerationIncludingGravity.y;
        const aZ = e.accelerationIncludingGravity.z;
        // Gravity estimation using complementary filter
        const alphaG = 0.9; // gravity filter constant
        gravity.x = alphaG * gravity.x + (1 - alphaG) * aX;
        gravity.y = alphaG * gravity.y + (1 - alphaG) * aY;
        gravity.z = alphaG * gravity.z + (1 - alphaG) * aZ;
        // Remove gravity component
        const linX = aX - gravity.x;
        const linY = aY - gravity.y;
        const linZ = aZ - gravity.z;
        magnitude = Math.sqrt(linX * linX + linY * linY + linZ * linZ);
      }
      // Display and smooth magnitude
      accValueEl.textContent = `Accel: ${magnitude.toFixed(2)} m/s²`;
      rawAcc.push(magnitude);
      if (rawAcc.length > maxPoints) rawAcc.shift();
      const alpha = parseFloat(alphaSlider.value);
      const magFilt = alpha * magnitude + (1 - alpha) * prevMagLPF;
      prevMagLPF = magFilt;
      lpfAcc.push(magFilt);
      if (lpfAcc.length > maxPoints) lpfAcc.shift();
      drawAcc();
    }

    function onGeo(pos) {
      const { latitude: lat, longitude: lon } = pos.coords;
      const timestamp = pos.timestamp;
      if (prevPos) {
        const dLat = (lat - prevPos.lat) * Math.PI / 180;
        const dLon = (lon - prevPos.lon) * Math.PI / 180;
        const a = Math.sin(dLat / 2) ** 2 + Math.cos(prevPos.lat * Math.PI / 180) * Math.cos(lat * Math.PI / 180) * Math.sin(dLon / 2) ** 2;
        const dist = 6371000 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const dt = (timestamp - prevPos.time) / 1000;
        const speedMps = dt > 0 ? dist / dt : 0;
        const speedKph = speedMps * 3.6;
        const speedFilt = alpha * speedKph + (1 - alpha) * prevSpeedLPF;
        prevSpeedLPF = speedFilt;
        speedValueEl.textContent = `Speed: ${speedFilt.toFixed(2)} km/h`;
        speedPoints.push(speedFilt);
        if (speedPoints.length > maxPoints) speedPoints.shift();
        drawSpeed();
      }
      prevPos = { lat, lon, time: timestamp };
    }

    // Update alpha display
    alphaSlider.addEventListener('input', () => {
      alphaValueEl.value = parseFloat(alphaSlider.value).toFixed(2);
    });

    function init() {
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(state => {
          if (state === 'granted') window.addEventListener('devicemotion', handleMotion);
        }).catch(console.error);
      } else {
        window.addEventListener('devicemotion', handleMotion);
      }
      if (navigator.geolocation) {
        navigator.geolocation.watchPosition(onGeo, console.error, { enableHighAccuracy: true, maximumAge: 1000 });
      }
    }
    init();
  </script>
</body>
</html>
