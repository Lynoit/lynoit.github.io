<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion & Speed Visualizer</title>
  <style>
    /* Dark mode styling */
    body { margin: 0; padding: 0; font-family: sans-serif; background: #121212; color: #fff; display: flex; flex-direction: column; align-items: center; }
    #displayRow { width: 90%; max-width: 600px; display: flex; justify-content: space-between; margin: 16px 0; }
    #controls { width: 90%; max-width: 600px; display: flex; align-items: center; gap: 8px; margin-bottom: 24px; }
    #speedValue, #accValue { font-size: 1.5rem; }
    .graph { border: 1px solid #444; background: #1e1e1e; width: 90%; max-width: 600px; height: 200px; margin-bottom: 24px; }
  </style>
</head>
<body>
  <div id="displayRow">
    <div id="speedValue">Speed: 0.00 km/h</div>
    <div id="accValue">Accel: 0.00 m/s²</div>
  </div>
  <div id="controls">
    <label for="alphaSlider">Filter α:</label>
    <input type="range" id="alphaSlider" min="0" max="1" step="0.01" value="0.1">
    <input type="text" id="alphaValue" value="0.10" readonly>
  </div>
  <canvas id="accGraph" class="graph"></canvas>
  <canvas id="speedGraph" class="graph"></canvas>

  <script>
    // Elements
    const speedValueEl = document.getElementById('speedValue');
    const accValueEl = document.getElementById('accValue');
    const alphaSlider = document.getElementById('alphaSlider');
    const alphaValueEl = document.getElementById('alphaValue');
    const accCanvas = document.getElementById('accGraph');
    const speedCanvas = document.getElementById('speedGraph');
    const accCtx = accCanvas.getContext('2d');
    const speedCtx = speedCanvas.getContext('2d');

    // Settings
    const margin = { left: 50, bottom: 30 };
    const maxAccel = 20;
    const maxPoints = 100;
    const speedTicks = 5;

    // Data buffers
    let rawAcc = [], lpfAcc = [], prevMagLPF = 0;
    let speedPoints = [], prevSpeedLPF = 0;
    let prevPos = null;

    // Resize and redraw
    function resizeAll() {
      [accCanvas, speedCanvas].forEach((canvas, idx) => {
        const ctx = idx === 0 ? accCtx : speedCtx;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.clientWidth * dpr;
        canvas.height = canvas.clientHeight * dpr;
        ctx.scale(dpr, dpr);
      });
      drawAcc();
      drawSpeed();
    }
    window.addEventListener('resize', resizeAll);
    resizeAll();

    // Draw axes
    function drawAxes(ctx, w, h, maxValue, ticks) {
      ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
      // Y axis
      ctx.beginPath(); ctx.moveTo(margin.left, 0); ctx.lineTo(margin.left, h - margin.bottom); ctx.stroke();
      // X axis
      ctx.beginPath(); ctx.moveTo(margin.left, h - margin.bottom); ctx.lineTo(w, h - margin.bottom); ctx.stroke();
      // Ticks
      ctx.fillStyle = '#ccc'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      const graphH = h - margin.bottom;
      for (let i = 0; i <= ticks; i++) {
        const val = (maxValue / ticks) * i;
        const y = graphH - (val / maxValue) * graphH;
        ctx.beginPath(); ctx.moveTo(margin.left - 5, y); ctx.lineTo(margin.left, y); ctx.stroke();
        ctx.fillText(val.toFixed(0), margin.left - 10, y);
      }
    }

    // Draw acceleration graph
    function drawAcc() {
      const w = accCanvas.clientWidth, h = accCanvas.clientHeight;
      accCtx.clearRect(0, 0, w, h);
      drawAxes(accCtx, w, h, maxAccel, 5);
      const graphW = w - margin.left, graphH = h - margin.bottom;
      // Raw
      accCtx.beginPath(); accCtx.strokeStyle = '#4caf50'; accCtx.lineWidth = 2;
      rawAcc.forEach((v, i) => {
        const x = margin.left + (graphW / (maxPoints - 1)) * i;
        const y = graphH - (v / maxAccel) * graphH;
        i === 0 ? accCtx.moveTo(x, y) : accCtx.lineTo(x, y);
      }); accCtx.stroke();
      // LPF
      accCtx.beginPath(); accCtx.strokeStyle = '#ff9800'; accCtx.lineWidth = 2;
      lpfAcc.forEach((v, i) => {
        const x = margin.left + (graphW / (maxPoints - 1)) * i;
        const y = graphH - (v / maxAccel) * graphH;
        i === 0 ? accCtx.moveTo(x, y) : accCtx.lineTo(x, y);
      }); accCtx.stroke();
    }

    // Draw speed graph
    function drawSpeed() {
      const w = speedCanvas.clientWidth, h = speedCanvas.clientHeight;
      speedCtx.clearRect(0, 0, w, h);
      const maxVal = Math.max(...speedPoints, 10);
      const axisMax = Math.ceil(maxVal / 10) * 10;
      drawAxes(speedCtx, w, h, axisMax, speedTicks);
      const graphW = w - margin.left, graphH = h - margin.bottom;
      speedCtx.beginPath(); speedCtx.strokeStyle = '#03a9f4'; speedCtx.lineWidth = 2;
      speedPoints.forEach((v, i) => {
        const x = margin.left + (graphW / (maxPoints - 1)) * i;
        const y = graphH - (v / axisMax) * graphH;
        i === 0 ? speedCtx.moveTo(x, y) : speedCtx.lineTo(x, y);
      }); speedCtx.stroke();
    }

    // Handle accelerometer
    function handleMotion(e) {
      let magnitude = 0;
      if (e.acceleration.x !== null) {
        magnitude = Math.hypot(e.acceleration.x, e.acceleration.y, e.acceleration.z);
      } else {
        // Fallback: approximate via includingGravity minus g
        const gx = e.accelerationIncludingGravity.x;
        const gy = e.accelerationIncludingGravity.y;
        const gz = e.accelerationIncludingGravity.z - 9.80665;
        magnitude = Math.hypot(gx, gy, gz);
      }
      accValueEl.textContent = `Accel: ${magnitude.toFixed(2)} m/s²`;
      rawAcc.push(magnitude); if (rawAcc.length > maxPoints) rawAcc.shift();
      const alpha = parseFloat(alphaSlider.value);
      const magFilt = alpha * magnitude + (1 - alpha) * prevMagLPF;
      prevMagLPF = magFilt;
      lpfAcc.push(magFilt); if (lpfAcc.length > maxPoints) lpfAcc.shift();
      drawAcc();
    }

    // Handle geolocation
    function onGeo(pos) {
      const { latitude: lat, longitude: lon } = pos.coords;
      const t = pos.timestamp;
      const alpha = parseFloat(alphaSlider.value);
      if (prevPos) {
        const dLat = (lat - prevPos.lat) * Math.PI/180;
        const dLon = (lon - prevPos.lon) * Math.PI/180;
        const a = Math.sin(dLat/2)**2 + Math.cos(prevPos.lat*Math.PI/180)*Math.cos(lat*Math.PI/180)*Math.sin(dLon/2)**2;
        const dist = 6371000 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const dt = (t - prevPos.time)/1000;
        const mps = dt > 0 ? dist/dt : 0;
        const kph = mps * 3.6;
        const speedFilt = alpha * kph + (1 - alpha) * prevSpeedLPF;
        prevSpeedLPF = speedFilt;
        speedValueEl.textContent = `Speed: ${speedFilt.toFixed(2)} km/h`;
        speedPoints.push(speedFilt); if (speedPoints.length > maxPoints) speedPoints.shift();
        drawSpeed();
      }
      prevPos = { lat, lon, time: t };
    }

    // Slider update
    alphaSlider.addEventListener('input', () => {
      alphaValueEl.value = parseFloat(alphaSlider.value).toFixed(2);
    });

    // Init
    function init() {
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(s => { if (s === 'granted') window.addEventListener('devicemotion', handleMotion); }).catch(console.error);
      } else window.addEventListener('devicemotion', handleMotion);
      if (navigator.geolocation) navigator.geolocation.watchPosition(onGeo, console.error, { enableHighAccuracy: true, maximumAge: 1000 });
    }
    init();
  </script>
</body>
</html>
