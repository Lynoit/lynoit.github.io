<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Motion, Speed & Energy Visualizer</title>
  <style>
    body { margin:0; font-family:sans-serif; background:#121212; color:#fff; display:flex; flex-direction:column; align-items:center; }
    #displayRow { width:90%; max-width:600px; display:flex; justify-content:space-between; margin:16px 0; }
    #controls { width:90%; max-width:600px; display:flex; align-items:center; gap:8px; margin-bottom:24px; }
    #speedValue, #limitValue, #optimalValue, #accValue { font-size:1.5rem; }
    .graph { border:1px solid #444; background:#1e1e1e; width:90%; max-width:600px; height:200px; margin-bottom:24px; }
  </style>
</head>
<body>
  <div id="displayRow">
    <div id="speedValue">Speed: 0.00 km/h</div>
    <div id="limitValue">Limit: N/A</div>
    <div id="optimalValue">Optimal: N/A</div>
    <div id="accValue">Accel: 0.00 m/s²</div>
  </div>
  <div id="controls">
    <label for="alphaSlider">Filter α:</label>
    <input type="range" id="alphaSlider" min="0" max="1" step="0.01" value="0.04">
    <input type="text" id="alphaValue" value="0.04" readonly>
  </div>
  <canvas id="accGraph" class="graph"></canvas>
  <canvas id="speedGraph" class="graph"></canvas>
  <canvas id="gpsAccGraph" class="graph"></canvas>
  <canvas id="scatterGraph" class="graph"></canvas>
  <canvas id="energyGraph" class="graph"></canvas>
  <!-- Sixth plot: ratio of actual vs optimal power -->
  <canvas id="ratioGraph" class="graph"></canvas>

  <script>
    const mass = 1500;
    const speedValueEl = document.getElementById('speedValue');
    const limitValueEl = document.getElementById('limitValue');
    const optimalValueEl = document.getElementById('optimalValue');
    const accValueEl = document.getElementById('accValue');
    const alphaSlider = document.getElementById('alphaSlider');
    const alphaValueEl = document.getElementById('alphaValue');
    const accCanvas = document.getElementById('accGraph');
    const speedCanvas = document.getElementById('speedGraph');
    const gpsAccCanvas = document.getElementById('gpsAccGraph');
    const scatterCanvas = document.getElementById('scatterGraph');
    const energyCanvas = document.getElementById('energyGraph');
    const ratioCanvas = document.getElementById('ratioGraph');
    const accCtx = accCanvas.getContext('2d');
    const speedCtx = speedCanvas.getContext('2d');
    const gpsAccCtx = gpsAccCanvas.getContext('2d');
    const scatterCtx = scatterCanvas.getContext('2d');
    const energyCtx = energyCanvas.getContext('2d');
    const ratioCtx = ratioCanvas.getContext('2d');

    const margin = { left: 50, bottom: 30 };
    const maxAccel = 20;
    const maxScatterSpeed = 100;
    const accTicks = 5;
    const speedTicks = 5;
    const maxPoints = 100;

    let rawAcc = [], lpfAcc = [];
    let speedPoints = [], limitPoints = [], optimalPoints = [];
    let gpsAccPoints = [];
    let power1 = [], power2 = [];
    let ratioPoints = [];
    let prevMagLPF = 0, prevSpeedLPF = 0, prevGpsAccLPF = 0;
    let prevLimit = 0, prevSpeedMps = 0;
    let prevPos = null;

    function resizeAll() {
      const canvases = [accCanvas, speedCanvas, gpsAccCanvas, scatterCanvas, energyCanvas, ratioCanvas];
      const ctxs = [accCtx, speedCtx, gpsAccCtx, scatterCtx, energyCtx, ratioCtx];
      canvases.forEach((c, i) => {
        const ctx = ctxs[i];
        const dpr = window.devicePixelRatio || 1;
        c.width = c.clientWidth * dpr;
        c.height = c.clientHeight * dpr;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      });
      drawAcc(); drawSpeed(); drawGpsAcc(); drawScatter(); drawEnergy(); drawRatio();
    }
    window.addEventListener('resize', resizeAll);
    resizeAll();

    function drawAxes(ctx, w, h, minV, maxV, ticks) {
      ctx.strokeStyle = '#888'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(margin.left, 0); ctx.lineTo(margin.left, h - margin.bottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(margin.left, h - margin.bottom); ctx.lineTo(w, h - margin.bottom); ctx.stroke();
      ctx.fillStyle = '#ccc'; ctx.textAlign = 'right'; ctx.textBaseline = 'middle';
      const gh = h - margin.bottom;
      for (let i = 0; i <= ticks; i++) {
        const val = minV + (maxV - minV) / ticks * i;
        const y = gh - ((val - minV) / (maxV - minV)) * gh;
        ctx.beginPath(); ctx.moveTo(margin.left - 5, y); ctx.lineTo(margin.left, y); ctx.stroke();
        ctx.fillText(val.toFixed(1), margin.left - 10, y);
      }
    }

    function drawRatio() {
      const w = ratioCanvas.clientWidth;
      const h = ratioCanvas.clientHeight;
      ratioCtx.clearRect(0, 0, w, h);
      // Legend
      ratioCtx.font = '12px sans-serif';
      ratioCtx.fillStyle = '#4caf50'; ratioCtx.fillRect(60, 10, 10, 10);
      ratioCtx.fillStyle = '#fff'; ratioCtx.fillText('P₁/P₂ Ratio', 75, 20);

      // Axes
      const xMin = 0, xMax = 150;
      const yMin = -3, yMax = 3;
      drawAxes(ratioCtx, w, h, yMin, yMax, accTicks);
      // x-axis ticks
      ratioCtx.textAlign = 'center'; ratioCtx.textBaseline = 'top';
      const graphH = h - margin.bottom;
      const graphW = w - margin.left;
      for (let i = 0; i <= speedTicks; i++) {
        const val = xMin + (xMax - xMin) / speedTicks * i;
        const x = margin.left + graphW / speedTicks * i;
        ratioCtx.beginPath(); ratioCtx.moveTo(x, graphH); ratioCtx.lineTo(x, graphH + 5); ratioCtx.stroke();
        ratioCtx.fillText(val.toFixed(0), x, graphH + 8);
      }

      // draw dots
      const now = Date.now();
      ratioPoints = ratioPoints.filter(p => now - p.t <= 30000);
      ratioPoints.forEach(p => {
        const sx = margin.left + (p.speed / xMax) * graphW;
        const sy = graphH - ((p.acc - yMin) / (yMax - yMin)) * graphH;
        // color gradient
        let color;
        if (p.ratio <= 1) color = 'rgb(0,255,0)';
        else if (p.ratio >= 1.5) color = 'rgb(255,0,0)';
        else if (p.ratio <= 1.25) {
          const t = (p.ratio - 1) / 0.25;
          const r = Math.round(t * 255);
          const g = 255;
          const b = 0;
          color = `rgb(${r},${g},${b})`;
        } else {
          const t = (p.ratio - 1.25) / 0.25;
          const r = 255;
          const g = Math.round((1 - t) * 255);
          const b = 0;
          color = `rgb(${r},${g},${b})`;
        }
        ratioCtx.fillStyle = color;
        ratioCtx.beginPath(); ratioCtx.arc(sx, sy, 3, 0, 2 * Math.PI); ratioCtx.fill();
      });
    }

    function handleMotion(e) {
      let mag = 0;
      if (e.acceleration.x !== null) {
        mag = Math.hypot(e.acceleration.x, e.acceleration.y, e.acceleration.z);
      } else {
        const ax = e.accelerationIncludingGravity.x;
        const ay = e.accelerationIncludingGravity.y;
        const az = e.accelerationIncludingGravity.z - 9.80665;
        mag = Math.hypot(ax, ay, az);
      }
      accValueEl.textContent = `Accel: ${mag.toFixed(2)} m/s²`;
      rawAcc.push(mag); if (rawAcc.length > maxPoints) rawAcc.shift();
      const alpha = parseFloat(alphaSlider.value);
      const magFilt = alpha * mag + (1 - alpha) * prevMagLPF; prevMagLPF = magFilt;
      lpfAcc.push(magFilt); if (lpfAcc.length > maxPoints) lpfAcc.shift();
      drawAcc(); drawScatter(); drawRatio();
    }

    function onGeo(pos) {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      const t = pos.timestamp;
      const alpha = parseFloat(alphaSlider.value);
      if (prevPos) {
        const dLat = (lat - prevPos.lat) * Math.PI / 180;
        const dLon = (lon - prevPos.lon) * Math.PI / 180;
        const a = Math.sin(dLat/2)**2 + Math.cos(prevPos.lat*Math.PI/180)*Math.cos(lat*Math.PI/180)*Math.sin(dLon/2)**2;
        const dist = 6371000 * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const dt = (t - prevPos.time)/1000;
        if (dt > 0) {
          const mps = dist/dt;
          let kph = Math.min(mps*3.6, 150);
          const speedFilt = alpha*kph + (1-alpha)*prevSpeedLPF; prevSpeedLPF = speedFilt;
          speedValueEl.textContent = `Speed: ${speedFilt.toFixed(2)} km/h`;
          const limitSync = prevLimit;
          limitValueEl.textContent = `Limit: ${limitSync.toFixed(0)} km/h`;
          limitPoints.push(limitSync); if(limitPoints.length>maxPoints) limitPoints.shift();
          const optSync = Math.max(Math.min(speedFilt, limitSync)-5,0);
          optimalValueEl.textContent = `Optimal: ${optSync.toFixed(2)} km/h`;
          optimalPoints.push(optSync); if(optimalPoints.length>maxPoints) optimalPoints.shift();
          drawSpeed();

          fetch('https://overpass-api.de/api/interpreter', {
            method:'POST', body:`[out:json];way(around:50,${lat},${lon})[\"highway\"][\"maxspeed\"];out tags;`
          }).then(r=>r.json()).then(data=>{
            if(data.elements?.length){
              const ms = data.elements[0].tags.maxspeed;
              if(ms) prevLimit = ms.includes('mph')?parseFloat(ms)*1.60934:parseFloat(ms);
            }
            limitValueEl.textContent = `Limit: ${prevLimit.toFixed(0)} km/h`;
          }).catch(console.error);

          const rawGpsAcc = (mps - prevSpeedMps)/dt; prevSpeedMps = mps;
          const gpsAccFilt = alpha*rawGpsAcc + (1-alpha)*prevGpsAccLPF; prevGpsAccLPF = gpsAccFilt;
          gpsAccPoints.push(gpsAccFilt); if(gpsAccPoints.length>maxPoints) gpsAccPoints.shift();
          drawGpsAcc(); drawScatter(); drawRatio();

          // energy and ratio
          const accelValue = lpfAcc[lpfAcc.length-1]||0;
          const p1 = mass*accelValue*(speedFilt/3.6)/1000;
          const p2 = mass*accelValue*(optSync/3.6)/1000;
          power1.push(p1); if(power1.length>maxPoints) power1.shift();
          power2.push(p2); if(power2.length>maxPoints) power2.shift();
          // ratio tracking
          const ratio = p2>0? p1/p2 : 0;
          ratioPoints.push({ speed: speedFilt, acc: accelValue, ratio, t: Date.now() });
          if(ratioPoints.length>maxPoints) ratioPoints.shift();
          drawEnergy(); drawRatio();
        }
      } else {
        prevSpeedMps = 0;
      }
      prevPos = { lat, lon, time: t };
    }

    alphaSlider.addEventListener('input', () => { alphaValueEl.value = alphaSlider.value; });
    function init() {
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(s => { if (s === 'granted') window.addEventListener('devicemotion', handleMotion); }).catch(console.error);
      } else {
        window.addEventListener('devicemotion', handleMotion);
      }
      if (navigator.geolocation) navigator.geolocation.watchPosition(onGeo, console.error, { enableHighAccuracy:true, maximumAge:1000 });
    }
    init();
  </script>
</body>
</html>
