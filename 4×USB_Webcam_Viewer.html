<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>4× USB Webcam Viewer — Car Layout</title>
<style>
  :root { --gap: 12px; --panel:#1a1a1a; --border:#2e2e2e; --text:#eee; --muted:#bbb; --accent:#2c7be5; --danger:#b54b4b; }
  * { box-sizing: border-box; }
  body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #111; color: var(--text); }
  header.topbar { padding: 12px 16px; background: #1b1b1b; border-bottom: 1px solid #333; }
  h1 { margin: 0; font-size: 18px; font-weight: 600; }
  label { font-size: 12px; color: var(--muted); }
  select, button { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #444; background: #202020; color: var(--text); }
  button { cursor: pointer; }
  button.primary { background: var(--accent); border-color: var(--accent); }
  button.danger { background: var(--danger); border-color: var(--danger); }
  button:disabled { opacity: 0.5; cursor: not-allowed; }

  /* Camera selectors */
  #controls { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--gap); padding: 12px 16px; background: #141414; border-bottom: 1px solid #2a2a2a; }
  .camctl { background: var(--panel); border: 1px solid var(--border); border-radius: 10px; padding: 10px; display: grid; gap: 8px; }
  .badge { font-variant-numeric: tabular-nums; font-size: 12px; color: var(--muted); }

  /* Global bar */
  #global { display: flex; gap: var(--gap); padding: 10px 16px; align-items: center; background: #141414; border-bottom: 1px solid #2a2a2a; flex-wrap: wrap; }
  .spacer { flex: 1 1 auto; }
  #fpsCtl { display:flex; align-items:center; gap:8px; }
  #fpsRange { width: 180px; }

  /* Layout creator */
  #layout { padding: 14px 16px; background: #141414; border-bottom: 1px solid #2a2a2a; display: grid; grid-template-columns: 320px 1fr; gap: 16px; }
  #carCanvas { position: relative; min-height: 260px; background: #101010; border: 1px dashed #333; border-radius: 12px; display: grid; place-items: center; }
  #carCanvas .zone { position: absolute; border: 2px dashed #555; color: #ccc; border-radius: 10px; padding: 8px; min-width: 120px; min-height: 52px;
                     display:flex; align-items:center; justify-content:center; gap:8px; background: rgba(255,255,255,0.02); }
  #zone-front { top: 8px; left: 50%; transform: translateX(-50%); }
  #zone-back  { bottom: 8px; left: 50%; transform: translateX(-50%); }
  #zone-left  { left: 8px; top: 50%; transform: translateY(-50%); }
  #zone-right { right: 8px; top: 50%; transform: translateY(-50%); }
  #carSVG { width: 180px; height: 240px; opacity: 0.9; }

  #tray { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 12px; }
  #tray h3 { margin: 0 0 8px 0; font-size: 14px; color: var(--muted); font-weight: 600; }
  #tray .tokens { display: flex; gap: 8px; flex-wrap: wrap; min-height: 44px; }

  .token, .zoneToken { user-select: none; background:#222; border:1px solid #3a3a3a; border-radius:999px; padding:6px 10px; font-size:12px; display:flex; gap:6px; align-items:center; }
  .token .dot, .zoneToken .dot { width:8px; height:8px; border-radius:50%; background:var(--accent); opacity:.85; }
  .zone.has-cam { border-color: var(--accent); background: rgba(44,123,229,0.08); }
  .zone .zlabel { font-weight: 600; letter-spacing: .2px; }
  .zone .assign { font-size: 12px; color: #9ad; }
  .zone.drop-hint { border-color:#2c7be5; box-shadow:0 0 0 2px rgba(44,123,229,.25) inset; }
  #tokenTray.drop-hint { outline:2px dashed #2c7be5; outline-offset:4px; }

  /* Video grid mapped to positions */
  #grid { display: grid; grid-template-columns: repeat(2, 1fr); grid-auto-rows: 1fr; gap: var(--gap); padding: var(--gap); height: calc(100vh - 380px); box-sizing: border-box; }
  .pane { position: relative; background: #000; border: 1px solid #333; border-radius: 12px; overflow: hidden; }
  .pane header { position: absolute; inset: 0 auto auto 0; background: rgba(0,0,0,0.55); border: none; padding: 6px 10px; font-size: 12px; z-index: 2; }
  video { width: 100%; height: 100%; object-fit: cover; background: #000; }

  @media (max-width: 1100px) { #layout { grid-template-columns: 1fr; } }
  @media (max-width: 900px) {
    #controls { grid-template-columns: repeat(2, 1fr); }
    #grid { grid-template-columns: 1fr; height: auto; }
    .pane { aspect-ratio: 16/9; }
  }
</style>
</head>
<body>
  <header class="topbar">
    <h1>4× USB Webcam Viewer — Car Layout</h1>
  </header>

  <!-- Camera selectors -->
  <div id="controls">
    <div class="camctl" data-idx="0">
      <label for="sel-0">Camera 1</label>
      <select id="sel-0"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start 1</button>
        <button class="danger" data-action="stop" disabled>Stop 1</button>
      </div>
      <small class="badge" id="info-0">Idle</small>
    </div>
    <div class="camctl" data-idx="1">
      <label for="sel-1">Camera 2</label>
      <select id="sel-1"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start 2</button>
        <button class="danger" data-action="stop" disabled>Stop 2</button>
      </div>
      <small class="badge" id="info-1">Idle</small>
    </div>
    <div class="camctl" data-idx="2">
      <label for="sel-2">Camera 3</label>
      <select id="sel-2"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start 3</button>
        <button class="danger" data-action="stop" disabled>Stop 3</button>
      </div>
      <small class="badge" id="info-2">Idle</small>
    </div>
    <div class="camctl" data-idx="3">
      <label for="sel-3">Camera 4</label>
      <select id="sel-3"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start 4</button>
        <button class="danger" data-action="stop" disabled>Stop 4</button>
      </div>
      <small class="badge" id="info-3">Idle</small>
    </div>
  </div>

  <!-- Global controls -->
  <div id="global">
    <button id="startAll" class="primary">Start All</button>
    <button id="stopAll" class="danger" disabled>Stop All</button>

    <div id="fpsCtl">
      <label for="fpsRange" title="Capture FPS cap">FPS</label>
      <input id="fpsRange" type="range" min="1" max="30" value="10" step="1" />
      <output id="fpsOut" for="fpsRange">10</output>
    </div>

    <div class="spacer"></div>

    <button id="refreshList">Refresh Camera List</button>
    <button id="resetRemembered">Reset Remembered Choices</button>
  </div>

  <!-- Layout creator -->
  <section id="layout">
    <div id="carCanvas">
      <!-- Car silhouette -->
      <svg id="carSVG" viewBox="0 0 120 180" aria-hidden="true">
        <!-- body -->
        <rect x="20" y="20" width="80" height="140" rx="10" fill="#2a2a2a" stroke="#444" />
        <!-- windshield & rear -->
        <rect x="28" y="28" width="64" height="40" rx="6" fill="#333"/>
        <rect x="28" y="112" width="64" height="40" rx="6" fill="#333"/>
        <!-- wheels -->
        <rect x="10" y="36" width="12" height="24" rx="3" fill="#222"/>
        <rect x="98" y="36" width="12" height="24" rx="3" fill="#222"/>
        <rect x="10" y="120" width="12" height="24" rx="3" fill="#222"/>
        <rect x="98" y="120" width="12" height="24" rx="3" fill="#222"/>
      </svg>

      <!-- Drop zones -->
      <div class="zone" id="zone-front" data-zone="front">
        <span class="zlabel">Front</span>
        <span class="assign" id="assign-front">—</span>
      </div>
      <div class="zone" id="zone-right" data-zone="right">
        <span class="zlabel">Right</span>
        <span class="assign" id="assign-right">—</span>
      </div>
      <div class="zone" id="zone-left" data-zone="left">
        <span class="zlabel">Left</span>
        <span class="assign" id="assign-left">—</span>
      </div>
      <div class="zone" id="zone-back" data-zone="back">
        <span class="zlabel">Back</span>
        <span class="assign" id="assign-back">—</span>
      </div>
    </div>

    <!-- Token tray -->
    <div id="tray">
      <h3>Unassigned — drag onto a zone</h3>
      <div class="tokens" id="tokenTray"></div>
    </div>
  </section>

  <!-- Video grid (mapped to the 4 zones) -->
  <main id="grid">
    <div class="pane"><header>Front</header><video id="pos-front" autoplay playsinline muted></video></div>
    <div class="pane"><header>Right</header><video id="pos-right" autoplay playsinline muted></video></div>
    <div class="pane"><header>Left</header><video id="pos-left" autoplay playsinline muted></video></div>
    <div class="pane"><header>Back</header><video id="pos-back" autoplay playsinline muted></video></div>
  </main>

<script>
(async () => {
  // ---------------- State ----------------
  const streams = [null, null, null, null];     // MediaStream per camera index (0..3)
  const rememberedKey = 'quadcam-deviceIds-v1';
  const mapKey = 'quadcam-layout-v1';

  // Start unassigned so tokens appear initially (saved layout will override if present)
  let mapping = { front: null, right: null, left: null, back: null };

  // ---------------- Elements ----------------
  const selects = [0,1,2,3].map(i => document.getElementById('sel-' + i));
  const infos   = [0,1,2,3].map(i => document.getElementById('info-' + i));
  const startAllBtn = document.getElementById('startAll');
  const stopAllBtn  = document.getElementById('stopAll');
  const refreshBtn  = document.getElementById('refreshList');
  const resetRememberedBtn = document.getElementById('resetRemembered');
  const fpsRange = document.getElementById('fpsRange');
  const fpsOut   = document.getElementById('fpsOut');
  const tokenTray = document.getElementById('tokenTray');
  const zoneEls = {
    front: document.getElementById('zone-front'),
    right: document.getElementById('zone-right'),
    left:  document.getElementById('zone-left'),
    back:  document.getElementById('zone-back')
  };
  const assignLabels = {
    front: document.getElementById('assign-front'),
    right: document.getElementById('assign-right'),
    left:  document.getElementById('assign-left'),
    back:  document.getElementById('assign-back')
  };
  const posVideos = {
    front: document.getElementById('pos-front'),
    right: document.getElementById('pos-right'),
    left:  document.getElementById('pos-left'),
    back:  document.getElementById('pos-back')
  };

  // Current FPS from GUI (default 10)
  function getTargetFps() { return Math.max(1, parseInt(fpsRange.value || '10', 10)); }

  // Debounced live-FPS listener
  let fpsDebounce;
  fpsRange.addEventListener('input', () => {
    fpsOut.textContent = fpsRange.value;
    clearTimeout(fpsDebounce);
    fpsDebounce = setTimeout(() => setLiveFpsForAll(getTargetFps()), 150);
  });

  // Attach start/stop per camera
  document.querySelectorAll('.camctl').forEach(block => {
    const idx = Number(block.dataset.idx);
    block.querySelector('[data-action="start"]').addEventListener('click', () => startOne(idx));
    block.querySelector('[data-action="stop"]').addEventListener('click', () => stopOne(idx));
  });

  startAllBtn.addEventListener('click', startAll);
  stopAllBtn.addEventListener('click', stopAll);
  refreshBtn.addEventListener('click', refreshDeviceList);
  resetRememberedBtn.addEventListener('click', () => {
    localStorage.removeItem(rememberedKey);
    alert('Saved camera choices cleared.');
  });

  navigator.mediaDevices?.addEventListener?.('devicechange', refreshDeviceList);

  // ---------------- Helpers ----------------
  function setButtonsEnabled(idx, running) {
    const block = document.querySelector(`.camctl[data-idx="${idx}"]`);
    const startBtn = block.querySelector('[data-action="start"]');
    const stopBtn = block.querySelector('[data-action="stop"]');
    startBtn.disabled = running;
    stopBtn.disabled  = !running;
    stopAllBtn.disabled = !streams.some(s => s);
  }

  // Live FPS adjuster for all running streams
  async function setLiveFpsForAll(fps) {
    const tasks = [];
    for (const s of streams) {
      if (!s) continue;
      const track = s.getVideoTracks()[0];
      if (!track) continue;
      const attempts = [
        { frameRate: fps },
        { frameRate: { ideal: fps, max: fps } },
        { frameRate: { max: fps } }
      ];
      tasks.push((async () => {
        let lastErr;
        for (const c of attempts) {
          try {
            await track.applyConstraints(c);
            const got = track.getSettings();
            console.log(`Live FPS set → ${got.frameRate ?? 'unknown'} fps`);
            return;
          } catch (e) { lastErr = e; }
        }
        console.warn('Live FPS change not supported by this camera/driver:', lastErr?.message || lastErr);
      })());
    }
    await Promise.all(tasks);
  }

  function rememberSelection(deviceIds) {
    try { localStorage.setItem(rememberedKey, JSON.stringify(deviceIds)); } catch {}
  }
  function loadRememberedSelection() {
    try {
      const raw = localStorage.getItem(rememberedKey);
      if (!raw) return null;
      const arr = JSON.parse(raw);
      if (Array.isArray(arr) && arr.length === 4) return arr;
    } catch {}
    return null;
  }

  function rememberMapping() {
    try { localStorage.setItem(mapKey, JSON.stringify(mapping)); } catch {}
  }
  function loadMapping() {
    try {
      const raw = localStorage.getItem(mapKey);
      if (!raw) return;
      const obj = JSON.parse(raw);
      if (obj && ['front','right','left','back'].every(k => k in obj)) mapping = obj;
    } catch {}
  }

  async function ensurePermissionPrompted() {
    try {
      const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      s.getTracks().forEach(t => t.stop());
    } catch (e) {
      console.warn('Initial permission request failed:', e);
    }
  }

  async function refreshDeviceList() {
    try {
      await ensurePermissionPrompted();
      const devices = await navigator.mediaDevices.enumerateDevices();
      const vids = devices.filter(d => d.kind === 'videoinput');

      const currentSelections = selects.map(sel => sel.value || '');
      selects.forEach((sel, i) => {
        sel.innerHTML = '';
        vids.forEach((d, ix) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          const label = d.label || `Camera ${ix+1}`;
          opt.textContent = `${label} [${ix+1}]`;
          sel.appendChild(opt);
        });
        const candidate = currentSelections[i] && vids.some(v => v.deviceId === currentSelections[i])
          ? currentSelections[i]
          : (vids[0]?.deviceId || '');
        sel.value = candidate;
      });

      // Update tokens & zone labels
      renderTokensAndZones();

      // Try apply remembered device selection
      const remembered = loadRememberedSelection();
      if (remembered) {
        remembered.forEach((id, i) => {
          if (id && [...selects[i].options].some(o => o.value === id)) {
            selects[i].value = id;
          }
        });
        renderTokensAndZones();
      }
    } catch (e) {
      console.error('Failed to refresh device list', e);
      alert('Failed to list cameras: ' + e.message);
    }
  }

  // Open with FPS-aware fallbacks (low bandwidth first)
  async function openWithFallbacks(deviceId, fpsCap) {
    const attempts = [
      { width: { exact: 640 },  height: { exact: 360 },  frameRate: { max: fpsCap } },
      { width: { exact: 640 },  height: { exact: 480 },  frameRate: { max: fpsCap } },
      { width: { max: 800 },    height: { max: 600 },    frameRate: { max: fpsCap } },
      { width: { max: 1280 },   height: { max: 720 },    frameRate: { max: fpsCap } },
    ];
    let lastErr;
    for (const video of attempts) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: deviceId }, ...video },
          audio: false
        });
        const track = stream.getVideoTracks()[0];
        const s = track.getSettings();
        console.log(`Negotiated ${s.width}×${s.height} @ ${s.frameRate} fps for ${deviceId}`);
        return stream;
      } catch (e) {
        lastErr = e;
        await new Promise(r => setTimeout(r, 200));
      }
    }
    throw lastErr || new Error('Could not start video source');
  }

  async function startOne(idx) {
    const deviceId = selects[idx].value;
    if (!deviceId) { alert(`Select a camera for slot ${idx + 1}`); return; }
    stopOne(idx);
    try {
      infos[idx].textContent = 'Starting...';
      await new Promise(r => setTimeout(r, idx * 150)); // stagger opens
      const stream = await openWithFallbacks(deviceId, getTargetFps());
      streams[idx] = stream;
      setButtonsEnabled(idx, true);
      infos[idx].textContent = 'Live';
      rememberSelection(selects.map(s => s.value));
      updatePositionVideos(); // rebind mapped outputs
    } catch (e) {
      infos[idx].textContent = 'Error';
      console.error(`Cam ${idx+1} start error:`, e);
      alert(`Camera ${idx+1} failed: ${e.name || 'Error'} — ${e.message || e}`);
      setButtonsEnabled(idx, false);
    }
  }

  function stopOne(idx) {
    const s = streams[idx];
    if (s) {
      s.getTracks().forEach(t => t.stop());
      streams[idx] = null;
    }
    infos[idx].textContent = 'Stopped';
    setButtonsEnabled(idx, false);
    updatePositionVideos();
  }

  async function startAll() {
    const chosen = new Set();
    for (let i = 0; i < 4; i++) {
      const id = selects[i].value;
      if (chosen.has(id)) {
        infos[i].textContent = 'Duplicate selection—pick a different camera.';
        continue;
      }
      chosen.add(id);
      await startOne(i); // serial to avoid driver contention
    }
    stopAllBtn.disabled = !streams.some(Boolean);
  }

  function stopAll() {
    for (let i = 0; i < 4; i++) stopOne(i);
    stopAllBtn.disabled = true;
  }

  // ---------- Layout (drag & drop) ----------
  function cameraLabel(idx) {
    const sel = selects[idx];
    return sel.selectedOptions[0]?.textContent || `Camera ${idx+1}`;
  }

  function makeToken(idx) {
    const el = document.createElement('div');
    el.className = 'token';
    el.draggable = true;
    el.dataset.cam = String(idx);
    el.innerHTML = `<span class="dot"></span><span>Cam ${idx+1}</span><span style="color:#9ad;">${cameraLabel(idx)}</span>`;
    el.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', String(idx));
      e.dataTransfer.effectAllowed = 'move';
    });
    return el;
  }

  function makeZoneToken(idx) {
    const el = document.createElement('div');
    el.className = 'zoneToken';
    el.draggable = true;
    el.dataset.cam = String(idx);
    el.innerHTML = `<span class="dot"></span><span>Cam ${idx+1}</span>`;
    el.title = cameraLabel(idx);
    el.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', String(idx));
      e.dataTransfer.effectAllowed = 'move';
    });
    return el;
  }

  function renderTokensAndZones() {
    // Zone contents
    Object.entries(mapping).forEach(([zone, camIdx]) => {
      const z = zoneEls[zone];
      const lab = assignLabels[zone];
      z.classList.remove('has-cam');
      lab.textContent = '—';
      [...z.querySelectorAll('.zoneToken')].forEach(n => n.remove());

      if (typeof camIdx === 'number') {
        z.classList.add('has-cam');
        lab.textContent = `Cam ${camIdx+1}`;
        z.appendChild(makeZoneToken(camIdx)); // draggable from zone
      }
    });

    // Tray: cams not assigned to any zone
    const assigned = new Set(Object.values(mapping).filter(v => typeof v === 'number'));
    tokenTray.innerHTML = '';
    [0,1,2,3].forEach(i => { if (!assigned.has(i)) tokenTray.appendChild(makeToken(i)); });
  }

  // Drop handlers for zones
  function onZoneDragOver(ev){ ev.preventDefault(); ev.currentTarget.classList.add('drop-hint'); ev.dataTransfer.dropEffect = 'move'; }
  function onZoneDragLeave(ev){ ev.currentTarget.classList.remove('drop-hint'); }
  function onZoneDrop(ev){
    ev.preventDefault();
    ev.currentTarget.classList.remove('drop-hint');
    const zone = ev.currentTarget.dataset.zone;
    const camIdx = Number(ev.dataTransfer.getData('text/plain'));
    if (!Number.isInteger(camIdx)) return;
    // Ensure uniqueness
    Object.keys(mapping).forEach(z => { if (mapping[z] === camIdx) mapping[z] = null; });
    mapping[zone] = camIdx;
    rememberMapping();
    renderTokensAndZones();
    updatePositionVideos();
  }
  Object.values(zoneEls).forEach(z=>{
    z.addEventListener('dragover', onZoneDragOver);
    z.addEventListener('dragleave', onZoneDragLeave);
    z.addEventListener('drop', onZoneDrop);
  });

  // Tray accepts drops to unassign
  function onTrayDragOver(ev){ ev.preventDefault(); tokenTray.classList.add('drop-hint'); ev.dataTransfer.dropEffect='move'; }
  function onTrayDragLeave(){ tokenTray.classList.remove('drop-hint'); }
  function onTrayDrop(ev){
    ev.preventDefault(); tokenTray.classList.remove('drop-hint');
    const camIdx = Number(ev.dataTransfer.getData('text/plain'));
    if (!Number.isInteger(camIdx)) return;
    Object.keys(mapping).forEach(z => { if (mapping[z] === camIdx) mapping[z] = null; });
    rememberMapping();
    renderTokensAndZones();
    updatePositionVideos();
  }
  tokenTray.addEventListener('dragover', onTrayDragOver);
  tokenTray.addEventListener('dragleave', onTrayDragLeave);
  tokenTray.addEventListener('drop', onTrayDrop);

  // Apply current mapping to the 4 position video elements
  function updatePositionVideos() {
    // Clear all first
    Object.values(posVideos).forEach(v => { v.srcObject = null; });

    for (const zone of ['front','right','left','back']) {
      const camIdx = mapping[zone];
      if (typeof camIdx === 'number' && streams[camIdx]) {
        posVideos[zone].srcObject = streams[camIdx];
      }
    }
    stopAllBtn.disabled = !streams.some(Boolean);
  }

  // ---------------- Init ----------------
  loadMapping();                 // restore saved layout if any
  renderTokensAndZones();

  if (!navigator.mediaDevices?.getUserMedia) {
    alert('getUserMedia not supported in this browser.');
  } else {
    await refreshDeviceList();
  }
})();
</script>
</body>
</html>
