<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>4× USB Webcam Viewer</title>
<style>
  :root { --gap: 12px; }
  body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #111; color: #eee; }
  header.topbar { padding: 12px 16px; background: #1b1b1b; border-bottom: 1px solid #333; }
  h1 { margin: 0; font-size: 18px; font-weight: 600; }
  #controls { display: grid; grid-template-columns: repeat(4, 1fr); gap: var(--gap); padding: 12px 16px; background: #141414; border-bottom: 1px solid #2a2a2a; }
  .camctl { background: #1a1a1a; border: 1px solid #2e2e2e; border-radius: 10px; padding: 10px; display: grid; gap: 8px; }
  label { font-size: 12px; color: #bbb; }
  select, button { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #444; background: #202020; color: #eee; }
  button { cursor: pointer; }
  button.primary { background: #2c7be5; border-color: #2c7be5; }
  button.danger { background: #b54b4b; border-color: #b54b4b; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  #global { display: flex; gap: var(--gap); padding: 10px 16px; align-items: center; background: #141414; border-bottom: 1px solid #2a2a2a; flex-wrap: wrap; }
  #grid { display: grid; grid-template-columns: repeat(2, 1fr); grid-auto-rows: 1fr; gap: var(--gap); padding: var(--gap); height: calc(100vh - 230px); box-sizing: border-box; }
  .pane { position: relative; background: #000; border: 1px solid #333; border-radius: 12px; overflow: hidden; }
  .pane header { position: absolute; inset: 0 auto auto 0; background: rgba(0,0,0,0.55); border: none; padding: 6px 10px; font-size: 12px; z-index: 2; }
  video { width: 100%; height: 100%; object-fit: cover; background: #000; }
  .badge { font-variant-numeric: tabular-nums; }
  .spacer { flex: 1 1 auto; }
  #fpsCtl { display:flex; align-items:center; gap:8px; }
  #fpsRange { width: 180px; }
  footer { padding: 8px 16px; font-size: 12px; color: #888; border-top: 1px solid #2a2a2a; background: #141414; }
  @media (max-width: 900px) {
    #controls { grid-template-columns: repeat(2, 1fr); }
    #grid { grid-template-columns: 1fr; height: auto; }
    .pane { aspect-ratio: 16/9; }
  }
</style>
</head>
<body>
  <header class="topbar">
    <h1>4× USB Webcam Viewer</h1>
  </header>

  <div id="controls">
    <div class="camctl" data-idx="0">
      <label for="sel-0">Front</label>
      <select id="sel-0"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Front</button>
        <button class="danger" data-action="stop" disabled>Stop Front</button>
      </div>
      <small class="badge" id="info-0">Idle</small>
    </div>
    <div class="camctl" data-idx="1">
      <label for="sel-1">Back</label>
      <select id="sel-1"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Back</button>
        <button class="danger" data-action="stop" disabled>Stop Back</button>
      </div>
      <small class="badge" id="info-1">Idle</small>
    </div>
    <div class="camctl" data-idx="2">
      <label for="sel-2">Left</label>
      <select id="sel-2"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Left</button>
        <button class="danger" data-action="stop" disabled>Stop Left</button>
      </div>
      <small class="badge" id="info-2">Idle</small>
    </div>
    <div class="camctl" data-idx="3">
      <label for="sel-3">Right</label>
      <select id="sel-3"></select>
      <div style="display:flex; gap:8px;">
        <button class="primary" data-action="start">Start Right</button>
        <button class="danger" data-action="stop" disabled>Stop Right</button>
      </div>
      <small class="badge" id="info-3">Idle</small>
    </div>
  </div>

  <div id="global">
    <button id="startAll" class="primary">Start All</button>
    <button id="stopAll" class="danger" disabled>Stop All</button>

    <div id="fpsCtl">
      <label for="fpsRange" title="Capture FPS cap">FPS</label>
      <input id="fpsRange" type="range" min="1" max="30" value="1" step="1" />
      <output id="fpsOut" for="fpsRange">1</output>
    </div>

    <button id="saveBtn" title="Record all active streams">Save streams</button>

    <div class="spacer"></div>

    <button id="refreshList">Refresh Camera List</button>
    <button id="resetRemembered">Reset Remembered Choices</button>
  </div>

  <main id="grid">
    <div class="pane">
      <header id="label-0">Front</header>
      <video id="vid-0" autoplay playsinline muted></video>
    </div>
    <div class="pane">
      <header id="label-1">Back</header>
      <video id="vid-1" autoplay playsinline muted></video>
    </div>
    <div class="pane">
      <header id="label-2">Left</header>
      <video id="vid-2" autoplay playsinline muted></video>
    </div>
    <div class="pane">
      <header id="label-3">Right</header>
      <video id="vid-3" autoplay playsinline muted></video>
    </div>
  </main>

  <footer>
    Use HTTPS or <code>http://localhost</code>. Grant camera access when prompted. After permission, device labels appear.
    For 4 simultaneous webcams, keep resolution modest (640×360/480) and FPS low.
  </footer>

<script>
(async () => {
  // --- State ---
  const streams = [null, null, null, null]; // MediaStream per pane
  const recorders = [null, null, null, null]; // MediaRecorder per pane
  const chunks = [[], [], [], []]; // Blob parts per pane
  let recording = false;

  const positionNames = ['Front','Back','Left','Right'];
  const rememberedKey = 'quadcam-deviceIds-v1';

  // --- Elements ---
  const selects = [0,1,2,3].map(i => document.getElementById('sel-' + i));
  const infos   = [0,1,2,3].map(i => document.getElementById('info-' + i));
  const labels  = [0,1,2,3].map(i => document.getElementById('label-' + i)); // video headers (fixed names)
  const videos  = [0,1,2,3].map(i => document.getElementById('vid-' + i));
  const startAllBtn = document.getElementById('startAll');
  const stopAllBtn  = document.getElementById('stopAll');
  const refreshBtn  = document.getElementById('refreshList');
  const resetRememberedBtn = document.getElementById('resetRemembered');
  const saveBtn = document.getElementById('saveBtn');
  const fpsRange = document.getElementById('fpsRange');
  const fpsOut   = document.getElementById('fpsOut');

  // Current FPS target from GUI
  function getTargetFps() {
    return Math.max(1, parseInt(fpsRange.value || '1', 10));
  }

  // Debounced live-FPS listener
  let fpsDebounce;
  fpsRange.addEventListener('input', () => {
    fpsOut.textContent = fpsRange.value;
    clearTimeout(fpsDebounce);
    fpsDebounce = setTimeout(() => setLiveFpsForAll(getTargetFps()), 150);
  });

  // Attach button handlers per camera control block
  document.querySelectorAll('.camctl').forEach(block => {
    const idx = Number(block.dataset.idx);
    block.querySelector('[data-action="start"]').addEventListener('click', () => startOne(idx));
    block.querySelector('[data-action="stop"]').addEventListener('click', () => stopOne(idx));
  });

  startAllBtn.addEventListener('click', startAll);
  stopAllBtn.addEventListener('click', stopAll);
  refreshBtn.addEventListener('click', refreshDeviceList);
  resetRememberedBtn.addEventListener('click', () => {
    localStorage.removeItem(rememberedKey);
    alert('Saved camera choices cleared.');
  });

  saveBtn.addEventListener('click', toggleRecordingAll);

  navigator.mediaDevices?.addEventListener?.('devicechange', refreshDeviceList);

  // --- Helpers ---
  function setButtonsEnabled(idx, running) {
    const block = document.querySelector(`.camctl[data-idx="${idx}"]`);
    const startBtn = block.querySelector('[data-action="start"]');
    const stopBtn = block.querySelector('[data-action="stop"]');
    startBtn.disabled = running;
    stopBtn.disabled  = !running;
    stopAllBtn.disabled = !streams.some(s => s);
  }

  function timestamp() {
    const d = new Date();
    const pad = n => String(n).padStart(2, '0');
    return `${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}`;
  }

  function pickSupportedMime() {
    const candidates = [
      'video/webm;codecs=vp9,opus',
      'video/webm;codecs=vp8,opus',
      'video/webm'
      // Safari (some versions) may support 'video/mp4' with H.264; uncomment if needed:
      // 'video/mp4'
    ];
    for (const m of candidates) {
      if (window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m;
    }
    return ''; // Let browser decide
  }

  async function toggleRecordingAll() {
    if (!recording) {
      // Start recording any active streams
      const mime = pickSupportedMime();
      let any = false;
      for (let i = 0; i < 4; i++) {
        if (!streams[i]) { infos[i].textContent = 'Not running'; continue; }
        try {
          chunks[i] = [];
          const rec = new MediaRecorder(streams[i], mime ? { mimeType: mime } : undefined);
          recorders[i] = rec;
          rec.ondataavailable = e => { if (e.data && e.data.size) chunks[i].push(e.data); };
          rec.onstop = () => { /* blob assembled later */ };
          rec.start(1000); // gather data every second
          any = true;
          infos[i].textContent = 'Recording…';
        } catch (e) {
          console.error(`Recorder ${i+1} error:`, e);
          infos[i].textContent = 'Recorder error';
        }
      }
      if (!any) { alert('No active streams to record. Start at least one camera.'); return; }
      recording = true;
      saveBtn.textContent = 'Stop & Download';
      saveBtn.classList.add('danger');
    } else {
      // Stop and download
      const stamp = timestamp();
      for (let i = 0; i < 4; i++) {
        if (recorders[i]) {
          await stopRecorder(recorders[i]);
          recorders[i] = null;
          const blob = new Blob(chunks[i], { type: (chunks[i][0]?.type || 'video/webm') });
          chunks[i] = [];
          if (blob.size > 0) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${stamp}_${positionNames[i]}.webm`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            infos[i].textContent = 'Saved';
          } else {
            infos[i].textContent = 'No data';
          }
        }
      }
      recording = false;
      saveBtn.textContent = 'Save streams';
      saveBtn.classList.remove('danger');
    }
  }

  function stopRecorder(rec) {
    return new Promise(resolve => {
      try {
        rec.onstop = () => resolve();
        if (rec.state !== 'inactive') rec.stop();
        else resolve();
      } catch { resolve(); }
    });
  }

  // Live FPS adjuster for all running streams
  async function setLiveFpsForAll(fps) {
    const tasks = [];
    for (const s of streams) {
      if (!s) continue;
      const track = s.getVideoTracks()[0];
      if (!track) continue;
      const attempts = [
        { frameRate: fps },                             // exact
        { frameRate: { ideal: fps, max: fps } },        // ideal + cap
        { frameRate: { max: fps } }                     // cap only
      ];
      tasks.push((async () => {
        let lastErr;
        for (const c of attempts) {
          try {
            await track.applyConstraints(c);
            const got = track.getSettings();
            console.log(`Live FPS set → ${got.frameRate ?? 'unknown'} fps`);
            return;
          } catch (e) { lastErr = e; }
        }
        console.warn('Live FPS change not supported by this camera/driver:', lastErr?.message || lastErr);
      })());
    }
    await Promise.all(tasks);
  }

  function rememberSelection(deviceIds) {
    try { localStorage.setItem(rememberedKey, JSON.stringify(deviceIds)); } catch {}
  }

  function loadRememberedSelection() {
    try {
      const raw = localStorage.getItem(rememberedKey);
      if (!raw) return null;
      const arr = JSON.parse(raw);
      if (Array.isArray(arr) && arr.length === 4) return arr;
    } catch {}
    return null;
  }

  async function ensurePermissionPrompted() {
    // To reveal device labels, prompt once for generic camera access.
    try {
      const s = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      s.getTracks().forEach(t => t.stop());
    } catch (e) {
      console.warn('Initial permission request failed:', e);
    }
  }

  async function refreshDeviceList() {
    try {
      await ensurePermissionPrompted();
      const devices = await navigator.mediaDevices.enumerateDevices();
      const vids = devices.filter(d => d.kind === 'videoinput');

      const currentSelections = selects.map(sel => sel.value || '');
      selects.forEach((sel, i) => {
        sel.innerHTML = '';
        vids.forEach((d, ix) => {
          const opt = document.createElement('option');
          opt.value = d.deviceId;
          const label = d.label || `Camera ${ix+1}`;
          opt.textContent = `${label} [${ix+1}]`;
          sel.appendChild(opt);
        });
        const candidate = currentSelections[i] && vids.some(v => v.deviceId === currentSelections[i])
          ? currentSelections[i]
          : (vids[0]?.deviceId || '');
        sel.value = candidate;
        // Keep pane headers fixed to Front/Back/Left/Right — do not overwrite labels[]
        // If you want to also show the selected device name, append here instead of replacing.
      });

      const remembered = loadRememberedSelection();
      if (remembered) {
        remembered.forEach((id, i) => {
          if (id && [...selects[i].options].some(o => o.value === id)) {
            selects[i].value = id;
          }
        });
      }
    } catch (e) {
      console.error('Failed to refresh device list', e);
      alert('Failed to list cameras: ' + e.message);
    }
  }

  // --- Open with FPS-aware fallbacks ---
  async function openWithFallbacks(deviceId, fpsCap) {
    // Try very low bandwidth first; all attempts cap frameRate at the GUI value
    const attempts = [
      { width: { exact: 640 },  height: { exact: 360 },  frameRate: { max: fpsCap } },
      { width: { exact: 640 },  height: { exact: 480 },  frameRate: { max: fpsCap } },
      { width: { max: 800 },    height: { max: 600 },    frameRate: { max: fpsCap } },
      { width: { max: 1280 },   height: { max: 720 },    frameRate: { max: fpsCap } },
    ];
    let lastErr;
    for (const video of attempts) {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: deviceId }, ...video },
          audio: false
        });
        // Log what we actually got
        const track = stream.getVideoTracks()[0];
        const s = track.getSettings();
        console.log(`Negotiated ${s.width}×${s.height} @ ${s.frameRate} fps for ${deviceId}`);
        return stream;
      } catch (e) {
        lastErr = e;
        await new Promise(r => setTimeout(r, 200));
      }
    }
    throw lastErr || new Error('Could not start video source');
  }

  async function startOne(idx) {
    const deviceId = selects[idx].value;
    if (!deviceId) { alert(`Select a camera for ${positionNames[idx]}`); return; }
    stopOne(idx);
    try {
      infos[idx].textContent = 'Starting...';
      // Stagger startup to reduce driver contention
      await new Promise(r => setTimeout(r, idx * 150));
      const stream = await openWithFallbacks(deviceId, getTargetFps());
      streams[idx] = stream;
      videos[idx].srcObject = stream;
      setButtonsEnabled(idx, true);
      infos[idx].textContent = 'Live';
      rememberSelection(selects.map(s => s.value));
    } catch (e) {
      infos[idx].textContent = 'Error';
      console.error(`Cam ${idx+1} start error:`, e);
      alert(`${positionNames[idx]} failed: ${e.name || 'Error'} — ${e.message || e}`);
      setButtonsEnabled(idx, false);
    }
  }

  function stopOne(idx) {
    // Stop any ongoing recording for this cam (so chunks flush cleanly)
    if (recorders[idx] && recording) {
      try { recorders[idx].stop(); } catch {}
      recorders[idx] = null;
      chunks[idx] = [];
    }
    const s = streams[idx];
    if (s) {
      s.getTracks().forEach(t => t.stop());
      streams[idx] = null;
    }
    videos[idx].srcObject = null;
    infos[idx].textContent = 'Stopped';
    setButtonsEnabled(idx, false);
  }

  async function startAll() {
    const chosen = new Set();
    for (let i = 0; i < 4; i++) {
      const id = selects[i].value;
      if (chosen.has(id)) {
        infos[i].textContent = 'Duplicate selection—pick a different camera.';
        continue;
      }
      chosen.add(id);
      await startOne(i); // serial, not parallel
    }
    stopAllBtn.disabled = !streams.some(Boolean);
  }

  function stopAll() {
    for (let i = 0; i < 4; i++) stopOne(i);
    stopAllBtn.disabled = true;
    if (recording) {
      // if user hit Stop All while recording, reset UI
      recording = false;
      saveBtn.textContent = 'Save streams';
      saveBtn.classList.remove('danger');
    }
  }

  // Keep info badge coherent on selection change
  selects.forEach((sel, i) => {
    sel.addEventListener('change', () => {
      infos[i].textContent = streams[i] ? 'Live' : 'Idle';
    });
  });

  // Initial load
  if (!navigator.mediaDevices?.getUserMedia) {
    alert('getUserMedia not supported in this browser.');
  } else {
    await refreshDeviceList();
  }
})();
</script>
</body>
</html>
