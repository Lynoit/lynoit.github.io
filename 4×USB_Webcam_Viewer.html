<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>4× USB Webcam Viewer + Detection + Birdview</title>
<style>
  body { margin:0; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; background:#111; color:#eee; display:flex; height:100vh; overflow:hidden; }
  #sidebar { width:260px; background:#1b1b1b; border-right:1px solid #333; display:flex; flex-direction:column; }
  #sessionList { flex:1; overflow-y:auto; padding:8px; }
  .session { padding:8px 10px; border-radius:6px; margin-bottom:4px; background:#222; cursor:pointer; }
  .session:hover { background:#2c2c2c; }
  .session.active { background:#2c7be5; color:#fff; }
 #main {
  display:flex;
  flex-direction:column;
  overflow:hidden;          /* no page scrollbars */
}
  #toolbar { padding:8px 12px; border-bottom:1px solid #333; background:#141414; display:flex; align-items:center; gap:8px; }
#videos {
  flex: 1 1 0;              /* take remaining height, allow shrinking */
  min-height: 0;            /* critical: enable children to shrink */
  display:grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  grid-template-rows:    repeat(2, minmax(0, 1fr));
  gap:6px;
  padding:6px;
}
video {
  width:100%;
  height:100%;
  object-fit:contain;
  background:#000;
}
.vwrap {
  position:relative;
  min-width:0;
  min-height:0;
}
  .vwrap header { position:absolute; top:4px; left:4px; background:rgba(0,0,0,0.5); padding:2px 6px; border-radius:4px; font-size:12px; }
.overlay {
  position:absolute;
  inset:0;
  pointer-events:none;
}
  #timeline { width:100%; }
  #currentTime { width:70px; text-align:right; font-variant-numeric:tabular-nums; }
  #sessionName { font-variant-numeric:tabular-nums; }
  button { background:#2c7be5; border:none; color:#fff; padding:6px 10px; border-radius:6px; cursor:pointer; }
  button:hover { background:#3d8af0; }
  label { display:flex; align-items:center; gap:6px; }
  input[type="number"] { width:76px; }

  /* Birdview panel */
#birdPanel {
  flex: 0 0 240px;          /* adjust height as you like (e.g., 200–300px) */
  border-top:1px solid #333;
  background:#141414;
  padding:8px 10px;
  display:flex;
  align-items:center;
  gap:12px;
}
  #birdviewWrap { flex:1; height:240px; position:relative; }
  #birdview { width:100%; height:100%; background:#0b0b0b; border:1px solid #333; border-radius:8px; display:block; }
  .kv { opacity:0.8; font-size:12px; }
</style>

<!-- Detection libs -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.21.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
</head>
<body>
  <div id="sidebar">
    <div style="padding:8px;border-bottom:1px solid #333;">
      <button id="pickFolder">Open Folder</button>
    </div>
    <div id="sessionList"></div>
  </div>

  <div id="main">
    <div id="toolbar">
      <button id="playPause" disabled>▶️ Play</button>
      <input id="timeline" type="range" min="0" max="100" value="0" step="0.01" disabled />
      <span id="currentTime">00:00</span>
      <div style="flex:1"></div>

      <span id="sessionName"></span>

      <!-- Detection controls -->
      <label title="Run object detection on the Front camera">
        <input type="checkbox" id="detectToggle" checked />
        Detect Front Objects
      </label>
      <label title="Horizontal FOV of the Front camera (degrees)">
        FOV°
        <input type="number" id="fovInput" min="20" max="180" step="0.1" value="90" />
      </label>
      <label title="Show a top-down plot of detected objects">
        <input type="checkbox" id="birdToggle" checked />
        Birdview
      </label>
      <label title="Max forward distance shown in birdview (meters)">
        Range
        <input type="number" id="birdRange" min="10" max="200" step="5" value="60" />
      </label>      
    </div>

    <div id="videos">
      <div class="vwrap">
        <header>Front</header>
        <video id="vidFront" preload="metadata" muted></video>
        <canvas id="ovlFront" class="overlay"></canvas>
      </div>
      <div class="vwrap"><header>Back</header> <video id="vidBack"  preload="metadata" muted></video></div>
      <div class="vwrap"><header>Left</header> <video id="vidLeft"  preload="metadata" muted></video></div>
      <div class="vwrap"><header>Right</header><video id="vidRight" preload="metadata" muted></video></div>
    </div>

    <!-- Birdview panel -->
    <div id="birdPanel">
      <div id="birdviewWrap"><canvas id="birdview"></canvas></div>
    </div>
  </div>

<script>
(async () => {
  const pickBtn = document.getElementById('pickFolder');
  const sessionList = document.getElementById('sessionList');
  const playPause = document.getElementById('playPause');
  const timeline = document.getElementById('timeline');
  const currentTime = document.getElementById('currentTime');
  const sessionNameEl = document.getElementById('sessionName');
  const vids = {
    Front: document.getElementById('vidFront'),
    Back:  document.getElementById('vidBack'),
    Left:  document.getElementById('vidLeft'),
    Right: document.getElementById('vidRight')
  };

  // Detection + UI
  const ovlFront = document.getElementById('ovlFront');
  const detectToggle = document.getElementById('detectToggle'); detectToggle.checked = true;
  const fovInput = document.getElementById('fovInput');
  const birdToggle = document.getElementById('birdToggle');
  const birdRangeInput = document.getElementById('birdRange');

  // Birdview canvas
  const birdCanvas = document.getElementById('birdview');
  const birdCtx = birdCanvas.getContext('2d');

  // Classes
  const CLASS_HEIGHTS = {
    person: 1.70,
    car: 1.50,
    bus: 3.20,
    truck: 3.00,
    bicycle: 1.50,
    motorcycle: 1.40
  };
  const KEEP = new Set(Object.keys(CLASS_HEIGHTS));
  const DISPLAY_LABEL = { person: 'pedestrian' }; // person => pedestrian
  const CLASS_COLOR = {
    car:'#53b4ff', truck:'#ffb453', bus:'#ffd753', motorcycle:'#9d7bff',
    bicycle:'#6dd36d', person:'#ff6b7d'
  };

  let cocoModel = null;
  let detRunning = false;
  let cancelDetCb = null;
  let lastInferT = 0;
  const INFER_EVERY_MS = 120;

  // Offscreen canvas for inference (sized to visible draw area)
  const inferCanvas = document.createElement('canvas');
  const inferCtx = inferCanvas.getContext('2d');

  // For passing detections to birdview per frame
  let lastBirdDetections = []; // [{label, score, dist, bearingRad}]

  let sessions = {};
  let currentSession = null;
  let baseDate = new Date(NaN);
  let master = null;
  let rVFCHandle = null;
  let playing = false;

  // Sync thresholds (seconds)
  const SOFT_SLEW_TH = 0.030, HARD_JUMP_TH = 0.100, MAX_SLEW = 0.03;

  // ---------- Utils ----------
  function fmtTime(sec){
    sec = Math.max(0,sec);
    const m=Math.floor(sec/60), s=Math.floor(sec%60);
    return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }
  function fmtHMSfromDate(dt){
    const h=dt.getHours(), m=dt.getMinutes(), s=dt.getSeconds();
    return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
  }
  function parseBaseDate(stamp){
    const m = stamp.match(/^(\d{4})(\d{2})(\d{2})_(\d{2})(\d{2})(\d{2})$/);
    if(!m) return new Date(NaN);
    const [_, Y, Mo, D, h, mi, s] = m;
    return new Date(+Y, +Mo-1, +D, +h, +mi, +s, 0);
  }
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const round1 = (x)=>Math.round(x*10)/10;

  // Folder pick + sessions
  async function pickFolder() {
    let files = [];
    if (window.showDirectoryPicker) {
      const dir = await window.showDirectoryPicker();
      for await (const entry of dir.values()) {
        if (entry.kind==='file' && entry.name.endsWith('.webm')) {
          files.push(await entry.getFile());
        }
      }
    } else {
      const input = document.createElement('input');
      input.type='file';
      input.multiple=true;
      input.accept='.webm';
      input.click();
      files = await new Promise(res=>{ input.onchange=()=>res([...input.files]); });
    }
    parseSessions(files);
  }

  function parseSessions(files){
    sessions={};
    for(const f of files){
      const m = f.name.match(/^(\d{8}_\d{6})_(Front|Back|Left|Right)\.webm$/i);
      if(!m) continue;
      const [,stamp,pos] = m;
      sessions[stamp] ||= {};
      sessions[stamp][pos] = f;
    }
    renderSidebar();
  }

  function renderSidebar(){
    sessionList.innerHTML='';
    const stamps = Object.keys(sessions).sort().reverse();
    for(const stamp of stamps){
      const div=document.createElement('div');
      div.className='session';
      div.textContent=stamp;
      div.onclick=()=>loadSession(stamp,div);
      sessionList.appendChild(div);
    }
  }

  async function loadSession(stamp,elem){
    stopSyncLoop();
    stopDetectionLoop();
    playing = false;
    playPause.textContent='▶️ Play';
    playPause.dataset.state='paused';

    [...sessionList.children].forEach(c=>c.classList.remove('active'));
    elem.classList.add('active');
    currentSession=stamp;

    baseDate = parseBaseDate(stamp);
    sessionNameEl.textContent = fmtHMSfromDate(baseDate);

    playPause.disabled=false;
    timeline.disabled=false;

    master = null;
    for(const pos of ['Front','Back','Left','Right']){
      const v = vids[pos];
      const file = sessions[stamp][pos];
      if(file){
        v.src = URL.createObjectURL(file);
        v.play().catch(()=>{});
        v.pause();
        v.currentTime=0;
        if (!master) master = v;
      } else {
        v.removeAttribute('src');
      }
      v.playbackRate = 1.0;
    }

    await Promise.all(Object.values(vids).map(v=> new Promise(r=>{
      if (!v.src) return r();
      v.onloadedmetadata=()=>r();
      setTimeout(r,500);
    })));

    resizeOverlayToFront();
    resizeBirdview();
    window.addEventListener('resize', () => {
  resizeOverlayToFront();
  resizeBirdview();
});

    const filesInSession = ['Front','Back','Left','Right']
      .map(pos => sessions[stamp][pos]).filter(Boolean);
    let elapsedByMtimeSec = 0;
    if (filesInSession.length) {
      const latestMs = Math.max(...filesInSession.map(f => f.lastModified || 0));
      const startMs  = baseDate.getTime();
      if (isFinite(latestMs) && isFinite(startMs) && latestMs > startMs) {
        elapsedByMtimeSec = Math.floor((latestMs - startMs) / 1000);
      }
    }
    const durations = Object.values(vids).map(v => (v.src ? (v.duration || 0) : 0));
    const maxDur = Math.max(...durations, 0);
    const totalSec = elapsedByMtimeSec > 0 ? elapsedByMtimeSec : maxDur;

    timeline.max = totalSec || 0;
    timeline.value=0;
    currentTime.textContent = fmtTime(0);
    sessionNameEl.textContent = fmtHMSfromDate(baseDate);
    drawBirdview([]); // clear panel
  }

  // playback control
  playPause.addEventListener('click', async ()=>{
    if(!currentSession || !master) return;
    const isPlaying = playPause.dataset.state==='playing';
    if(isPlaying){
      pauseAll();
      stopDetectionLoop();
    } else {
      playAll();
      if (detectToggle.checked) {
        await ensureModelLoaded();
        startDetectionLoop();
      }
    }
  });

  function playAll(){
    playPause.textContent='⏸ Pause';
    playPause.dataset.state='playing';
    playing = true;

    for (const v of Object.values(vids)) {
      if (!v.src) continue;
      v.play().catch(()=>{});
    }
    startSyncLoop();
  }

  function pauseAll(){
    playPause.textContent='▶️ Play';
    playPause.dataset.state='paused';
    playing = false;

    for (const v of Object.values(vids)) {
      if (!v.src) continue;
      v.pause();
      v.playbackRate = 1.0;
    }
    stopSyncLoop();
  }

  // toggles
  detectToggle.addEventListener('change', async ()=>{
    if (detectToggle.checked && playing) {
      await ensureModelLoaded();
      startDetectionLoop();
    } else {
      stopDetectionLoop(true);
      drawBirdview([]); // clear
    }
  });
  birdToggle.addEventListener('change', ()=> drawBirdview(lastBirdDetections));

  // timeline scrubbing
  timeline.addEventListener('input', ()=>{
    if(!master) return;
    const t=parseFloat(timeline.value);
    master.currentTime = t;
    for (const v of Object.values(vids)) {
      if (v !== master && v.src) v.currentTime = t;
    }
    currentTime.textContent = fmtTime(t);
    const nowDt = new Date(baseDate.getTime() + Math.floor(t)*1000);
    sessionNameEl.textContent = fmtHMSfromDate(nowDt);
    clearOverlay();
    drawBirdview([]);
  });

  // master-driven sync loop
  function startSyncLoop(){
    if (!master) return;
    const followers = Object.values(vids).filter(v => v !== master && v.src);

    const loop = () => {
      const t = master.currentTime || 0;

      const tClamped = Math.min(t, parseFloat(timeline.max) || t);
      timeline.value = tClamped;
      currentTime.textContent = fmtTime(tClamped);
      const nowDt = new Date(baseDate.getTime() + Math.floor(tClamped)*1000);
      sessionNameEl.textContent = fmtHMSfromDate(nowDt);

      for (const v of followers) {
        const drift = (v.currentTime || 0) - t;
        const adrift = Math.abs(drift);

        if (adrift > HARD_JUMP_TH) {
          v.currentTime = t;
          v.playbackRate = 1.0;
        } else if (adrift > SOFT_SLEW_TH) {
          const sign = (drift > 0) ? -1 : 1;
          const adj = Math.min(MAX_SLEW, Math.max(-MAX_SLEW, sign * Math.min(MAX_SLEW, adrift * 0.5)));
          v.playbackRate = 1.0 + adj;
        } else {
          v.playbackRate = 1.0;
        }
      }

      if (playing && master.requestVideoFrameCallback) {
        rVFCHandle = master.requestVideoFrameCallback(() => loop());
      } else if (playing) {
        rVFCHandle = setTimeout(loop, 33);
      }
    };

    if (master.requestVideoFrameCallback) {
      rVFCHandle = master.requestVideoFrameCallback(() => loop());
    } else {
      rVFCHandle = setTimeout(loop, 33);
    }
  }

  function stopSyncLoop(){
    if (master && master.cancelVideoFrameCallback && rVFCHandle) {
      try { master.cancelVideoFrameCallback(rVFCHandle); } catch {}
    } else if (rVFCHandle) {
      clearTimeout(rVFCHandle);
    }
    rVFCHandle = null;
  }

  // ------- Detection helpers (letterbox mapping, overlay, distance, bearing) -------
  function resizeOverlayToFront(){
    const box = vids.Front.getBoundingClientRect();
    ovlFront.width  = Math.max(1, Math.round(box.width));
    ovlFront.height = Math.max(1, Math.round(box.height));
  }
  function clearOverlay(){
    const ctx = ovlFront.getContext('2d');
    ctx.clearRect(0,0,ovlFront.width, ovlFront.height);
  }
  window.addEventListener('resize', ()=>{ resizeOverlayToFront(); resizeBirdview(); });

  async function ensureModelLoaded(){
    if (!cocoModel) {
      cocoModel = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
    }
  }

  // Map intrinsic → visible draw area (letterboxed)
  function computeLetterboxMapping(videoEl, canvasEl){
    const vw = Math.max(1, videoEl.videoWidth || 1);
    const vh = Math.max(1, videoEl.videoHeight || 1);
    const cw = Math.max(1, canvasEl.width  || 1);
    const ch = Math.max(1, canvasEl.height || 1);

    const videoAspect  = vw / vh;
    const canvasAspect = cw / ch;

    let drawW, drawH, padX, padY;
    if (videoAspect > canvasAspect) {
      drawW = cw; drawH = cw / videoAspect; padX = 0; padY = (ch - drawH) / 2;
    } else {
      drawH = ch; drawW = ch * videoAspect; padY = 0; padX = (cw - drawW) / 2;
    }

    const scaleX = drawW / vw;
    const scaleY = drawH / vh;

    return { vw, vh, cw, ch, drawW, drawH, padX, padY, scaleX, scaleY };
  }

  // Distance from bbox height (display pixels) + FOV
  function estimateDistanceMeters(hPix){
    const imgH = ovlFront.height;
    const imgW = ovlFront.width;
    if (hPix <= 2) return null;

    const hFovDeg = parseFloat(fovInput.value) || 90;
    const hFov = hFovDeg * Math.PI/180;
    const vFov = 2 * Math.atan( Math.tan(hFov/2) * (imgH/imgW) );
    const fy = (imgH/2) / Math.tan(vFov/2);
    // Z = Hreal*fy/hPix (Hreal applied externally per class)
    return { fy };
  }

  // Draw detections on front overlay and prepare birdview info
  function drawDetections(dets, map){
    const ctx = ovlFront.getContext('2d');
    clearOverlay();
    ctx.lineWidth = 2;
    ctx.font = '12px system-ui, Segoe UI, Roboto, Arial, sans-serif';

    const imgCenterX = map.padX + map.drawW/2;
    const hFov = (parseFloat(fovInput.value) || 90) * Math.PI/180;

    lastBirdDetections = [];

    for (const d of dets){
      const {bbox, class: label, score} = d;
      if (!KEEP.has(label)) continue;

      // bbox in draw-area coords; shift by padding to overlay
      const x = map.padX + bbox[0];
      const y = map.padY + bbox[1];
      const w = bbox[2];
      const h = bbox[3];

      // Distance with class height
      const Hreal = CLASS_HEIGHTS[label];
      const { fy } = estimateDistanceMeters(h) || {};
      const dist = fy ? clamp((Hreal * fy) / h, 0.1, 300) : null;

      // Bearing from bbox center relative to visible draw area center
      const cx = x + w/2;
      const norm = clamp((cx - imgCenterX) / (map.drawW/2), -1, 1); // -1..1 across draw width
      const bearing = norm * (hFov/2); // radians (left negative, right positive)

      // Save for birdview
      if (dist) {
        lastBirdDetections.push({
          label, score, dist, bearingRad: bearing
        });
      }

      // Visuals
      const name = DISPLAY_LABEL[label] || label;
      const color = CLASS_COLOR[label] || 'rgba(72, 190, 255, 0.95)';
      const labelText = `${name} ${(score*100).toFixed(0)}% • ${round1(dist||0)} m`;

      ctx.strokeStyle = color;
      ctx.strokeRect(x, y, w, h);

      const pad = 4;
      const metrics = ctx.measureText(labelText);
      const textH = 14;
      const textW = metrics.width + pad*2;
      const textX = Math.max(0, Math.min(ovlFront.width - textW, x));
      const textY = Math.max(0, y - (textH + 6));
      ctx.fillStyle = 'rgba(0,0,0,0.65)';
      ctx.fillRect(textX, textY, textW, textH + 4);
      ctx.fillStyle = '#eaf6ff';
      ctx.fillText(labelText, textX + pad, textY + textH - 2);
    }

    // Update birdview each draw
    drawBirdview(lastBirdDetections);
  }

  // Detection loop on offscreen infer canvas
  function startDetectionLoop(){
    if (detRunning) return;
    detRunning = true;

    const v = vids.Front;
    if (!v || !v.src || !cocoModel) return;

    const step = async () => {
      if (!detRunning || !playing || !detectToggle.checked) return;

      const now = performance.now();
      if (now - lastInferT >= INFER_EVERY_MS) {
        lastInferT = now;
        try {
          const map = computeLetterboxMapping(vids.Front, ovlFront);

          // Resize infer canvas to draw area
          const targetW = Math.max(1, Math.floor(map.drawW));
          const targetH = Math.max(1, Math.floor(map.drawH));
          if (inferCanvas.width !== targetW || inferCanvas.height !== targetH) {
            inferCanvas.width  = targetW;
            inferCanvas.height = targetH;
          }

          // Draw intrinsic video to draw area (no padding)
          inferCtx.drawImage(
            vids.Front,
            0, 0, vids.Front.videoWidth || 1, vids.Front.videoHeight || 1,
            0, 0, inferCanvas.width, inferCanvas.height
          );

          // Detect
          const preds = await cocoModel.detect(inferCanvas, 20);

          // Show + prep birdview
          drawDetections(preds, map);
        } catch (e) {
          console.error('Detection error:', e);
        }
      }

      if (v.requestVideoFrameCallback) {
        cancelDetCb = v.requestVideoFrameCallback(() => step());
      } else {
        cancelDetCb = setTimeout(step, 33);
      }
    };

    if (v.requestVideoFrameCallback) {
      cancelDetCb = v.requestVideoFrameCallback(() => step());
    } else {
      cancelDetCb = setTimeout(step, 33);
    }
  }

  function stopDetectionLoop(clear=false){
    detRunning = false;
    const v = vids.Front;
    if (v && v.cancelVideoFrameCallback && cancelDetCb) {
      try { v.cancelVideoFrameCallback(cancelDetCb); } catch {}
    } else if (cancelDetCb) {
      clearTimeout(cancelDetCb);
    }
    cancelDetCb = null;
    if (clear) { clearOverlay(); drawBirdview([]); }
  }

  // ----------------- Birdview -----------------
  function resizeBirdview(){
    const wrap = document.getElementById('birdviewWrap').getBoundingClientRect();
    birdCanvas.width  = Math.max(200, Math.floor(wrap.width));
    birdCanvas.height = Math.max(160, Math.floor(wrap.height));
  }

  function drawBirdview(items){
  // items: [{label, score, dist, bearingRad}]
  const ctx = birdCtx;
  const W = birdCanvas.width, H = birdCanvas.height;
  ctx.clearRect(0,0,W,H);

  if (!birdToggle.checked) return;

  // Desired world extents (meters)
  const rangeM = parseFloat(birdRangeInput.value) || 60; // forward
  const sideM  = Math.max(10, rangeM/2);                 // lateral half-range

  // Drawing margins
  const margin = 14;

  // Available pixels for plotting
  const availYpx = H - 2*margin;   // forward space in px
  const availXpx = W - 2*margin;   // lateral space in px

  // --- Isotropic scale (same m→px for x and y) ---
  // Use the limiting dimension so both axes share the same scale S
  const S = Math.min(availYpx / rangeM, availXpx / (2*sideM)); // px per meter

  // Compute actual pixel extents based on S
  const usedYpx = S * rangeM;        // forward span we can draw
  const usedXpx = S * (2*sideM);     // lateral span we can draw

  // Center plot horizontally; ego at bottom
  const centerX = W/2;
  const leftX   = centerX - usedXpx/2;
  const rightX  = centerX + usedXpx/2;
  const topY    = (H - usedYpx) - margin + usedYpx - usedYpx; // equals margin + (availYpx - usedYpx) but simpler below
  const egoY    = H - margin;        // bottom line for ego
  const topPlotY = egoY - usedYpx;   // top edge of the plot area

  // --- Grid (forward every 10 m, lateral every 5 m) ---
  ctx.strokeStyle = '#2a2a2a';
  ctx.lineWidth = 1;
  ctx.font = '11px system-ui';
  ctx.fillStyle = '#777';

  // Forward gridlines
  for (let m=10; m<=rangeM; m+=10){
    const y = egoY - m*S;
    ctx.beginPath(); ctx.moveTo(leftX, y); ctx.lineTo(rightX, y); ctx.stroke();
    ctx.fillText(`${m} m`, Math.max(4, leftX+4), y-2);
  }
  // Lateral gridlines (centered)
  for (let m=5; m<=sideM; m+=5){
    const xR = centerX + m*S;
    const xL = centerX - m*S;
    ctx.beginPath(); ctx.moveTo(xR, topPlotY); ctx.lineTo(xR, egoY); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(xL, topPlotY); ctx.lineTo(xL, egoY); ctx.stroke();
  }
  // Center line
  ctx.beginPath(); ctx.moveTo(centerX, topPlotY); ctx.lineTo(centerX, egoY); ctx.stroke();

  // Ego vehicle
  //ctx.fillStyle = '#3aa3ff';
  //ctx.strokeStyle = '#3aa3ff';
  //ctx.lineWidth = 2;
  //const egoW=24, egoH=36;
  //ctx.fillRect(centerX-egoW/2, egoY-egoH, egoW, egoH);
  //ctx.beginPath(); ctx.moveTo(centerX-egoW/2, egoY-egoH); ctx.lineTo(centerX+egoW/2, egoY-egoH); ctx.stroke();

  // Plot detections using isotropic S
  for (const it of items){
    const { label, dist, bearingRad, score } = it;
    if (!dist || dist<=0) continue;

    const x_m = Math.sin(bearingRad) * dist; // lateral (right +)
    const y_m = Math.cos(bearingRad) * dist; // forward

    // Skip if outside configured world extents
    if (y_m < 0 || y_m > rangeM || Math.abs(x_m) > sideM) continue;

    const px = centerX + x_m * S;
    const py = egoY  - y_m * S;

    const name = (DISPLAY_LABEL[label] || label);
    const color = CLASS_COLOR[label] || '#e6e6e6';

    ctx.fillStyle = color;
    ctx.beginPath(); ctx.arc(px, py, 6, 0, Math.PI*2); ctx.fill();

    const txt = `${name} • ${round1(dist)} m`;
    ctx.font = '12px system-ui';
    ctx.fillStyle = '#ddd';
    const textX = Math.min(px+8, rightX-110);
    const textY = Math.max(py-8, topPlotY+12);
    ctx.fillText(txt, textX, textY);
  }

  // Plot border
  ctx.strokeStyle = '#333';
  ctx.strokeRect(leftX + 0.5, topPlotY + 0.5, usedXpx - 1, usedYpx - 1);
}

  // --------------- Wire up ---------------
  pickBtn.onclick = pickFolder;
})();
</script>
</body>
</html>
