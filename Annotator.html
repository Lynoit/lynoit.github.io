<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Annotator</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  
  <!-- JSZip for zipping snapshots -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <script>
  // 1) pull in questions from CSV
  function loadMetaQueries() {
    console.log('‚è≥ loading meta-questions‚Ä¶');
    return fetch('Metaqueries.csv')
      .then(r => {
        if (!r.ok) throw new Error('CSV not found');
        return r.text();
      })
      .then(csv => {
        const { data } = Papa.parse(csv, { header: true, skipEmptyLines: true });
        const qs = data.map(r => r.question).filter(q => q);
        renderMetaForm(qs);
      });
  }

  // 2) build the form fields
function renderMetaForm(questions) {
  const form    = document.getElementById('metaForm');
  const submit  = form.querySelector('button[type=submit]');
  const skipBtn = document.getElementById('skipButton');

  // Wire up the Skip button
  skipBtn.addEventListener('click', () => {
    // Populate defaults
    window.metaAnswers = {};
    questions.forEach(q => {
      window.metaAnswers[q] = 'Not filled in';
    });
    // Close overlay, render table, start app
    document.getElementById('metaOverlay').style.display = 'none';
    renderMetaTable();
    startApp();
  });

  // Inject question inputs just before the submit button
  questions.forEach((q, i) => {
    const lbl = document.createElement('label');
    lbl.htmlFor = `mq-${i}`;
    lbl.textContent = q;

    const inp = document.createElement('input');
    inp.id        = `mq-${i}`;
    inp.name      = q;
    inp.required  = true;

    form.insertBefore(lbl, submit);
    form.insertBefore(inp, submit);
  });

  // Handle the OK (submit) action
  form.addEventListener('submit', e => {
    e.preventDefault();
    window.metaAnswers = {};
    questions.forEach(q => {
      window.metaAnswers[q] = form.elements[q].value.trim();
    });
    document.getElementById('metaOverlay').style.display = 'none';
    renderMetaTable();
    startApp();
  });
}

  // 3) show the answers in your new table
  function renderMetaTable() {
    const tbl = document.getElementById('metaTable');
    Object.entries(window.metaAnswers).forEach(([q,a]) => {
      const row = document.createElement('tr');
      row.innerHTML = `<td>${q}</td><td>${a}</td>`;
      tbl.appendChild(row);
    });
  }

  // 4) adjust your onload to kick things off
  window.onload = () => {
    loadMetaQueries().catch(err => {
      console.error('MetaQueries load failed:', err);
      document.getElementById('metaOverlay').style.display = 'none';
      startApp();
    });
  };
</script>

<script defer src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@1.31.0/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle.js"></script>

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; padding: 0; font-family: Arial, sans-serif; }
    #sidebar {
      position: fixed; top: 0; left: 0; height: 100%; width: 182px;
      transform: translateX(-152px); transition: transform .3s ease;
      background: #fff; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto; padding: 50px 10px 10px; z-index: 1000;
    }

    body {
       background-color: #121212;  /* almost-black */
       color: #e0e0e0;
    }

    #sidebar {
      background-color: #121212;
      color: #e0e0e0;
    }

    #sidebar * {
       color: #e0e0e0;
    }

    /* Sidebar slides in/out */
    #sidebar.expanded  { transform: translateX(0); }
    #sidebar.collapsed { transform: translateX(-152px); }

    /* Main content shifts based on sidebar state */
    #sidebar.expanded  ~ #mainContent { margin-left: 202px; }
    #sidebar.collapsed ~ #mainContent { margin-left: 45px; }
    
    #toggleSidebar {
      position: fixed; top: 10px; left: 10px;
      background: #007bff; border: none; color: #fff;
      font-size: 1.5em; padding: 4px 8px; cursor: pointer;
      border-radius: 4px; z-index: 1100;
    }

    .issue-label {
  background: rgba(255, 255, 255, 0.9);
  color: #000;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
    }

    .spinner {
      border: 2px solid rgba(0,0,0,0.1);
      border-left-color: #333;
      border-radius: 50%; width: 16px; height: 16px;
      animation: spin .8s linear infinite; display: inline-block;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #totalDistance.updated { transition: background .5s; background: yellow; }

    .bigButton { display: block; width: 80%; min-width: 80px; padding: 12px; font-size: 14px; border-radius: 4px; cursor: pointer; margin: 8px auto; }
    .orangeButton { background-color: orange; color: white; }
    .blueButton   { background-color: blue;   color: white; }
    .greyButton   { background-color: grey;   color: white; }
    .greenButton  { background-color: green;  color: white; }
    .redButton    { background-color: red;    color: white; }

    #mainContent {
      height: 100vh;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
      transition: margin-left .3s ease;
    }

    /* ‚îÄ‚îÄ Manual Annotation Layout ‚îÄ‚îÄ */
    #manualAnnotation {
  display: grid;
  /* three columns: lamp, growing textarea, annotation-button */
  grid-template-columns: auto 1fr auto;
  /* two rows: voice controls / annotation controls */
  grid-template-rows: auto auto;
  gap: 10px;
  align-items: center;
  margin-bottom: 20px;
}

/* place each element into its cell */
#manualAnnotation #micLamp {
  grid-column: 1;
  grid-row:    1;
}

#manualAnnotation #micToggle {
  grid-column: 2;
  grid-row:    1;
}

#manualAnnotation textarea {
  grid-column: 1 / 3;  /* span columns 1 and 2 */
  grid-row:    2;
  /* keep your existing textarea styling */
  resize: vertical;
  font-size: 14px;
  padding: 8px;
}

#manualAnnotation .blueButton {
  grid-column: 3;
  grid-row:    2;
  /* keep your existing button styling */
  padding: 6px 10px;
  font-size: 12px;
  white-space: nowrap;
}

    table { width: 100%; margin: 10px 0; border-collapse: collapse; }
    td, th { text-align: center; padding: 10px; }
    #logTableContainer table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #logTableContainer table th,
    #logTableContainer table td {
      border: 1px solid #444;
      padding: 6px 8px;
      text-align: center;
    }
    #countTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #countTable th,
    #countTable td {
    border: 1px solid #444 !important;
    padding: 6px 8px;
    text-align: center;
    margin-bottom: 80px;
    }
    #mapContainer {
      margin-bottom: 80px;
    }
    #countContainer {
      margin-bottom: 80px;
    }
    #chartsContainer {
      margin-bottom: 80px;
    }
    #chartsContainer .chartBox + .chartBox {
      margin-top: 80px;
    }
    #streetTable {
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
   #streetTable th,
   #streetTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }

  #statsTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#statsTable th,
#statsTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
  overflow-wrap: anywhere;   /* modern spec */
  word-wrap: break-word;     /* legacy name */
  word-break: break-word;    /* ensure break if no natural wrap point */
  hyphens: auto;             /* enable hyphenation at hyphens */
}

#metaTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;  /* or whatever spacing you prefer */
}
#metaTable th,
#metaTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}

#metaForm {
  background-color: #dddddd;  /* light grey */
  color: #000000;             /* black text */
}

/* Ensure headings, labels and inputs also render in black */
#metaForm h2,
#metaForm label,
#metaForm input,
#metaForm button {
  color: #000000;
}

#countryTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#countryTable th,
#countryTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}
    
    #weatherTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #weatherTable th,
   #weatherTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
   #phaseTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #phaseTable th,
   #phaseTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
 #snapshotTableContainer table {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#snapshotTableContainer table th,
#snapshotTableContainer table td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}
   }

    .center-groups { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }

    .section { margin-bottom: 30px; }
    .page-break { page-break-after: always; }

    /* circular speed-limit sign */
.speedSign{
  width: 46px;
  height: 46px;
  border: 4px solid red;   /* red rim */
  border-radius: 50%;
  background: #fff;        /* white face */
  color: #000;             /* black digits */
  display: flex;
  align-items: center;
  justify-content: center;
  font: bold 14px/1 Arial, sans-serif;
  margin: 6px 0;
}

.speedLimitRow{
  display:flex;
  align-items:center;   /* vertical centring */
  gap:6px;              /* space between label and sign */
}

.speedLabel{
  font-weight: normal;
  font-size: inherit;
}
    
@media print {
  /* reset page‚Äêsizing so we don‚Äôt clip */
  html, body {
    height: auto !important;
    overflow: visible !important;
  }

  /* hide the sidebar and toggle button */
  #sidebar,
  #toggleSidebar {
    display: none !important;
  }

  /* hide everything except mainContent */
  body * {
    visibility: hidden !important;
  }
  #mainContent,
  #mainContent * {
    visibility: visible !important;
  }

  /* stretch mainContent to fill the page and show all of it */
  #mainContent {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    margin: 0 !important;
    width: 100% !important;
    height: auto !important;         /* ‚Üê override the 100vh */
    max-height: none !important;     /* ‚Üê remove any implicit max */
    overflow: visible !important;    /* ‚Üê show all the content */
  }
  }

  /* hide the tiny weather icon in sidebar */
  #weatherIcon {
    display: none !important;
  }

    .distance-label {
  pointer-events: none;
  font-weight: bold;
  background: rgba(255,255,255,0.8);
  padding: 2px 6px;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  white-space: nowrap;
}

 #camera {
  display: none;          /* Removes it from layout */
  /*  (alt ideas)
  visibility: hidden;     Keeps its slot but hides it
  height: 0;
  width: 0;
  */
  #cameraContainer > h3 {
  display: none !important;
  }
}    
  </style>

    <style>
    /* simple full-screen modal */
    #metaOverlay {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex; align-items: center; justify-content: center;
      z-index: 2000;
    }
    #metaForm {
      background: #fff; padding: 20px; border-radius: 8px;
      max-width: 400px; width: 90%;
    }
    #metaForm label { display: block; margin-top: 10px; }
    #metaForm input { width: 100%; padding: 6px; margin-top: 4px; }
    #metaForm button { margin-top: 20px; padding: 8px 12px; }
  </style>
  
</head>
<body>

    <div id="metaOverlay">
    <form id="metaForm">
     <h2>Please fill in test details</h2>
     <!-- question inputs get injected here -->     
     <button type="submit">OK</button>
     <button type="button" id="skipButton">Skip</button>
    </form>
    </div>
  
  <button id="toggleSidebar" aria-expanded="true">‚ò∞</button>
  <div id="sidebar" class="expanded">
    <p id="dateTime"></p>
    <p id="dayPhase">Phase: N/A</p>
    <div class="weatherSection">
      <img id="weatherIcon" src="" alt="Weather">
      <p id="temperature">Temp: N/A</p>
    </div>
    <p id="streetCity">Street: N/A<br>City: N/A<br>Country: N/A</p>
    <p id="location"></p>
    <p id="roadType">Road type: N/A</p>
    <p id="speed">Speed: N/A</p>
    <div class="speedLimitRow">
      <span class="speedLabel">Speed&nbsp;limit:</span>
      <div id="legalSpeed" class="speedSign">‚Äì</div>
    </div>   
    <div class="distanceContainer">
      <p id="totalDistance">Distance: 0.0 km</p>
    </div>
    <button class="bigButton orangeButton" id="uploadNowButton">Upload data to cloud</button>
    <button class="bigButton greenButton" onclick="saveAndPrint()">Save report to PDF</button>
  </div>

  <div id="mainContent">

    <div id="manualAnnotation" class="section">
  <span id="micLamp"
        title="Voice control ready"
        style="display:inline-block;width:10px;height:10px;
               margin-right:6px;border-radius:50%;background:#888;">
  </span>
  <button id="micToggle" class="greyButton" style="width:auto;">
    Start voice control
  </button>

  <textarea id="textBox" rows="2"
            placeholder="Speak after you say ‚ÄúAnnotator‚Äù‚Ä¶">
  </textarea>
  <button class="blueButton"
          onclick="logButton('Manual annotation', false)">
    Manual annotation
  </button>
</div>

    <style>
      /* start hidden */
#buttonGroups {
  display: none;
}
#showButtons:checked ~ #buttonGroups {
  display: flex;
  align-items: flex-start;
  gap: 6px;
}
    </style>

<div
  style="
    margin-bottom: 10px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 6px;
  ">
  <input type="checkbox" id="showButtons" checked>
  <label for="showButtons">Show KPI buttons</label>

  <!-- your new dropdown lives beside the checkbox -->
  <label for="buttonConfig" style="margin-left:8px;">Button setup:</label>
  <select id="buttonConfig">
    <option value="KPI_buttons.csv">ADAS KPI</option>
    <option value="buttons.csv">ADAS KPI (old)</option>
    <option value="Tuning_buttons.csv">China tuning 25w23</option>
    <option value="annotator_gt_buttons.csv">KPI groundtruth</option>
    <option value="annotator_gt_buttons_YN.csv">KPI groundtruth YN</option>
  </select>
  <!-- buildButtons will populate this directly -->
  <div id="buttonGroups" class="center-groups" style="margin-top:6px; margin-bottom:30px;">
   </div>
   </div>

    <div class="page-break"></div>

    <h3>Issue list</h3>
    <div id="logTableContainer" class="section"></div>
    <div class="page-break"></div>

     <div id="snapshotContainer" class="section">
       <h3>Issue Snapshots</h3>
       <div id="snapshotTableContainer"></div>
     </div>
    
    <div id="cameraContainer" class="section">
      <h3 style="display:none">Camera preview</h3>
      <video id="camera" autoplay playsinline
         style="border:1px solid #444;"></video>
      </div>
    
    <canvas id="cameraCanvas" width="320" height="240" style="display:none;"></canvas>

    <div id="countContainer" class="section">
      <h3>KPI Calculation</h3>
      <table id="countTable">
        <tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>
        <tr><td colspan="3">&nbsp;</td></tr>
      </table>
    </div>
    <div class="page-break"></div>
    
    <div id="map2Container" class="section">
      <h3>Street View</h3>
      <div id="map2" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>
    
    <div id="mapContainer" class="section">
      <h3>Route view</h3>
      <div id="map" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>

  <div id="metaContainer" class="section">
    <h3>Test details</h3>
    <table id="metaTable">
      <!-- rows will be injected here -->
    </table>
  </div>
    
    <div id="statsContainer" class="section">
      <h3>Statistics</h3>
      <table id="statsTable">
        <tr><th>Metric</th><th>Value</th></tr>
        <tr><td colspan="2">&nbsp;</td></tr>
      </table>
    </div>

    <div id="streetsContainer" class="section">
      <h3>Road Types</h3>
      <table id="streetTable"><tr><th>Road type</th></tr></table>
    </div>

    <div id="countryContainer" class="section">
       <h3>Countries</h3>
       <table id="countryTable">
       <tr>
         <th>Country</th>
         <th>Distance&nbsp;(km)</th>
         <th>No&nbsp;of&nbsp;issues</th>
       </tr>
       </table>
     </div>

    <div id="weatherContainer" class="section">
      <h3>Weather</h3>
      <table id="weatherTable">
         <tr><th>Condition</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <div id="phaseContainer" class="section">
      <h3>Phase</h3>
      <table id="phaseTable">
         <tr><th>Phase</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <footer style="text-align:center; padding:10px; font-size:12px; color:#666;">
      Ver 1.16
      ¬© Lynoit Tech 2025
    </footer>
  </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-image@0.4.0/leaflet-image.js"></script>

  <script>

    console.log('main script executing');
    
    // DOM refs
    const appStartTime = new Date();
    const metaAnswers = {};
    const toggleBtn = document.getElementById('toggleSidebar');
    const sidebar   = document.getElementById('sidebar');
    const locEl     = document.getElementById('location');
    const roadTypeEl= document.getElementById('roadType');
    const streetCityEl=document.getElementById('streetCity');
    const tempEl    = document.getElementById('temperature');
    const iconEl    = document.getElementById('weatherIcon');
    const distEl    = document.getElementById('totalDistance');
    const speedEl   = document.getElementById('speed');
    const countTbl  = document.getElementById('countTable');
    const streetTbl = document.getElementById('streetTable');
    const countryTable = document.getElementById('countryTable');
    const logContainer = document.getElementById('logTableContainer');
    const buttonGroups = document.getElementById('buttonGroups');
    const micLamp   = document.getElementById('micLamp');
    const textBox   = document.getElementById('textBox');
    const countryDistances  = {};
    const weatherDistances = {};
    const phaseDistances = {};
    const AZURE_KEY    = '31mglZQASLS9g4mcaTvMpznyzYYJyFr7I3ERTm84jeQrPNOlp5tXJQQJ99BEACi5YpzXJ3w3AAAYACOGJuNe';
    const AZURE_REGION = 'northeurope';
    const PHASE_THROTTLE = 5 * 60 * 1000;
    const TABLE_THROTTLE = 30 * 1000;
    const UPLOAD_THROTTLE = 5 * 60 * 1000
    const citySet = new Set();   // unique city names encountered
    const legalSpeedEl = document.getElementById('legalSpeed');
    const samplingTable = [];

    let lastLimit = null;
    let limitChanges = 0;
    let roundaboutCount     = 0;
    let trafficLightCount   = 0;
    let lastWasRoundabout   = false;   // debounce flags
    let lastWasTrafficLight = false;
    let bridgeCount   = 0;
    let tunnelCount   = 0;
    let lastWasBridge = false;   // debounce flags
    let lastWasTunnel = false;
    let bridgeStreak = 0;
    let corrections = {};
    let lastUploadTime = 0;
    
    // ‚îÄ‚îÄ Whitelist of road types we care about ‚îÄ‚îÄ
    const allowedRoadTypes = new Set([
     'motorway','motorway_link',
     'trunk','trunk_link',
     'primary','primary_link',
     'secondary','secondary_link',
     'tertiary','tertiary_link',
     'unclassified','residential','service','construction'
    ]);

    const workbookTables = [
      { id: 'metaTable',    name: 'Test details'  },
      { id: 'logTable',     name: 'Issues'     },
      { id: 'countTable',   name: 'KPI'        },
      { id: 'statsTable',   name: 'Statistics' },
      { id: 'streetTable',  name: 'Road types' },
      { id: 'countryTable', name: 'Country'    },
      { id: 'weatherTable', name: 'Weather'    },
      { id: 'phaseTable',   name: 'Phase'      }
    ];


    let startTime = null;        // timestamp of the first GPS fix (ms)
    const topSpeeds = [];   // running list of the 10 highest samples
    
    let maxSpeed  = 0;    // value that ends up in the Statistics table
    let lastTableUpdate = 0;
    let lastPhaseUpdate = 0;
    let logTable=[], redCounts={}, lastPos=null, totalDist=0;
    let positions=[], timeData=[], distData=[], speedData=[];
    let map, trackLine, distanceChart, speedChart;
    let roadTypes=new Set(), lastChartTs=0, posCount=0, lastCity=null;
    let lastCountry = null;
    let roadDistances = {};
    let currentDistMarker = null;
    let map2, circle2;
    let roadRedCounts = {};
    let countryRedCounts   = {};
    let weatherRedCounts   = {};    // red presses per weather condition
    let phaseRedCounts     = {};    // (optional) red presses per day phase
    let isDirty = false;
    let wakeLock = null;
    let lastSpeedKmh = 0;

    function markDirty() { isDirty = true; }
    function markClean()  { isDirty = false; }

    function formatAppStartTimestamp() {
       const d = appStartTime;
       const pad = n => String(n).padStart(2, '0');
       const YYYY = d.getFullYear();
       const MM   = pad(d.getMonth() + 1);
       const DD   = pad(d.getDate());
       const hh   = pad(d.getHours());
       const mm   = pad(d.getMinutes());
       const ss   = pad(d.getSeconds());
      return `${YYYY}-${MM}-${DD}_${hh}${mm}${ss}`;
    }

    const reportBaseName = `Annotator_report_${formatAppStartTimestamp()}`; 
    
    window.addEventListener('beforeunload', e => {
      if (!isDirty) return;
      e.preventDefault();
      e.returnValue = '';
    });
    
    toggleBtn.onclick = () => {
      const exp = sidebar.classList.toggle('expanded');
      sidebar.classList.toggle('collapsed', !exp);
      toggleBtn.setAttribute('aria-expanded', exp);
    };

    window.onload = () => {
  // 1) load meta-questions & wait for answers
  loadMetaQueries()
    .catch(err => {
      console.error('MetaQueries load failed:', err);
      // if questions can‚Äôt load, skip straight to app
      document.getElementById('metaOverlay').style.display = 'none';
      startApp();
    });
};

  async function requestWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake lock acquired');
        wakeLock.addEventListener('release', () => {
          console.log('Wake lock released');
        });
      } catch (err) {
        console.error('Failed to acquire wake lock:', err);
      }
    } else {
      console.warn('Wake Lock API not supported on this browser');
    }
  }

  async function releaseWakeLock() {
    if (wakeLock) {
      try {
        await wakeLock.release();
        wakeLock = null;
        console.log('Wake lock released manually');
      } catch (err) {
        console.error('Error releasing wake lock:', err);
      }
    }
  }

  document.addEventListener('visibilitychange', () => {
    if (wakeLock !== null && document.visibilityState === 'visible') {
      requestWakeLock();
    }
  });

  function startApp() {
    // 1) Acquire a wake lock right away
    requestWakeLock();
    
  loadCorrections()
    .then(() => console.log('Corrections loaded:', corrections))
    .catch(err => console.warn('Corrections load failed:', err));  
  initMap();
  initMap2();
  updateDateTime();
  setInterval(updateDateTime, 1000);

    // ‚îÄ‚îÄ‚îÄ schedule 30 sec samples for (Timestamp, Lat, Lon, Distance, Speed, Maxspeed) ‚îÄ‚îÄ‚îÄ
setInterval(() => {
  // Only record if we have at least one GPS fix
  if (!lastPos) return;

  // Build a new row
  const rowNo       = samplingTable.length + 1;
  const timestamp   = new Date().toISOString();          // ISO format, e.g. "2025-06-02T14:08:30.123Z"
  const latitude    = lastPos.lat;
  const longitude   = lastPos.lon;
  // totalDist is in meters; convert to kilometers with 3 decimals
  const distanceKm  = (totalDist / 1000).toFixed(3);
  // lastSpeedKmh was stored above
  const speed       = lastSpeedKmh.toFixed(1);
  // maxSpeed is already a Number; record with 1 decimal
  const maxSpd      = maxSpeed.toFixed(1);

  // Push into our hidden sampling table
  samplingTable.push({
    no:        rowNo,
    timestamp: timestamp,
    lat:       latitude,
    lon:       longitude,
    distance:  distanceKm,
    speed:     speed,
    maxspeed:  maxSpd
  });
}, 10 * 1000);  // every 30 000 ms
    
  navigator.geolocation.watchPosition(showPosition, showError, {
    enableHighAccuracy: true,
    maximumAge: 5000,
    timeout: 10000
  });
    const configSelect = document.getElementById('buttonConfig');
  configSelect.addEventListener('change', e => {
    // rebuild with the newly selected CSV
    buildButtons(e.target.value);
  });
  // initial build
  buildButtons(configSelect.value);
  startCamera();
}   

    let recognizer;  // Azure continuous recogniser
    let recogniserReady   = false;   // built at least once?
    let recogniserRunning = false;   // currently listening?

    // ‚îÄ‚îÄ‚îÄ Voice‚Äëcontrol start/stop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('micToggle').onclick = async event => {
  // 1. Build recogniser only the first time the button is pressed
  if (!recogniserReady) {
    await initAzureSpeech();           // creates the recogniser object
    recogniserReady = true;
  }

  // 2. Toggle listening state
  if (recogniserRunning) {
    recognizer.stopContinuousRecognitionAsync();
    recogniserRunning = false;
    micLamp.style.background = '#4caf50';          // üü¢ idle
    event.target.textContent = 'Start voice control';
  } else {
    recognizer.startContinuousRecognitionAsync();
    recogniserRunning = true;
    micLamp.style.background = '#f44336';          // üî¥ listening
    event.target.textContent = 'Stop voice control';
  }
};

function loadCorrections() {
  return fetch('corrections.csv')
    .then(r => r.ok ? r.text() : Promise.reject('CSV load failed'))
    .then(csv => {
      const { data } = Papa.parse(csv, { header: true, skipEmptyLines: true });
      data.forEach(({ misheard, correct }) => {
        if (misheard && correct) corrections[misheard.trim().toLowerCase()] = correct.trim();
      });
    });
}
    
function applyCorrections(text) {
  return text.replace(/\b\w+\b/g, w => corrections[w.toLowerCase()] || w);
}

function updateCountryTable() {
  let html = `
    <tr>
      <th>Country</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  for (const c in countryDistances) {
    const meters = countryDistances[c] || 0;
    const km     = (meters / 1000).toFixed(1);
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';
    const count  = countryRedCounts[c] || 0;

    html += `
      <tr>
        <td>${c}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  countryTable.innerHTML = html;
}

function stripHotWord(text) {
  const match = text.match(/^\s*annotator[,:]?\s*/i);   // any leading spaces
  if (!match) return null;                              // ‚Üê hot‚Äëword not found
  return text.slice(match[0].length).trim();            // rest of the phrase
}

async function initAzureSpeech() {
  console.log('initAzureSpeech started');    //  ‚Üê already added last time?
  const warn = msg => console.warn('Speech init:', msg);

  if (!window.SpeechSDK) {
    warn('SpeechSDK global missing ‚Äì script failed to load?');
    micLamp.style.background = '#ffc107';   // üü°  error
    return;
  }

  let recognizer;
  try {
    const speechConfig = SpeechSDK.SpeechConfig.fromSubscription(
      AZURE_KEY, AZURE_REGION
    );
    speechConfig.speechRecognitionLanguage = 'en-US';
    speechConfig.setProperty(
      SpeechSDK.PropertyId.SpeechServiceResponse_PostProcessingOption,
      'TrueText'
    );

    const audioConfig  = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
    recognizer         = new SpeechSDK.SpeechRecognizer(
      speechConfig, audioConfig
    );
  } catch (e) {
    warn(e);
    micLamp.style.background = '#ffc107';   // üü°
    return;
  }

  /* Lamp colours */
  recognizer.sessionStarted = ()  => micLamp.style.background = '#f44336'; // üî¥ listening
  recognizer.sessionStopped = ()  => micLamp.style.background = '#4caf50'; // üü¢ ready
  recognizer.canceled       = (_,e)=> {
    warn('Canceled: ' + e.errorDetails);
    micLamp.style.background = '#ffc107';   // üü° error
  };

  /* Hot‚Äëword gate */
  recognizer.recognizing = (_,e)=> {
    const draft = stripHotWord(e.result.text);
    if (draft) textBox.value = draft + ' [draft]';
  };
  recognizer.recognized  = (_,e)=> {
    if (e.result.reason !== SpeechSDK.ResultReason.RecognizedSpeech) return;
    const cleaned = stripHotWord(e.result.text);
    if (cleaned) {
      textBox.value = cleaned;
      logButton('Manual annotation', false);
    }
  };

  recognizer.startContinuousRecognitionAsync();
}

 function parseMaxSpeed(tag){
  const m = /(\d+)/.exec(tag);        // first number in the tag
  return m ? m[1] : null;             // e.g. "80"  (null if none)
}
    
  function initMap () {
    map = L.map('map', {
    zoomControl:       false,
    scrollWheelZoom:   false,
    doubleClickZoom:   false,
    touchZoom:         false,
    boxZoom:           false,
    keyboard:          false,
    dragging:          false,   // ‚üµ blocks mouse & touch drag
    tap:               false    // ‚üµ blocks iOS ‚Äútap-drag‚Äù panning
    }).setView([0, 0], 2);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);

    trackLine = L.polyline([], { weight: 4 }).addTo(map);
  }

  /* ‚îÄ‚îÄ Street-view radius map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function initMap2 () {
    map2 = L.map('map2', {
    zoomControl:       false,
    scrollWheelZoom:   false,
    doubleClickZoom:   false,
    touchZoom:         false,
    boxZoom:           false,
    keyboard:          false,
    dragging:          false,
    tap:               false,
    attributionControl:false
    }).setView([0, 0], 18);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors'
    }).addTo(map2);

    circle2 = L.circle([0, 0], { radius: 100, color: 'blue', fillOpacity: 0.1 }).addTo(map2);
    currentPosMarker2 = L.circleMarker([0, 0], { radius: 8, color: 'red', fillColor: 'red', fillOpacity: 1 }).addTo(map2);
  }
    
    function initCharts(){
      distanceChart=new Chart(document.getElementById('distanceChart').getContext('2d'),{type:'line',data:{labels:timeData,datasets:[{label:'Distance (km)',data:distData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'time',time:{unit:'minute',tooltipFormat:'HH:mm:ss'}},y:{beginAtZero:true}}}});
      speedChart=new Chart(document.getElementById('speedChart').getContext('2d'),{type:'line',data:{labels:distData,datasets:[{label:'Speed (km/h)',data:speedData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'linear',title:{display:true,text:'Distance (km)'}},y:{beginAtZero:true,title:{display:true,text:'Speed (km/h)'}}}}});
    }

    function startCamera() {
      const video = document.getElementById('camera');
      if (!navigator.mediaDevices?.getUserMedia) {
        console.warn('getUserMedia not supported');
        return;
    }
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => { video.srcObject = stream; })
      .catch(err   => { console.error('Camera error', err); });
   }
    
  function showPosition(pos) {
  const { latitude: lat, longitude: lon } = pos.coords;
  const ts = pos.timestamp;
  let segDist = 0; // in meters

  if (!startTime) startTime = ts;
    
  // 1) Calculate segment distance & apply noise threshold
  if (lastPos) {
    segDist = calculateDistance(lastPos.lat, lastPos.lon, lat, lon);
    if (segDist < 10) return; // ignore tiny jitters

    // accumulate total and per‚Äêweather
    totalDist += segDist;
    const phaseText = document.getElementById('dayPhase').textContent.split(': ')[1] || 'Unknown';
    phaseDistances[phaseText] = (phaseDistances[phaseText] || 0) + segDist;
    const condition = iconEl.alt || 'Unknown';
    weatherDistances[condition] = (weatherDistances[condition] || 0) + segDist;

        const distKm = (totalDist / 1000).toFixed(2);
    const labelHtml = `<div class="distance-label">${distKm} km</div>`;

    if (!currentDistMarker) {
      currentDistMarker = L.marker([lat, lon], {
        icon: L.divIcon({
          className: '',        // styling lives in .distance-label
          html: labelHtml,
          iconSize: [0, 0],     // let the inner div size itself
          iconAnchor: [0, -10]  // float just above the point
        })
      }).addTo(map);
    } else {
      currentDistMarker.setLatLng([lat, lon]);
      currentDistMarker.setIcon(L.divIcon({
        className: '',
        html: labelHtml,
        iconSize: [0, 0],
        iconAnchor: [0, -10]
      }));
    }    
  }

  // 2) Update position state & map
  const prevPos = lastPos;
  lastPos = { lat, lon, ts };
  posCount++;
  trackLine.addLatLng([lat, lon]);
  if (positions.length === 0) {
    map.setView([lat, lon], 15);
  } else if (posCount % 20 === 0) {
    map.fitBounds(trackLine.getBounds().pad(0.2));
  }
  positions.push([lat, lon]);

  // 3) Update speed display
  if (prevPos) {
    const dt = (ts - prevPos.ts) / 1000; // seconds
    const speedKmh = dt > 0 ? (segDist / dt) * 3.6 : 0;

      /* ‚îÄ‚îÄ reject implausible spikes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  if (speedKmh > 250) {
    console.warn(`Discarded unrealistic speed: ${speedKmh.toFixed(1)} km/h`);
    speedEl.textContent = 'Speed: N/A';
    // skip max-speed bookkeeping and chart push for this sample
  } else {
    /* existing ‚Äúvalid sample‚Äù logic ‚Äî keep exactly as you have it */

    lastSpeedKmh = speedKmh;
    
    // 1. maintain the top-10 speeds list
    topSpeeds.push(speedKmh);
    topSpeeds.sort((a, b) => b - a);
    if (topSpeeds.length > 10) topSpeeds.pop();
    maxSpeed = topSpeeds.length === 10 ? topSpeeds[9] : topSpeeds[0];

    // 2. show live speed read-out
    speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;

    // 3. later (in the chart-update section) you already push
    //    speedData.push(speedKmh);  ‚Üê keep that line; it now runs only here
  }

    if (speedKmh > 0) {                    // ignore the very first 0 km/h
  topSpeeds.push(speedKmh);

  // keep the array sorted descending and trimmed to 10 values
  topSpeeds.sort((a, b) => b - a);
  if (topSpeeds.length > 10) topSpeeds.pop();

  // once we have 10 samples, maxSpeed = the lowest of them
  // (otherwise just use the current highest seen so far)
  maxSpeed = topSpeeds.length === 10
               ? topSpeeds[9]                 // index 9 = smallest of the top 10
               : topSpeeds[0];                // highest sample so far
}
    
    speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;
  }

  // 4) Update distance display & charts
  distEl.textContent = `Distance: ${(totalDist / 1000).toFixed(1)} km`;
  distEl.classList.add('updated');
  setTimeout(() => distEl.classList.remove('updated'), 500);

  if (Date.now() - lastChartTs > 5000) {
    timeData.push(new Date(ts));
    distData.push((totalDist / 1000).toFixed(3));
    speedData.push(speedEl.textContent.split(' ')[1]);
    requestAnimationFrame(() => {
      distanceChart.update();
      speedChart.update();
      maybeUpdateTables();
    });
    lastChartTs = Date.now();
  }

  // 5) Update raw lat/lon display
  locEl.innerHTML = `Lat: ${lat}<br>Lon: ${lon}`;

  const now = Date.now();
  if (now - lastPhaseUpdate > PHASE_THROTTLE) {
    updateDayPhase(lat, lon);
    lastPhaseUpdate = now;
  }

  // 6) Reverse‚Äêgeocode + whitelist + accumulate per‚Äêtype distance
  fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&extratags=1&lat=${lat}&lon=${lon}`)
    .then(r => r.json())
    .then(data => {
      const rawRt = data.extratags?.highway || data.type || 'unknown';
      const displayRt = allowedRoadTypes.has(rawRt) ? rawRt : 'Other';
      const tags = data.extratags || {};

      const isBridge = tags.bridge === 'yes';

        const isRoundabout =
       tags.junction === 'roundabout'
    || tags.highway  === 'mini_roundabout';

  // traffic-light junctions
  const isTrafficLight = tags.highway === 'traffic_signals';

  // tunnels
  const isTunnel      = tags.tunnel === 'yes';

  // now your existing debounce/count logic‚Ä¶
  if (isRoundabout   && !lastWasRoundabout)   roundaboutCount++;
  if (isTrafficLight && !lastWasTrafficLight) trafficLightCount++;
  if (isTunnel       && !lastWasTunnel)       tunnelCount++;

  lastWasRoundabout   = isRoundabout;
  lastWasTrafficLight = isTrafficLight;
  lastWasBridge       = isBridge;
  lastWasTunnel       = isTunnel;

      if (tags.bridge === 'yes') {
  bridgeStreak++;
  if (bridgeStreak === 8) {
    bridgeCount++;
  }
} else {
  bridgeStreak = 0;
}
      
      const maxTag =
      data.extratags?.maxspeed
   || data.extratags?.['maxspeed:forward']
   || data.extratags?.['maxspeed:backward'];

const limit = maxTag ? parseMaxSpeed(maxTag) : null;
legalSpeedEl.textContent = limit ?? '‚Äì';

/* ‚îÄ‚îÄ count speed-limit transitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
if (limit !== null && limit !== lastLimit) {
  if (lastLimit !== null) limitChanges++;   // skip the very first limit
  lastLimit = limit;
}

     if (segDist > 0) {    
       roadDistances[displayRt] =
      (roadDistances[displayRt] || 0) + segDist;
     }

      // update sidebar & sets
      roadTypeEl.textContent = `Road type: ${displayRt}`;
      if (allowedRoadTypes.has(rawRt)) roadTypes.add(rawRt);

      // street & city display
      const street = data.address.road
        || data.address.pedestrian
        || data.address.footway
        || 'Unknown street';
      const city = data.address.city
        || data.address.town
        || data.address.village
        || 'Unknown city';

      const country = data.address.country || 'Unknown country';

      if (segDist > 0) {
         countryDistances[country] = (countryDistances[country] || 0) + segDist;
      }
      
      streetCityEl.innerHTML = `Street: ${street}<br>City: ${city}<br>Country: ${country}`;

      // ‚îÄ‚îÄ NEW: auto‚Äëlog when the country changes ‚îÄ‚îÄ
      if (country !== lastCountry && lastCountry !== null) {
      // Re‚Äëuse the regular logger so it shows up everywhere
      logButton(`Entered ${country}`, false);   // false ‚áí not a KPI ‚Äúred‚Äù event
      }
      lastCountry = country;

      // fetch weather on city change
      if (city !== lastCity) {
        lastCity = city;
        citySet.add(city);
        getWeather(city);
      }

      // refresh all tables
      maybeUpdateTables();
    })
    .catch(err => {
      streetCityEl.textContent = 'Error: ' + err.message;
      console.error('Reverse geocode error', err);
    });

    if (map2) {
      map2.setView([lat, lon], 20);  // zoom level 20 ‚âÉ 100 m across
      currentPosMarker2.setLatLng([lat, lon]);
    }     
}
    
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6_371_000;          // earth‚Äôs radius in meters
      const toRad = Math.PI / 180;
      const œÜ1 = lat1 * toRad;
      const œÜ2 = lat2 * toRad;
      const dœÜ = (lat2 - lat1) * toRad;
      const dŒª = (lon2 - lon1) * toRad;

      const a = Math.sin(dœÜ/2)**2
          + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(dŒª/2)**2;

      // clamp (1 - a) to [0,1] to avoid small floating‚Äëpoint overshoot
      const oneMinusA = Math.max(0, 1 - a);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(oneMinusA));
      return R * c;  // distance in meters
    }
    
function updateStreetTable() {
  // 1) header now has an extra column
  let html = `
    <tr>
      <th>Road type</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  // 2) loop each road type
  for (const rt of roadTypes) {
    const meters = roadDistances[rt] || 0;
    const km     = (meters / 1000).toFixed(1);
    // guard against division by zero
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';

    const count  = roadRedCounts[rt] || 0;

    // 3) inject the new <td> for pct
    html += `
      <tr>
        <td>${rt}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  streetTbl.innerHTML = html;
}

function updateStatsTable () {
  // ‚ë† total test time hh:mm:ss
  const totalMs   = startTime ? (lastPos.ts - startTime) : 0;
  const timeStr   = new Date(totalMs).toISOString().substring(11, 19);

  // ‚ë° total distance & mean speed
  const km        = (totalDist / 1000).toFixed(1);
  const hrs       = totalMs / 3_600_000;
  const meanSpd   = hrs > 0 ? (km / hrs).toFixed(1) : '‚Äî';

  // ‚ë¢ build a ‚ÄúCity1 - City2 - ‚Ä¶‚Äù list
  const citiesList    = Array.from(citySet).join(' - ') || '‚Äî';

  // ‚ë£ build a ‚ÄúCountry1 - Country2 - ‚Ä¶‚Äù list
  const countriesList = Object.keys(countryDistances).join(' - ') || '‚Äî';

  // render the table
  document.getElementById('statsTable').innerHTML = `
    <tr><th>Metric</th><th>Value</th></tr>
    <tr><td>Total test time</td>            <td>${timeStr}</td></tr>
    <tr><td>Total test distance</td>        <td>${km} km</td></tr>
    <tr><td>Max speed</td>                  <td>${maxSpeed.toFixed(1)} km/h</td></tr>
    <tr><td>Mean speed</td>                 <td>${meanSpd} km/h</td></tr>
    <tr><td>Speed limit changes</td>        <td>${limitChanges}</td></tr>
    <tr><td>Roundabouts</td>                <td>${roundaboutCount}</td></tr>
    <tr><td>Traffic-light junctions</td>     <td>${trafficLightCount}</td></tr>
    <tr><td>Bridges</td>                    <td>${bridgeCount}</td></tr>
    <tr><td>Tunnels</td>                    <td>${tunnelCount}</td></tr>
    <tr><td>Cities</td>                     <td>${citiesList}</td></tr>
    <tr><td>Countries</td>                  <td>${countriesList}</td></tr>`;
}
    
 function resetDistance(){totalDist=0;lastPos=null;positions=[];roadTypes.clear();distEl.textContent='Distance: 0.0 km';speedEl.textContent='Speed: N/A';roadTypeEl.textContent = 'Road type: N/A';timeData=[];distData=[];speedData=[];trackLine.setLatLngs([]);map.setView([0,0],2);updateStreetTable();updateCountTable();}
 function saveAndPrint () {
  const btn  = event.currentTarget;
  btn.disabled = true;

  const orig = btn.textContent;
  btn.innerHTML = '<span class="spinner"></span> Generating‚Ä¶';

  // Removed: logButton('Save report to PDF', false);

  // Give the spinner a brief moment to show, then print
  setTimeout(() => {
    window.print();
    btn.disabled  = false;
    btn.textContent = orig;
  }, 500);
}
    function showError(e){locEl.textContent='Error: '+e.message;speedEl.textContent='Speed: N/A';}
    function getWeather(city){fetch(`https://api.weatherapi.com/v1/current.json?key=ad8caecea06c43d1912181938230407&q=${encodeURIComponent(city)}`)
        .then(r=>r.json()).then(d=>{const iconPath=d.current.condition.icon||'';const iconUrl=iconPath.startsWith('//')?'https:'+iconPath:iconPath;iconEl.src=iconUrl;iconEl.alt=d.current.condition.text||'weather';tempEl.textContent=`Temp: ${d.current.temp_c}¬∞C`;}).catch(err=>{tempEl.textContent='Temp: N/A';console.error('Weather error',err);});}

  function logButton(name, isRed) {
    // ‚ë† Timestamp
    const dt   = new Date();
    const date = dt.toLocaleDateString();
    const time = dt.toLocaleTimeString();

    // ‚ë° Phase & weather
    const fullPhase = document.getElementById('dayPhase').textContent;
    const phase     = fullPhase.split(': ')[1] || fullPhase;
    const condition = iconEl.alt || 'Unknown';

    // ‚ë¢ Location
    const [lat, lon] = locEl.innerHTML
      .split('<br>')
      .map(l => l.split(': ')[1]);

    // ‚ë£ Distance, speed, road type
    const dist = (totalDist / 1000).toFixed(1);
    const spd  = speedEl.textContent.split(' ')[1];
    const rt   = roadTypeEl.textContent.split(': ')[1];

    // ‚ë§ Comment (apply corrections just once)
    let comment = document.getElementById('textBox').value;
    comment = applyCorrections(comment);

    // ‚ë• Optional camera snapshot
    let camDataUrl = null;
    try {
const video  = document.getElementById('camera');
const canvas = document.getElementById('cameraCanvas');
const ctx    = canvas.getContext('2d');

// 1) Match canvas to the video‚Äôs actual dimensions
canvas.width  = video.videoWidth  || 640;   // fallback if not ready
canvas.height = video.videoHeight || 480;

// 2) Draw full-resolution frame
ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

// 3) Export at 80% JPEG quality
camDataUrl = canvas.toDataURL('image/jpeg', 0.8);
    } catch (e) {
      console.warn('Camera frame failed', e);
    }

    // ‚ë¶ Push into the log array
    logTable.push([
      name, date, time, phase,
      tempEl.textContent, condition,
      lat, lon, dist, spd, rt,
      comment, camDataUrl
    ]);

    markDirty();

    // ‚ëß Update displays
    displayLogTable();
    displayCameraTable();

      const issueNumber = logTable.length;

  // add marker with number instead of text
  L.marker([+lat, +lon], {
    icon: L.divIcon({
      className: 'issue-label',
      html: `<strong>${issueNumber}</strong>`
    })
  }).addTo(map);

    // ‚ë® If it‚Äôs a ‚Äúred‚Äù KPI event, update counts & tables
    if (isRed) {
      redCounts[name]                    = (redCounts[name]                     || 0) + 1;
      roadRedCounts[rt]                  = (roadRedCounts[rt]                   || 0) + 1;
      countryRedCounts[lastCountry]      = (countryRedCounts[lastCountry]       || 0) + 1;
      weatherRedCounts[condition]        = (weatherRedCounts[condition]         || 0) + 1;
      weatherDistances[condition]        = weatherDistances[condition]         || 0;
      phaseRedCounts[phase]              = (phaseRedCounts[phase]               || 0) + 1;
      phaseDistances[phase]              = phaseDistances[phase]               || 0;

      updateStreetTable();
      updateCountryTable();
      updateWeatherTable();
      updatePhaseTable();
      updateCountTable();
    }

    // ‚ë© Clear the textbox
    document.getElementById('textBox').value = '';
  }

function displayCameraTable() {
  const target = document.getElementById('cameraTableContainer');
  if (!target) return;

  let html = `
    <table>
      <tr><th>No.</th><th>Snapshot</th></tr>`;
  logTable.forEach((row, i) => {
    const img = row[12];          // index of the picture we just added
    const cell = img
      ? `<img src="${img}"
              alt="Camera ${i+1}"
              style="width:320px;height:240px;object-fit:cover;border:1px solid #444;">`
      : '‚Äî';
    html += `<tr><td>${i+1}</td><td>${cell}</td></tr>`;
  });
  html += '</table>';
  target.innerHTML = html;
}
    
function displayLogTable() {
/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   1.  ‚ÄúIssue list‚Äù table (unchanged)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  let mainHtml = `
    <table id="logTable">
      <tr>
        <th>No.</th><th>Issue</th><th>Date</th><th>Time</th>
        <th>Phase</th><th>Temp</th><th>Weather</th>
        <th>Lat</th><th>Lon</th><th>Distance (km)</th>
        <th>Speed (km/h)</th><th>Road</th><th>Comment</th>
      </tr>`;
  logTable.forEach((row, i) => {
    mainHtml += `<tr><td>${i + 1}</td>` +
                row.slice(0, 12).map(v => `<td>${v ?? '‚Äî'}</td>`).join('') +
                `</tr>`;
  });
  mainHtml += `</table>`;
  logContainer.innerHTML = mainHtml;



/* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   2.  ‚ÄúIssue Snapshots‚Äù table
       ‚Üí Leaflet mini-map + camera frame
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  let snapHtml = `
    <table id="snapshotTable"
           style="width:100%;border-collapse:collapse;
                  border:1px solid #444;margin-bottom:80px;">
      <tr>
        <th style="border:1px solid #444;padding:6px 8px;">No.</th>
        <th style="border:1px solid #444;padding:6px 8px;">Issue</th>
        <th style="border:1px solid #444;padding:6px 8px;">Map</th>
        <th style="border:1px solid #444;padding:6px 8px;">Photo</th>
      </tr>`;

  logTable.forEach((row, i) => {
    const [issue,,,,,, lat, lon, , , , , camUrl] = row;

    snapHtml += `
      <tr>
        <td style="border:1px solid #444;padding:6px 8px;">${i + 1}</td>
        <td style="border:1px solid #444;padding:6px 8px;">${issue}</td>

        <!-- map cell gets an empty div we‚Äôll turn into a Leaflet map -->
        <td id="mapcell-${i}"
            style="border:1px solid #444;padding:6px 8px;">
            <div id="snapmap-${i}"
                 style="width:300px;height:200px;"></div>
        </td>

        <td style="border:1px solid #444;padding:6px 8px;">
          ${
            camUrl
              ? `<img src="${camUrl}"
                      alt="Photo ${i + 1}"
                      style="width:300px;height:200px;
                             object-fit:cover;border:1px solid #444;">`
              : '‚Äî'
          }
        </td>
      </tr>`;
  });

  snapHtml += `</table>`;
  document.getElementById('snapshotTableContainer').innerHTML = snapHtml;


/* 3.  Bake each snap-map into a PNG via leaflet-image */
logTable.forEach((row, i) => {
  const lat = parseFloat(row[6]), lon = parseFloat(row[7]);
  const mapId = `snapmap-${i}`;
  // 3.1 Build the live Leaflet map exactly as before
  const mini = L.map(mapId, {
    zoomControl: false,
    attributionControl: false,
    dragging: false,
    scrollWheelZoom: false,
    doubleClickZoom: false,
    boxZoom: false,
    keyboard: false,
    tap: false,
    preferCanvas: true
  }).setView([lat, lon], 17);

   const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
     attribution: '¬© OSM contributors',
     crossOrigin: true
   }).addTo(mini);

  L.circleMarker([lat, lon], {
    radius: 6,
    color: 'red',
    fillColor: 'red',
    fillOpacity: 1
  }).addTo(mini);

  mini.invalidateSize();

   // ‚óã wait until the tile layer has fired its ‚Äúload‚Äù event‚Ä¶
   tiles.once('load', () => {
     // 3.2 Now snapshot it into a canvas ‚Üí PNG
     leafletImage(mini, function(err, canvas) {
  
    if (err) {
      console.error('leaflet-image error', err);
      return;
    }
    const imgUrl = canvas.toDataURL('image/png');

    // 3.3 Swap out the <div> for a real <img>  
    const cell = document.getElementById(`mapcell-${i}`);
    cell.innerHTML = `
      <img
        src="${imgUrl}"
        width="300" height="200"
        style="object-fit:cover;border:1px solid #444;"
        alt="Map snapshot ${i+1}"
      />
    `;

    // 3.4 Tear down the temporary map
    mini.remove();
     });
   });  // ‚Üê end of tiles.once('load')
});
}

  function updateCountTable(){let html='<tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>';const km=totalDist/1000;for(let issue in redCounts){const c=redCounts[issue];const per=km>0?((c/km)*1000).toFixed(1):'‚Äî';html+=`<tr><td>${issue}</td><td>${c}</td><td>${per}</td></tr>`;}countTbl.innerHTML=html;}

    // Build buttons from CSV using fetch + PapaParse
  function buildButtons(csvFile = 'KPI_buttons.csv') {
  // 1. Get the container and clear out any existing buttons
  const buttonGroups = document.getElementById('buttonGroups');
  buttonGroups.innerHTML = '';

  // 2. Fetch & parse the CSV
  fetch(csvFile)
    .then(response => {
      if (!response.ok) {
        throw new Error(`Failed to load ${csvFile}: ${response.status} ${response.statusText}`);
      }
      return response.text();
    })
    .then(csvText => {
      const { data, errors } = Papa.parse(csvText, {
        header: true,
        skipEmptyLines: true
      });
      if (errors.length) {
        console.error('CSV parse errors:', errors);
      }

      // 3. Organize buttons by group
      const groups = {};  // { groupName: <div> }

      data.forEach(row => {
        const {
          group    = '',
          label    = '',
          cssClass = '',
          logName  = label    // fallback if not specified
        } = row;

        if (!group || !label) return;  // skip invalid rows

        // Create a container for this group if needed
        if (!groups[group]) {
          const wrap = document.createElement('div');
          wrap.className = 'button-group';
          buttonGroups.appendChild(wrap);
          groups[group] = wrap;
        }

        // Create the button
        const btn = document.createElement('button');
        btn.textContent = label;
        btn.classList.add('bigButton', ...cssClass.trim().split(/\s+/));

        // Determine whether it's a "red" KPI event
        const isRed = btn.classList.contains('redButton');

        // Wire up the click handler
        btn.addEventListener('click', () => logButton(logName, isRed));

        // Add it to the right group
        groups[group].appendChild(btn);
      });
    })
    .catch(err => {
      console.error('Error building buttons:', err);
    });
}
  
    function updateDayPhase(lat, lon) {
    fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&formatted=0`)
    .then(r => r.json())
    .then(data => {
      const now   = new Date();
      const dawn  = new Date(data.results.civil_twilight_begin);
      const sunrise = new Date(data.results.sunrise);
      const sunset  = new Date(data.results.sunset);
      const dusk    = new Date(data.results.civil_twilight_end);

      let phase;
      if (now < dawn) {
        phase = 'Night';
      } else if (now < sunrise) {
        phase = 'Dawn';
      } else if (now < sunset) {
        phase = 'Daylight';
      } else if (now < dusk) {
        phase = 'Dusk';
      } else {
        phase = 'Night';
      }

      document.getElementById('dayPhase').textContent = `Phase: ${phase}`;
    })
    .catch(err => console.error('Sun API error', err));
}

function updateWeatherTable() {
  let html = `
    <tr>
      <th>Condition</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  for (const cond in weatherDistances) {
    const meters = weatherDistances[cond] || 0;
    const km     = (meters / 1000).toFixed(1);
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';
    const count  = weatherRedCounts[cond] || 0;

    html += `
      <tr>
        <td>${cond}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  document.getElementById('weatherTable').innerHTML = html;
}

const tablesToUpload = [
  'logTable',
  'statsTable',
  'countTable',
  'streetTable',
  'metaTable',
  'countryTable',
  'weatherTable',
  'phaseTable'
];

async function maybeUpdateTables() {
  const now = Date.now();

  // 1) Table updates (unchanged)
  if (now - lastTableUpdate > TABLE_THROTTLE) {
    displayLogTable();
    updateStatsTable();
    updateCountTable();
    updateStreetTable();
    updateCountryTable();
    updateWeatherTable();
    updatePhaseTable();
    uploadSnapshotsZip();
    uploadWorkbookToAzure()
      .then(() => console.log('Workbook auto-uploaded'))
      .catch(err => console.error('Workbook upload failed:', err));
    lastTableUpdate = now;
  }

  // 2) Uploads, but only once every 5 minutes
  if (now - lastUploadTime > UPLOAD_THROTTLE) {
    lastUploadTime = now;
    //uploadWorkbookToAzure()
    //  .then(() => console.log('Workbook auto-uploaded'))
    //  .catch(err => console.error('Workbook upload failed:', err));
    //exportMainContentToAzure()
    //  .then(() => console.log('Main content auto-uploaded'))
    //  .catch(err => console.error('HTML upload failed:', err));
    //exportPDFToAzure()
    //  .then(() => console.log('PDF report uploaded'))
    //  .catch(err => console.error('PDF upload failed:', err));

    exportCustomSectionsToAzure()
      .then(() => console.log('PDF report uploaded'))
      .catch(err => console.error('PDF upload failed:', err));    
  }
}

function updatePhaseTable() {
  let html = `
    <tr>
      <th>Phase</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  for (const ph in phaseDistances) {
    const meters = phaseDistances[ph] || 0;
    const km     = (meters / 1000).toFixed(1);
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';
    const count  = phaseRedCounts[ph] || 0;

    html += `
      <tr>
        <td>${ph}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  document.getElementById('phaseTable').innerHTML = html;
}

    function updateDateTime() { document.getElementById('dateTime').textContent = new Date().toLocaleString();
    }

        function tableToCSV(tableEl) {
      const rows = Array.from(tableEl.querySelectorAll('tr'));
      return rows
        .map(row => {
          const cells = Array.from(row.querySelectorAll('th,td'));
          return cells
            .map(cell => {
              // escape quotes, wrap in quotes
              const txt = cell.textContent.replace(/"/g, '""');
              return `"${txt}"`;
            })
            .join(',');
        })
        .join('\n');
    }

//const containerSasUrl = "https://annotationcsv.blob.core.windows.net/csv?sv=2024-11-04&ss=bfqt&srt=co&sp=rwdlacupiytfx&se=2025-11-19T14:10:22Z&st=2025-05-19T05:10:22Z&spr=https&sig=EUXvbKk2bF2h%2B2cf5fjyVGkasbqBZJb%2FevLVJ6R%2FYCA%3D";
// const containerSasUrl = "https://annotationcsv.blob.core.windows.net/csv?sp=r&st=2025-07-01T05:31:09Z&se=2025-11-30T14:31:09Z&spr=https&sv=2024-11-04&sr=c&sig=HaISxUqexWhVDtK6zfpvsW3DbYzS21yFYu2YTCozd5U%3D";
const containerSasUrl = "https://annotationcsv.blob.core.windows.net/csv?sv=2024-11-04&ss=b&srt=co&sp=rwdlaciytfx&sr=c&se=2025-12-30T15:55:03Z&st=2025-07-01T06:55:03Z&spr=https&sig=NeNMbZI0PsppH4amjEmNcqMI00oC35rO8cV2swmbsyw%3D";
    
async function uploadCSVtoAzure(tableId) {
  // 1. Grab the table and convert to CSV
  const table    = document.getElementById(tableId);
  const csv      = tableToCSV(table);

  // 2. Build a timestamped blob name
  const ts       = formatAppStartTimestamp();          // e.g. "2025-05-19_084215"
  const blobName = `${tableId}-${ts}.csv`;             // e.g. "statsTable-2025-05-19_084215.csv"

  // 3. Split the SAS URL into base and token
  const [baseUrl, token] = containerSasUrl.split('?');

  // 4. Construct the full PUT URL
  const uploadUrl = `${baseUrl}/${blobName}?${token}`;

  // 5. Perform the upload
  const resp = await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
      'x-ms-blob-type': 'BlockBlob',
      'Content-Type':   'text/csv'
    },
    body: csv
  });

  if (!resp.ok) {
    throw new Error(`Upload failed: ${resp.status} ${resp.statusText}`);
  }

  console.log(`‚úî Uploaded ${blobName}`);
}

    async function uploadWorkbookToAzure() {
  // 1. Create a new workbook
  const wb = XLSX.utils.book_new();

  // 2. For each visible table: convert and append
  workbookTables.forEach(({ id, name }) => {
    const tblEl = document.getElementById(id);
    if (!tblEl) {
      console.warn(`Table #${id} not found‚Äîskipping sheet "${name}"`);
      return;
    }

    // 2.1) Convert the HTML table into a worksheet
    const ws = XLSX.utils.table_to_sheet(tblEl);

    // 2.2) If it‚Äôs one of the ‚Äúpercent‚Äù sheets, multiply column C by 100
    if (['Road types', 'Country', 'Weather', 'Phase'].includes(name)) {
      const range = XLSX.utils.decode_range(ws['!ref']);
      for (let row = range.s.r + 1; row <= range.e.r; ++row) {
        const cellRef = XLSX.utils.encode_cell({ r: row, c: 2 });
        const cell = ws[cellRef];
        if (cell && typeof cell.v === 'number') {
          cell.v = cell.v * 100;
        }
      }
    }

    // 2.3) Append that sheet under its given name
    XLSX.utils.book_append_sheet(wb, ws, name);
  });

  // 3. Build and append the hidden "Sampling" sheet
  // 3.1) First row = headers
  const samplingAoA = [
    ["No", "Timestamp", "Latitude", "Longitude", "Distance (km)", "Speed (km/h)", "Legal Speed (km/h)"]
  ];

  // 3.2) One row per entry in samplingTable (each entry must have .legalSpeed)
  samplingTable.forEach(entry => {
    samplingAoA.push([
      entry.no,
      entry.timestamp,
      entry.lat,
      entry.lon,
      entry.distance,
      entry.speed,
      entry.legalSpeed
    ]);
  });

  // 3.3) Convert that array‚Äêof‚Äêarrays into a worksheet and append as "Sampling"
  const wsSampling = XLSX.utils.aoa_to_sheet(samplingAoA);
  XLSX.utils.book_append_sheet(wb, wsSampling, "Sampling");

  // 4. Generate the binary workbook
  const wbout = XLSX.write(wb, {
    bookType: 'xlsx',
    type:      'array'
  });

  // 5. Wrap in a Blob
  const blob = new Blob([wbout], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  });

  // 6. Determine filename using your appStartTime helper
  const blobName = `${reportBaseName}.xlsx`;

  // 7. Build upload URL from containerSasUrl
  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl        = `${baseUrl}/${blobName}?${token}`;

  // 8. PUT to Azure Blob Storage
  const resp = await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
      'x-ms-blob-type': 'BlockBlob',
      'Content-Type':   'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    },
    body: blob
  });

  if (!resp.ok) {
    throw new Error(`Workbook upload failed: ${resp.status} ${resp.statusText}`);
  }

  console.log(`‚úî Uploaded workbook: ${blobName}`);
}
    
  async function exportMainContentToAzure() {
  const mainEl = document.getElementById('mainContent');
  const htmlDoc = `
    <!DOCTYPE html><html lang="en"><head>
      <meta charset="UTF-8"/>
      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
      <title>Annotation Report</title>
      <style>
        /* your critical styles */
        body { font-family: Arial,sans-serif; margin:0; padding:0; }
        #mainContent { padding:20px; }
      </style>
    </head><body>
      ${mainEl.outerHTML}
    </body></html>`.trim();

  const blob = new Blob([htmlDoc], { type: 'text/html' });
  const blobName = `${reportBaseName}.html`;  // same base, different extension

  // build uploadUrl from your containerSasUrl
  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl        = `${baseUrl}/${blobName}?${token}`;

  const resp = await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
      'x-ms-blob-type': 'BlockBlob',
      'Content-Type':   'text/html'
    },
    body: blob
  });

  if (!resp.ok) {
    throw new Error(`HTML export failed: ${resp.status} ${resp.statusText}`);
  }
  console.log(`‚úî Uploaded HTML report: ${blobName}`);
}

async function exportPDFToAzure() {
  // 0) Locate the live map and its parent wrapper
  const map2El     = document.getElementById('map2');
  const wrapper    = map2El.parentElement;  
  const reportName = `${reportBaseName}.pdf`;

  // 1) Ensure there‚Äôs a hidden snapshot container alongside #map2
  let snapEl = wrapper.querySelector('#map2-snapshot');
  if (!snapEl) {
    snapEl = document.createElement('div');
    snapEl.id = 'map2-snapshot';
    snapEl.style.display = 'none';
    snapEl.style.width  = map2El.style.width  || '100%';
    snapEl.style.height = map2El.style.height || 'auto';
    wrapper.appendChild(snapEl);
  }

  // 2) Render the live map into the hidden container
  await new Promise(resolve => {
    leafletImage(map2, (err, canvas) => {
      if (!err && canvas) {
        const imgUrl = canvas.toDataURL('image/png');
        snapEl.innerHTML = `
          <img
            src="${imgUrl}"
            alt="Street View Snapshot"
            style="width:100%; height:auto; object-fit:cover;"
          >
        `;
      }
      resolve();
    });
  });

  // 3) Swap visibility: hide live map, show snapshot
  map2El.style.display  = 'none';
  snapEl.style.display  = 'block';

  // 4) Expand mainContent for HTML‚ÜíPDF
  const mainEl      = document.getElementById('mainContent');
  const origHeight  = mainEl.style.height;
  const origOverflow= mainEl.style.overflow;
  mainEl.style.height   = 'auto';
  mainEl.style.overflow = 'visible';

  try {
    // 5) Generate the PDF blob with html2pdf
    const opt = {
      margin:       0.2,
      filename:     reportName,
      image:        { type: 'jpeg', quality: 0.98 },
      html2canvas:  { scale: 1.5, useCORS: true },
      jsPDF: {
        unit:        'in',
        format:      'a4',
        orientation: 'landscape'
      }
    };
    const pdfBlob = await html2pdf().set(opt).from(mainEl).outputPdf('blob');

    // 6) Upload to Azure
    const [baseUrl, token] = containerSasUrl.split('?');
    const uploadUrl        = `${baseUrl}/${reportName}?${token}`;
    const resp = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'x-ms-blob-type': 'BlockBlob',
        'Content-Type':   'application/pdf'
      },
      body: pdfBlob
    });
    if (!resp.ok) {
      throw new Error(`PDF upload failed: ${resp.status} ${resp.statusText}`);
    }
  } finally {
    // 7) Restore everything: mainContent style, swap map back
    mainEl.style.height   = origHeight;
    mainEl.style.overflow = origOverflow;
    snapEl.style.display  = 'none';
    map2El.style.display  = 'block';
  }
}

// 1) List the IDs you want to include, in order
const SECTIONS_TO_EXPORT = [
  'metaContainer',         // Test details
  'statsContainer',        // Statistics
  'logTableContainer',     // Issue list
  'snapshotContainer',     // Issue Snapshots
  'countContainer',        // KPI Calculation
  'mapContainer',          // Route view
  'streetsContainer',      // Road Types
  'countryContainer',      // Countries
  'weatherContainer',      // Weather
  'phaseContainer',        // Phase
  'chartsContainer'        // Charts (gets replaced with images)
];

let sectionTexts = {};
  async function loadSectionTexts() {
    try {
      const resp = await fetch('sectionTexts.json');
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      sectionTexts = await resp.json();
    } catch (err) {
      console.warn('Could not load section-text mapping:', err);
      sectionTexts = {};
    }
  }

  async function exportCustomSectionsToAzure() {
  // 0) Load your external section-texts JSON
  await loadSectionTexts();

  // 1) Prep blob name & upload URL
  const blobName = `${reportBaseName}.pdf`;
  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl       = `${baseUrl}/${blobName}?${token}`;

  // 2) Create off-DOM wrapper sized to A4 width
  const tmp = document.createElement('div');
  tmp.id = 'pdf-custom-clone';
  Object.assign(tmp.style, {
    position:   'relative',
    width:      '180mm',      /* tightened from 190mm */
    margin:     '0 auto',
    background: '#fff',
    boxSizing:  'border-box',
  });
  document.body.appendChild(tmp);

  // 3) Inject CSS for headings, paragraphs, tables, snapshot-table column widths
  const style = document.createElement('style');
  style.textContent = `
    #pdf-custom-clone h2 {
      font-size: 18px;
      margin: 0.5em 0 0.2em;
    }
    #pdf-custom-clone p {
      font-size: 11px;
      margin: 0 0 8px;
    }
    #pdf-custom-clone table {
      width: 100% !important;
      table-layout: fixed;
      word-wrap: break-word;
      font-size: 9px;
      border-collapse: collapse;
    }
    #pdf-custom-clone th,
    #pdf-custom-clone td {
      padding: 4px;
      border: 1px solid #444;
      vertical-align: top;
    }
    /* Snapshot table: tighten first two cols, expand last two */
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(1),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(1),
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(2),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(2) {
      width: 5%;
    }
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(3),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(3),
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(4),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(4) {
      width: 45%;
    }
    .page-break { page-break-after: always; }
  `;
  tmp.appendChild(style);

  // 4) Clone each section in order, injecting header/text first
  SECTIONS_TO_EXPORT.forEach((id, idx) => {
    // 4a) Insert custom header + text if present
    const info = sectionTexts[id];
    if (info) {
      const h2 = document.createElement('h2');
      h2.textContent = info.header;
      tmp.appendChild(h2);
      const p = document.createElement('p');
      p.textContent = info.text;
      tmp.appendChild(p);
    }

    // 4b) Render charts as images, or clone the DOM section
    if (id === 'chartsContainer') {
      const wrapper = document.createElement('div');
      wrapper.id = 'chartsContainer';

      // Distance vs Time chart
      const distImg = new Image();
      distImg.src   = distanceChart.toBase64Image();
      distImg.style.width = '100%';
      wrapper.appendChild(distImg);

      // Page-break between charts
      wrapper.appendChild(Object.assign(document.createElement('div'), { className: 'page-break' }));

      // Speed vs Distance chart
      const speedImg = new Image();
      speedImg.src   = speedChart.toBase64Image();
      speedImg.style.width = '100%';
      wrapper.appendChild(speedImg);

      tmp.appendChild(wrapper);
    } else {
      const src = document.getElementById(id);
      if (src) {
        const clone = src.cloneNode(true);
        // Strip out interactive elements
        clone.querySelectorAll('button,input').forEach(n => n.remove());
        tmp.appendChild(clone);
      }
    }

    // 4c) Insert a page-break after each section (except last)
    if (idx < SECTIONS_TO_EXPORT.length - 1) {
      const pbr = document.createElement('div');
      pbr.className = 'page-break';
      tmp.appendChild(pbr);
    }
  });

  // 5) Prepare for html2canvas/pdf
  const htmlEl = document.documentElement;
  const bodyEl = document.body;
  const origHtmlOv = htmlEl.style.overflow;
  const origBodyOv = bodyEl.style.overflow;
  htmlEl.style.overflow = 'visible';
  bodyEl.style.overflow = 'visible';

  // 6) Generate PDF blob
  let pdfBlob;
  try {
    const opt = {
      margin:      5,
      filename:    blobName,
      image:       { type:'jpeg', quality:0.98 },
      html2canvas: { scale:1, useCORS:true, scrollX:0, scrollY:0 },
      jsPDF:       { unit:'mm', format:'a4', orientation:'portrait' }
    };
    pdfBlob = await html2pdf().set(opt).from(tmp).outputPdf('blob');
  } catch (err) {
    console.error('PDF generation failed:', err);
  } finally {
    htmlEl.style.overflow = origHtmlOv;
    bodyEl.style.overflow = origBodyOv;
    document.body.removeChild(tmp);
  }
  if (!pdfBlob) return;

  // 7) Upload PDF to Azure Blob Storage
  try {
    const resp = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'x-ms-blob-type': 'BlockBlob',
        'Content-Type':   'application/pdf'
      },
      body: pdfBlob
    });
    if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
    console.log(`‚úî Uploaded custom PDF as ${blobName}`);
  } catch (err) {
    console.error('Custom PDF upload failed:', err);
  }
}

async function uploadSnapshotsZip() {
  console.log('üíæ uploadSnapshotsZip() called; logTable.length =', logTable.length);
  const zip = new JSZip();

  logTable.forEach((row, i) => {
    const dataUrl = row[12];
    if (!dataUrl) return;   // skip if no snapshot

    const [meta, base64] = dataUrl.split(',');
    const ext = meta.includes('png') ? 'png' : 'jpg';
    const filename = `${i+1}.${ext}`;    // 1.jpg, 2.jpg, 3.jpg, ‚Ä¶

    zip.file(filename, base64, { base64: true });
  });

  const content = await zip.generateAsync({ type: 'blob' });

  // Use the same base name as your PDF/XLSX, but with .zip
  const blobName = `${reportBaseName}.zip`;

  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl        = `${baseUrl}/${blobName}?${token}`;

  const resp = await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
      'x-ms-blob-type': 'BlockBlob',
      'Content-Type':   'application/zip'
    },
    body: content
  });
  if (!resp.ok) {
    throw new Error(`Snapshot ZIP upload failed: ${resp.status} ${resp.statusText}`);
  }
  console.log(`‚úî Uploaded snapshots ZIP as ${blobName}`);
}
    
// 1) Grab the existing Upload button
const uploadNowBtn = document.getElementById('uploadNowButton');

// 2) Helper to show a brief spinner state (you already have this)
function withSpinner(btn, fn) {
  const orig = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Uploading‚Ä¶';
  return fn()
    .catch(err => console.error('Manual upload failed:', err))
    .finally(() => {
      btn.disabled = false;
      btn.innerHTML = orig;
    });
}

// 3) Wire it all together
uploadNowBtn.addEventListener('click', () => {
  withSpinner(uploadNowBtn, async () => {
    // upload the XLSX
    await uploadWorkbookToAzure();

    // upload the full PDF
    //await exportPDFToAzure();

    // upload *your* custom-sections PDF
    await uploadSnapshotsZip();

    console.log('‚úî All uploads complete');
  });
});

    
  function updateSnapshotTable() {
  const container = document.getElementById('snapshotTableContainer');
  if (!container) return;
  
  // start the table
  let html = `
    <table>
      <tr>
        <th>No.</th>
        <th>Snapshot</th>
        <th>Issue</th>
      </tr>`;

  // one row per log entry
  logTable.forEach((row, i) => {
    const [ name,, , , , , lat, lon ] = row;
    // build a URL for a small static map centered on [lat,lon]
    const mapUrl = 
      `https://staticmap.openstreetmap.de/staticmap.php`
      + `?center=${lat},${lon}`
      + `&zoom=17`
      + `&size=300x200`
      + `&markers=${lat},${lon},red-pushpin`;

    html += `
      <tr>
        <td>${i+1}</td>
        <td>
          <img 
            src="${mapUrl}" 
            alt="Map at ${lat},${lon}" 
            style="width:300px; height:200px; object-fit:cover; border:1px solid #ccc;"
          />
        </td>
        <td>${name}</td>
      </tr>`;
  });

  html += `</table>`;
  container.innerHTML = html;
}
    
  </script>
</body>
</html>
