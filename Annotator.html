<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Annotator</title>

  <link rel="icon" type="image/svg+xml" href="/favicon_speed_A_carbon_bold.svg">
  <link rel="alternate icon" href="/favicon.ico">

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  
  <!-- JSZip for zipping snapshots -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <script>
  // 1) pull in questions from CSV
  function loadMetaQueries() {
    console.log('‚è≥ loading meta-questions‚Ä¶');
    return fetch('Metaqueries.csv')
      .then(r => {
        if (!r.ok) throw new Error('CSV not found');
        return r.text();
      })
      .then(csv => {
        const { data } = Papa.parse(csv, { header: true, skipEmptyLines: true });
        const qs = data.map(r => r.question).filter(q => q);
        renderMetaForm(qs);
      });
  }

  // 2) build the form fields
function renderMetaForm(questions) {
  const form    = document.getElementById('metaForm');
  const submit  = form.querySelector('button[type=submit]');
  const skipBtn = document.getElementById('skipButton');

  // Wire up the Skip button
skipBtn.addEventListener('click', async () => {
  // Populate defaults
  window.metaAnswers = {};
  questions.forEach(q => {
    window.metaAnswers[q] = 'Not filled in';
  });

  // üîã request wake lock on a user gesture
  try { await requestWakeLock(); } catch (e) { console.warn(e); }

  // Close overlay, render table, start app
  document.getElementById('metaOverlay').style.display = 'none';
  renderMetaTable();
  startApp();
});

  // Inject question inputs just before the submit button
  questions.forEach((q, i) => {
    const lbl = document.createElement('label');
    lbl.htmlFor = `mq-${i}`;
    lbl.textContent = q;

    const inp = document.createElement('input');
    inp.id        = `mq-${i}`;
    inp.name      = q;
    inp.required  = true;

    form.insertBefore(lbl, submit);
    form.insertBefore(inp, submit);
  });

// Handle the OK (submit) action
form.addEventListener('submit', async e => {
  e.preventDefault();
  window.metaAnswers = {};
  questions.forEach(q => {
    window.metaAnswers[q] = form.elements[q].value.trim();
  });

  // üîã request wake lock on a user gesture
  try { await requestWakeLock(); } catch (e) { console.warn(e); }

  document.getElementById('metaOverlay').style.display = 'none';
  renderMetaTable();
  startApp();
});
}

  // 3) show the answers in your new table
  function renderMetaTable() {
    const tbl = document.getElementById('metaTable');
    Object.entries(window.metaAnswers).forEach(([q,a]) => {
      const row = document.createElement('tr');
      row.innerHTML = `<td>${q}</td><td>${a}</td>`;
      tbl.appendChild(row);
    });
  }

  // 4) adjust your onload to kick things off
  window.onload = () => {
    loadMetaQueries().catch(err => {
      console.error('MetaQueries load failed:', err);
      document.getElementById('metaOverlay').style.display = 'none';
      startApp();
    });
  };
</script>

<script defer src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@1.31.0/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle.js"></script>

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; padding: 0; font-family: Arial, sans-serif; }
    #sidebar {
      position: fixed; top: 0; left: 0; height: 100%; width: 182px;
      transform: translateX(-152px); transition: transform .3s ease;
      background: #fff; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto; padding: 50px 10px 10px; z-index: 1000;
    }

    body {
       background-color: #121212;  /* almost-black */
       color: #e0e0e0;
    }

    #sidebar {
      background-color: #121212;
      color: #e0e0e0;
    }

    #sidebar * {
       color: #e0e0e0;
    }

    /* Make the speed-limit digits bold, black, and larger */
#sidebar .speedSign {
  color: #000;          /* override the gray from #sidebar * */
  font-weight: 900;
  font-size: 20px;      /* tweak 18‚Äì24px to taste */
  line-height: 1;       /* keeps it snugly centered */
  text-shadow: 0 0 1px rgba(0,0,0,.35);  /* subtle crispness (optional) */
}

    /* keep sidebar fixed, no scrolling here */
#sidebar{
  position: fixed; top: 0; left: 0; width: 182px; height: 100%;
  transform: translateX(-152px); transition: transform .3s ease;
  background: #121212; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
  padding: 50px 10px 10px; z-index: 1000;
  /* IMPORTANT: let the inner element handle scrolling */
  overflow: hidden;
}

/* the scrollable area */
#sidebarScroll{
  height: calc(100% - 60px);   /* 50px top padding + a little buffer */
  overflow-y: auto;
  -webkit-overflow-scrolling: touch; /* mobile smooth scroll */
  padding-bottom: 120px;       /* breathing room for bottom buttons */
}

/* sidebar state still controls main content offset */
#sidebar.expanded  ~ #mainContent { margin-left: 202px; }
#sidebar.collapsed ~ #mainContent { margin-left: 45px; }


    /* Sidebar slides in/out */
    #sidebar.expanded  { transform: translateX(0); }
    #sidebar.collapsed { transform: translateX(-152px); }

    /* Main content shifts based on sidebar state */
    #sidebar.expanded  ~ #mainContent { margin-left: 202px; }
    #sidebar.collapsed ~ #mainContent { margin-left: 45px; }
    
    .issue-label {
  background: rgba(255, 255, 255, 0.9);
  color: #000;
  font-weight: bold;
  padding: 2px 6px;
  border-radius: 4px;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
  white-space: nowrap;
    }

    .spinner {
      border: 2px solid rgba(0,0,0,0.1);
      border-left-color: #333;
      border-radius: 50%; width: 16px; height: 16px;
      animation: spin .8s linear infinite; display: inline-block;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #totalDistance { transition: opacity .25s; }
    #totalDistance.updated { opacity: 0.6; }

    .bigButton { display: block; width: 80%; min-width: 80px; padding: 12px; font-size: 14px; border-radius: 4px; cursor: pointer; margin: 8px auto; }
    .orangeButton { background-color: orange; color: white; }
    .blueButton   { background-color: blue;   color: white; }
    .greyButton   { background-color: grey;   color: white; }
    .greenButton  { background-color: green;  color: white; }
    .redButton    { background-color: red;    color: white; }

/* --- Subtle gradient greys for secondary buttons (overrides) --- */
.bigButton.blueButton,
.bigButton.greyButton{
  color:#c9d1d9;
  border:1px solid #30363d;
  background:#21262d; /* fallback */
  background-image: linear-gradient(#2b3138, #1f242b); /* light‚Üídark */
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.04), /* top highlight */
    0 1px 0 rgba(1,4,9,0.1);              /* outer edge */
}

.bigButton.blueButton:hover,
.bigButton.greyButton:hover{
  background:#30363d; /* fallback */
  background-image: linear-gradient(#343b43, #232a31);
  border-color:#8b949e;
}

.bigButton.blueButton:active,
.bigButton.greyButton:active{
  background:#161b22; /* fallback */
  background-image: linear-gradient(#1a1f26, #11161c);
  box-shadow:
    inset 0 1px 0 rgba(0,0,0,0.25),
    0 1px 0 rgba(1,4,9,0.08);
  transform: translateY(1px);
}

.bigButton.blueButton:focus-visible,
.bigButton.greyButton:focus-visible{
  outline:2px solid #1f6feb;
  outline-offset:2px;
}

/* Small note icon on tri-toggles that have a custom annotation */
.toggleButton[data-has-note="1"]::after {
  content: "üìù";
  margin-left: 6px;
  font-size: 0.85em;
}

    /* Keep its position, but borrow the bigButton.blueButton styling */
#toggleSidebar {
  position: fixed;
  top: 10px;
  left: 10px;
  z-index: 1100;
}

/* Size it like a compact button (not full-width) */
#toggleSidebar.bigButton {
  min-width: 0;
  width: auto;
  padding: 6px 10px;
  border-radius: 6px;
  line-height: 1;
}
    
  /* --- Toggle pill styles (dark mode friendly) --- */
  .toggleButton {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 10px 12px;
    border-radius: 999px;
    border: 1px solid #555;
    background: #2a2a2a;
    color: #e0e0e0;
    user-select: none;
  }
  .toggleButton .track {
    position: relative;
    width: 44px; height: 24px;
    border-radius: 999px;
    background: #555;
    transition: background .15s ease;
  }
  .toggleButton .thumb {
    position: absolute;
    top: 2px; left: 2px;
    width: 20px; height: 20px;
    border-radius: 50%;
    background: #e0e0e0;
    transition: left .15s ease;
  }
  .toggleButton[aria-checked="true"] .track { background: #2e7d32; }
  .toggleButton[aria-checked="true"] .thumb { left: 22px; }
  .toggleButton:focus-visible { outline: 2px solid #90caf9; outline-offset: 2px; }

    /* === Column layout for KPI button groups === */
#buttonGroups{
  display:flex;
  align-items:flex-start;
  gap:16px;               /* space between columns */
  flex-wrap:wrap;         /* allow multiple rows of columns if needed */
}

/* each group becomes a column */
.button-group{
  display:flex;
  flex-direction:column;  /* stack buttons vertically */
  align-items:stretch;
  width:260px;            /* column width; tweak to taste (220‚Äì300px) */
}

/* make buttons fill the column width */
.button-group .bigButton{
  width:100%;
  min-width:0;            /* cancel the 80% min-width from the global rule */
  text-align:left;        /* optional: left-align labels */
}

/* style for the grey header button at the top of each column */
.button-group .group-header{
  margin-bottom:8px;      /* spacing below header */
  cursor:default;         /* feels like a label */
}

    /* Container already flex row via .center-groups */
.button-group{
  display:flex;
  flex-direction:column;
  gap:10px;
  min-width:280px; /* adjust as needed */
}

/* Align the top control bar and buttons container vertically */
#buttonGroups {
  display: flex;
  flex-wrap: wrap;
  gap: 16px;
  margin-top: 12px;          /* spacing below the dropdown row */
  align-items: flex-start;
}

/* Each column (group) */
.button-group {
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-width: 220px;          /* consistent column width */
}

/* Optional: center the whole block if wide screen */
.center-groups {
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start; /* left align columns under the controls */
  width: 100%;
}
   

    #mainContent {
      height: 100vh;
      overflow-y: auto;
      padding: 20px;
      box-sizing: border-box;
      transition: margin-left .3s ease;
    }

/* base transitions */
#dayPhase, #temperature, #location, #roadType, #xlsxAgo, #totalDistance {
  transition: opacity .25s;
}
/* nudge state */
#dayPhase.updated, #temperature.updated, #location.updated,
#roadType.updated, #xlsxAgo.updated, #totalDistance.updated {
  opacity: 0.6;
}
    
    /* ‚îÄ‚îÄ Manual Annotation Layout ‚îÄ‚îÄ */
    #manualAnnotation {
  display: grid;
  /* three columns: lamp, growing textarea, annotation-button */
  grid-template-columns: auto 1fr auto;
  /* two rows: voice controls / annotation controls */
  grid-template-rows: auto auto;
  gap: 10px;
  align-items: center;
  margin-bottom: 20px;
}

/* place each element into its cell */
#manualAnnotation #micLamp {
  grid-column: 1;
  grid-row:    1;
}

#manualAnnotation #micToggle {
  grid-column: 2;
  grid-row:    1;
}

#manualAnnotation textarea {
  grid-column: 1 / 3;  /* span columns 1 and 2 */
  grid-row:    2;
  /* keep your existing textarea styling */
  resize: vertical;
  font-size: 14px;
  padding: 8px;
}

#manualAnnotation .blueButton {
  grid-column: 3;
  grid-row:    2;
  /* keep your existing button styling */
  padding: 6px 10px;
  font-size: 12px;
  white-space: nowrap;
}

/* Make Start voice control align left even with .bigButton styles */
#manualAnnotation #micToggle {
  justify-self: start;        /* align left in its grid cell */
  margin-left: 0 !important;  /* kill the auto-centering */
  margin-right: 0 !important;
  width: auto !important;     /* don't use the 80% width from .bigButton */
}

    table { width: 100%; margin: 10px 0; border-collapse: collapse; }
    td, th { text-align: center; padding: 10px; }
    #logTableContainer table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #logTableContainer table th,
    #logTableContainer table td {
      border: 1px solid #444;
      padding: 6px 8px;
      text-align: center;
    }
/* Placeholder-style hint inside editable comment cells */
.commentCell {
  position: relative;
}

/* Show hint text only when the cell is marked .empty */
.commentCell.empty::before {
  content: "Click to add/edit comment";
  position: absolute;
  left: 6px;
  top: 50%;
  transform: translateY(-50%);
  color: #888;
  font-size: 11px;
  font-style: italic;
  pointer-events: none;   /* don‚Äôt block clicks */
  white-space: nowrap;
}
    #countTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #countTable th,
    #countTable td {
    border: 1px solid #444 !important;
    padding: 6px 8px;
    text-align: center;
    margin-bottom: 80px;
    }
    #mapContainer {
      margin-bottom: 80px;
    }
    #countContainer {
      margin-bottom: 80px;
    }
    #chartsContainer {
      margin-bottom: 80px;
    }
    #chartsContainer .chartBox + .chartBox {
      margin-top: 80px;
    }
    #streetTable {
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
   #streetTable th,
   #streetTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }

  #statsTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#statsTable th,
#statsTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
  overflow-wrap: anywhere;   /* modern spec */
  word-wrap: break-word;     /* legacy name */
  word-break: break-word;    /* ensure break if no natural wrap point */
  hyphens: auto;             /* enable hyphenation at hyphens */
}

#metaTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;  /* or whatever spacing you prefer */
}
#metaTable th,
#metaTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}

#metaForm {
  background-color: #dddddd;  /* light grey */
  color: #000000;             /* black text */
}

/* Ensure headings, labels and inputs also render in black */
#metaForm h2,
#metaForm label,
#metaForm input,
#metaForm button {
  color: #000000;
}

#countryTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#countryTable th,
#countryTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}
    
    #weatherTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #weatherTable th,
   #weatherTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
   #phaseTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #phaseTable th,
   #phaseTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
 #snapshotTableContainer table {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#snapshotTableContainer table th,
#snapshotTableContainer table td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}
   }

    .center-groups { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }

    .section { margin-bottom: 30px; }
    .page-break { page-break-after: always; }

    /* circular speed-limit sign */
.speedSign{
  width: 46px;
  height: 46px;
  border: 4px solid red;   /* red rim */
  border-radius: 50%;
  background: #fff;        /* white face */
  color: #000;             /* black digits */
  display: flex;
  align-items: center;
  justify-content: center;
  font: bold 14px/1 Arial, sans-serif;
  margin: 6px 0;
}

.speedLimitRow{
  display:flex;
  align-items:center;   /* vertical centring */
  gap:6px;              /* space between label and sign */
}

.speedLabel{
  font-weight: normal;
  font-size: inherit;
}

/* --- GitHub-like button styles mapped onto your existing classes --- */

/* Base */
.bigButton{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  padding:8px 14px;
  font-size:14px;
  font-weight:600;
  border-radius:6px;
  border:1px solid transparent;
  cursor:pointer;
  user-select:none;
  text-decoration:none;
  width:auto;              /* no more full-width look */
  min-width:120px;
  line-height:1.2;
  box-shadow:0 1px 0 rgba(1,4,9,0.1);
  transition:
    background-color .12s ease,
    border-color .12s ease,
    box-shadow .12s ease,
    transform .02s ease;
}

/* Secondary (gray) ‚Äî use your .blueButton OR .greyButton class */
.bigButton.blueButton,
.bigButton.greyButton{
  background:#21262d;            /* GitHub dark secondary */
  color:#c9d1d9;
  border-color:#30363d;
}
.bigButton.blueButton:hover,
.bigButton.greyButton:hover{
  background:#30363d;
  border-color:#8b949e;
}
.bigButton.blueButton:active,
.bigButton.greyButton:active{
  background:#161b22;
  transform:translateY(1px);
}
.bigButton.blueButton:focus-visible,
.bigButton.greyButton:focus-visible{
  outline:2px solid #1f6feb;     /* blue focus ring */
  outline-offset:2px;
}

/* Primary (green) ‚Äî use your .greenButton class */
.bigButton.greenButton{
  background:#2da44e;            /* GitHub green */
  color:#fff;
  border-color:#1f6b33;
  box-shadow:0 1px 0 rgba(1,4,9,0.1), inset 0 1px 0 rgba(255,255,255,0.03);
}
.bigButton.greenButton:hover{
  background:#2c974b;
  border-color:#1e6a33;
}
.bigButton.greenButton:active{
  background:#298e46;
  transform:translateY(1px);
}
.bigButton.greenButton:focus-visible{
  outline:2px solid rgba(46,164,79,.55);
  outline-offset:2px;
}

/* Danger (red) ‚Äî keep your .redButton for destructive actions */
.bigButton.redButton{
  background:#d1242f;
  color:#fff;
  border-color:#8a1820;
}
.bigButton.redButton:hover{
  background:#b81f2a;
}
.bigButton.redButton:active{
  background:#a31c26;
  transform:translateY(1px);
}
.bigButton.redButton:focus-visible{
  outline:2px solid rgba(209,36,47,.55);
  outline-offset:2px;
}

/* Warning/attention (optional ‚Äì maps your .orangeButton) */
.bigButton.orangeButton{
  background:#9e6a03;
  color:#fff;
  border-color:#7a5200;
}
.bigButton.orangeButton:hover{ background:#8d5f03; }
.bigButton.orangeButton:active{ background:#7f5603; transform:translateY(1px); }

/* Disabled state */
.bigButton:disabled{
  opacity:.6;
  cursor:not-allowed;
  transform:none;
}

/* Each group (column) */
.button-group{
  display: flex;
  flex-direction: column;
  gap: 10px;
  min-width: 280px;   /* widen if your labels are long */
}

/* Arrange two buttons side-by-side like the screenshot */
.actionRow{
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}
   
@media print {
  /* reset page‚Äêsizing so we don‚Äôt clip */
  html, body {
    height: auto !important;
    overflow: visible !important;
  }

  /* hide the sidebar and toggle button */
  #sidebar,
  #toggleSidebar {
    display: none !important;
  }

  /* hide everything except mainContent */
  body * {
    visibility: hidden !important;
  }
  #mainContent,
  #mainContent * {
    visibility: visible !important;
  }

  /* stretch mainContent to fill the page and show all of it */
  #mainContent {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    margin: 0 !important;
    width: 100% !important;
    height: auto !important;         /* ‚Üê override the 100vh */
    max-height: none !important;     /* ‚Üê remove any implicit max */
    overflow: visible !important;    /* ‚Üê show all the content */
  }
  }

  /* hide the tiny weather icon in sidebar */
  #weatherIcon {
    display: none !important;
  }

    .distance-label {
  pointer-events: none;
  font-weight: bold;
  background: rgba(255,255,255,0.8);
  padding: 2px 6px;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  white-space: nowrap;
}

 #camera {
  display: none;          /* Removes it from layout */
  /*  (alt ideas)
  visibility: hidden;     Keeps its slot but hides it
  height: 0;
  width: 0;
  */
  #cameraContainer > h3 {
  display: none !important;
  }
}    
  </style>

    <style>
    /* simple full-screen modal */
    #metaOverlay {
      position: fixed; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.6);
      display: flex; align-items: center; justify-content: center;
      z-index: 2000;
    }
    #metaForm {
      background: #fff; padding: 20px; border-radius: 8px;
      max-width: 400px; width: 90%;
    }
    #metaForm label { display: block; margin-top: 10px; }
    #metaForm input { width: 100%; padding: 6px; margin-top: 4px; }
    #metaForm button { margin-top: 20px; padding: 8px 12px; }
  </style>
  
</head>
<body>

    <div id="metaOverlay">
    <form id="metaForm">
     <h2>Please fill in test details</h2>
     <!-- question inputs get injected here -->     
     <button type="submit">OK</button>
     <button type="button" id="skipButton">Skip</button>
    </form>
    </div>
  
  <button id="toggleSidebar" class="bigButton blueButton" aria-expanded="true" title="Toggle sidebar">‚ò∞</button>

  <div id="sidebar" class="expanded">
    <div id="sidebarScroll">
    <p id="dateTime"></p>
    <p id="dayPhase">Phase: N/A</p>
    <div class="weatherSection">
      <img id="weatherIcon" src="" alt="Weather">
      <p id="temperature">Temp: N/A</p>
    </div>
    <p id="streetCity">Street: N/A<br>City: N/A<br>Country: N/A</p>
    <p id="location"></p>
    <p id="roadType">Road type: N/A</p>
    <p id="speed">Speed: N/A</p>
    <div class="speedLimitRow">
      <span class="speedLabel">Speed&nbsp;limit:</span>
      <div id="legalSpeed" class="speedSign">‚Äì</div>
    </div>   
    <div class="distanceContainer">
      <p id="totalDistance">Distance: 0.0 km</p>
      <p id="xlsxAgo">Last upload: never</p>
    </div>
    <button class="bigButton blueButton" id="uploadNowButton">Upload data to cloud</button>
    <!-- <button class="bigButton greenButton" onclick="saveAndPrint()">Save report to PDF</button> -->
    <button class="bigButton redButton" id="stopTestingBtn">End test</button>
    </div>
  </div>

  <div id="mainContent">

    <div id="manualAnnotation" class="section">
  <span id="micLamp"
        title="Voice control ready"
        style="display:inline-block;width:10px;height:10px;
               margin-right:6px;border-radius:50%;background:#888;">
  </span>
<button id="micToggle" class="bigButton blueButton micBtn">
  Start voice control
</button>

<textarea id="textBox" rows="2" placeholder="Write your annotation here..."></textarea>

<button class="bigButton blueButton manualAnnBtn"
        onclick="logButton('Manual annotation', false)">
  Manual annotation
</button>
</div>

    <style>
      /* start hidden */
#buttonGroups {
  display: none;
}
#showButtons:checked ~ #buttonGroups {
  display: flex;
  align-items: flex-start;
  gap: 6px;
}
    </style>

<div
  style="
    margin-bottom: 10px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 6px;
  ">
  <!-- <input type="checkbox" id="showButtons" checked> -->
  <input type="checkbox" id="showButtons">
  <label for="showButtons">Show KPI buttons</label>

  <!-- your new dropdown lives beside the checkbox -->
  <label for="buttonConfig" style="margin-left:8px;">Button setup:</label>
  <select id="buttonConfig">
    <option value="KPI_buttons.csv">ADAS KPI</option>
    <option value="Benchmark_capability_buttons.csv">Benchmark Capability</option>
    <option value="Tuning_buttons.csv">China tuning 25w23</option>
    <option value="annotator_gt_buttons.csv">KPI groundtruth</option>
    <option value="annotator_gt_buttons_YN.csv">KPI groundtruth YN</option>
  </select>
  <!-- buildButtons will populate this directly -->
  <div id="buttonGroups" class="center-groups" style="margin-top:6px; margin-bottom:30px;">
   </div>
   </div>

    <div class="page-break"></div>

    <h3>Issue list</h3>
    <div id="logTableContainer" class="section"></div>
    <div class="page-break"></div>

     <div id="snapshotContainer" class="section">
       <h3>Issue Snapshots (5 latest)</h3>
       <div id="snapshotTableContainer"></div>
     </div>
    
    <div id="cameraContainer" class="section">
      <h3 style="display:none">Camera preview</h3>
      <video id="camera" autoplay playsinline
         style="border:1px solid #444;"></video>
      </div>
    
    <canvas id="cameraCanvas" width="320" height="240" style="display:none;"></canvas>

    <div id="countContainer" class="section">
      <h3>KPI Calculation</h3>
      <table id="countTable">
        <tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>
        <tr><td colspan="3">&nbsp;</td></tr>
      </table>
    </div>
    <div class="page-break"></div>
        
    <div id="mapContainer" class="section">
      <h3>Route view</h3>
      <div id="map" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>

  <div id="metaContainer" class="section">
    <h3>Test details</h3>
    <table id="metaTable">
      <!-- rows will be injected here -->
    </table>
  </div>
    
    <div id="statsContainer" class="section">
      <h3>Statistics</h3>
      <table id="statsTable">
        <tr><th>Metric</th><th>Value</th></tr>
        <tr><td colspan="2">&nbsp;</td></tr>
      </table>
    </div>

    <div id="streetsContainer" class="section">
      <h3>Road Types</h3>
      <table id="streetTable"><tr><th>Road type</th></tr></table>
    </div>

    <div id="countryContainer" class="section">
       <h3>Countries</h3>
       <table id="countryTable">
       <tr>
         <th>Country</th>
         <th>Distance&nbsp;(km)</th>
         <th>No&nbsp;of&nbsp;issues</th>
       </tr>
       </table>
     </div>

    <div id="weatherContainer" class="section">
      <h3>Weather</h3>
      <table id="weatherTable">
         <tr><th>Condition</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <div id="phaseContainer" class="section">
      <h3>Phase</h3>
      <table id="phaseTable">
         <tr><th>Phase</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <footer style="text-align:center; padding:10px; font-size:12px; color:#666;">
      Ver 1.16
      ¬© Lynoit Tech 2025
    </footer>
  </div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-image@0.4.0/leaflet-image.js"></script>

  <script>
/* --- Chime audio setup --- */
let audioCtx = null;
let chimeBus = null; // master gain for chimes

function initAudioOnce() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  chimeBus = audioCtx.createGain();
  chimeBus.gain.value = 0.08;       // overall chime volume
  chimeBus.connect(audioCtx.destination);
}

/* Unlock the AudioContext on first user gesture */
['click','touchstart','keydown'].forEach(evt => {
  window.addEventListener(evt, () => {
    initAudioOnce();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }, { once:true, passive:true });
});

/* --- Success audio (ascending 3-note arpeggio) --- */
function playSuccess(kind = 'normal') {
  if (!audioCtx || audioCtx.state !== 'running') return;

  const now = audioCtx.currentTime;

  // Base pitches (C major-ish)
  const notes = (kind === 'red')
    ? [659.25, 783.99, 987.77]   // E5, G5, B5 ‚Äì a bit brighter for red
    : [523.25, 659.25, 783.99];  // C5, E5, G5

  const dur = 0.08;      // each pip
  const gap = 0.04;      // tiny space between pips
  const peak = 0.22;     // envelope peak
  const tail = 0.0001;   // end level

  notes.forEach((hz, i) => {
    const t0  = now + i * (dur + gap);
    const osc = audioCtx.createOscillator();
    const env = audioCtx.createGain();

    // slightly bell-like: sine + tiny frequency dip
    osc.type = 'sine';
    osc.frequency.setValueAtTime(hz, t0);
    osc.frequency.exponentialRampToValueAtTime(hz * 0.98, t0 + dur * 0.5);

    // quick attack/decay envelope
    env.gain.setValueAtTime(tail, t0);
    env.gain.linearRampToValueAtTime(peak, t0 + 0.01);
    env.gain.exponentialRampToValueAtTime(tail, t0 + dur);

    osc.connect(env).connect(chimeBus);
    osc.start(t0);
    osc.stop(t0 + dur + 0.02);
  });
}
</script>

  <script>

    console.log('main script executing');

const isTouchDevice =
  ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

if (isTouchDevice) {
  document.addEventListener('contextmenu', e => {
    e.preventDefault();
  }, { passive: false });
}    
    // DOM refs
const appStartTime    = new Date();
const appStartDateStr = appStartTime.toISOString().slice(0,10); // "YYYY-MM-DD"
const metaAnswers     = {};

    const toggleBtn = document.getElementById('toggleSidebar');
    const sidebar   = document.getElementById('sidebar');
    const locEl     = document.getElementById('location');
    const roadTypeEl= document.getElementById('roadType');
    const streetCityEl=document.getElementById('streetCity');
    const tempEl    = document.getElementById('temperature');
    const iconEl    = document.getElementById('weatherIcon');
    const distEl    = document.getElementById('totalDistance');
    const speedEl   = document.getElementById('speed');
    const countTbl  = document.getElementById('countTable');
    const streetTbl = document.getElementById('streetTable');
    const countryTable = document.getElementById('countryTable');
    const logContainer = document.getElementById('logTableContainer');
    const buttonGroups = document.getElementById('buttonGroups');
    const micLamp   = document.getElementById('micLamp');
    const textBox   = document.getElementById('textBox');

// --- button sorting for tri-state toggles ---
let triToggleSerial = 0;   // stable original order among tri toggles
let sortTimeoutId   = null;
const SORT_DELAY_MS = 30000;  // 30 seconds before resorting

if (buttonGroups) {
  // any click on a KPI button restarts the timer
  buttonGroups.addEventListener('click', () => {
    if (sortTimeoutId) clearTimeout(sortTimeoutId);
    sortTimeoutId = setTimeout(resortTriToggles, SORT_DELAY_MS);
  });
}
  
    // Clear any previous pending snapshot when the user focuses the box
textBox.addEventListener('focus', () => {
  pendingSnapshotDataUrl = null;
});

// Take a snapshot as soon as the user begins typing a non-whitespace char.
// Only capture once per entry (until they submit or focus again).
textBox.addEventListener('input', () => {
  if (pendingSnapshotDataUrl) return;                   // already captured for this entry
  if (textBox.value.trim().length === 0) return;        // ignore blanks
  const snap = captureSnapshotFromCamera();
  if (snap) pendingSnapshotDataUrl = snap;
});
    
    const countryDistances  = {};
    const weatherDistances = {};
    const phaseDistances = {};
    const AZURE_KEY    = '31mglZQASLS9g4mcaTvMpznyzYYJyFr7I3ERTm84jeQrPNOlp5tXJQQJ99BEACi5YpzXJ3w3AAAYACOGJuNe';
    const AZURE_REGION = 'northeurope';
    const PHASE_THROTTLE = 5 * 60 * 1000;
    const TABLE_THROTTLE = 10 * 1000;
    const UPLOAD_THROTTLE = 5 * 60 * 1000
    const citySet = new Set();   // unique city names encountered
    const legalSpeedEl = document.getElementById('legalSpeed');
    const samplingTable = [];

// --- Toggle system ---
const toggleState = {};
const triToggleTouched = {};   // signals for tri-toggles that have been changed

let   toggleDefs  = [];
let   toggleNotes = {};   // per-signal free-text notes for tri-state toggles

    let lastLimit = null;
    let limitChanges = 0;
    let roundaboutCount     = 0;
    let trafficLightCount   = 0;
    let lastWasRoundabout   = false;   // debounce flags
    let lastWasTrafficLight = false;
    let bridgeCount   = 0;
    let tunnelCount   = 0;
    let lastWasBridge = false;   // debounce flags
    let lastWasTunnel = false;
    let bridgeStreak = 0;
    let corrections = {};
    let lastUploadTime = 0;

    let pendingSnapshotDataUrl = null; // snapshot taken when user starts typing

    let currentLegalSpeed = null;

    let sessionEnded = false;

   let geoWatchId            = null;
   let samplingIntervalId    = null;
   let dateTimeIntervalId    = null;
   let uploadAgoIntervalId   = null; // if you added the minutes-since-upload label
    
    // ‚îÄ‚îÄ Whitelist of road types we care about ‚îÄ‚îÄ
    const allowedRoadTypes = new Set([
     'motorway','motorway_link',
     'trunk','trunk_link',
     'primary','primary_link',
     'secondary','secondary_link',
     'tertiary','tertiary_link',
     'unclassified','residential','service','construction'
    ]);

    const workbookTables = [
      { id: 'metaTable',    name: 'Test details'  },
      { id: 'logTable',     name: 'Issues'     },
      { id: 'countTable',   name: 'KPI'        },
      { id: 'statsTable',   name: 'Statistics' },
      { id: 'streetTable',  name: 'Road types' },
      { id: 'countryTable', name: 'Country'    },
      { id: 'weatherTable', name: 'Weather'    },
      { id: 'phaseTable',   name: 'Phase'      }
    ];


    let startTime = null;        // timestamp of the first GPS fix (ms)
    const topSpeeds = [];   // running list of the 10 highest samples
    
    let maxSpeed  = 0;    // value that ends up in the Statistics table
    let lastTableUpdate = 0;
    let lastPhaseUpdate = 0;
    let logTable=[], redCounts={}, lastPos=null, totalDist=0;
    let issueMarkers = [];   // one Leaflet marker per issue row
    let positions=[], timeData=[], distData=[], speedData=[];
    let map, trackLine, distanceChart, speedChart;
    let roadTypes=new Set(), lastChartTs=0, posCount=0, lastCity=null;
    let lastCountry = null;
    let roadDistances = {};
    let currentDistMarker = null;
    let map2, circle2;
    let roadRedCounts = {};
    let countryRedCounts   = {};
    let weatherRedCounts   = {};    // red presses per weather condition
    let phaseRedCounts     = {};    // (optional) red presses per day phase
    let isDirty = false;
    let wakeLock = null;
    let lastSpeedKmh = 0;
    let azureClockOffsetMs = null;  // device vs Azure time (ms, + = device ahead)

    // near other globals
let uploadsEnabled = false;

function checkUploadEligibility() {
  uploadsEnabled = (totalDist >= 100) || (logTable.length > 0); // totalDist is meters
  const btn = document.getElementById('uploadNowButton');
  if (btn) btn.disabled = !uploadsEnabled; // optional UX: grey out button until allowed
}

    function markDirty() { isDirty = true; }
    function markClean()  { isDirty = false; }

    function formatAppStartTimestamp() {
       const d = appStartTime;
       const pad = n => String(n).padStart(2, '0');
       const YYYY = d.getFullYear();
       const MM   = pad(d.getMonth() + 1);
       const DD   = pad(d.getDate());
       const hh   = pad(d.getHours());
       const mm   = pad(d.getMinutes());
       const ss   = pad(d.getSeconds());
      return `${YYYY}-${MM}-${DD}_${hh}${mm}${ss}`;
    }

let lastXlsxUploadMs = 0;

function formatMinutesAgo(ms) {
  if (!ms) return 'never';
  const mins = Math.floor((Date.now() - ms) / 60000); // milliseconds ‚Üí minutes
  if (mins === 0) return 'just now';
  if (mins === 1) return '1 minute ago';
  return `${mins} minutes ago`;
}

function nudge(el) {
  if (!el) return;
  el.classList.add('updated');
  setTimeout(() => el.classList.remove('updated'), 250);
}

function updateUploadAgo() {
  const el = document.getElementById('xlsxAgo');
  if (!el) return;
  el.textContent = `Last upload: ${formatMinutesAgo(lastXlsxUploadMs)}`;
  nudge(el);
}

    const reportBaseName = `Annotator_report_${formatAppStartTimestamp()}`; 
    
    window.addEventListener('beforeunload', e => {
      if (!isDirty) return;
      e.preventDefault();
      e.returnValue = '';
    });
    
    toggleBtn.onclick = () => {
      const exp = sidebar.classList.toggle('expanded');
      sidebar.classList.toggle('collapsed', !exp);
      toggleBtn.setAttribute('aria-expanded', exp);
    };

    window.onload = () => {
  // 1) load meta-questions & wait for answers
  loadMetaQueries()
    .catch(err => {
      console.error('MetaQueries load failed:', err);
      // if questions can‚Äôt load, skip straight to app
      document.getElementById('metaOverlay').style.display = 'none';
      startApp();
    });
};

  async function requestWakeLock() {
    if ('wakeLock' in navigator) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake lock acquired');
        wakeLock.addEventListener('release', () => {
          console.log('Wake lock released');
        });
      } catch (err) {
        console.error('Failed to acquire wake lock:', err);
      }
    } else {
      console.warn('Wake Lock API not supported on this browser');
    }
  }

  async function releaseWakeLock() {
    if (wakeLock) {
      try {
        await wakeLock.release();
        wakeLock = null;
        console.log('Wake lock released manually');
      } catch (err) {
        console.error('Error releasing wake lock:', err);
      }
    }
  }

  document.addEventListener('visibilitychange', () => {
    if (wakeLock !== null && document.visibilityState === 'visible') {
      requestWakeLock();
    }
  });

 // Acquire wake lock on first user interaction too (one-time)
['click','touchstart','keydown'].forEach(evt =>
  window.addEventListener(evt, () => requestWakeLock(), { once: true, passive: true })
);

// Stop testing + final upload
// Stop testing + final upload + end-screen
async function stopTesting() {
  // prevent double runs
  if (typeof sessionEnded !== 'undefined' && sessionEnded) return;
  window.sessionEnded = true;

  try {
    // 1) Freeze UI
    try {
      document.querySelectorAll('#buttonGroups button, #micToggle, #uploadNowButton, #stopTestingBtn')
        .forEach(b => b && (b.disabled = true));
    } catch {}

    // 2) Stop timers & GPS
    try { if (typeof samplingIntervalId  !== 'undefined' && samplingIntervalId)  clearInterval(samplingIntervalId); } catch {}
    try { if (typeof dateTimeIntervalId  !== 'undefined' && dateTimeIntervalId)  clearInterval(dateTimeIntervalId); } catch {}
    try { if (typeof uploadAgoIntervalId !== 'undefined' && uploadAgoIntervalId) clearInterval(uploadAgoIntervalId); } catch {}
    try {
      if (typeof geoWatchId !== 'undefined' && geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
      }
    } catch {}

    // 3) Stop camera stream
    try {
      const video = document.getElementById('camera');
      if (video && video.srcObject) {
        video.srcObject.getTracks().forEach(t => t.stop());
        video.srcObject = null;
      }
    } catch {}

    // 4) Stop Azure speech recognizer (if present) & release wake lock
    try { if (typeof recognizer !== 'undefined' && recognizer) recognizer.stopContinuousRecognitionAsync(); } catch {}
    try { if (typeof releaseWakeLock === 'function') await releaseWakeLock(); } catch {}

    // 5) Final table refresh (guard if elements were removed)
    try { if (typeof displayLogTable     === 'function') displayLogTable(); } catch {}
    try { if (typeof renderLatestSnapshots === 'function') renderLatestSnapshots(5); } catch {}
    try { if (typeof updateStatsTable    === 'function') updateStatsTable(); } catch {}
    try { if (typeof updateCountTable    === 'function') updateCountTable(); } catch {}
    try { if (typeof updateStreetTable   === 'function') updateStreetTable(); } catch {}
    try { if (typeof updateCountryTable  === 'function') updateCountryTable(); } catch {}
    try { if (typeof updateWeatherTable  === 'function') updateWeatherTable(); } catch {}
    try { if (typeof updatePhaseTable    === 'function') updatePhaseTable(); } catch {}

    // 6) Final uploads (log errors but keep going)
    try {
      if (typeof uploadWorkbookToAzure === 'function') {
        await uploadWorkbookToAzure();
        // stamp "last upload" time if you use the sidebar label
        if (typeof lastXlsxUploadMs !== 'undefined') lastXlsxUploadMs = Date.now();
        if (typeof updateUploadAgo === 'function') updateUploadAgo();
      }
    } catch (e) {
      console.error('Final XLSX upload failed:', e);
    }

    try {
      if (typeof uploadSnapshotsZip === 'function') {
        await uploadSnapshotsZip();
      }
    } catch (e) {
      console.error('Final snapshots ZIP upload failed:', e);
    }

    // optionally:
    // try { if (typeof exportPDFToAzure === 'function') await exportPDFToAzure(); } catch(e){ console.error(e); }

    // 7) Clear the ‚Äúunsaved changes‚Äù prompt flag
    try { if (typeof markClean === 'function') markClean(); } catch {}

  } finally {
    // 8) Replace main window with end message (do this LAST to avoid update funcs crashing)
    const main = document.getElementById('mainContent');
    if (main) {
      main.innerHTML = `
        <div style="
          min-height: 70vh;
          display: flex;
          align-items: center;
          justify-content: center;
          text-align: center;
          padding: 24px;
        ">
          <div>
            <h2 style="margin:0 0 8px;">Session ended</h2>
            <p>Reload window to start new test</p>
          </div>
        </div>`;
    }

    // (optional) hide sidebar & toggle
    const sb  = document.getElementById('sidebar');
    const tgl = document.getElementById('toggleSidebar');
    if (sb)  sb.style.display  = 'none';
    if (tgl) tgl.style.display = 'none';

    console.log('‚úî Session ended and shutdown completed');
  }
}
    
  function startApp() {
    // 1) Acquire a wake lock right away
    requestWakeLock();
    
  loadCorrections()
    .then(() => console.log('Corrections loaded:', corrections))
    .catch(err => console.warn('Corrections load failed:', err));  
  initMap();
  //initMap2();
  updateDateTime();
  dateTimeIntervalId = setInterval(updateDateTime, 1000);
updateUploadAgo();
setInterval(updateUploadAgo, 60 * 1000); // every 60 seconds
    
// üîπ one-time clock offset measurement vs Azure
measureAzureClockOffset();
    
let lastSampleMeters = 0;
let lastSampleTimeMs = 0;

function shouldSampleNow() {
  const movedMeters = totalDist - lastSampleMeters; // totalDist is in meters
  const now = Date.now();
  const timeGapOk = (now - lastSampleTimeMs) >= 10_000; // max 10 s gap
  const distGapOk = movedMeters >= 50;                  // 50 m step

  return distGapOk || timeGapOk;
}

samplingIntervalId = setInterval(() => {
  if (!lastPos) return;
  if (!shouldSampleNow()) return;

  recordSample('');
  lastSampleMeters = totalDist;
  lastSampleTimeMs = Date.now();
}, 2 * 1000); // check frequently; actual writes are gated
    
geoWatchId = navigator.geolocation.watchPosition(showPosition, showError, {
  enableHighAccuracy: true,
  maximumAge: 5000,
  timeout: 10000
});

    const configSelect = document.getElementById('buttonConfig');
  configSelect.addEventListener('change', e => {
    // rebuild with the newly selected CSV
    buildButtons(e.target.value);
  });
  // initial build
  buildButtons(configSelect.value);
  startCamera();
    
// Page/tab visibility changes
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    resumeCameraIfNeeded();
  }
});

// iOS Safari prefers pageshow (esp. after bfcache)
window.addEventListener('pageshow', () => {
  resumeCameraIfNeeded();
});

// When the video track ends (some Androids fire this)
document.getElementById('camera')?.addEventListener('emptied', () => {
  resumeCameraIfNeeded();
});
    
}   

    let recognizer;  // Azure continuous recogniser
    let recogniserReady   = false;   // built at least once?
    let recogniserRunning = false;   // currently listening?

    // ‚îÄ‚îÄ‚îÄ Voice‚Äëcontrol start/stop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.getElementById('micToggle').onclick = async event => {
  // 1. Build recogniser only the first time the button is pressed
  if (!recogniserReady) {
    await initAzureSpeech();           // creates the recogniser object
    recogniserReady = true;
  }

  // 2. Toggle listening state
  if (recogniserRunning) {
    recognizer.stopContinuousRecognitionAsync();
    recogniserRunning = false;
    micLamp.style.background = '#4caf50';          // üü¢ idle
    event.target.textContent = 'Start voice control';
  } else {
    recognizer.startContinuousRecognitionAsync();
    recogniserRunning = true;
    micLamp.style.background = '#f44336';          // üî¥ listening
    event.target.textContent = 'Stop voice control';
  }
};

function loadCorrections() {
  return fetch('corrections.csv')
    .then(r => r.ok ? r.text() : Promise.reject('CSV load failed'))
    .then(csv => {
      const { data } = Papa.parse(csv, { header: true, skipEmptyLines: true });
      data.forEach(({ misheard, correct }) => {
        if (misheard && correct) corrections[misheard.trim().toLowerCase()] = correct.trim();
      });
    });
}
    
function applyCorrections(text) {
  return text.replace(/\b\w+\b/g, w => corrections[w.toLowerCase()] || w);
}

function updateCountryTable() {
  let html = `
    <tr>
      <th>Country</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  for (const c in countryDistances) {
    const meters = countryDistances[c] || 0;
    const km     = (meters / 1000).toFixed(1);
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';
    const count  = countryRedCounts[c] || 0;

    html += `
      <tr>
        <td>${c}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  countryTable.innerHTML = html;
}

function stripHotWord(text) {
  const match = text.match(/^\s*annotator[,:]?\s*/i);   // any leading spaces
  if (!match) return null;                              // ‚Üê hot‚Äëword not found
  return text.slice(match[0].length).trim();            // rest of the phrase
}

async function initAzureSpeech() {
  console.log('initAzureSpeech started');    //  ‚Üê already added last time?
  const warn = msg => console.warn('Speech init:', msg);

  if (!window.SpeechSDK) {
    warn('SpeechSDK global missing ‚Äì script failed to load?');
    micLamp.style.background = '#ffc107';   // üü°  error
    return;
  }

  let recognizer;
  try {
    const speechConfig = SpeechSDK.SpeechConfig.fromSubscription(
      AZURE_KEY, AZURE_REGION
    );
    speechConfig.speechRecognitionLanguage = 'en-US';
    speechConfig.setProperty(
      SpeechSDK.PropertyId.SpeechServiceResponse_PostProcessingOption,
      'TrueText'
    );

    const audioConfig  = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
    recognizer         = new SpeechSDK.SpeechRecognizer(
      speechConfig, audioConfig
    );
  } catch (e) {
    warn(e);
    micLamp.style.background = '#ffc107';   // üü°
    return;
  }

  /* Lamp colours */
  recognizer.sessionStarted = ()  => micLamp.style.background = '#f44336'; // üî¥ listening
  recognizer.sessionStopped = ()  => micLamp.style.background = '#4caf50'; // üü¢ ready
  recognizer.canceled       = (_,e)=> {
    warn('Canceled: ' + e.errorDetails);
    micLamp.style.background = '#ffc107';   // üü° error
  };

  /* Hot‚Äëword gate */
recognizer.recognizing = (_, e) => {
  const draft = stripHotWord(e.result.text);

  if (draft) {
    // Show preview text
    textBox.value = draft + ' [draft]';

    // ‚è±Ô∏è Early snapshot for voice (once per utterance)
    if (!pendingSnapshotDataUrl) {
      const snap = captureSnapshotFromCamera();
      if (snap) pendingSnapshotDataUrl = snap;
    }
  }
};

  recognizer.recognized  = (_,e)=> {
    if (e.result.reason !== SpeechSDK.ResultReason.RecognizedSpeech) return;
    const cleaned = stripHotWord(e.result.text);
    if (cleaned) {
      textBox.value = cleaned;
      logButton('Manual annotation', false);
    }
  };

  recognizer.startContinuousRecognitionAsync();
}

 function parseMaxSpeed(tag){
  const m = /(\d+)/.exec(tag);        // first number in the tag
  return m ? m[1] : null;             // e.g. "80"  (null if none)
}
    
  function initMap () {
    map = L.map('map', {
    zoomControl:       false,
    scrollWheelZoom:   false,
    doubleClickZoom:   false,
    touchZoom:         false,
    boxZoom:           false,
    keyboard:          false,
    dragging:          false,   // ‚üµ blocks mouse & touch drag
    tap:               false    // ‚üµ blocks iOS ‚Äútap-drag‚Äù panning
    }).setView([0, 0], 2);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors'
    }).addTo(map);

    trackLine = L.polyline([], { weight: 4 }).addTo(map);
  }

  /* ‚îÄ‚îÄ Street-view radius map ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  function initMap2 () {
    map2 = L.map('map2', {
    zoomControl:       false,
    scrollWheelZoom:   false,
    doubleClickZoom:   false,
    touchZoom:         false,
    boxZoom:           false,
    keyboard:          false,
    dragging:          false,
    tap:               false,
    attributionControl:false
    }).setView([0, 0], 18);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '¬© OpenStreetMap contributors'
    }).addTo(map2);

    circle2 = L.circle([0, 0], { radius: 100, color: 'blue', fillOpacity: 0.1 }).addTo(map2);
    currentPosMarker2 = L.circleMarker([0, 0], { radius: 8, color: 'red', fillColor: 'red', fillOpacity: 1 }).addTo(map2);
  }
    
    function initCharts(){
      distanceChart=new Chart(document.getElementById('distanceChart').getContext('2d'),{type:'line',data:{labels:timeData,datasets:[{label:'Distance (km)',data:distData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'time',time:{unit:'minute',tooltipFormat:'HH:mm:ss'}},y:{beginAtZero:true}}}});
      speedChart=new Chart(document.getElementById('speedChart').getContext('2d'),{type:'line',data:{labels:distData,datasets:[{label:'Speed (km/h)',data:speedData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'linear',title:{display:true,text:'Distance (km)'}},y:{beginAtZero:true,title:{display:true,text:'Speed (km/h)'}}}}});
    }

function startCamera() {
  const video = document.getElementById('camera');
  if (!video) return;

  if (!navigator.mediaDevices?.getUserMedia) {
    console.warn('getUserMedia not supported');
    return;
  }

  // Stop any old stream cleanly
  const stopStream = () => {
    try {
      if (video.srcObject) {
        video.srcObject.getTracks().forEach(t => t.stop());
        video.srcObject = null;
      }
    } catch {}
  };

  const constraints = {
    audio: false,
    video: {
      facingMode: { ideal: 'environment' },
      width:     { ideal: 1280 },
      height:    { ideal: 720 },
      frameRate: { ideal: 30, max: 30 },
      advanced: [{ focusMode: 'continuous' }] // ignored if unsupported
    }
  };

  const restart = () => {
    // small debounce to avoid rapid restarts
    stopStream();
    setTimeout(open, 200);
  };

  const open = () =>
    navigator.mediaDevices.getUserMedia(constraints)
      .then(stream => {
        video.srcObject = stream;
        video.setAttribute('playsinline', ''); // iOS: stay inline
        video.muted = true;                    // be safe on autoplay policies
        // restart if the track ends/goes inactive (common on app switch)
        const vt = stream.getVideoTracks()[0];
        if (vt) vt.addEventListener('ended', restart);
        stream.addEventListener?.('inactive', restart);
        return video.play().catch(() => {});   // ignore autoplay errors
      })
      .catch(err => {
        console.error('Camera error', err);
      });

  // First open
  open();

  // Try to recover when returning to the tab/app
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') restart();
  });

  window.addEventListener('pageshow', () => restart());
}
    
    function getCameraConstraints() {
  return { video: { facingMode: 'environment' } };
}

function streamIsLive(stream) {
  if (!stream) return false;
  const v = stream.getVideoTracks?.()[0];
  return !!(v && v.readyState === 'live' && !v.muted && !v.stopped);
}

async function restartCamera() {
  try {
    // stop old tracks first
    const video = document.getElementById('camera');
    if (video?.srcObject) {
      video.srcObject.getTracks().forEach(t => t.stop());
      video.srcObject = null;
    }
  } catch {}
  await startCamera(); // reuse your existing function
}

async function resumeCameraIfNeeded() {
  const video = document.getElementById('camera');
  if (!video) return;

  // Case 1: track looks dead ‚Üí hard restart
  if (!streamIsLive(video.srcObject)) {
    await restartCamera();
    return;
  }

  // Case 2: track is live, but element is ‚Äústuck‚Äù ‚Üí nudge play()
  try { await video.play(); } catch {}
}
    
  function showPosition(pos) {
  const { latitude: lat, longitude: lon } = pos.coords;
  const ts = pos.timestamp;
  let segDist = 0; // in meters

  if (!startTime) startTime = ts;
    
  // 1) Calculate segment distance & apply noise threshold
  if (lastPos) {
    segDist = calculateDistance(lastPos.lat, lastPos.lon, lat, lon);
    if (segDist < 10) return; // ignore tiny jitters

    // accumulate total and per‚Äêweather
    totalDist += segDist;
    checkUploadEligibility();
    const phaseText = document.getElementById('dayPhase').textContent.split(': ')[1] || 'Unknown';
    phaseDistances[phaseText] = (phaseDistances[phaseText] || 0) + segDist;
    const condition = iconEl.alt || 'Unknown';
    weatherDistances[condition] = (weatherDistances[condition] || 0) + segDist;

        const distKm = (totalDist / 1000).toFixed(2);
    const labelHtml = `<div class="distance-label">${distKm} km</div>`;

    if (!currentDistMarker) {
      currentDistMarker = L.marker([lat, lon], {
        icon: L.divIcon({
          className: '',        // styling lives in .distance-label
          html: labelHtml,
          iconSize: [0, 0],     // let the inner div size itself
          iconAnchor: [0, -10]  // float just above the point
        })
      }).addTo(map);
    } else {
      currentDistMarker.setLatLng([lat, lon]);
      currentDistMarker.setIcon(L.divIcon({
        className: '',
        html: labelHtml,
        iconSize: [0, 0],
        iconAnchor: [0, -10]
      }));
    }    
  }

  // 2) Update position state & map
  const prevPos = lastPos;
  lastPos = { lat, lon, ts };
  posCount++;
  trackLine.addLatLng([lat, lon]);
  if (positions.length === 0) {
    map.setView([lat, lon], 15);
  } else if (posCount % 20 === 0) {
    map.fitBounds(trackLine.getBounds().pad(0.2));
  }
  positions.push([lat, lon]);

  // 3) Update speed display
  if (prevPos) {
    const dt = (ts - prevPos.ts) / 1000; // seconds
    const speedKmh = dt > 0 ? (segDist / dt) * 3.6 : 0;

      /* ‚îÄ‚îÄ reject implausible spikes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
  if (speedKmh > 250) {
    console.warn(`Discarded unrealistic speed: ${speedKmh.toFixed(1)} km/h`);
    speedEl.textContent = 'Speed: N/A';
    // skip max-speed bookkeeping and chart push for this sample
  } else {
    /* existing ‚Äúvalid sample‚Äù logic ‚Äî keep exactly as you have it */

    lastSpeedKmh = speedKmh;
    
    // 1. maintain the top-10 speeds list
    topSpeeds.push(speedKmh);
    topSpeeds.sort((a, b) => b - a);
    if (topSpeeds.length > 10) topSpeeds.pop();
    maxSpeed = topSpeeds.length === 10 ? topSpeeds[9] : topSpeeds[0];

    // 2. show live speed read-out
    speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;

    // 3. later (in the chart-update section) you already push
    //    speedData.push(speedKmh);  ‚Üê keep that line; it now runs only here
  }

    if (speedKmh > 0) {                    // ignore the very first 0 km/h
  topSpeeds.push(speedKmh);

  // keep the array sorted descending and trimmed to 10 values
  topSpeeds.sort((a, b) => b - a);
  if (topSpeeds.length > 10) topSpeeds.pop();

  // once we have 10 samples, maxSpeed = the lowest of them
  // (otherwise just use the current highest seen so far)
  maxSpeed = topSpeeds.length === 10
               ? topSpeeds[9]                 // index 9 = smallest of the top 10
               : topSpeeds[0];                // highest sample so far
}
    
    speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;
  }

  // 4) Update distance display & charts
  distEl.textContent = `Distance: ${(totalDist / 1000).toFixed(1)} km`;
  distEl.classList.add('updated');
  setTimeout(() => distEl.classList.remove('updated'), 500);

if (Date.now() - lastChartTs > 5000) {
  maybeUpdateTables();
  lastChartTs = Date.now();
}

  // 5) Update raw lat/lon display
  locEl.innerHTML = `Lat: ${lat}<br>Lon: ${lon}`;
  nudge(locEl);

  const now = Date.now();
  if (now - lastPhaseUpdate > PHASE_THROTTLE) {
    updateDayPhase(lat, lon);
    lastPhaseUpdate = now;
  }

  // 6) Reverse‚Äêgeocode + whitelist + accumulate per‚Äêtype distance
  fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&extratags=1&lat=${lat}&lon=${lon}`)
    .then(r => r.json())
    .then(data => {
      const rawRt = data.extratags?.highway || data.type || 'unknown';
      const displayRt = allowedRoadTypes.has(rawRt) ? rawRt : 'Other';
      const tags = data.extratags || {};

      const isBridge = tags.bridge === 'yes';

        const isRoundabout =
       tags.junction === 'roundabout'
    || tags.highway  === 'mini_roundabout';

  // traffic-light junctions
  const isTrafficLight = tags.highway === 'traffic_signals';

  // tunnels
  const isTunnel      = tags.tunnel === 'yes';

  // now your existing debounce/count logic‚Ä¶
  if (isRoundabout   && !lastWasRoundabout)   roundaboutCount++;
  if (isTrafficLight && !lastWasTrafficLight) trafficLightCount++;
  if (isTunnel       && !lastWasTunnel)       tunnelCount++;

  lastWasRoundabout   = isRoundabout;
  lastWasTrafficLight = isTrafficLight;
  lastWasBridge       = isBridge;
  lastWasTunnel       = isTunnel;

      if (tags.bridge === 'yes') {
  bridgeStreak++;
  if (bridgeStreak === 8) {
    bridgeCount++;
  }
} else {
  bridgeStreak = 0;
}
      
      const maxTag =
      data.extratags?.maxspeed
   || data.extratags?.['maxspeed:forward']
   || data.extratags?.['maxspeed:backward'];

const limit = maxTag ? parseMaxSpeed(maxTag) : null;
legalSpeedEl.textContent = limit ?? '‚Äì';
currentLegalSpeed = limit !== null ? Number(limit) : null;

/* ‚îÄ‚îÄ count speed-limit transitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
if (limit !== null && limit !== lastLimit) {
  if (lastLimit !== null) limitChanges++;   // skip the very first limit
  lastLimit = limit;
}

     if (segDist > 0) {    
       roadDistances[displayRt] =
      (roadDistances[displayRt] || 0) + segDist;
     }

      // update sidebar & sets
      roadTypeEl.textContent = `Road type: ${displayRt}`;
      //nudge(roadTypeEl);
      if (allowedRoadTypes.has(rawRt)) roadTypes.add(rawRt);

      // street & city display
      const street = data.address.road
        || data.address.pedestrian
        || data.address.footway
        || 'Unknown street';
      const city = data.address.city
        || data.address.town
        || data.address.village
        || 'Unknown city';

      const country = data.address.country || 'Unknown country';

      if (segDist > 0) {
         countryDistances[country] = (countryDistances[country] || 0) + segDist;
      }
      
      streetCityEl.innerHTML = `Street: ${street}<br>City: ${city}<br>Country: ${country}`;

      // ‚îÄ‚îÄ NEW: auto‚Äëlog when the country changes ‚îÄ‚îÄ
      if (country !== lastCountry && lastCountry !== null) {
      // Re‚Äëuse the regular logger so it shows up everywhere
      logButton(`Entered ${country}`, false);   // false ‚áí not a KPI ‚Äúred‚Äù event
      }
      lastCountry = country;

      // fetch weather on city change
      if (city !== lastCity) {
        lastCity = city;
        citySet.add(city);
        getWeather(city);
      }

      // refresh all tables
      maybeUpdateTables();
    })
    .catch(err => {
      streetCityEl.textContent = 'Error: ' + err.message;
      console.error('Reverse geocode error', err);
    });

    if (map2) {
      map2.setView([lat, lon], 20);  // zoom level 20 ‚âÉ 100 m across
      currentPosMarker2.setLatLng([lat, lon]);
    }     
}
    
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6_371_000;          // earth‚Äôs radius in meters
      const toRad = Math.PI / 180;
      const œÜ1 = lat1 * toRad;
      const œÜ2 = lat2 * toRad;
      const dœÜ = (lat2 - lat1) * toRad;
      const dŒª = (lon2 - lon1) * toRad;

      const a = Math.sin(dœÜ/2)**2
          + Math.cos(œÜ1) * Math.cos(œÜ2) * Math.sin(dŒª/2)**2;

      // clamp (1 - a) to [0,1] to avoid small floating‚Äëpoint overshoot
      const oneMinusA = Math.max(0, 1 - a);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(oneMinusA));
      return R * c;  // distance in meters
    }
    
function updateStreetTable() {
  // 1) header now has an extra column
  let html = `
    <tr>
      <th>Road type</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  // 2) loop each road type
  for (const rt of roadTypes) {
    const meters = roadDistances[rt] || 0;
    const km     = (meters / 1000).toFixed(1);
    // guard against division by zero
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';

    const count  = roadRedCounts[rt] || 0;

    // 3) inject the new <td> for pct
    html += `
      <tr>
        <td>${rt}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  streetTbl.innerHTML = html;
}

function formatAzureOffsetForStats(offsetMs) {
  if (offsetMs == null) return 'Not measured';

  const seconds = (offsetMs / 1000).toFixed(2);
  const sign    = offsetMs > 0 ? '+' : '';
  let dir;

  if (offsetMs > 0)      dir = 'device ahead of Azure';
  else if (offsetMs < 0) dir = 'device behind Azure';
  else                   dir = 'in sync with Azure';

  return `${sign}${seconds} s (${dir})`;
}  

function updateStatsTable () {
  // ‚ë† total test time hh:mm:ss
  const totalMs   = startTime ? (lastPos.ts - startTime) : 0;
  const timeStr   = new Date(totalMs).toISOString().substring(11, 19);

  // ‚ë° total distance & mean speed
  const km        = (totalDist / 1000).toFixed(1);
  const hrs       = totalMs / 3_600_000;
  const meanSpd   = hrs > 0 ? (km / hrs).toFixed(1) : '‚Äî';

  // ‚ë¢ build a ‚ÄúCity1 - City2 - ‚Ä¶‚Äù list
  const citiesList    = Array.from(citySet).join(' - ') || '‚Äî';

  // ‚ë£ build a ‚ÄúCountry1 - Country2 - ‚Ä¶‚Äù list
  const countriesList = Object.keys(countryDistances).join(' - ') || '‚Äî';

  // ‚ë§ format Azure offset text
  const clockOffsetText = formatAzureOffsetForStats(azureClockOffsetMs);

  // render the table
  document.getElementById('statsTable').innerHTML = `
    <tr><th>Metric</th><th>Value</th></tr>
    <tr><td>Total test time</td>            <td>${timeStr}</td></tr>
    <tr><td>Clock offset vs Azure</td>      <td>${clockOffsetText}</td></tr>
    <tr><td>Total test distance</td>        <td>${km} km</td></tr>
    <tr><td>Max speed</td>                  <td>${maxSpeed.toFixed(1)} km/h</td></tr>
    <tr><td>Mean speed</td>                 <td>${meanSpd} km/h</td></tr>
    <tr><td>Speed limit changes</td>        <td>${limitChanges}</td></tr>
    <tr><td>Roundabouts</td>                <td>${roundaboutCount}</td></tr>
    <tr><td>Traffic-light junctions</td>    <td>${trafficLightCount}</td></tr>
    <tr><td>Bridges</td>                    <td>${bridgeCount}</td></tr>
    <tr><td>Tunnels</td>                    <td>${tunnelCount}</td></tr>
    <tr><td>Cities</td>                     <td>${citiesList}</td></tr>
    <tr><td>Countries</td>                  <td>${countriesList}</td></tr>`;
}
    
 function resetDistance(){totalDist=0;lastPos=null;positions=[];roadTypes.clear();distEl.textContent='Distance: 0.0 km';speedEl.textContent='Speed: N/A';roadTypeEl.textContent = 'Road type: N/A';timeData=[];distData=[];speedData=[];trackLine.setLatLngs([]);map.setView([0,0],2);updateStreetTable();updateCountTable();}
 function saveAndPrint () {
  const btn  = event.currentTarget;
  btn.disabled = true;

  const orig = btn.textContent;
  btn.innerHTML = '<span class="spinner"></span> Generating‚Ä¶';

  // Removed: logButton('Save report to PDF', false);

  // Give the spinner a brief moment to show, then print
  setTimeout(() => {
    window.print();
    btn.disabled  = false;
    btn.textContent = orig;
  }, 500);
}
    function showError(e){locEl.textContent='Error: '+e.message;speedEl.textContent='Speed: N/A';}
    function getWeather(city){fetch(`https://api.weatherapi.com/v1/current.json?key=ad8caecea06c43d1912181938230407&q=${encodeURIComponent(city)}`)
        .then(r=>r.json()).then(d=>{const iconPath=d.current.condition.icon||'';const iconUrl=iconPath.startsWith('//')?'https:'+iconPath:iconPath;iconEl.src=iconUrl;iconEl.alt=d.current.condition.text||'weather';tempEl.textContent=`Temp: ${d.current.temp_c}¬∞C`;}).catch(err=>{tempEl.textContent='Temp: N/A';console.error('Weather error',err);});}

  function captureSnapshotFromCamera() {
  try {
    const video  = document.getElementById('camera');
    const canvas = document.getElementById('cameraCanvas');
    if (!video || !canvas) return null;

    // Ensure camera is actually streaming
    if (!video.videoWidth || !video.videoHeight) return null;

    canvas.width  = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    return canvas.toDataURL('image/jpeg', 0.8); // ~80% quality
  } catch (e) {
    console.warn('captureSnapshotFromCamera failed', e);
    return null;
  }
}

function recordSample(issueText = '') {
  if (!lastPos) return;

  const rowNo      = samplingTable.length + 1;
  const timestamp  = new Date().toISOString();
  const latitude   = lastPos.lat;
  const longitude  = lastPos.lon;
  const distanceKm = (totalDist / 1000).toFixed(3);
  const speed      = lastSpeedKmh.toFixed(1);
  const maxSpd     = maxSpeed.toFixed(1);
  const legalSpd   = (currentLegalSpeed ?? '');

  // snapshot current toggles (so export is time-accurate)
  const toggleSnapshot = {};
  toggleDefs.forEach(def => {
    if (def.kind === 'tri') {
      // tri-state: Not tested / No / Yes
      const fallback = def.states?.[0] || 'Not tested';
      toggleSnapshot[def.signal] = toggleState[def.signal] ?? fallback;
    } else {
      // binary legacy toggle
      toggleSnapshot[def.signal] = toggleState[def.signal] ?? def.offValue;
    }
  });

  samplingTable.push({
    no:        rowNo,
    timestamp,
    lat:       latitude,
    lon:       longitude,
    distance:  distanceKm,
    speed:     speed,
    maxspeed:  maxSpd,
    legalSpeed: legalSpd,
    issue:     issueText || '',
    toggles:   toggleSnapshot
  });
}
    
function logButton(name, isRed) {
  // ‚ë† Timestamp
  const dt   = new Date();
  const date = dt.toLocaleDateString();
  const time = dt.toLocaleTimeString();

  // ‚ë° Phase & weather
  const fullPhase = document.getElementById('dayPhase').textContent;
  const phase     = fullPhase.split(': ')[1] || fullPhase;
  const condition = iconEl.alt || 'Unknown';

  // ‚ë¢ Location (lat/lon text from sidebar)
  const [lat, lon] = locEl.innerHTML
    .split('<br>')
    .map(l => l.split(': ')[1]);

  // ‚ë£ Distance, speed, road type, country
  const dist    = (totalDist / 1000).toFixed(1);
  const spd     = speedEl.textContent.split(' ')[1];
  const rt      = roadTypeEl.textContent.split(': ')[1];
  const country = lastCountry || 'Unknown';

  // ‚ë§ Comment (apply corrections just once)
  let comment = document.getElementById('textBox').value;
  comment = applyCorrections(comment);

  // ‚ë• Optional camera snapshot
  // Prefer the early snapshot captured when typing; fall back to capturing now.
  let camDataUrl = pendingSnapshotDataUrl || captureSnapshotFromCamera();

  // ‚ë¶ Push into the log array as an OBJECT (not raw array anymore)
  const row = {
    issue:     name,
    date,
    time,
    phase,
    temp:      tempEl.textContent,
    condition,
    lat,
    lon,
    dist,
    speed:     spd,
    roadType:  rt,
    comment,
    snapshot:  camDataUrl,
    isRed:     !!isRed,
    country
  };
  logTable.push(row);
  checkUploadEligibility();

  try { playSuccess(isRed ? 'red' : 'normal'); } catch(e) {}

  // still record a sampling row with the issue text
  recordSample(name);

  // ‚ëß Map marker for this issue (numbered)
  const issueNumber = logTable.length;
  const marker = L.marker([+lat, +lon], {
    icon: L.divIcon({
      className: 'issue-label',
      html: `<strong>${issueNumber}</strong>`
    })
  }).addTo(map);
  issueMarkers.push(marker);

  // ‚ë® Recompute KPI counts from the whole log (so deletions will also work)
  recomputeAggregatesFromLog();
  updateStreetTable();
  updateCountryTable();
  updateWeatherTable();
  updatePhaseTable();
  updateCountTable();

  // ‚ë© Refresh tables & snapshots
  displayLogTable();        // renders Issue list only
  renderLatestSnapshots(5); // renders only the latest 5 snapshots
  displayCameraTable();

  markDirty();

  // ‚ë™ Clear the textbox and snapshot cache
  document.getElementById('textBox').value = '';
  pendingSnapshotDataUrl = null;
}

function displayCameraTable() {
  const target = document.getElementById('cameraTableContainer');
  if (!target) return;

  let html = `
    <table>
      <tr><th>No.</th><th>Snapshot</th></tr>`;
  logTable.forEach((row, i) => {
    const img = row.snapshot;
    const cell = img
      ? `<img src="${img}"
              alt="Camera ${i+1}"
              style="width:320px;height:240px;object-fit:cover;border:1px solid #444;">`
      : '‚Äî';
    html += `<tr><td>${i+1}</td><td>${cell}</td></tr>`;
  });
  html += '</table>';
  target.innerHTML = html;
}
    
function displayLogTable() {
  let mainHtml = `
    <table id="logTable">
      <tr>
        <th>No.</th>
        <th>Issue</th>
        <th>Date</th>
        <th>Time</th>
        <th>Phase</th>
        <th>Temp</th>
        <th>Weather</th>
        <th>Lat</th>
        <th>Lon</th>
        <th>Distance (km)</th>
        <th>Speed (km/h)</th>
        <th>Road</th>
        <th>Comment</th>
        <th data-export="no">Remove</th>
      </tr>`;

  logTable.forEach((row, i) => {
    // treat this row as an object as in your current version:
    // { issue, date, time, phase, temp, condition, lat, lon, dist, speed, roadType, comment, camDataUrl }
    const hasComment = !!(row.comment && row.comment.trim());

    mainHtml += `
      <tr data-log-index="${i}">
        <td>${i + 1}</td>
        <td>${row.issue      ?? '‚Äî'}</td>
        <td>${row.date       ?? '‚Äî'}</td>
        <td>${row.time       ?? '‚Äî'}</td>
        <td>${row.phase      ?? '‚Äî'}</td>
        <td>${row.temp       ?? '‚Äî'}</td>
        <td>${row.condition  ?? '‚Äî'}</td>
        <td>${row.lat        ?? '‚Äî'}</td>
        <td>${row.lon        ?? '‚Äî'}</td>
        <td>${row.dist       ?? '‚Äî'}</td>
        <td>${row.speed      ?? '‚Äî'}</td>
        <td>${row.roadType   ?? '‚Äî'}</td>

        <!-- editable comment cell with placeholder behaviour -->
        <td class="commentCell ${hasComment ? '' : 'empty'}" contenteditable="true">
          ${hasComment ? row.comment : ''}
        </td>

        <td data-export="no">
          <button type="button"
                  class="bigButton redButton"
                  style="min-width:0;padding:2px 6px;font-size:11px;"
                  onclick="deleteIssue(${i})">
            ‚úï
          </button>
        </td>
      </tr>`;
  });

  mainHtml += `</table>`;
  document.getElementById('logTableContainer').innerHTML = mainHtml;

  // attach handlers for editing comments
  attachCommentEditHandlers();
}

function attachCommentEditHandlers() {
  const container = document.getElementById('logTableContainer');
  if (!container) return;

  const cells = container.querySelectorAll('.commentCell');
  cells.forEach(cell => {
    cell.addEventListener('blur', onCommentCellBlur);
  });
}

function onCommentCellBlur(e) {
  const cell  = e.target;
  const rowEl = cell.closest('tr');
  if (!rowEl) return;

  const index = Number(rowEl.dataset.logIndex);
  if (!Number.isInteger(index) || !logTable[index]) return;

  // Normalize text
  const newText = cell.textContent.replace(/\s+/g, ' ').trim();

  // Update model
  logTable[index].comment = newText;

  // Toggle placeholder style
  if (newText) {
    cell.classList.remove('empty');
  } else {
    cell.classList.add('empty');
  }

  if (typeof markDirty === 'function') {
    markDirty();
  }
}

function renderLatestSnapshots(limit = 5) {
  const container = document.getElementById('snapshotTableContainer');
  if (!container) return;

  const start = Math.max(0, logTable.length - limit);
  const rows  = logTable.slice(start);

  const table = document.createElement('table');
  table.id = 'snapshotTable';
  table.style.cssText = 'width:100%;border-collapse:collapse;border:1px solid #444;margin-bottom:80px;';

  const head = document.createElement('tr');
  head.innerHTML = `
    <th style="border:1px solid #444;padding:6px 8px;">No.</th>
    <th style="border:1px solid #444;padding:6px 8px;">Issue</th>
    <th style="border:1px solid #444;padding:6px 8px;">Map</th>
    <th style="border:1px solid #444;padding:6px 8px;">Photo</th>`;
  table.appendChild(head);

  rows.forEach((row, i) => {
    const tr = document.createElement('tr');
    const globalIndex = start + i;

    const rawLat = String(row.lat ?? '').trim().replace(',', '.');
    const rawLon = String(row.lon ?? '').trim().replace(',', '.');
    const lat    = Number(rawLat);
    const lon    = Number(rawLon);
    const issue  = row.issue;
    const camUrl = row.snapshot;

    const tdNo    = document.createElement('td');
    const tdIssue = document.createElement('td');
    tdNo.style.cssText = tdIssue.style.cssText = 'border:1px solid #444;padding:6px 8px;';
    tdNo.textContent    = String(globalIndex + 1);
    tdIssue.textContent = issue ?? '‚Äî';

    const tdMap = document.createElement('td');
    tdMap.style.cssText = 'border:1px solid #444;padding:6px 8px;';
    if (Number.isFinite(lat) && Number.isFinite(lon)) {
      const dLat = 0.003, dLon = 0.005;
      const bbox = [
        (lon - dLon).toFixed(6),
        (lat - dLat).toFixed(6),
        (lon + dLon).toFixed(6),
        (lat + dLat).toFixed(6)
      ].join('%2C');

      const iframe = document.createElement('iframe');
      iframe.width  = '300';
      iframe.height = '200';
      iframe.loading = 'lazy';
      iframe.referrerPolicy = 'no-referrer-when-downgrade';
      iframe.style.border = '1px solid #444';
      iframe.src =
        `https://www.openstreetmap.org/export/embed.html?bbox=${bbox}` +
        `&marker=${encodeURIComponent(lat)},${encodeURIComponent(lon)}` +
        `&layer=mapnik`;
      tdMap.appendChild(iframe);
    } else {
      tdMap.innerHTML =
        `<div style="width:300px;height:200px;display:flex;align-items:center;justify-content:center;border:1px solid #444;color:#bbb;">Bad lat/lon</div>`;
    }

    const tdPhoto = document.createElement('td');
    tdPhoto.style.cssText = 'border:1px solid #444;padding:6px 8px;';
    if (camUrl) {
      const img = document.createElement('img');
      img.loading = 'lazy';
      img.src = camUrl;
      img.width  = 300;
      img.height = 200;
      img.style.cssText = 'object-fit:cover;border:1px solid #444;';
      tdPhoto.appendChild(img);
    } else {
      tdPhoto.textContent = '‚Äî';
    }

    tr.appendChild(tdNo);
    tr.appendChild(tdIssue);
    tr.appendChild(tdMap);
    tr.appendChild(tdPhoto);
    table.appendChild(tr);
  });

  container.innerHTML = '';
  container.appendChild(table);
}

function recomputeAggregatesFromLog() {
  // Reset all per-issue counters
  redCounts        = {};
  roadRedCounts    = {};
  countryRedCounts = {};
  weatherRedCounts = {};
  phaseRedCounts   = {};

  logTable.forEach(row => {
    if (!row || !row.isRed) return;

    const issue   = row.issue;
    const rt      = row.roadType || 'Unknown';
    const country = row.country  || 'Unknown';
    const cond    = row.condition || 'Unknown';
    const phase   = row.phase || 'Unknown';

    redCounts[issue]          = (redCounts[issue]          || 0) + 1;
    roadRedCounts[rt]         = (roadRedCounts[rt]         || 0) + 1;
    countryRedCounts[country] = (countryRedCounts[country] || 0) + 1;
    weatherRedCounts[cond]    = (weatherRedCounts[cond]    || 0) + 1;
    phaseRedCounts[phase]     = (phaseRedCounts[phase]     || 0) + 1;
  });
}

function deleteIssue(index) {
  if (index < 0 || index >= logTable.length) return;

  const row = logTable[index];
  const label =
    row && row.issue
      ? `#${index + 1} ‚Äì "${row.issue}"`
      : `issue #${index + 1}`;

  if (!confirm(`Remove ${label}?`)) return;

  // 1) Remove from log
  logTable.splice(index, 1);

  // 2) Remove matching marker if present
  if (issueMarkers[index]) {
    try {
      map.removeLayer(issueMarkers[index]);
    } catch (e) {
      console.warn('Failed to remove marker', e);
    }
    issueMarkers.splice(index, 1);
  }

  // 3) Re-number marker labels so they match the new indices
  issueMarkers.forEach((marker, i) => {
    marker.setIcon(L.divIcon({
      className: 'issue-label',
      html: `<strong>${i + 1}</strong>`
    }));
  });

  // 4) Recompute counts and refresh KPI tables
  recomputeAggregatesFromLog();
  updateCountTable();
  updateStreetTable();
  updateCountryTable();
  updateWeatherTable();
  updatePhaseTable();

  // 5) Refresh UI tables & snapshots
  displayLogTable();
  renderLatestSnapshots(5);
  displayCameraTable();

  checkUploadEligibility();
  markDirty();
}

function updateCountTable(){let html='<tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>';const km=totalDist/1000;for(let issue in redCounts){const c=redCounts[issue];const per=km>0?((c/km)*1000).toFixed(1):'‚Äî';html+=`<tr><td>${issue}</td><td>${c}</td><td>${per}</td></tr>`;}countTbl.innerHTML=html;}

function resortTriToggles() {
  const groups = document.querySelectorAll('#buttonGroups .button-group');

  groups.forEach(group => {
    // only tri-state toggles (we‚Äôll tag them in buildButtons)
    const triButtons = Array.from(
      group.querySelectorAll('button[data-toggle-kind="tri"]')
    );
    if (triButtons.length === 0) return;

    triButtons.sort((a, b) => {
      const sigA = a.dataset.signal;
      const sigB = b.dataset.signal;

      const stateA = toggleState[sigA]; // "Not tested" / "No" / "Yes"
      const stateB = toggleState[sigB];

      const rankA = stateA === 'Not tested' ? 0 : 1;
      const rankB = stateB === 'Not tested' ? 0 : 1;

      if (rankA !== rankB) return rankA - rankB;

      // same rank ‚Üí keep original CSV order
      const orderA = Number(a.dataset.order || 0);
      const orderB = Number(b.dataset.order || 0);
      return orderA - orderB;
    });

    // remove and append back in sorted order
    triButtons.forEach(btn => group.removeChild(btn));
    triButtons.forEach(btn => group.appendChild(btn));
  });
}
    
// Build buttons from CSV using fetch + PapaParse
function buildButtons(csvFile = 'KPI_buttons.csv') {
  const buttonGroups = document.getElementById('buttonGroups');
  buttonGroups.innerHTML = '';
  toggleDefs = []; // reset on rebuild
  toggleNotes = {}; // reset all notes when loading a new button config
  Object.keys(triToggleTouched).forEach(k => delete triToggleTouched[k]);

  fetch(csvFile)
    .then(r => {
      if (!r.ok) throw new Error(`Failed to load ${csvFile}: ${r.status} ${r.statusText}`);
      return r.text();
    })
    .then(csvText => {
      const { data, errors } = Papa.parse(csvText, { header: true, skipEmptyLines: true });
      if (errors?.length) console.error('CSV parse errors:', errors);

      const groups = {};  // { groupKey: <div.button-group> }

      data.forEach(row => {
        // --- normalize all CSV fields (trim + sane defaults) ---
        const groupKey = String(row.group ?? '').trim();
        const label    = String(row.label ?? '').trim();
        const cssClass = String(row.cssClass ?? '').trim();
        const logName  = String((row.logName ?? label)).trim();
        const type     = String(row.type ?? '').trim().toLowerCase();
        const signal   = String(row.signal ?? '').trim();
        const onValue  = String(row.onValue ?? '1').trim();
        const offValue = String(row.offValue ?? '0').trim();
        const def      = String(row.default ?? '').trim();

        if (!groupKey || !label) return;

        // one column per group (header item will be just another row in the group)
        if (!groups[groupKey]) {
          const wrap = document.createElement('div');
          wrap.className = 'button-group';
          groups[groupKey] = wrap;
          buttonGroups.appendChild(wrap);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // 2-STATE TOGGLE  (BACKWARDS-COMPATIBLE)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (type === 'toggle' && signal) {
          const isOn =
            def === '1' || def.toLowerCase() === 'true' || def.toLowerCase() === 'on';

          toggleState[signal] = isOn ? onValue : offValue;
          toggleDefs.push({ signal, onValue, offValue, label, kind: 'binary' });

          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = `toggleButton bigButton ${cssClass}`.trim();
          btn.setAttribute('role', 'switch');
          btn.setAttribute('aria-checked', String(isOn));

          const text  = document.createElement('span');
          const track = document.createElement('span');
          const thumb = document.createElement('span');
          track.className = 'track';
          thumb.className = 'thumb';
          track.appendChild(thumb);
          btn.append(text, track);

          const render = () => {
            const on = btn.getAttribute('aria-checked') === 'true';
            const current = on ? onValue : offValue;
            text.textContent = `${label}: ${current}`;
          };
          const flip = () => {
            const on = btn.getAttribute('aria-checked') === 'true';
            btn.setAttribute('aria-checked', String(!on));
            toggleState[signal] = !on ? onValue : offValue;
            render();
          };
          render();
          btn.addEventListener('click', flip);
          btn.addEventListener('keydown', e => {
            if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); flip(); }
          });

          groups[groupKey].appendChild(btn);
          return;
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3-STATE TOGGLE  (NEW: type = toggle3 / tri-toggle / tristate)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3-STATE TOGGLE  (NEW: type = toggle3 / tri-toggle / tristate)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if ((type === 'toggle3' || type === 'tri-toggle' || type === 'tristate') && signal) {
  const states = ['Not tested', 'No', 'Yes'];

  let defaultIndex = 0;
  const d = def.toLowerCase();
  if (d === 'no'  || d === '0')                 defaultIndex = 1;
  if (d === 'yes' || d === '1' || d === 'true') defaultIndex = 2;

  let stateIndex = defaultIndex;
  toggleState[signal] = states[stateIndex];

  toggleDefs.push({
    signal,
    label,
    kind: 'tri',
    states
  });

  const btn = document.createElement('button');
  btn.type = 'button';
  btn.className = `toggleButton bigButton ${cssClass}`.trim();
  btn.setAttribute('role', 'button');

  btn.dataset.toggleKind = 'tri';
  btn.dataset.signal     = signal;
  btn.dataset.order      = String(triToggleSerial++);

  const text = document.createElement('span');
  btn.appendChild(text);

  const render = () => {
    const state = states[stateIndex];
    const note  = toggleNotes[signal];
    text.textContent = note
      ? `${label}: ${state} üìù`
      : `${label}: ${state}`;

    if (state === 'Yes') {
      btn.style.backgroundColor = '#2e7d32';
    } else if (state === 'No') {
      btn.style.backgroundColor = '#8b0000';
    } else {
      btn.style.backgroundColor = '#2a2a2a';
    }
  };

  function openNotePrompt() {
    const prev = toggleNotes[signal] || '';
    const next = prompt(`Custom annotation for "${label}":`, prev);
    if (next === null) return;
    const trimmed = next.trim();
    if (trimmed) {
      toggleNotes[signal] = trimmed;
    } else {
      delete toggleNotes[signal];
    }
    render();
  }

  // üì± / üíª note trigger wiring
  let longPressTimer = null;
  let longPressTriggered = false;

  // Desktop: right-click only if NOT touch
  if (!isTouchDevice) {
    btn.addEventListener('contextmenu', e => {
      e.preventDefault();
      e.stopPropagation();
      openNotePrompt();
    });
  }

  // Touch: long-press
  function startLongPress(e) {
    if (e.type === 'touchstart') {
      longPressTriggered = false;
      longPressTimer = setTimeout(() => {
        longPressTriggered = true;
        openNotePrompt();
      }, 600);
    }
  }

  function cancelLongPress() {
    if (longPressTimer) {
      clearTimeout(longPressTimer);
      longPressTimer = null;
    }
  }

  btn.addEventListener('touchstart', startLongPress, { passive: true });
  btn.addEventListener('touchend',   cancelLongPress);
  btn.addEventListener('touchmove',  cancelLongPress);
  btn.addEventListener('touchcancel',cancelLongPress);

  const cycle = () => {
    // remember index before the click
    const prevIndex = stateIndex;

    // advance state
    stateIndex = (stateIndex + 1) % states.length;
    toggleState[signal] = states[stateIndex];

    // mark this tri-toggle as "touched" once it ever leaves its default state
    if (stateIndex !== defaultIndex || prevIndex !== defaultIndex) {
      triToggleTouched[signal] = true;
    }

    render();
  };

  render();

  btn.addEventListener('click', e => {
    if (longPressTriggered) {
      longPressTriggered = false; // swallow click after long-press
      return;
    }
    cycle();
  });

  btn.addEventListener('keydown', e => {
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      cycle();
    }
  });

  groups[groupKey].appendChild(btn);
  return;
}

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Normal press-to-log buttons (including grey headers)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const btn = document.createElement('button');
        btn.textContent = label;
        btn.className = `bigButton ${cssClass}`.trim();
        const isRed = btn.classList.contains('redButton');
        btn.addEventListener('click', () => logButton(logName, isRed));
        groups[groupKey].appendChild(btn);
      });
    })
    .catch(err => console.error('Error building buttons:', err));
}
  
    function updateDayPhase(lat, lon) {
    fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&formatted=0`)
    .then(r => r.json())
    .then(data => {
      const now   = new Date();
      const dawn  = new Date(data.results.civil_twilight_begin);
      const sunrise = new Date(data.results.sunrise);
      const sunset  = new Date(data.results.sunset);
      const dusk    = new Date(data.results.civil_twilight_end);

      let phase;
      if (now < dawn) {
        phase = 'Night';
      } else if (now < sunrise) {
        phase = 'Dawn';
      } else if (now < sunset) {
        phase = 'Daylight';
      } else if (now < dusk) {
        phase = 'Dusk';
      } else {
        phase = 'Night';
      }

      document.getElementById('dayPhase').textContent = `Phase: ${phase}`;
    })
    .catch(err => console.error('Sun API error', err));
}

function updateWeatherTable() {
  let html = `
    <tr>
      <th>Condition</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  for (const cond in weatherDistances) {
    const meters = weatherDistances[cond] || 0;
    const km     = (meters / 1000).toFixed(1);
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';
    const count  = weatherRedCounts[cond] || 0;

    html += `
      <tr>
        <td>${cond}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  document.getElementById('weatherTable').innerHTML = html;
}

const tablesToUpload = [
  'logTable',
  'statsTable',
  'countTable',
  'streetTable',
  'metaTable',
  'countryTable',
  'weatherTable',
  'phaseTable'
];

async function maybeUpdateTables() {
  const now = Date.now();

  if (now - lastTableUpdate > TABLE_THROTTLE) {
    displayLogTable();
    renderLatestSnapshots(5);
    updateStatsTable();
    updateCountTable();
    updateStreetTable();
    updateCountryTable();
    updateWeatherTable();
    updatePhaseTable();
    lastTableUpdate = now;
  }

if (uploadsEnabled && (now - lastUploadTime > UPLOAD_THROTTLE)) {
  lastUploadTime = now;

  uploadWorkbookToAzure().then(() => console.log('Workbook auto-uploaded'))
    .catch(err => console.error('Workbook upload failed:', err));

  uploadSnapshotsZip().then(() => console.log('Snapshots ZIP uploaded'))
    .catch(err => console.error('Snapshots ZIP upload failed:', err));

    //exportCustomSectionsToAzure()
    //  .then(() => console.log('PDF report uploaded'))
    //  .catch(err => console.error('PDF upload failed:', err));
  }
}

function updatePhaseTable() {
  let html = `
    <tr>
      <th>Phase</th>
      <th>Distance (km)</th>
      <th>Distance (%)</th>
      <th>No of issues</th>
    </tr>`;

  for (const ph in phaseDistances) {
    const meters = phaseDistances[ph] || 0;
    const km     = (meters / 1000).toFixed(1);
    const pct    = totalDist > 0
      ? ((meters / totalDist) * 100).toFixed(1)
      : '0.0';
    const count  = phaseRedCounts[ph] || 0;

    html += `
      <tr>
        <td>${ph}</td>
        <td>${km}</td>
        <td>${pct}%</td>
        <td>${count}</td>
      </tr>`;
  }

  document.getElementById('phaseTable').innerHTML = html;
}

function updateDateTime() {
  const now = new Date();
  document.getElementById('dateTime').textContent = now.toLocaleString();

  const todayStr = now.toISOString().slice(0,10); // "YYYY-MM-DD"

  // If a new calendar day has started while the page is still open,
  // automatically end the old session so a new test will start next time.
  if (
    !sessionEnded &&                       // not already ended
    todayStr !== appStartDateStr &&        // date changed
    (totalDist > 0 || logTable.length > 0) // there *was* a test running
  ) {
    console.log('New day detected ‚Üí auto-ending previous session');
    stopTesting(); // uses your existing shutdown + upload logic
  }
}

function tableToCSV(tableEl) {
  const rows = Array.from(tableEl.querySelectorAll('tr'));
  return rows
    .map(row => {
      const cells = Array.from(row.querySelectorAll('th,td'))
        .filter(cell => cell.dataset.export !== 'no');   // ‚¨Ö skip Delete column
      return cells
        .map(cell => {
          // escape quotes, wrap in quotes
          const txt = cell.textContent.replace(/"/g, '""');
          return `"${txt}"`;
        })
        .join(',');
    })
    .join('\n');
}

//const containerSasUrl = "https://annotationcsv.blob.core.windows.net/csv?sv=2024-11-04&ss=bfqt&srt=co&sp=rwdlacupiytfx&se=2025-11-19T14:10:22Z&st=2025-05-19T05:10:22Z&spr=https&sig=EUXvbKk2bF2h%2B2cf5fjyVGkasbqBZJb%2FevLVJ6R%2FYCA%3D";
//const containerSasUrl = "https://annotationcsv.blob.core.windows.net/csv?sv=2024-11-04&ss=b&srt=co&sp=rwdlaciytfx&sr=c&se=2025-12-30T15:55:03Z&st=2025-07-01T06:55:03Z&spr=https&sig=NeNMbZI0PsppH4amjEmNcqMI00oC35rO8cV2swmbsyw%3D";
const containerSasUrl = "https://annotationcsv.blob.core.windows.net/?sv=2024-11-04&ss=bfqt&srt=sco&sp=rwdlacupiytfx&se=2026-12-30T23:33:30Z&st=2026-01-02T15:18:30Z&spr=https&sig=BoWBgheeFkDsFQk8Ckq1xwO3mbqtUZSdMey0pWWkzGk%3D";
    
async function measureAzureClockOffset() {
  try {
    if (!containerSasUrl) {
      throw new Error('containerSasUrl not set');
    }

    // Use the container itself as a lightweight time source
    const [baseUrl, token] = containerSasUrl.split('?');
    const url = `${baseUrl}?restype=container&${token}`;

    const t0 = Date.now();
    const resp = await fetch(url, { method: 'HEAD', cache: 'no-store' });
    const t1 = Date.now();

    if (!resp.ok) {
      throw new Error(`HTTP ${resp.status} ${resp.statusText}`);
    }

    const dateHeader =
      resp.headers.get('Date') ||
      resp.headers.get('date');

    if (!dateHeader) {
      throw new Error('No Date header from Azure');
    }

    const serverMs = Date.parse(dateHeader);  // Azure time (UTC)
    const clientAtMidpoint = (t0 + t1) / 2;   // our best guess of local time
    // Positive = device is ahead of Azure, negative = behind
    azureClockOffsetMs = clientAtMidpoint - serverMs;

    console.log(
      '[ClockOffset] Azure Date =', dateHeader,
      'offsetMs =', azureClockOffsetMs
    );

    // Refresh stats so the row stops saying "Not measured"
    updateStatsTable();
  } catch (err) {
    console.error('measureAzureClockOffset failed:', err);
    // leave azureClockOffsetMs as-is (null or previous value)
  }
}
    
function saveBlobLocally(blob, filename) {
  try {
    const url = URL.createObjectURL(blob);
    const a   = document.createElement('a');
    a.href        = url;
    a.download    = filename;
    a.style.display = 'none';

    document.body.appendChild(a);
    a.click();

    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 0);
  } catch (e) {
    console.error('Failed to trigger local download:', e);
  }
}
    
async function uploadCSVtoAzure(tableId) {
  // 1. Grab the table and convert to CSV
  const table    = document.getElementById(tableId);
  const csv      = tableToCSV(table);

  // 2. Build a timestamped blob name
  const ts       = formatAppStartTimestamp();          // e.g. "2025-05-19_084215"
  const blobName = `${tableId}-${ts}.csv`;             // e.g. "statsTable-2025-05-19_084215.csv"

  // 3. Split the SAS URL into base and token
  const [baseUrl, token] = containerSasUrl.split('?');

  // 4. Construct the full PUT URL
  const uploadUrl = `${baseUrl}/${blobName}?${token}`;

  // 5. Perform the upload
  const resp = await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
      'x-ms-blob-type': 'BlockBlob',
      'Content-Type':   'text/csv'
    },
    body: csv
  });

  if (!resp.ok) {
    throw new Error(`Upload failed: ${resp.status} ${resp.statusText}`);
  }

  console.log(`‚úî Uploaded ${blobName}`);
}

async function uploadWorkbookToAzure() {
  // 1. Create a new workbook
  const wb = XLSX.utils.book_new();

  // 2. For each visible table: convert and append
  workbookTables.forEach(({ id, name }) => {
    const tblEl = document.getElementById(id);
    if (!tblEl) {
      console.warn(`Table #${id} not found‚Äîskipping sheet "${name}"`);
      return;
    }

    let ws;

    if (id === 'logTable') {
      // üîπ Build Issues sheet manually, skipping cells with data-export="no"
      const rows = Array.from(tblEl.querySelectorAll('tr')).map(tr => {
        const cells = Array.from(tr.querySelectorAll('th,td'))
          .filter(cell => cell.dataset.export !== 'no'); // ‚¨Ö skip Remove column
        return cells.map(cell => cell.textContent);
      });
      ws = XLSX.utils.aoa_to_sheet(rows);
    } else {
      // default path for all other tables
      ws = XLSX.utils.table_to_sheet(tblEl);
    }

    // üî∏ Percent sheets: multiply column C by 100 (unchanged)
    if (['Road types', 'Country', 'Weather', 'Phase'].includes(name)) {
      const range = XLSX.utils.decode_range(ws['!ref']);
      for (let row = range.s.r + 1; row <= range.e.r; ++row) {
        const cellRef = XLSX.utils.encode_cell({ r: row, c: 2 }); // column C
        const cell = ws[cellRef];
        if (cell && typeof cell.v === 'number') {
          cell.v = cell.v * 100;
        }
      }
    }

    XLSX.utils.book_append_sheet(wb, ws, name);
  });

  // 3. --- Sampling sheet (as before, but toggle-aware) ---
  const samplingHeader = [
    "No","Timestamp","Latitude","Longitude",
    "Distance (km)","Speed (km/h)","Legal Speed (km/h)","Issue"
  ];
  // one column per configured toggle signal (order = CSV order)
  toggleDefs.forEach(def => samplingHeader.push(def.signal));

  const samplingAoA = [ samplingHeader ];

  samplingTable.forEach(entry => {
    const row = [
      entry.no,
      entry.timestamp,
      entry.lat,
      entry.lon,
      entry.distance,
      entry.speed,
      entry.legalSpeed,
      entry.issue || ''
    ];
    toggleDefs.forEach(def => {
      const valFromEntry = entry.toggles?.[def.signal];
      if (def.kind === 'tri') {
        const fallback = def.states?.[0] || 'Not tested';
        row.push(valFromEntry ?? fallback);
      } else {
        row.push(valFromEntry ?? def.offValue);
      }
    });
    samplingAoA.push(row);
  });

  const wsSampling = XLSX.utils.aoa_to_sheet(samplingAoA);
  XLSX.utils.book_append_sheet(wb, wsSampling, "Sampling");

  // 4. --- Benchmark sheet: ONLY tri-state toggles, and ONLY if at least one was used ---
  const triDefs = toggleDefs.filter(def => def.kind === 'tri');

  // keep only tri-toggles that have been changed from default at least once
  const changedTriDefs = triDefs.filter(def => triToggleTouched[def.signal]);

  if (changedTriDefs.length > 0) {
    const benchmarkAoA = [
      ["Label", "Signal", "Type", "Current value", "Comment"]
    ];

    changedTriDefs.forEach(def => {
      const value = toggleState[def.signal];
      const note  = (toggleNotes[def.signal] || '').trim();

      benchmarkAoA.push([
        def.label || def.signal,
        def.signal,
        "3-state",
        value,
        note
      ]);
    });

    const wsBenchmark = XLSX.utils.aoa_to_sheet(benchmarkAoA);
    XLSX.utils.book_append_sheet(wb, wsBenchmark, "Benchmark");
  } else {
    console.log('No tri-state buttons pressed ‚Äì skipping Benchmark sheet.');
  }

  // 5. Generate the binary workbook
  const wbout = XLSX.write(wb, {
    bookType: 'xlsx',
    type:      'array'
  });

  // 6. Wrap in a Blob
  const blob = new Blob([wbout], {
    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  });

  // 7. Determine filename using your appStartTime helper
  const blobName = `${reportBaseName}.xlsx`;

  // 8. Build upload URL from containerSasUrl
  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl        = `${baseUrl}/${blobName}?${token}`;

  // 9. Try cloud upload, fallback to local download if offline / failed
  try {
    if (!navigator.onLine) {
      throw new Error('Offline ‚Äì skipping cloud upload');
    }

    const resp = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'x-ms-blob-type': 'BlockBlob',
        'Content-Type':   'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      },
      body: blob
    });

    if (!resp.ok) {
      throw new Error(`Workbook upload failed: ${resp.status} ${resp.statusText}`);
    }

    console.log(`‚úî Uploaded workbook: ${blobName}`);
    lastXlsxUploadMs = Date.now();
    updateUploadAgo();
  } catch (err) {
    console.error('Cloud workbook upload failed, saving locally instead:', err);
    saveBlobLocally(blob, blobName);
  }
}
    
  async function exportMainContentToAzure() {
  const mainEl = document.getElementById('mainContent');
  const htmlDoc = `
    <!DOCTYPE html><html lang="en"><head>
      <meta charset="UTF-8"/>
      <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
      <title>Annotation Report</title>
      <style>
        /* your critical styles */
        body { font-family: Arial,sans-serif; margin:0; padding:0; }
        #mainContent { padding:20px; }
      </style>
    </head><body>
      ${mainEl.outerHTML}
    </body></html>`.trim();

  const blob = new Blob([htmlDoc], { type: 'text/html' });
  const blobName = `${reportBaseName}.html`;  // same base, different extension

  // build uploadUrl from your containerSasUrl
  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl        = `${baseUrl}/${blobName}?${token}`;

  const resp = await fetch(uploadUrl, {
    method: 'PUT',
    headers: {
      'x-ms-blob-type': 'BlockBlob',
      'Content-Type':   'text/html'
    },
    body: blob
  });

  if (!resp.ok) {
    throw new Error(`HTML export failed: ${resp.status} ${resp.statusText}`);
  }
  console.log(`‚úî Uploaded HTML report: ${blobName}`);
}

async function exportPDFToAzure() {
  // 0) Locate the live map and its parent wrapper
  const map2El     = document.getElementById('map2');
  const wrapper    = map2El.parentElement;  
  const reportName = `${reportBaseName}.pdf`;

  // 1) Ensure there‚Äôs a hidden snapshot container alongside #map2
  let snapEl = wrapper.querySelector('#map2-snapshot');
  if (!snapEl) {
    snapEl = document.createElement('div');
    snapEl.id = 'map2-snapshot';
    snapEl.style.display = 'none';
    snapEl.style.width  = map2El.style.width  || '100%';
    snapEl.style.height = map2El.style.height || 'auto';
    wrapper.appendChild(snapEl);
  }

  // 2) Render the live map into the hidden container
  await new Promise(resolve => {
    leafletImage(map2, (err, canvas) => {
      if (!err && canvas) {
        const imgUrl = canvas.toDataURL('image/png');
        snapEl.innerHTML = `
          <img
            src="${imgUrl}"
            alt="Street View Snapshot"
            style="width:100%; height:auto; object-fit:cover;"
          >
        `;
      }
      resolve();
    });
  });

  // 3) Swap visibility: hide live map, show snapshot
  map2El.style.display  = 'none';
  snapEl.style.display  = 'block';

  // 4) Expand mainContent for HTML‚ÜíPDF
  const mainEl      = document.getElementById('mainContent');
  const origHeight  = mainEl.style.height;
  const origOverflow= mainEl.style.overflow;
  mainEl.style.height   = 'auto';
  mainEl.style.overflow = 'visible';

  try {
    // 5) Generate the PDF blob with html2pdf
    const opt = {
      margin:       0.2,
      filename:     reportName,
      image:        { type: 'jpeg', quality: 0.98 },
      html2canvas:  { scale: 1.5, useCORS: true },
      jsPDF: {
        unit:        'in',
        format:      'a4',
        orientation: 'landscape'
      }
    };
    const pdfBlob = await html2pdf().set(opt).from(mainEl).outputPdf('blob');

    // 6) Upload to Azure
    const [baseUrl, token] = containerSasUrl.split('?');
    const uploadUrl        = `${baseUrl}/${reportName}?${token}`;
    const resp = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'x-ms-blob-type': 'BlockBlob',
        'Content-Type':   'application/pdf'
      },
      body: pdfBlob
    });
    if (!resp.ok) {
      throw new Error(`PDF upload failed: ${resp.status} ${resp.statusText}`);
    }
  } finally {
    // 7) Restore everything: mainContent style, swap map back
    mainEl.style.height   = origHeight;
    mainEl.style.overflow = origOverflow;
    snapEl.style.display  = 'none';
    map2El.style.display  = 'block';
  }
}

// 1) List the IDs you want to include, in order
const SECTIONS_TO_EXPORT = [
  'metaContainer',         // Test details
  'statsContainer',        // Statistics
  'logTableContainer',     // Issue list
  'snapshotContainer',     // Issue Snapshots
  'countContainer',        // KPI Calculation
  'mapContainer',          // Route view
  'streetsContainer',      // Road Types
  'countryContainer',      // Countries
  'weatherContainer',      // Weather
  'phaseContainer'        // Phase
];

let sectionTexts = {};
  async function loadSectionTexts() {
    try {
      const resp = await fetch('sectionTexts.json');
      if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
      sectionTexts = await resp.json();
    } catch (err) {
      console.warn('Could not load section-text mapping:', err);
      sectionTexts = {};
    }
  }

  async function exportCustomSectionsToAzure() {
  // 0) Load your external section-texts JSON
  await loadSectionTexts();

  // 1) Prep blob name & upload URL
  const blobName = `${reportBaseName}.pdf`;
  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl       = `${baseUrl}/${blobName}?${token}`;

  // 2) Create off-DOM wrapper sized to A4 width
  const tmp = document.createElement('div');
  tmp.id = 'pdf-custom-clone';
  Object.assign(tmp.style, {
    position:   'relative',
    width:      '180mm',      /* tightened from 190mm */
    margin:     '0 auto',
    background: '#fff',
    boxSizing:  'border-box',
  });
  document.body.appendChild(tmp);

  // 3) Inject CSS for headings, paragraphs, tables, snapshot-table column widths
  const style = document.createElement('style');
  style.textContent = `
    #pdf-custom-clone h2 {
      font-size: 18px;
      margin: 0.5em 0 0.2em;
    }
    #pdf-custom-clone p {
      font-size: 11px;
      margin: 0 0 8px;
    }
    #pdf-custom-clone table {
      width: 100% !important;
      table-layout: fixed;
      word-wrap: break-word;
      font-size: 9px;
      border-collapse: collapse;
    }
    #pdf-custom-clone th,
    #pdf-custom-clone td {
      padding: 4px;
      border: 1px solid #444;
      vertical-align: top;
    }
    /* Snapshot table: tighten first two cols, expand last two */
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(1),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(1),
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(2),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(2) {
      width: 5%;
    }
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(3),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(3),
    #pdf-custom-clone #snapshotTableContainer table th:nth-child(4),
    #pdf-custom-clone #snapshotTableContainer table td:nth-child(4) {
      width: 45%;
    }
    .page-break { page-break-after: always; }
  `;
  tmp.appendChild(style);

  // 4) Clone each section in order, injecting header/text first
  SECTIONS_TO_EXPORT.forEach((id, idx) => {
    // 4a) Insert custom header + text if present
    const info = sectionTexts[id];
    if (info) {
      const h2 = document.createElement('h2');
      h2.textContent = info.header;
      tmp.appendChild(h2);
      const p = document.createElement('p');
      p.textContent = info.text;
      tmp.appendChild(p);
    }

    // 4b) Render charts as images, or clone the DOM section
    if (id === 'chartsContainer') {
      const wrapper = document.createElement('div');
      wrapper.id = 'chartsContainer';

      // Distance vs Time chart
      const distImg = new Image();
      distImg.src   = distanceChart.toBase64Image();
      distImg.style.width = '100%';
      wrapper.appendChild(distImg);

      // Page-break between charts
      wrapper.appendChild(Object.assign(document.createElement('div'), { className: 'page-break' }));

      // Speed vs Distance chart
      const speedImg = new Image();
      speedImg.src   = speedChart.toBase64Image();
      speedImg.style.width = '100%';
      wrapper.appendChild(speedImg);

      tmp.appendChild(wrapper);
    } else {
      const src = document.getElementById(id);
      if (src) {
        const clone = src.cloneNode(true);
        // Strip out interactive elements
        clone.querySelectorAll('button,input').forEach(n => n.remove());
        tmp.appendChild(clone);
      }
    }

    // 4c) Insert a page-break after each section (except last)
    if (idx < SECTIONS_TO_EXPORT.length - 1) {
      const pbr = document.createElement('div');
      pbr.className = 'page-break';
      tmp.appendChild(pbr);
    }
  });

  // 5) Prepare for html2canvas/pdf
  const htmlEl = document.documentElement;
  const bodyEl = document.body;
  const origHtmlOv = htmlEl.style.overflow;
  const origBodyOv = bodyEl.style.overflow;
  htmlEl.style.overflow = 'visible';
  bodyEl.style.overflow = 'visible';

  // 6) Generate PDF blob
  let pdfBlob;
  try {
    const opt = {
      margin:      5,
      filename:    blobName,
      image:       { type:'jpeg', quality:0.98 },
      html2canvas: { scale:1, useCORS:true, scrollX:0, scrollY:0 },
      jsPDF:       { unit:'mm', format:'a4', orientation:'portrait' }
    };
    pdfBlob = await html2pdf().set(opt).from(tmp).outputPdf('blob');
  } catch (err) {
    console.error('PDF generation failed:', err);
  } finally {
    htmlEl.style.overflow = origHtmlOv;
    bodyEl.style.overflow = origBodyOv;
    document.body.removeChild(tmp);
  }
  if (!pdfBlob) return;

  // 7) Upload PDF to Azure Blob Storage
  try {
    const resp = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'x-ms-blob-type': 'BlockBlob',
        'Content-Type':   'application/pdf'
      },
      body: pdfBlob
    });
    if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`);
    console.log(`‚úî Uploaded custom PDF as ${blobName}`);
  } catch (err) {
    console.error('Custom PDF upload failed:', err);
  }
}

async function uploadSnapshotsZip() {
  console.log('üíæ uploadSnapshotsZip() called; logTable.length =', logTable.length);
  const zip = new JSZip();

  logTable.forEach((row, i) => {
    const dataUrl = row.snapshot;
    if (!dataUrl) return;   // skip if no snapshot

    const [meta, base64] = dataUrl.split(',');
    const ext = meta.includes('png') ? 'png' : 'jpg';
    const filename = `${i+1}.${ext}`;    // 1.jpg, 2.jpg, 3.jpg, ‚Ä¶

    zip.file(filename, base64, { base64: true });
  });

  const content = await zip.generateAsync({ type: 'blob' });

  // Use the same base name as your PDF/XLSX, but with .zip
  const blobName = `${reportBaseName}.zip`;

  const [baseUrl, token] = containerSasUrl.split('?');
  const uploadUrl        = `${baseUrl}/${blobName}?${token}`;

  try {
    if (!navigator.onLine) {
      throw new Error('Offline ‚Äì skipping cloud upload');
    }

    const resp = await fetch(uploadUrl, {
      method: 'PUT',
      headers: {
        'x-ms-blob-type': 'BlockBlob',
        'Content-Type':   'application/zip'
      },
      body: content
    });

    if (!resp.ok) {
      throw new Error(`Snapshot ZIP upload failed: ${resp.status} ${resp.statusText}`);
    }

    console.log(`‚úî Uploaded snapshots ZIP as ${blobName}`);
  } catch (err) {
    console.error('Cloud ZIP upload failed, saving locally instead:', err);
    saveBlobLocally(content, blobName);
  }
}
    
// 1) Grab the existing Upload button
const uploadNowBtn = document.getElementById('uploadNowButton');

// 2) Helper to show a brief spinner state (you already have this)
function withSpinner(btn, fn) {
  const orig = btn.innerHTML;
  btn.disabled = true;
  btn.innerHTML = '<span class="spinner"></span> Uploading‚Ä¶';
  return fn()
    .catch(err => console.error('Manual upload failed:', err))
    .finally(() => {
      btn.disabled = false;
      btn.innerHTML = orig;
    });
}

// 3) Wire it all together
uploadNowBtn.addEventListener('click', () => {
  withSpinner(uploadNowBtn, async () => {
    // upload the XLSX
    await uploadWorkbookToAzure();

    // upload the full PDF
    //await exportPDFToAzure();

    // upload *your* custom-sections PDF
    await uploadSnapshotsZip();

    console.log('‚úî All uploads complete');
  });
});

// Stop testing button
const stopBtn = document.getElementById('stopTestingBtn');
if (stopBtn) {
  stopBtn.addEventListener('click', () => withSpinner(stopBtn, stopTesting));
}
    
  </script>
</body>
</html>

