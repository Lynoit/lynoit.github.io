<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Segmented Radar KPI — Multi-Software</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#111; --muted:#666; --card:#f6f7fb;
      --good:#0a9910; --ok:#ffd000; --nok:#d43b3b; --nofunc:#000000;
    }
    html,body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--ink); background:var(--bg);}
    h1{font-size:18px; margin:14px 0 8px;}
    .wrap{display:grid; grid-template-columns: 380px 1fr; gap:16px; padding:16px; align-items:start;}
    .panel{background:#f6f7fb; border-radius:14px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06);}
    .controls{display:grid; gap:8px; grid-template-columns:minmax(0,1fr) auto auto; align-items:center; margin-bottom:8px;}
    .controls label{font-size:12px; color:var(--muted)}
    textarea{width:100%; min-height:220px; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px;}
    button{appearance:none; border:none; background:#111; color:white; padding:8px 12px; border-radius:10px; cursor:pointer}
    button.secondary{background:#e9ecf5; color:#111}
    .charts{display:grid; grid-template-columns:repeat(auto-fit,minmax(420px,1fr)); gap:16px;}
    .chart-card{background:white; border-radius:14px; padding:10px; box-shadow:0 3px 12px rgba(0,0,0,.08); position:relative}
    .download{position:absolute; left:12px; top:12px; font-size:12px; background:#f0f2f8; color:#222; padding:6px 8px; border-radius:8px; cursor:pointer}
    .small{font-size:12px; color:#666}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Input (paste TSV/CSV)</h1>
      <div class="controls">
        <div>
          <label>Delimiter:</label>
          <select id="delimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <button id="btnRender">Generate charts</button>
      </div>
      <textarea id="dataIn" spellcheck="false" placeholder="Paste data with headers:  Function — KPI,  Target,  Max allowed,  0824(TO),  0830(TO), ..."></textarea>
      <div class="small">Rules: ≤Target = <b>Green</b>, Target…(Max allowed) = <b>Yellow</b>, &gt;Max allowed = <b>Red</b>, value = 1000 = <b>Black</b>.</div>
    </div>

    <div class="panel">
      <div id="charts" class="charts"></div>
    </div>
  </div>

<script>
/* ---------- Colors & helpers ---------- */
const GREEN = '#0a9910', YELLOW = '#ffd000', RED = '#d43b3b', BLACK = '#000';

function colorFor(v, tgt, max){
  if (v == null || Number.isNaN(v)) return null;
  if (v === 1000) return BLACK;         // No function
  if (v <= tgt) return GREEN;           // Good
  if (v < (max + 1)) return YELLOW;     // OK (Target..Max)
  return RED;                           // NOK
}
function parseNumber(x){
  if (x==null) return null;
  const t = (""+x).trim();
  if (!t) return null;
  const v = Number(t.replace(',', '.'));
  return isNaN(v) ? null : v;
}
function detectDelimiter(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return '\t';
  const sel = document.getElementById('delimiter').value;
  if (sel !== 'auto') return sel;
  const cand = ['\t', ',', ';'];
  let best = '\t', bestCnt = 0;
  for (const d of cand){ const c = lines[0].split(d).length; if (c > bestCnt){ bestCnt = c; best = d; } }
  return best;
}
function splitFuncKpi(s){
  if (!s) return {func:'', kpi:''};
  const em = s.split('—'); if (em.length>=2) return {func:em[0].trim(), kpi:em.slice(1).join('—').trim()};
  const dash = s.split(' - '); if (dash.length>=2) return {func:dash[0].trim(), kpi:dash.slice(1).join(' - ').trim()};
  const sp = s.split(' ');
  return {func: sp[0]||'', kpi: s};
}
function normalizeHeader(h){
  if(!h) return '';
  return h.toLowerCase()
    .replace(/\u00a0/g,' ')      // NBSP → space
    .replace(/\s+/g,' ')         // collapse spaces
    .replace(/[^a-z0-9 ]/g,'')   // strip punctuation
    .trim();
}

/* ---------- Parse table ---------- */
function parseTable(text){
  const selectVal = document.getElementById('delimiter').value;
  const tryParse = (d)=> text.split(/\r?\n/)
      .filter(r=>r.trim().length>0)
      .map(r=>r.split(d));

  let delim = (selectVal==='auto') ? detectDelimiter(text) : selectVal;
  let rows = tryParse(delim);
  if (!rows.length) return {headers:[], entries:[], software:[]};

  let headers = rows[0].map(h=>h.trim());
  let norm = headers.map(normalizeHeader);
  let idxTarget = norm.findIndex(h=> h==='target');
  let idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');

  // fallback to auto if user forced wrong delimiter
  if ((idxTarget<0 || idxMax<0) && selectVal!=='auto'){
    const auto = detectDelimiter(text);
    if (auto !== delim){
      delim = auto; rows = tryParse(delim); headers = rows[0].map(h=>h.trim()); norm = headers.map(normalizeHeader);
      idxTarget = norm.findIndex(h=> h==='target');
      idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');
    }
  }
  if (idxTarget<0 || idxMax<0){
    alert("Missing required columns: 'Target' and 'Max allowed'. Try Auto-detect delimiter.\nHeaders seen: " + headers.join(', '));
    return {headers, entries:[], software:[]};
  }

  // software columns (dedupe identical names like 0830(TO))
  const swCols = [];
  for (let i = idxMax+1; i < headers.length; i++){
    const base = headers[i].trim();
    const countPrev = swCols.filter(s => s.base===base).length;
    const label = countPrev ? `${base} — ${countPrev+1}` : base;
    swCols.push({idx:i, base, label: label.replace('(TO)', ' (TO)')});
  }

  const entries = [];
  for (let r=1; r<rows.length; r++){
    const row = rows[r];
    if (!row || row.length===0) continue;
    const {func, kpi} = splitFuncKpi((row[0]||'').trim());
    if (!func && !kpi) continue;
    const target = parseNumber(row[idxTarget]);
    const max = parseNumber(row[idxMax]);
    const values = {};
    for (const sw of swCols){ values[sw.label] = parseNumber(row[sw.idx]); }
    entries.push({func, kpi, target, max, values});
  }
  return {headers, entries, software: swCols.map(s=>s.label)};
}

/* ---------- Renderer ---------- */
function renderCharts(parsed){
  const container = d3.select('#charts').html('');
  if (!parsed || !parsed.entries || !parsed.entries.length){
    container.append('div').attr('class','small').text('No data to render.');
    return;
  }

  (parsed.software||[]).forEach(swLabel=>{
    // Only render chart if this software has at least one numeric value
    const hasAny = parsed.entries.some(e => e.values[swLabel]!=null && !Number.isNaN(e.values[swLabel]));
    if (!hasAny) return;

    const card = container.append('div').attr('class','chart-card');

    // Download button
    card.append('button').attr('class','download').text('Download PNG').on('click',()=>{
      const svg = card.select('svg').node();
      const url = URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(svg)], {type:'image/svg+xml'}));
      const img = new Image();
      const w = svg.viewBox.baseVal && svg.viewBox.baseVal.width ? svg.viewBox.baseVal.width : svg.width.baseVal.value;
      const h = svg.viewBox.baseVal && svg.viewBox.baseVal.height ? svg.viewBox.baseVal.height : svg.height.baseVal.value;
      img.onload = ()=>{
        const canvas = document.createElement('canvas'); canvas.width=w; canvas.height=h;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
        ctx.drawImage(img,0,0);
        const a=document.createElement('a'); a.download = `${swLabel.replaceAll(' ','_')}.png`; a.href = canvas.toDataURL('image/png'); a.click();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    /* --- Layout: reserve space for legend on the right --- */
    const w = 600, h = 560;
    const legW = 160, legPad = 8, legItemH = 18, legOffset = 12;
    const centerX = (w - (legW + legOffset)) / 2;
    const centerY = h / 2;
    const rMax = Math.min(centerX, centerY) - 16;

    const svg = card.append('svg').attr('width', w).attr('height', h);
    const g = svg.append('g').attr('transform', `translate(${centerX},${centerY})`);

    // Title inside SVG (exports)
    svg.append('text')
      .attr('x', w/2).attr('y', 20)
      .attr('text-anchor', 'middle').attr('font-weight', 700)
      .text(swLabel);

    // SVG Legend (exports)
    const legendItems = [
      {label:'Green = Good',  color: GREEN},
      {label:'Yellow = OK',   color: YELLOW},
      {label:'Red = NOK',     color: RED},
      {label:'Black = No function', color: BLACK},
    ];
    const legendG = svg.append('g')
      .attr('class','svg-legend')
      .attr('transform', `translate(${w - legW - 12}, 32)`);
    legendG.append('rect')
      .attr('rx',8).attr('ry',8)
      .attr('width', legW)
      .attr('height', legPad*2 + legItemH*legendItems.length)
      .attr('fill', '#ffffff').attr('fill-opacity', 0.85)
      .attr('stroke', 'none');
    legendItems.forEach((it, i)=>{
      const y = legPad + i*legItemH + 12;
      legendG.append('rect').attr('x', legPad).attr('y', y-7)
        .attr('width',12).attr('height',12).attr('fill', it.color);
      legendG.append('text').attr('x', legPad+18).attr('y', y)
        .attr('dominant-baseline','middle').attr('font-size', 12)
        .text(it.label);
    });

    // Functions for THIS software (skip functions with no values)
    const functions = [];
    parsed.entries.forEach(e=>{
      const v = e.values[swLabel];
      if (v!=null && !Number.isNaN(v) && !functions.includes(e.func)) functions.push(e.func);
    });
    if (!functions.length){
      card.append('div').attr('class','small').text('No KPI values for this software.');
      return;
    }

    // Piecewise radius: 0–10 linear, 10–1000 log
    const linearPortion = 0.55;             // fraction of radius
    const rLinear = rMax * linearPortion;
    const logMin = 10, logMax = 1000;
    const logDen = Math.log10(logMax) - Math.log10(logMin);
    function toR(v){
      if (v==null || Number.isNaN(v)) return null;
      if (v <= 0) return 0;
      const vv = Math.min(v, logMax);
      if (vv < logMin) return (vv / logMin) * rLinear;
      return rLinear + ((Math.log10(vv) - Math.log10(logMin)) / logDen) * (rMax - rLinear);
    }

    // Grid rings & labels (1..10 plus 30, 100, 300, 1000)
    const ringGrid = [1,2,3,4,5,6,7,8,9,10,30,100,300,1000];
    g.selectAll('.ring').data(ringGrid).enter().append('circle')
      .attr('class','ring')
      .attr('r', d=>toR(d))
      .attr('fill','none')
      .attr('stroke','#999')
      .attr('stroke-opacity',0.22);
    g.selectAll('.rlabel').data(ringGrid).enter().append('text')
      .attr('class','rlabel')
      .attr('x', 6)
      .attr('y', d=> -toR(d))
      .attr('dominant-baseline','middle')
      .attr('font-size', 11)
      .attr('fill', '#666')
      .text(d=>d);

    // Axis label aligned with vertical axis (left side), rotated
    const axisY = -rMax * 0.70;
    g.append('text')
      .attr('x', -8)
      .attr('y', axisY)
      .attr('transform', `rotate(-90, 0, ${axisY})`)
      .attr('text-anchor','end')
      .attr('font-size', 11)
      .text('Number of events');

    // Segment backgrounds + boundaries + function labels
    const F = functions.length;
    const wedge = (Math.PI*2) / F;
    const innerFrac = 0.98;
    const spread = wedge * innerFrac;

    const arc = d3.arc();
    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const end = start + wedge;
      // subtle background
      g.append('path')
        .attr('d', arc({innerRadius:0, outerRadius:rMax, startAngle:start, endAngle:end}))
        .attr('fill', idx % 2 ? '#f6f7fb' : '#eef2ff')
        .attr('fill-opacity', 0.06)
        .attr('stroke', 'none');
      // boundary
      g.append('line')
        .attr('x1',0).attr('y1',0)
        .attr('x2', Math.cos(start)*rMax)
        .attr('y2', Math.sin(start)*rMax)
        .attr('stroke','#000').attr('stroke-opacity',0.25);
      // function label (blue)
      const cen = (start + end) / 2;
      g.append('text')
        .attr('x', Math.cos(cen)*(rMax+16))
        .attr('y', Math.sin(cen)*(rMax+16))
        .attr('text-anchor','middle')
        .attr('font-weight',700)
        .attr('fill','#1f3de3')
        .text(f);
    });

    // Per-function KPI dots (spread + collision avoidance + black-dot avoidance)
    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const center = start + wedge/2;

      const items = parsed.entries.filter(e=>e.func===f);
      const K = items.length;
      const avail = spread * 0.96;
      const baseOffs = (K===1) ? [0] : d3.range(K).map(i => (i-(K-1)/2)/(K-1) * (avail/2));

      const placed = [];
      const minSep = wedge * 0.09;
      const radBin = rMax * 0.12;
      const labelAvoid = wedge * 0.18;

      items.forEach((e, i)=>{
        const v = e.values[swLabel]; if (v==null || Number.isNaN(v)) return;
        let r = toR(v);
        let ang = center + baseOffs[i];
        const isBlack = (v === 1000);

        if (isBlack && Math.abs(ang - center) < labelAvoid){
          const dir = (ang >= center) ? 1 : -1;
          ang = center + dir * (labelAvoid + wedge*0.02);
        }
        ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));

        // collision resolution scoped to avoid duplicate identifiers
        {
          let tries = 0;
          while (placed.some(p => Math.abs(p.ang - ang) < minSep && Math.abs(p.r - r) < radBin) && tries < 120){
            const dir = (tries % 2 === 0) ? 1 : -1;
            ang += dir * (minSep * 0.65);
            ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
            tries++;
          }
          if (tries >= 120){
            r = Math.min(r + 8, rMax * 0.98); // last-resort radial nudge
          }
        }
        placed.push({ang, r});

        const cx = Math.cos(ang)*r, cy = Math.sin(ang)*r;
        const fill = colorFor(v, e.target, e.max);
        if (!fill) return;

        // dot (smaller)
        g.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 10).attr('fill', fill)
          .append('title').text(`${f} — ${e.kpi}: ${v}`);

        // label above dot
        const rLabel = Math.min(r + 18, rMax * 0.98);
        const lx = Math.cos(ang)*rLabel, ly = Math.sin(ang)*rLabel;
        g.append('text')
          .attr('x', lx).attr('y', ly)
          .attr('text-anchor','middle')
          .attr('font-size', 11)
          .attr('paint-order', 'stroke')
          .attr('stroke', 'white').attr('stroke-width', 3)
          .text(e.kpi);
      });
    });
  });

  if (!container.node().children.length){
    container.append('div').attr('class','small').text('No software columns with values found.');
  }
}

/* ---------- Wire up UI ---------- */
const btnRender = document.getElementById('btnRender');
btnRender.onclick = ()=>{
  const parsed = parseTable(document.getElementById('dataIn').value);
  renderCharts(parsed);
};
</script>
</body>
</html>
