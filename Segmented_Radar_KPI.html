<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Segmented Radar KPI — Multi-Software (with Scoring)</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#111; --muted:#666; --card:#f6f7fb;
      --good:#0a9910; --ok:#ffd000; --nok:#d43b3b; --nofunc:#000000;
    }
    html,body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--ink); background:var(--bg);}
    h1{font-size:18px; margin:14px 0 8px;}
    .wrap{display:grid; grid-template-columns: 380px 1fr; gap:16px; padding:16px; align-items:start;}
    .panel{background:#f6f7fb; border-radius:14px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06);} 
    .controls{display:grid; gap:8px; grid-template-columns:minmax(0,1fr) auto auto; align-items:center; margin-bottom:8px;}
    .controls label{font-size:12px; color:var(--muted)}
    textarea{width:100%; min-height:220px; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px;}
    button{appearance:none; border:none; background:#111; color:white; padding:8px 12px; border-radius:10px; cursor:pointer}
    button.secondary{background:#e9ecf5; color:#111}
    .charts{display:grid; grid-template-columns:repeat(auto-fit,minmax(420px,1fr)); gap:16px;}
    .chart-card{
      background:white; border-radius:14px; padding:10px; box-shadow:0 3px 12px rgba(0,0,0,.08);
      position:relative; overflow-x:auto; /* ensure no clipping on very narrow layouts */
    }
    .download{position:absolute; left:12px; top:12px; font-size:12px; background:#f0f2f8; color:#222; padding:6px 8px; border-radius:8px; cursor:pointer}
    .small{font-size:12px; color:#666}
    .row{display:grid; gap:8px; grid-template-columns: 1fr auto auto;}
    .hint{font-size:11px; color:#555; margin-top:4px}
    input[type="text"]{width:100%; padding:8px 10px; border-radius:10px; border:1px solid #d7dcef; font-size:12px; background:#fff}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Input (paste TSV/CSV)</h1>
      <div class="controls">
        <div>
          <label>Delimiter:</label>
          <select id="delimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <button id="btnRender">Generate charts</button>
      </div>

      <label style="font-size:12px; color:var(--muted); display:block; margin:8px 0 4px">Scoring thresholds (comma-separated; lower bounds for scores 1→10)</label>
      <div class="row" style="grid-template-columns: 1fr auto auto; align-items:center">
        <input id="scoreThresholds" type="text" spellcheck="false" />
        <button class="secondary" id="btnApply">Apply</button>
        <button class="secondary" id="btnReset">Reset defaults</button>
      </div>
      <div class="hint">Format: <code>50,30,20,15,10,7,5,2,1,0</code> means<br>
        1: ≥50 (Worst), 2: ≥30, 3: ≥20, 4: ≥15, 5: ≥10, 6: ≥7, 7: ≥5, 8: ≥2, 9: ≥1, 10: &lt;1 (incl. 0). The value 1000 counts in the average.</div>

      <textarea id="dataIn" spellcheck="false" placeholder="Paste data with headers:  Function — KPI,  Target,  Max allowed,  0824(TO),  0830(TO), ..."></textarea>
      <div class="small">Rules: ≤Target = <b>Green</b>, Target…(Max allowed) = <b>Yellow</b>, &gt;Max allowed = <b>Red</b>, value = 1000 = <b>Black</b>.</div>
    </div>

    <div class="panel">
      <div id="charts" class="charts"></div>
    </div>
  </div>

<script>
/* ---------- Colors & helpers ---------- */
const GREEN = '#0a9910', YELLOW = '#ffd000', RED = '#d43b3b', BLACK = '#000';
const DEFAULT_THRESH_STR = '50,30,20,15,10,7,5,2,1,0';
const LS_KEY = 'segRadarKPI.thresholds';

function colorFor(v, tgt, max){
  if (v == null || Number.isNaN(v)) return null;
  if (v === 1000) return BLACK;
  if (v <= tgt) return GREEN;
  if (v < (max + 1)) return YELLOW;
  return RED;
}
function parseNumber(x){
  if (x==null) return null;
  const t = (""+x).trim();
  if (!t) return null;
  const v = Number(t.replace(',', '.'));
  return isNaN(v) ? null : v;
}
function detectDelimiter(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return '\t';
  const sel = document.getElementById('delimiter').value;
  if (sel !== 'auto') return sel;
  const cand = ['\t', ',', ';'];
  let best = '\t', bestCnt = 0;
  for (const d of cand){ const c = lines[0].split(d).length; if (c > bestCnt){ bestCnt = c; best = d; } }
  return best;
}
function splitFuncKpi(s){
  if (!s) return {func:'', kpi:''};
  const em = s.split('—'); if (em.length>=2) return {func:em[0].trim(), kpi:em.slice(1).join('—').trim()};
  const dash = s.split(' - '); if (dash.length>=2) return {func:dash[0].trim(), kpi:dash.slice(1).join(' - ').trim()};
  const sp = s.split(' ');
  return {func: sp[0]||'', kpi: s};
}
function normalizeHeader(h){
  if(!h) return '';
  return h.toLowerCase().replace(/\u00a0/g,' ').replace(/\s+/g,' ').replace(/[^a-z0-9 ]/g,'').trim();
}

/* ---------- Thresholds ---------- */
function parseThresholds(str){
  const arr = (str||'').split(',').map(s=>s.trim()).filter(s=>s!=='').map(Number);
  if (arr.length !== 10 || arr.some(n=>Number.isNaN(n))) return null;
  for (let i=1;i<arr.length;i++){ if (arr[i] > arr[i-1]) return null; }
  return arr;
}
function getThresholds(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  let t = parseThresholds(ui);
  if (t) return t;
  const ls = localStorage.getItem(LS_KEY);
  t = parseThresholds(ls);
  if (t) return t;
  return parseThresholds(DEFAULT_THRESH_STR);
}
function setThresholdsToUI(arr){
  const s = (arr && arr.length===10) ? arr.join(',') : DEFAULT_THRESH_STR;
  document.getElementById('scoreThresholds').value = s;
}
function saveThresholdsFromUI(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  const t = parseThresholds(ui);
  if (!t){
    alert('Please enter 10 comma-separated numbers in non-increasing order (e.g., '+DEFAULT_THRESH_STR+').');
    return false;
  }
  localStorage.setItem(LS_KEY, t.join(','));
  return true;
}
function resetThresholds(){
  localStorage.setItem(LS_KEY, DEFAULT_THRESH_STR);
  setThresholdsToUI(parseThresholds(DEFAULT_THRESH_STR));
}
const fmtNum = n => Number.isInteger(n) ? String(n) : String(parseFloat(n.toFixed(2)));
function scoreRangeLabels(T){
  const lab = [];
  for (let i=0;i<9;i++) lab.push('≥ ' + fmtNum(T[i]));
  lab.push('< ' + fmtNum(T[8]) + (T[9] === 0 ? ' (incl. 0)' : ''));
  return lab;
}

/* ---------- Parse table ---------- */
function parseTable(text){
  const selectVal = document.getElementById('delimiter').value;
  const tryParse = (d)=> text.split(/\r?\n/).filter(r=>r.trim().length>0).map(r=>r.split(d));

  let delim = (selectVal==='auto') ? detectDelimiter(text) : selectVal;
  let rows = tryParse(delim);
  if (!rows.length) return {headers:[], entries:[], software:[]};

  let headers = rows[0].map(h=>h.trim());
  let norm = headers.map(normalizeHeader);
  let idxTarget = norm.findIndex(h=> h==='target');
  let idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');

  if ((idxTarget<0 || idxMax<0) && selectVal!=='auto'){
    const auto = detectDelimiter(text);
    if (auto !== delim){
      delim = auto; rows = tryParse(delim); headers = rows[0].map(h=>h.trim()); norm = headers.map(normalizeHeader);
      idxTarget = norm.findIndex(h=> h==='target');
      idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');
    }
  }
  if (idxTarget<0 || idxMax<0){
    alert("Missing required columns: 'Target' and 'Max allowed'. Try Auto-detect delimiter.\nHeaders seen: " + headers.join(', '));
    return {headers, entries:[], software:[]};
  }

  const swCols = [];
  for (let i = idxMax+1; i < headers.length; i++){
    const base = headers[i].trim();
    const countPrev = swCols.filter(s => s.base===base).length;
    const label = countPrev ? `${base} — ${countPrev+1}` : base;
    swCols.push({idx:i, base, label: label.replace('(TO)', ' (TO)')});
  }

  const entries = [];
  for (let r=1; r<rows.length; r++){
    const row = rows[r];
    if (!row || row.length===0) continue;
    const {func, kpi} = splitFuncKpi((row[0]||'').trim());
    const target = parseNumber(row[idxTarget]);
    const max = parseNumber(row[idxMax]);
    const values = {};
    for (const sw of swCols){ values[sw.label] = parseNumber(row[sw.idx]); }
    entries.push({func, kpi, target, max, values});
  }
  return {headers, entries, software: swCols.map(s=>s.label)};
}

/* ---------- Renderer ---------- */
let lastParsed = null;

function renderCharts(parsed){
  lastParsed = parsed; // remember for resize
  const T = getThresholds();
  const rangeLabels = scoreRangeLabels(T);
  const container = d3.select('#charts').html('');
  if (!parsed || !parsed.entries || !parsed.entries.length){
    container.append('div').attr('class','small').text('No data to render.');
    return;
  }

  (parsed.software||[]).forEach(swLabel=>{
    const hasAny = parsed.entries.some(e => e.values[swLabel]!=null && !Number.isNaN(e.values[swLabel]));
    if (!hasAny) return;

    const card = container.append('div').attr('class','chart-card');

    // Responsive width: use the card's inner width (card has 10px padding)
    const cardW = Math.max(420, (card.node().clientWidth || 600) - 20);
    const w = cardW;

    // Responsive scale (relative to the original 600px design)
    const S = Math.min(1, w / 600);

    // Download button
    card.append('button').attr('class','download').text('Download PNG').on('click',()=>{
      const svg = card.select('svg').node();
      const url = URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(svg)], {type:'image/svg+xml'}));
      const img = new Image();
      const W = svg.viewBox?.baseVal?.width || svg.width.baseVal.value;
      const H = svg.viewBox?.baseVal?.height || svg.height.baseVal.value;
      img.onload = ()=>{
        const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
        ctx.drawImage(img,0,0);
        const a=document.createElement('a'); a.download = `${swLabel.replaceAll(' ','_')}.png`; a.href = canvas.toDataURL('image/png'); a.click();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    /* --- Layout constants (some scale with S) --- */
    const radarH = 540 * S;
    const scoreTopPad = 28 * S;         // gap before scoring band
    const rowH = 22 * S, headerH = 24 * S, tableSidePad = 12 * S, colGap = 8 * S;
    const scoreH = 150 * S;

    const legW = 160 * S, legOffset = 12 * S;
    const centerX = (w - (legW + legOffset)) / 2;
    const centerY = radarH / 2;

    // ---- Build table data ----
    const rows = parsed.entries
      .filter(e => e.values[swLabel] != null && !Number.isNaN(e.values[swLabel]))
      .map(e => ({ kpi: e.kpi, target: e.target, max: e.max, events: e.values[swLabel] }));

    // --- accurate text measurement (SVG) ---
    function measureMaxWidth(texts, fontSize=11, fontWeight=400){
      const tmp = d3.select('body').append('svg')
        .attr('width',0).attr('height',0)
        .style('position','absolute').style('left','-9999px').style('top','-9999px');
      let max = 0;
      texts.forEach(t=>{
        const node = tmp.append('text')
          .attr('font-size', fontSize*S)
          .attr('font-weight', fontWeight)
          .text(t==null ? '' : String(t))
          .node();
        max = Math.max(max, node.getComputedTextLength());
      });
      tmp.remove();
      return max;
    }
    const fmtCell = v => (v==null || Number.isNaN(v)) ? '—' : (Number.isInteger(v) ? String(v) : String(parseFloat(v.toFixed(2)).replace(/\.00$/,'')));

    const kpiTexts = rows.map(r=>r.kpi);
    const tgtTexts = rows.map(r=>fmtCell(r.target));
    const maxTexts = rows.map(r=>fmtCell(r.max));
    const evtTexts = rows.map(r=>fmtCell(r.events));

    const kpiW = measureMaxWidth(kpiTexts, 11, 400) + 16*S;
    let col2W = Math.max(50*S, Math.min(120*S, measureMaxWidth(tgtTexts, 11, 400) + 16*S));
    let col3W = Math.max(60*S, Math.min(140*S, measureMaxWidth(maxTexts, 11, 400) + 16*S));
    let col4W = Math.max(60*S, Math.min(140*S, measureMaxWidth(evtTexts, 11, 700) + 16*S)); // bold-ish

    const tableWUsed = kpiW + col2W + col3W + col4W + colGap*3;

    const x0 = tableSidePad;
    const x1 = x0 + kpiW + colGap;
    const x2 = x1 + col2W + colGap;
    const x3 = x2 + col3W + colGap;

    // Create SVG now
    const svg = card.append('svg').attr('width', w);

    // --- defs: glow for selected score box ---
    const defs = svg.append('defs');
    const glow = defs.append('filter').attr('id','glow').attr('x','-30%').attr('y','-50%').attr('width','160%').attr('height','220%');
    glow.append('feGaussianBlur').attr('in','SourceGraphic').attr('stdDeviation', 4*S);
    glow.append('feMerge').html('<feMergeNode/><feMergeNode in="SourceGraphic"/>');

    // Title
    svg.append('text')
      .attr('x', w/2).attr('y', 20*S)
      .attr('text-anchor', 'middle').attr('font-weight', 700)
      .attr('font-size', 14*S)
      .text(swLabel);

    // Legend
    const legendItems = [
      {label:'Green = Good',  color: GREEN},
      {label:'Yellow = OK',   color: YELLOW},
      {label:'Red = NOK',     color: RED},
      {label:'Black = No function', color: BLACK},
    ];
    const legendG = svg.append('g').attr('transform', `translate(${w - 160*S - 12*S}, ${32*S})`);
    legendG.append('rect').attr('rx',8*S).attr('ry',8*S).attr('width', 160*S)
      .attr('height', 8*2*S + 18*legendItems.length*S)
      .attr('fill', '#ffffff').attr('fill-opacity', 0.85);
    legendItems.forEach((it, i)=>{
      const y = 8*S + i*18*S + 12*S;
      legendG.append('rect').attr('x', 8*S).attr('y', y-7*S).attr('width',12*S).attr('height',12*S).attr('fill', it.color);
      legendG.append('text').attr('x', 26*S).attr('y', y).attr('dominant-baseline','middle').attr('font-size', 12*S).text(it.label);
    });

    // ---- Radar chart ----
    const rMax = Math.min(centerX, centerY) - 16*S;
    const g = svg.append('g').attr('transform', `translate(${centerX},${centerY})`);

    const functions = [];
    parsed.entries.forEach(e=>{
      const v = e.values[swLabel];
      if (v!=null && !Number.isNaN(v) && !functions.includes(e.func)) functions.push(e.func);
    });
    if (!functions.length){
      card.append('div').attr('class','small').text('No KPI values for this software.');
      return;
    }

    const linearPortion = 0.55;
    const rLinear = rMax * linearPortion;
    const logMin = 10, logMax = 1000;
    const logDen = Math.log10(logMax) - Math.log10(logMin);
    function toR(v){
      if (v==null || Number.isNaN(v)) return null;
      if (v <= 0) return 0;
      const vv = Math.min(v, logMax);
      if (vv < logMin) return (vv / logMin) * rLinear;
      return rLinear + ((Math.log10(vv) - Math.log10(logMin)) / logDen) * (rMax - rLinear);
    }

    const ringGrid = [1,2,3,4,5,6,7,8,9,10,30,100,300,1000];
    g.selectAll('.ring').data(ringGrid).enter().append('circle')
      .attr('r', d=>toR(d)).attr('fill','none').attr('stroke','#999').attr('stroke-opacity',0.22);
    g.selectAll('.rlabel').data(ringGrid).enter().append('text')
      .attr('x', 6*S).attr('y', d=> -toR(d))
      .attr('dominant-baseline','middle').attr('font-size', 11*S).attr('fill', '#666')
      .text(d=>d);

    const axisY = -rMax * 0.70;
    g.append('text').attr('x', -8*S).attr('y', axisY)
      .attr('transform', `rotate(-90, 0, ${axisY})`)
      .attr('text-anchor','end').attr('font-size', 11*S)
      .text('Number of events');

    const F = functions.length;
    const wedge = (Math.PI*2) / F;
    const innerFrac = 0.98;
    const spread = wedge * innerFrac;
    const arc = d3.arc();
    const FUNC_LABEL_OFFSET = 16*S; // used also for table placement

    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const end = start + wedge;
      g.append('path')
        .attr('d', arc({innerRadius:0, outerRadius:rMax, startAngle:start, endAngle:end}))
        .attr('fill', idx % 2 ? '#f6f7fb' : '#eef2ff')
        .attr('fill-opacity', 0.06);
      g.append('line')
        .attr('x1',0).attr('y1',0)
        .attr('x2', Math.cos(start)*rMax)
        .attr('y2', Math.sin(start)*rMax)
        .attr('stroke','#000').attr('stroke-opacity',0.25);
      const cen = (start + end) / 2;
      g.append('text')
        .attr('x', Math.cos(cen)*(rMax+FUNC_LABEL_OFFSET))
        .attr('y', Math.sin(cen)*(rMax+FUNC_LABEL_OFFSET))
        .attr('text-anchor','middle')
        .attr('font-weight',700)
        .attr('font-size', 12*S)
        .attr('fill','#1f3de3')
        .text(f);
    });

    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const center = start + wedge/2;
      const items = parsed.entries.filter(e=>e.func===f);
      const K = items.length;
      const avail = spread * 0.96;
      const baseOffs = (K===1) ? [0] : d3.range(K).map(i => (i-(K-1)/2)/(K-1) * (avail/2));
      const placed = [];
      const minSep = wedge * 0.09;
      const radBin = rMax * 0.12;
      const labelAvoid = wedge * 0.18;

      items.forEach((e, i)=>{
        const v = e.values[swLabel]; if (v==null || Number.isNaN(v)) return;
        let r = toR(v);
        let ang = center + baseOffs[i];
        const isBlack = (v === 1000);

        if (isBlack && Math.abs(ang - center) < labelAvoid){
          const dir = (ang >= center) ? 1 : -1;
          ang = center + dir * (labelAvoid + wedge*0.02);
        }
        ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
        let tries = 0;
        while (placed.some(p => Math.abs(p.ang - ang) < minSep && Math.abs(p.r - r) < radBin) && tries < 120){
          const dir = (tries % 2 === 0) ? 1 : -1;
          ang += dir * (minSep * 0.65);
          ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
          tries++;
        }
        if (tries >= 120){ r = Math.min(r + 8*S, rMax * 0.98); }
        placed.push({ang, r});

        const cx = Math.cos(ang)*r, cy = Math.sin(ang)*r;
        const fill = colorFor(v, e.target, e.max);
        if (!fill) return;

        g.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 10*S).attr('fill', fill)
          .append('title').text(`${f} — ${e.kpi}: ${v}`);

        const rLabel = Math.min(r + 18*S, rMax * 0.98);
        const lx = Math.cos(ang)*rLabel, ly = Math.sin(ang)*rLabel;
        g.append('text')
          .attr('x', lx).attr('y', ly)
          .attr('text-anchor','middle')
          .attr('font-size', 11*S)
          .attr('paint-order', 'stroke')
          .attr('stroke', 'white').attr('stroke-width', 3*S)
          .text(e.kpi);
      });
    });

    /* ---------- KPI TABLE (space-optimized) ---------- */
    const tableY = centerY + rMax + FUNC_LABEL_OFFSET + 2; // super-tight
    const tableH = headerH + rows.length * rowH + 8*S;
    const tableG = svg.append('g').attr('transform', `translate(0, ${tableY})`);

    tableG.append('rect')
      .attr('x', 12*S-4*S).attr('y', 2*S)
      .attr('width', tableWUsed + 8*S).attr('height', tableH)
      .attr('rx', 8*S).attr('ry', 8*S)
      .attr('fill', '#ffffff').attr('stroke', '#e4e7f3');

    tableG.append('rect')
      .attr('x', x0).attr('y', 4*S)
      .attr('width', tableWUsed).attr('height', headerH)
      .attr('rx', 6*S).attr('ry', 6*S)
      .attr('fill', '#f6f7fb');

    tableG.append('text')
      .attr('x', x0+6*S).attr('y', 4*S + headerH/2)
      .attr('dominant-baseline','middle').attr('font-size',12*S).attr('font-weight',700)
      .text('KPI');
    tableG.append('text')
      .attr('x', x1 + col2W - 6*S).attr('y', 4*S + headerH/2)
      .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size',12*S).attr('font-weight',700)
      .text('Target');

    const hMax = tableG.append('text')
      .attr('x', x2 + col3W - 6*S).attr('y', 4*S + 8*S)
      .attr('text-anchor','end').attr('font-size',12*S).attr('font-weight',700);
    hMax.append('tspan').text('Max').attr('x', x2 + col3W - 6*S).attr('dy', 0);
    hMax.append('tspan').text('allowed').attr('x', x2 + col3W - 6*S).attr('dy', 12*S);

    const hEvt = tableG.append('text')
      .attr('x', x3 + col4W - 6*S).attr('y', 4*S + 8*S)
      .attr('text-anchor','end').attr('font-size',12*S).attr('font-weight',700);
    hEvt.append('tspan').text('Number of').attr('x', x3 + col4W - 6*S).attr('dy', 0);
    hEvt.append('tspan').text('events').attr('x', x3 + col4W - 6*S).attr('dy', 12*S);

    rows.forEach((r, i)=>{
      const y = 4*S + headerH + i*rowH;
      tableG.append('rect')
        .attr('x', x0).attr('y', y)
        .attr('width', tableWUsed).attr('height', rowH)
        .attr('fill', i%2 ? '#fafbff' : '#ffffff');

      tableG.append('text')
        .attr('x', x0+6*S).attr('y', y + rowH/2)
        .attr('dominant-baseline','middle').attr('font-size', 11*S)
        .text(r.kpi);

      tableG.append('text')
        .attr('x', x1 + col2W - 6*S).attr('y', y + rowH/2)
        .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11*S)
        .text(fmtCell(r.target));

      tableG.append('text')
        .attr('x', x2 + col3W - 6*S).attr('y', y + rowH/2)
        .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11*S)
        .text(fmtCell(r.max));

      tableG.append('text')
        .attr('x', x3 + col4W - 6*S).attr('y', y + rowH/2)
        .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11*S).attr('font-weight',600)
        .text(fmtCell(r.events));
    });

    [x1 - colGap/2, x2 - colGap/2, x3 - colGap/2].forEach(xx=>{
      tableG.append('line')
        .attr('x1', xx).attr('x2', xx)
        .attr('y1', 4*S + headerH).attr('y2', 4*S + headerH + rows.length*rowH)
        .attr('stroke', '#eef1fb');
    });

    /* ---------- Scoring band (responsive) ---------- */
    const valuesForAvg = parsed.entries.map(e => e.values[swLabel]).filter(v => v != null && !Number.isNaN(v));
    const avgEvents = valuesForAvg.length ? d3.mean(valuesForAvg.map(v => Math.min(v, 1000))) : null;

    function scoreFromAvg(a, thresholds){
      if (a == null || Number.isNaN(a)) return null;
      if (a === 0) return 10;
      for (let i=0;i<9;i++){ if (a >= thresholds[i]) return i+1; }
      return 10;
    }

    const scoreColors = ['#e60000','#ff1e1e','#ff6a00','#ffa000','#ffe07a','#ffff33','#9acd32','#66bb6a','#00a878','#2e7d32'];
    const scoreText   = ['Worst','Too bad','Bad','Not good','Unacceptable','Marginal','Acceptable','Good','Impressive','Exceptional'];
    const score = avgEvents==null ? null : scoreFromAvg(avgEvents, T);

    const barMargin = Math.max(8*S, Math.min(20*S, w*0.03)); // responsive margin
    const boxH2 = 42*S;
    const barW = w - barMargin*2;
    const boxW = barW / 10;

    const scoreBandY = tableY + tableH + 28*S; // gap after table
    const scoreG = svg.append('g').attr('transform', `translate(0, ${scoreBandY})`);

    const caption = (avgEvents==null)
      ? 'Average per 1000km:  n/a (only "No function" or missing values)'
      : `Average per 1000km:  ${avgEvents.toFixed(1)} events → Score: ${score} (${scoreText[score-1]})`;
    scoreG.append('text')
      .attr('x', barMargin).attr('y', 14*S)
      .attr('font-size', 12*S)
      .text(caption);

    const ranges = rangeLabels;
    for (let i=0;i<10;i++){
      const x = barMargin + i*boxW;
      const isSel = (score === i+1);

      if (isSel){
        scoreG.append('rect')
          .attr('x', x - 6*S).attr('y', 22*S)
          .attr('width', boxW + 12*S).attr('height', boxH2 + 14*S)
          .attr('rx', 6*S).attr('ry', 6*S)
          .attr('fill', scoreColors[i]).attr('fill-opacity', 0.30)
          .attr('filter', 'url(#glow)');
      }

      const r = scoreG.append('rect')
        .attr('x', x).attr('y', 28*S)
        .attr('width', boxW).attr('height', boxH2)
        .attr('fill', scoreColors[i])
        .attr('stroke', isSel ? '#000' : '#111')
        .attr('stroke-width', isSel ? 3*S : 0.4*S);

      r.append('title').text(`Score ${i+1}: ${scoreText[i]} — ${ranges[i]}`);

      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 28*S + 14*S)
        .attr('text-anchor','middle')
        .attr('font-weight', isSel ? 950 : 750)
        .attr('font-size', 13*S)
        .text(i+1);

      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 28*S + 14*S + 16*S)
        .attr('text-anchor','middle')
        .attr('font-weight', isSel ? 850 : 550)
        .attr('font-size', 11*S)
        .text(scoreText[i]);

      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 28*S + boxH2 + 14*S)
        .attr('text-anchor','middle')
        .attr('font-size', 10*S)
        .text(ranges[i]);
    }

    const totalHeight = scoreBandY + 28*S + boxH2 + 26*S + 16*S;
    svg.attr('height', totalHeight);
  });

  if (!container.node().children.length){
    container.append('div').attr('class','small').text('No software columns with values found.');
  }
}

/* ---------- Resize handling (re-render responsive) ---------- */
function debounce(fn, wait=150){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), wait); }; }
window.addEventListener('resize', debounce(()=>{ if (lastParsed) renderCharts(lastParsed); }, 150));

/* ---------- Wire up UI ---------- */
function initialThresholds(){
  const ls = localStorage.getItem(LS_KEY);
  const t = parseThresholds(ls) || parseThresholds(DEFAULT_THRESH_STR);
  setThresholdsToUI(t);
}
initialThresholds();

document.getElementById('btnRender').onclick = ()=>{
  const parsed = parseTable(document.getElementById('dataIn').value);
  renderCharts(parsed);
};
document.getElementById('btnApply').onclick = ()=>{
  if (!saveThresholdsFromUI()) return;
  const parsed = parseTable(document.getElementById('dataIn').value);
  renderCharts(parsed);
};
document.getElementById('btnReset').onclick = ()=>{
  resetThresholds();
  const parsed = parseTable(document.getElementById('dataIn').value);
  renderCharts(parsed);
};
</script>
</body>
</html>
