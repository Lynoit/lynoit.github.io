<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KPI Scoring Visualizer</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#111; --muted:#666; --card:#f6f7fb;
      --good:#0a9910; --ok:#ffd000; --nok:#d43b3b; --nofunc:#000000;
      --sideW:380px; --gap:16px;
    }
    html,body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--ink); background:var(--bg);}
    h1{font-size:18px; margin:14px 0 8px;}
    .wrap{display:grid; grid-template-columns: var(--sideW) 1fr; gap:var(--gap); padding:16px; align-items:start; transition: grid-template-columns .22s ease;}
    .wrap.collapsed{--sideW:0px; --gap:0;}
    .panel{background:#f6f7fb; border-radius:14px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06);}
    .sidebar{overflow:hidden; transition: opacity .18s ease, transform .18s ease;}
    .wrap.collapsed .sidebar{opacity:0; transform:translateX(-12px); pointer-events:none;}
    .controls{display:grid; gap:8px; grid-template-columns:minmax(0,1fr) auto auto; align-items:center; margin-bottom:8px;}
    .controls label{font-size:12px; color:var(--muted)}
    textarea{width:100%; min-height:220px; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px;}
    button{appearance:none; border:none; background:#111; color:white; padding:8px 12px; border-radius:10px; cursor:pointer}
    button.secondary{background:#e9ecf5; color:#111}
    input[type="text"], select{width:100%; padding:8px 10px; border-radius:10px; border:1px solid #d7dcef; font-size:12px; background:#fff}

    .charts{display:grid; grid-template-columns:repeat(auto-fit,minmax(680px,1fr)); gap:16px;}
    .chart-card{background:white; border-radius:14px; padding:10px; box-shadow:0 3px 12px rgba(0,0,0,.08); position:relative}
    .summary-card { grid-column: 1 / -1; display:grid; justify-content:center; }
    .small{font-size:12px; color:#666}

    /* Summary table */
    .summary-title{font-weight:700; font-size:16px; margin:4px 0 8px 0; text-align:center}
    .summary-table{ display:inline-table; margin:6px 0 10px; table-layout:auto; border-collapse:separate; border-spacing:0; font-size:12px; }
    .summary-table th, .summary-table td{ padding:8px 10px; text-align:left; border-bottom:1px solid #eef1fb; vertical-align:middle; }
    .summary-table th{ background:#f6f7fb; font-weight:700; }
    .summary-table th:nth-child(2), .summary-table td:nth-child(2){ text-align:center; white-space:nowrap; }
    .summary-table th:nth-child(3), .summary-table td:nth-child(3){ text-align:right; white-space:nowrap; }
    .summary-table th:nth-child(4), .summary-table td:nth-child(4){ text-align:center; white-space:nowrap; width:1%; }
    .summary-table th:nth-child(5), .summary-table td:nth-child(5){ white-space:nowrap; }
    .summary-table th:nth-child(6), .summary-table td:nth-child(6){ text-align:center; white-space:nowrap; }
    .software-cell{ display:inline-block; max-width:min(52vw, 680px); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; vertical-align:bottom; }
    .summary-chip{ display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #e9ecf5; font-weight:600; }
    .link{ color:#1f3de3; text-decoration:underline; cursor:pointer; }

    /* Floating toggle */
    .toggle{
      position:fixed; left:14px; top:14px; z-index:50;
      background:#111; color:#fff; border-radius:999px; padding:8px 12px; box-shadow:0 4px 16px rgba(0,0,0,.16);
    }
    .toggle:focus{outline:2px solid #6ea8ff; outline-offset:2px;}

    /* Modal */
    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal{ background:#fff; color:#111; border-radius:12px; box-shadow:0 20px 70px rgba(0,0,0,.35);
      width:min(760px, 92vw); max-height:80vh; overflow:auto; padding:16px 16px 8px; }
    .modal header{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .modal h2{ margin:0; font-size:16px; }
    .modal .close{ background:#e9ecf5; color:#111; border:none; border-radius:10px; padding:6px 10px; cursor:pointer; }
    .modal .content{ margin:12px 2px 8px; }
    .modal .content ul{ margin:0; padding-left:18px; }
    .modal .content li{ margin:6px 0; line-height:1.35; }
    .modal .empty{ color:#666; font-style:italic; }
  </style>
</head>
<body>
  <button id="toggleSidebar" class="toggle" aria-expanded="false" aria-controls="sidebar">Show input</button>

  <div class="wrap collapsed">
    <div id="sidebar" class="panel sidebar">
      <h1>Input</h1>
      <div class="controls" style="grid-template-columns: 1fr 1fr auto;">
        <div>
          <label>Delimiter:</label>
          <select id="delimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <div>
          <label>CSV file (same folder):</label>
          <input id="csvFile" type="text" value="weekly_kpi_data.csv" />
        </div>
        <button id="btnLoad">Load CSV</button>
      </div>

      <label style="font-size:12px; color:var(--muted); display:block; margin:8px 0 4px">Scoring thresholds (comma-separated; lower bounds for scores 1→10)</label>
      <div class="controls" style="grid-template-columns: 1fr auto auto;">
        <input id="scoreThresholds" type="text" spellcheck="false" value="100,60,40,30,20,15,10,5,3,2"/>
        <button class="secondary" id="btnApply">Apply</button>
        <button class="secondary" id="btnReset">Reset defaults</button>
      </div>
      <div class="hint">1: ≥100 (Worst), 2: ≥60, 3: ≥40, 4: ≥30, 5: ≥20, 6: ≥15, 7: ≥10, 8: ≥5, 9: ≥3, 10: &lt;2 (incl. 0). The value 1000 counts in the average.</div>

      <label style="font-size:12px; color:var(--muted); display:block; margin:12px 0 4px">
        Paste data with headers: <code>Function — KPI, Target, Max allowed, …</code><br>
        Add test dates like: <code>CC 0830(TO) [2025-09-04]</code><br>
        Optional inline notes: add a row with first cell <code>Release note</code>, put notes under each software column, bullets separated by literal <code>\n</code>.<br>
        Optional file notes: create <code>&lt;software base&gt;.csv</code> (no date) with one bullet per line, e.g. <code>CC 0830(TO).csv</code>.
      </label>
      <textarea id="dataIn" spellcheck="false" placeholder="Function — KPI, Target, Max allowed, Audi Q6 e-tron [2025-09-10], CC 0830(TO) [2025-09-04], ..."></textarea>
      <div class="controls" style="grid-template-columns:auto 1fr;">
        <button id="btnRenderText">Render pasted text</button>
        <div class="hint">Tip: switch delimiter or thresholds and re-render.</div>
      </div>
      <div class="small">Rules: ≤Target = <b>Green</b>, Target…(Max allowed) = <b>Yellow</b>, &gt;Max allowed = <b>Red</b>, value = 1000 = <b>Black</b>.</div>
    </div>

    <div class="panel">
      <div id="charts" class="charts"></div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modalBackdrop" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <header>
        <h2 id="modalTitle">Release Note</h2>
        <button class="close" id="modalClose" aria-label="Close">Close</button>
      </header>
      <div class="content" id="modalContent"></div>
    </div>
  </div>

<script>
/* ---------- Colors & helpers ---------- */
const GREEN = '#0a9910', YELLOW = '#ffd000', RED = '#d43b3b', BLACK = '#000';
const DEFAULT_THRESH_STR = '100,60,40,30,20,15,10,5,3,2';
const LS_KEY = 'segRadarKPI.thresholds';
let LAST_RAW = '';

const scoreColors = ['#e60000','#ff1e1e','#ff6a00','#ffa000','#ffe07a','#ffff33','#9acd32','#66bb6a','#00a878','#2e7d32'];
const scoreText   = ['Worst','Too bad','Bad','Not good','Unacceptable','Marginal','Acceptable','Good','Impressive','Exceptional'];
const fmtCell = v => (v==null || Number.isNaN(v)) ? '—' : (Number.isInteger(v) ? String(v) : String(parseFloat(v.toFixed(2)).replace(/\.00$/,'')));

/* ---------- Scoring ---------- */
function scoreFromAvg(a, thresholds){
  if (a == null || Number.isNaN(a)) return null;
  if (a === 0) return 10;
  for (let i=0;i<9;i++){ if (a >= thresholds[i]) return i+1; }
  return 10;
}
function colorFor(v, tgt, max){
  if (v == null || Number.isNaN(v)) return null;
  if (v === 1000) return BLACK;
  if (v <= tgt) return GREEN;
  if (v < (max + 1)) return YELLOW;
  return RED;
}
function parseNumber(x){
  if (x==null) return null;
  const t = (""+x).trim();
  if (!t) return null;
  const v = Number(t.replace(',', '.'));
  return isNaN(v) ? null : v;
}
function detectDelimiter(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return '\t';
  const sel = document.getElementById('delimiter').value;
  if (sel !== 'auto') return sel;
  const cand = ['\t', ',', ';'];
  let best = '\t', bestCnt = 0;
  for (const d of cand){ const c = lines[0].split(d).length; if (c > bestCnt){ bestCnt = c; best = d; } }
  return best;
}
function splitFuncKpi(s){
  if (!s) return {func:'', kpi:''};
  const em = s.split('—'); if (em.length>=2) return {func:em[0].trim(), kpi:em.slice(1).join('—').trim()};
  const dash = s.split(' - '); if (dash.length>=2) return {func:dash[0].trim(), kpi:dash.slice(1).join(' - ').trim()};
  const sp = s.split(' ');
  return {func: sp[0]||'', kpi: s};
}
function normalizeHeader(h){
  if(!h) return '';
  return h.toLowerCase().replace(/\u00a0/g,' ').replace(/\s+/g,' ').replace(/[^a-z0-9 ]/g,'').trim();
}

/* ---------- Thresholds ---------- */
function parseThresholds(str){
  const arr = (str||'').split(',').map(s=>s.trim()).filter(s=>s!=='').map(Number);
  if (arr.length !== 10 || arr.some(n=>Number.isNaN(n))) return null;
  for (let i=1;i<arr.length;i++){ if (arr[i] > arr[i-1]) return null; }
  return arr;
}
function getThresholds(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  let t = parseThresholds(ui);
  if (t) return t;
  const ls = localStorage.getItem(LS_KEY);
  t = parseThresholds(ls);
  if (t) return t;
  return parseThresholds(DEFAULT_THRESH_STR);
}
function setThresholdsToUI(arr){
  const s = (arr && arr.length===10) ? arr.join(',') : DEFAULT_THRESH_STR;
  document.getElementById('scoreThresholds').value = s;
}
function saveThresholdsFromUI(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  const t = parseThresholds(ui);
  if (!t){
    alert('Please enter 10 comma-separated numbers in non-increasing order (e.g., '+DEFAULT_THRESH_STR+').');
    return false;
  }
  localStorage.setItem(LS_KEY, t.join(','));
  return true;
}
function resetThresholds(){
  localStorage.setItem(LS_KEY, DEFAULT_THRESH_STR);
  setThresholdsToUI(parseThresholds(DEFAULT_THRESH_STR));
}
const fmtNum = n => Number.isInteger(n) ? String(n) : String(parseFloat(n.toFixed(2)));
function scoreRangeLabels(T){
  const lab = [];
  for (let i=0;i<9;i++) lab.push('≥ ' + fmtNum(T[i]));
  lab.push('< ' + fmtNum(T[8]) + (T[9] === 0 ? ' (incl. 0)' : ''));
  return lab;
}

/* ---------- Parse table (dates + inline "Release note" row) ---------- */
function parseTable(text){
  const selectVal = document.getElementById('delimiter').value;
  const tryParse = (d)=> text
    .split(/\r?\n/)
    .filter(r => r.trim().length > 0)
    .map(r => r.split(d));

  let delim = (selectVal === 'auto') ? detectDelimiter(text) : selectVal;
  let rows = tryParse(delim);
  if (!rows.length) return { headers: [], entries: [], software: [], releaseNotes: {} };

  let headers = rows[0].map(h => h.trim());

  // Auto-insert missing first header cell if needed
  if (rows.length > 1 && rows[1].length === headers.length + 1) {
    const firstCell = (rows[1][0] || '').trim();
    const looksText = parseNumber(firstCell) == null;
    const normH = headers.map(normalizeHeader);
    const hasTarget = normH.includes('target');
    const hasMax = normH.includes('max allowed') || normH.includes('maxallowed');
    if (looksText && hasTarget && hasMax) headers = ['Function — KPI', ...headers];
  }

  let norm = headers.map(normalizeHeader);
  let idxTarget = norm.findIndex(h => h === 'target');
  let idxMax    = norm.findIndex(h => (h === 'max allowed' || h === 'maxallowed'));

  // Auto-fallback delimiter if target/max not found
  if ((idxTarget < 0 || idxMax < 0) && selectVal !== 'auto') {
    const auto = detectDelimiter(text);
    if (auto !== delim) {
      delim = auto; rows = tryParse(delim);
      headers = rows[0].map(h => h.trim());
      if (rows.length > 1 && rows[1].length === headers.length + 1) {
        const firstCell = (rows[1][0] || '').trim();
        const looksText = parseNumber(firstCell) == null;
        const normH2 = headers.map(normalizeHeader);
        const hasTarget2 = normH2.includes('target');
        const hasMax2 = normH2.includes('max allowed') || normH2.includes('maxallowed');
        if (looksText && hasTarget2 && hasMax2) headers = ['Function — KPI', ...headers];
      }
      norm = headers.map(normalizeHeader);
      idxTarget = norm.findIndex(h => h === 'target');
      idxMax    = norm.findIndex(h => (h === 'max allowed' || h === 'maxallowed'));
    }
  }

  if (idxTarget < 0 || idxMax < 0) {
    alert("Missing required columns: 'Target' and 'Max allowed'. Try Auto-detect delimiter.\nHeaders seen: " + headers.join(', '));
    return { headers, entries: [], software: [], releaseNotes: {} };
  }

  // Software columns (strip optional [YYYY-MM-DD])
  const swCols = [];
  for (let i = idxMax + 1; i < headers.length; i++) {
    const raw = headers[i].trim();
    const m = raw.match(/\[(\d{4}-\d{2}-\d{2})\]\s*$/);
    const date = m ? m[1] : null;
    const baseNoDate = m ? raw.replace(/\s*\[\d{4}-\d{2}-\d{2}\]\s*$/, '') : raw;
    const basePretty = baseNoDate.replace('(TO)', ' (TO)');
    const countPrev = swCols.filter(s => s.base === basePretty).length;
    const label = countPrev ? `${basePretty} — ${countPrev + 1}` : basePretty;
    swCols.push({ idx: i, base: basePretty, label, date });
  }

  const releaseNotes = {};
  const entries = [];

  for (let r = 1; r < rows.length; r++) {
    const row = rows[r];
    if (!row || row.length === 0) continue;

    const firstCellRaw = (row[0] || '').trim();
    const firstNorm = normalizeHeader(firstCellRaw);

    if (firstNorm === 'releasenote' || firstCellRaw.toLowerCase() === 'release note') {
      // Inline style: collect notes in matching software columns (bullets separated by literal \n)
      for (const sw of swCols) {
        const raw = (row[sw.idx] ?? '').trim();
        if (raw) {
          releaseNotes[sw.label] = (releaseNotes[sw.label] ? (releaseNotes[sw.label] + '\\n' + raw) : raw);
        }
      }
      continue;
    }

    const { func, kpi } = splitFuncKpi(firstCellRaw);
    const target = parseNumber(row[idxTarget]);
    const max    = parseNumber(row[idxMax]);

    const values = {};
    for (const sw of swCols) values[sw.label] = parseNumber(row[sw.idx]);

    entries.push({ func, kpi, target, max, values });
  }

  return { headers, entries, software: swCols, releaseNotes };
}

/* ---------- Modal helpers ---------- */
function openReleaseNoteModal(title, noteText){
  const backdrop = document.getElementById('modalBackdrop');
  const titleEl  = document.getElementById('modalTitle');
  const content  = document.getElementById('modalContent');

  titleEl.textContent = title || 'Release Note';

  const parts = String(noteText || '')
    .replace(/\r/g,'')
    .split(/\\n|\n/g)
    .map(s => s.trim())
    .filter(s => s.length);

  content.innerHTML = '';
  if (parts.length === 0){
    const p = document.createElement('p'); p.className = 'empty'; p.textContent = 'No release note provided.'; content.appendChild(p);
  } else {
    const ul = document.createElement('ul');
    parts.forEach(t => { const li = document.createElement('li'); li.textContent = t; ul.appendChild(li); });
    content.appendChild(ul);
  }

  backdrop.style.display = 'flex';
  backdrop.setAttribute('aria-hidden', 'false');
}
function closeReleaseNoteModal(){
  const backdrop = document.getElementById('modalBackdrop');
  backdrop.style.display = 'none';
  backdrop.setAttribute('aria-hidden', 'true');
}

/* ---------- Optional manifest + file-based notes (avoid 404s) ---------- */
const RN_MANIFEST_FILE = 'release_notes_manifest.json';

async function readTextOrNull(path){
  try{
    const res = await fetch(encodeURI(path) + '?t=' + Date.now(), {cache:'no-store'});
    if (!res.ok) return null;
    return await res.text();
  }catch{ return null; }
}
async function loadReleaseNotesManifest(){
  try{
    const res = await fetch(RN_MANIFEST_FILE + '?t=' + Date.now(), {cache:'no-store'});
    if (!res.ok) return null;
    const list = await res.json();
    if (!Array.isArray(list)) return null;
    return new Set(list.map(s => String(s).toLowerCase()));
  }catch{ return null; }
}
// Loads "<base>.csv" for each software (base = header without date). One bullet per line.
// If a manifest is present, only fetch files that are listed (prevents 404s).
async function loadReleaseNotesFromFiles(swCols, manifestSet){
  const out = {};
  for (const sw of (swCols||[])){
    const file = `${sw.base}.csv`;
    if (manifestSet && !manifestSet.has(file.toLowerCase())) continue; // skip unknown files
    const txt = await readTextOrNull(file);
    if (!txt) continue;
    const lines = txt.replace(/\r/g,'').split('\n').map(s=>s.trim()).filter(Boolean);
    if (lines.length){
      const joined = lines.join('\n'); // real newlines; modal code splits on \n
      out[sw.label] = (out[sw.label] ? (out[sw.label] + '\n' + joined) : joined);
    }
  }
  return out;
}

/* ---------- Summary card (hides column when no notes) ---------- */
function renderSummary(container, parsed){
  const T = getThresholds();
  if (!parsed || !parsed.software || !parsed.software.length) return;

  const rowsRaw = parsed.software.map(sw => {
    const swLabel = sw.label;
    const vals = parsed.entries.map(e => e.values[swLabel]).filter(v => v != null && !Number.isNaN(v));
    const avg = vals.length ? d3.mean(vals.map(v => Math.min(v, 1000))) : null;
    const score = avg == null ? null : scoreFromAvg(avg, T);
    return {
      sw: swLabel,
      date: sw.date,
      avg,
      score,
      text: score == null ? 'n/a' : scoreText[score - 1],
      note: (parsed.releaseNotes?.[swLabel] || '').trim()
    };
  });

  const hasAnyNotes = rowsRaw.some(r => r.note.length > 0);

  const rows = rowsRaw.slice().sort((a,b)=>{
    const sa = a.score ?? -1, sb = b.score ?? -1;
    if (sa !== sb) return sb - sa;
    if (a.avg == null && b.avg == null) return 0;
    if (a.avg == null) return 1;
    if (b.avg == null) return -1;
    return a.avg - b.avg;
  });

  const chartData = rows.filter(r => r.avg != null);
  if (!rows.length) return;

  const card = container.append('div').attr('class', 'chart-card summary-card');
  card.append('div').attr('class','summary-title').text('Summary Weekly KPI');

  // Build table
  const table = card.append('table').attr('class', 'summary-table');
  const colgroup = hasAnyNotes
    ? `<col class="col-sw"><col class="col-date"><col class="col-avg"><col class="col-score"><col class="col-rating"><col class="col-note">`
    : `<col class="col-sw"><col class="col-date"><col class="col-avg"><col class="col-score"><col class="col-rating">`;
  table.append('colgroup').html(colgroup);

  const thead = table.append('thead').append('tr');
  thead.html(
    hasAnyNotes
      ? `<th>Software</th><th>Test date</th><th>Average events per 1000 km</th><th>Score</th><th>Rating</th><th>Release Note</th>`
      : `<th>Software</th><th>Test date</th><th>Average events per 1000 km</th><th>Score</th><th>Rating</th>`
  );

  const tbody = table.append('tbody');
  rows.forEach(r=>{
    const tr = tbody.append('tr');
    tr.append('td').append('span').attr('class','software-cell').attr('title', r.sw).text(r.sw);
    tr.append('td').text(r.date || '—');
    tr.append('td').text(r.avg == null ? '—' : r.avg.toFixed(1));

    const scoreCell = tr.append('td');
    if (r.score == null){
      scoreCell.text('—'); tr.append('td').text('n/a');
    } else {
      scoreCell.append('span')
        .attr('class', 'summary-chip')
        .attr('style', `background:${scoreColors[r.score-1]}22; border-color:${scoreColors[r.score-1]}66; color:#111`)
        .text(r.score);
      tr.append('td').text(r.text);
    }

    if (hasAnyNotes){
      const tdNote = tr.append('td');
      if (r.note){
        const a = tdNote.append('span').attr('class','link').text('Release Note');
        a.on('click', ()=> openReleaseNoteModal(`${r.sw}${r.date ? ' — ' + r.date : ''}`, r.note));
      } else {
        tdNote.text(''); // empty when other rows have notes but this one doesn't
      }
    }
  });

  // Caption + bars (compact)
  if (chartData.length){
    card.append('div').attr('class','small').style('margin','8px 0 4px').text('Average events per 1000 km (bar color = score)');

    const yLabels = chartData.map(d => d.date ? `${d.sw}  (${d.date})` : d.sw);
    const measureTextWidth = (texts, fontSize=12, fontWeight=400)=>{
      const tmp = d3.select('body').append('svg').attr('width',0).attr('height',0).style('position','absolute').style('left','-9999px').style('top','-9999px');
      let max = 0;
      texts.forEach(t=>{
        const node = tmp.append('text').attr('font-size', fontSize).attr('font-weight', fontWeight).text(t==null ? '' : String(t)).node();
        max = Math.max(max, node.getComputedTextLength());
      });
      tmp.remove(); return max;
    };

    const labelW = Math.ceil(measureTextWidth(yLabels, 12, 400));
    const cardW = Math.max(0, Math.ceil(card.node().getBoundingClientRect().width) - 20);
    const cw = Math.max(560, Math.min(1000, cardW));
    const leftPad = Math.min(Math.floor(cw * 0.48), Math.max(160, labelW + 14));
    const rightPad = 16, topPad = 8, barH = 22, gap = 6;

    const svg = card.append('svg').style('display','block').style('margin','0 auto 6px').attr('width', cw).attr('height', topPad + chartData.length * (barH + gap) + 34);
    const g = svg.append('g').attr('transform', `translate(0, ${topPad})`);

    const maxAvg = d3.max(chartData, d => Math.min(1000, d.avg));
    const x = d3.scaleLinear().domain([0, Math.max(1, maxAvg)]).range([leftPad, cw - rightPad]);

    chartData.forEach((d,i)=> d._y = i * (barH + gap));

    g.selectAll('.ylabel').data(chartData).enter().append('text')
      .attr('class','ylabel').attr('x', leftPad - 10).attr('y', d => d._y + barH/2)
      .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 12)
      .text((d,i)=> yLabels[i]).append('title').text(d => d.sw);

    g.selectAll('.bar').data(chartData).enter().append('rect')
      .attr('class','bar').attr('x', x(0)).attr('y', d => d._y)
      .attr('width', d => x(Math.min(1000, d.avg)) - x(0)).attr('height', barH)
      .attr('fill', d => scoreColors[(d.score || 10) - 1]).attr('fill-opacity', 0.9)
      .append('title').text(d => `Score ${d.score}: ${d.text} — ${d.avg.toFixed(1)} /1000km`);

    g.selectAll('.val').data(chartData).enter().append('text')
      .attr('x', d => x(Math.min(1000, d.avg)) + 6).attr('y', d => d._y + barH/2)
      .attr('dominant-baseline','middle').attr('font-size', 12).text(d => d.avg.toFixed(1));

    const axisY = chartData.length * (barH + gap);
    g.append('g').attr('transform', `translate(0, ${axisY})`).call(d3.axisBottom(x).ticks(6));
  }

  // Scoring legend
  const ranges = scoreRangeLabels(T);
  const legCw = Math.max(560, Math.min(1000, Math.max(0, Math.ceil(card.node().getBoundingClientRect().width) - 20)));
  const legend = card.append('svg').style('display','block').style('margin','6px auto 2px').attr('width', legCw);
  const bandMargin = 20, boxH = 42;
  const barW = legCw - bandMargin*2, boxW = barW / 10;
  legend.append('text').attr('x', 12).attr('y', 12).attr('font-size', 12).attr('fill', '#555').text('Scoring legend (1 = worst, 10 = best)');
  for (let i=0;i<10;i++){
    const x0 = bandMargin + i*boxW; const gBox = legend.append('g');
    gBox.append('rect').attr('x', x0).attr('y', 20).attr('width', boxW).attr('height', boxH).attr('fill', scoreColors[i]).attr('stroke', '#111').attr('stroke-width', 0.4)
      .append('title').text(`Score ${i+1}: ${scoreText[i]} — ${ranges[i]}`);
    gBox.append('text').attr('x', x0 + boxW/2).attr('y', 20 + 14).attr('text-anchor','middle').attr('font-weight', 800).attr('font-size', 13).text(i+1);
    gBox.append('text').attr('x', x0 + boxW/2).attr('y', 20 + 14 + 16).attr('text-anchor','middle').attr('font-size', 11).text(scoreText[i]);
    gBox.append('text').attr('x', x0 + boxW/2).attr('y', 20 + boxH + 14).attr('text-anchor','middle').attr('font-size', 10).text(ranges[i]);
  }
  legend.attr('height', 20 + boxH + 28 + 6);
}

/* ---------- Main renderer ---------- */
function renderCharts(parsed){
  const container = d3.select('#charts').html('');
  if (!parsed || !parsed.entries || !parsed.entries.length){
    container.append('div').attr('class','small').text('No data to render.');
    return;
  }
  renderSummary(container, parsed);
}

/* ---------- Loader (uses optional manifest, hides links when missing) ---------- */
async function loadCsvAndRender(){
  const file = (document.getElementById('csvFile').value || '').trim() || 'weekly_kpi_data.csv';
  try{
    const res = await fetch(file + '?t=' + Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    LAST_RAW = text;

    let parsed = parseTable(text);
    const manifestSet = await loadReleaseNotesManifest(); // may be null
    const fileNotes = await loadReleaseNotesFromFiles(parsed.software, manifestSet);
    parsed = { ...parsed, releaseNotes: { ...(parsed.releaseNotes||{}), ...fileNotes } };

    renderCharts(parsed);
  }catch(err){
    d3.select('#charts').html('');
    alert(`Could not load "${file}". Make sure it sits next to this HTML and that you're serving over http(s).\n\nError: ${err.message}`);
  }
}

/* ---------- Re-render helper ---------- */
async function rerenderAll(){
  if (!LAST_RAW.trim()){
    d3.select('#charts').html('');
    return;
  }
  let parsed = parseTable(LAST_RAW);
  const manifestSet = await loadReleaseNotesManifest();
  const fileNotes = await loadReleaseNotesFromFiles(parsed.software, manifestSet);
  parsed = { ...parsed, releaseNotes: { ...(parsed.releaseNotes||{}), ...fileNotes } };
  renderCharts(parsed);
}

/* ---------- Wire up UI ---------- */
function initialThresholds(){
  const ls = localStorage.getItem(LS_KEY);
  const t = parseThresholds(ls) || parseThresholds(DEFAULT_THRESH_STR);
  setThresholdsToUI(t);
}
document.addEventListener('DOMContentLoaded', ()=>{
  console.log('Initialized driver at:', new Date().toString());
  initialThresholds();
  loadCsvAndRender();

  const wrap = document.querySelector('.wrap');
  const btn = document.getElementById('toggleSidebar');
  btn.addEventListener('click', ()=>{
    const collapsed = wrap.classList.toggle('collapsed');
    btn.textContent = collapsed ? 'Show input' : 'Hide input';
    btn.setAttribute('aria-expanded', String(!collapsed));
  });

  // Keyboard toggle
  document.addEventListener('keydown', (e)=>{ if (e.key.toLowerCase() === 'i' && !e.altKey && !e.ctrlKey && !e.metaKey) btn.click(); });

  // Modal close
  document.getElementById('modalClose').addEventListener('click', closeReleaseNoteModal);
  document.getElementById('modalBackdrop').addEventListener('click', (e)=>{ if (e.target.id === 'modalBackdrop') closeReleaseNoteModal(); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeReleaseNoteModal(); });
});

document.getElementById('btnLoad').onclick = ()=> loadCsvAndRender();

document.getElementById('btnRenderText').onclick = async ()=>{
  const text = (document.getElementById('dataIn').value || '').trim();
  if (!text){ alert('Paste some data first.'); return; }
  LAST_RAW = text;
  await rerenderAll();
};

document.getElementById('delimiter').addEventListener('change', async ()=>{ await rerenderAll(); });
document.getElementById('btnApply').onclick = async ()=>{ if (saveThresholdsFromUI()) await rerenderAll(); };
document.getElementById('btnReset').onclick = async ()=>{ resetThresholds(); await rerenderAll(); };
</script>
</body>
</html>
