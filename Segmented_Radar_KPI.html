<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Radar KPI with Scoring</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#111; --muted:#666; --card:#f6f7fb;
      --good:#0a9910; --ok:#ffd000; --nok:#d43b3b; --nofunc:#000000;
    }
    html,body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--ink); background:var(--bg);}
    h1{font-size:18px; margin:14px 0 8px;}
    .wrap{display:grid; grid-template-columns: 380px 1fr; gap:16px; padding:16px; align-items:start;}
    .panel{background:#f6f7fb; border-radius:14px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06);} 
    .controls{display:grid; gap:8px; grid-template-columns:minmax(0,1fr) auto auto; align-items:center; margin-bottom:8px;}
    .controls label{font-size:12px; color:var(--muted)}
    textarea{width:100%; min-height:220px; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px;}
    button{appearance:none; border:none; background:#111; color:white; padding:8px 12px; border-radius:10px; cursor:pointer}
    button.secondary{background:#e9ecf5; color:#111}
    input[type="text"], select{width:100%; padding:8px 10px; border-radius:10px; border:1px solid #d7dcef; font-size:12px; background:#fff}

    .charts{display:grid; grid-template-columns:repeat(auto-fit,minmax(680px,1fr)); gap:16px;}
    .chart-card{background:white; border-radius:14px; padding:10px; box-shadow:0 3px 12px rgba(0,0,0,.08); position:relative}
    .download{position:absolute; left:12px; top:12px; font-size:12px; background:#f0f2f8; color:#222; padding:6px 8px; border-radius:8px; cursor:pointer}
    .small{font-size:12px; color:#666}
    .hint{font-size:11px; color:#555; margin-top:4px}

    /* Summary table styling */
    .summary-title{font-weight:700; font-size:16px; margin:4px 0 8px 0; text-align:center}
    .summary-table{width:100%; border-collapse:separate; border-spacing:0; font-size:12px}
    .summary-table th, .summary-table td{padding:10px 10px; text-align:left; border-bottom:1px solid #eef1fb;}
    .summary-table th{background:#f6f7fb; font-weight:700}
    .summary-chip{display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #e9ecf5; font-weight:600;}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Input</h1>
      <div class="controls" style="grid-template-columns: 1fr 1fr auto;">
        <div>
          <label>Delimiter:</label>
          <select id="delimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <div>
          <label>CSV file (same folder):</label>
          <input id="csvFile" type="text" value="weekly_kpi_data.csv" />
        </div>
        <button id="btnLoad">Load CSV</button>
      </div>

      <label style="font-size:12px; color:var(--muted); display:block; margin:8px 0 4px">Scoring thresholds (comma-separated; lower bounds for scores 1→10)</label>
      <div class="controls" style="grid-template-columns: 1fr auto auto;">
        <input id="scoreThresholds" type="text" spellcheck="false" value="50,30,20,15,10,7,5,2,1,0"/>
        <button class="secondary" id="btnApply">Apply</button>
        <button class="secondary" id="btnReset">Reset defaults</button>
      </div>
      <div class="hint">1: ≥50 (Worst), 2: ≥30, 3: ≥20, 4: ≥15, 5: ≥10, 6: ≥7, 7: ≥5, 8: ≥2, 9: ≥1, 10: &lt;1 (incl. 0). The value 1000 counts in the average.</div>

      <label style="font-size:12px; color:var(--muted); display:block; margin:12px 0 4px">
        Or paste data below (headers required: <code>Function — KPI, Target, Max allowed, …</code>)
      </label>
      <textarea id="dataIn" spellcheck="false" placeholder="Paste data with headers:  Function — KPI,  Target,  Max allowed,  CX OKTB EU,  CX OKTB UK,  0824(TO),  0830(TO),  0830(TO)"></textarea>
      <div class="controls" style="grid-template-columns:auto 1fr;">
        <button id="btnRenderText">Render pasted text</button>
        <div class="hint">Tip: you can switch delimiter or thresholds and re-render.</div>
      </div>
      <div class="small">Rules: ≤Target = <b>Green</b>, Target…(Max allowed) = <b>Yellow</b>, &gt;Max allowed = <b>Red</b>, value = 1000 = <b>Black</b>.</div>
    </div>

    <div class="panel">
      <div id="charts" class="charts"></div>
    </div>
  </div>

<script>
/* ---------- Colors & helpers ---------- */
const GREEN = '#0a9910', YELLOW = '#ffd000', RED = '#d43b3b', BLACK = '#000';
const DEFAULT_THRESH_STR = '50,30,20,15,10,7,5,2,1,0';
const LS_KEY = 'segRadarKPI.thresholds'; // only thresholds persist

let LAST_RAW = ''; // holds last loaded/pasted table text

const scoreColors = ['#e60000','#ff1e1e','#ff6a00','#ffa000','#ffe07a','#ffff33','#9acd32','#66bb6a','#00a878','#2e7d32'];
const scoreText   = ['Worst','Too bad','Bad','Not good','Unacceptable','Marginal','Acceptable','Good','Impressive','Exceptional'];

const fmtCell = v => (v==null || Number.isNaN(v)) ? '—' : (Number.isInteger(v) ? String(v) : String(parseFloat(v.toFixed(2)).replace(/\.00$/,'')));

function scoreFromAvg(a, thresholds){
  if (a == null || Number.isNaN(a)) return null;
  if (a === 0) return 10;
  for (let i=0;i<9;i++){ if (a >= thresholds[i]) return i+1; }
  return 10;
}

function colorFor(v, tgt, max){
  if (v == null || Number.isNaN(v)) return null;
  if (v === 1000) return BLACK;
  if (v <= tgt) return GREEN;
  if (v < (max + 1)) return YELLOW;
  return RED;
}
function parseNumber(x){
  if (x==null) return null;
  const t = (""+x).trim();
  if (!t) return null;
  const v = Number(t.replace(',', '.'));
  return isNaN(v) ? null : v;
}
function detectDelimiter(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return '\t';
  const sel = document.getElementById('delimiter').value;
  if (sel !== 'auto') return sel;
  const cand = ['\t', ',', ';'];
  let best = '\t', bestCnt = 0;
  for (const d of cand){ const c = lines[0].split(d).length; if (c > bestCnt){ bestCnt = c; best = d; } }
  return best;
}
function splitFuncKpi(s){
  if (!s) return {func:'', kpi:''};
  const em = s.split('—'); if (em.length>=2) return {func:em[0].trim(), kpi:em.slice(1).join('—').trim()};
  const dash = s.split(' - '); if (dash.length>=2) return {func:dash[0].trim(), kpi:dash.slice(1).join(' - ').trim()};
  const sp = s.split(' ');
  return {func: sp[0]||'', kpi: s};
}
function normalizeHeader(h){
  if(!h) return '';
  return h.toLowerCase().replace(/\u00a0/g,' ').replace(/\s+/g,' ').replace(/[^a-z0-9 ]/g,'').trim();
}

/* ---------- Thresholds ---------- */
function parseThresholds(str){
  const arr = (str||'').split(',').map(s=>s.trim()).filter(s=>s!=='').map(Number);
  if (arr.length !== 10 || arr.some(n=>Number.isNaN(n))) return null;
  for (let i=1;i<arr.length;i++){ if (arr[i] > arr[i-1]) return null; }
  return arr;
}
function getThresholds(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  let t = parseThresholds(ui);
  if (t) return t;
  const ls = localStorage.getItem(LS_KEY);
  t = parseThresholds(ls);
  if (t) return t;
  return parseThresholds(DEFAULT_THRESH_STR);
}
function setThresholdsToUI(arr){
  const s = (arr && arr.length===10) ? arr.join(',') : DEFAULT_THRESH_STR;
  document.getElementById('scoreThresholds').value = s;
}
function saveThresholdsFromUI(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  const t = parseThresholds(ui);
  if (!t){
    alert('Please enter 10 comma-separated numbers in non-increasing order (e.g., '+DEFAULT_THRESH_STR+').');
    return false;
  }
  localStorage.setItem(LS_KEY, t.join(','));
  return true;
}
function resetThresholds(){
  localStorage.setItem(LS_KEY, DEFAULT_THRESH_STR);
  setThresholdsToUI(parseThresholds(DEFAULT_THRESH_STR));
}
const fmtNum = n => Number.isInteger(n) ? String(n) : String(parseFloat(n.toFixed(2)));
function scoreRangeLabels(T){
  const lab = [];
  for (let i=0;i<9;i++) lab.push('≥ ' + fmtNum(T[i]));
  lab.push('< ' + fmtNum(T[8]) + (T[9] === 0 ? ' (incl. 0)' : ''));
  return lab;
}

/* ---------- Parse table ---------- */
function parseTable(text){
  const selectVal = document.getElementById('delimiter').value;
  const tryParse = (d)=> text.split(/\r?\n/).filter(r=>r.trim().length>0).map(r=>r.split(d));

  let delim = (selectVal==='auto') ? detectDelimiter(text) : selectVal;
  let rows = tryParse(delim);
  if (!rows.length) return {headers:[], entries:[], software:[]};

  let headers = rows[0].map(h=>h.trim());
  let norm = headers.map(normalizeHeader);
  let idxTarget = norm.findIndex(h=> h==='target');
  let idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');

  if ((idxTarget<0 || idxMax<0) && selectVal!=='auto'){
    const auto = detectDelimiter(text);
    if (auto !== delim){
      delim = auto; rows = tryParse(delim); headers = rows[0].map(h=>h.trim()); norm = headers.map(normalizeHeader);
      idxTarget = norm.findIndex(h=> h==='target');
      idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');
    }
  }
  if (idxTarget<0 || idxMax<0){
    alert("Missing required columns: 'Target' and 'Max allowed'. Try Auto-detect delimiter.\nHeaders seen: " + headers.join(', '));
    return {headers, entries:[], software:[]};
  }

  const swCols = [];
  for (let i = idxMax+1; i < headers.length; i++){
    const base = headers[i].trim();
    const countPrev = swCols.filter(s => s.base===base).length;
    const label = countPrev ? `${base} — ${countPrev+1}` : base;
    swCols.push({idx:i, base, label: label.replace('(TO)', ' (TO)')});
  }

  const entries = [];
  for (let r=1; r<rows.length; r++){
    const row = rows[r];
    if (!row || row.length===0) continue;
    const {func, kpi} = splitFuncKpi((row[0]||'').trim());
    const target = parseNumber(row[idxTarget]);
    const max = parseNumber(row[idxMax]);
    const values = {};
    for (const sw of swCols){ values[sw.label] = parseNumber(row[sw.idx]); }
    entries.push({func, kpi, target, max, values});
  }
  return {headers, entries, software: swCols.map(s=>s.label)};
}

/* ---------- Summary card ---------- */
function renderSummary(container, parsed){
  const T = getThresholds();
  if (!parsed.software || !parsed.software.length) return;

  const rows = parsed.software.map(swLabel=>{
    const vals = parsed.entries.map(e => e.values[swLabel]).filter(v => v!=null && !Number.isNaN(v));
    const avg = vals.length ? d3.mean(vals.map(v => Math.min(v, 1000))) : null;
    const score = avg==null ? null : scoreFromAvg(avg, T);
    return { sw: swLabel, avg, score, text: score==null ? 'n/a' : scoreText[score-1] };
  });

  if (rows.every(r => r.avg==null)) return;

  const card = container.append('div').attr('class','chart-card');
  card.append('div').attr('class','summary-title').text('Summary — Average Events / 1000 km & Score');

  const table = card.append('table').attr('class','summary-table');
  const thead = table.append('thead').append('tr');
  thead.html(`
    <th>Software</th>
    <th style="text-align:right">Avg events / 1000 km</th>
    <th style="text-align:center">Score</th>
    <th>Rating</th>
  `);
  const tbody = table.append('tbody');

  rows.forEach(r=>{
    const tr = tbody.append('tr');
    tr.append('td').text(r.sw);
    tr.append('td').attr('style','text-align:right').text(r.avg==null ? '—' : r.avg.toFixed(1));
    const scoreCell = tr.append('td').attr('style','text-align:center');
    if (r.score==null){
      scoreCell.text('—');
      tr.append('td').text('n/a');
    }else{
      const chip = scoreCell.append('span')
        .attr('class','summary-chip')
        .attr('style', `background:${scoreColors[r.score-1]}22; border-color:${scoreColors[r.score-1]}66; color:#111`);
      chip.text(r.score);
      tr.append('td').text(r.text);
    }
  });
}

/* ---------- Renderer (cards) ---------- */
function renderCharts(parsed){
  const T = getThresholds();
  const rangeLabels = scoreRangeLabels(T);
  const container = d3.select('#charts').html('');
  if (!parsed || !parsed.entries || !parsed.entries.length){
    container.append('div').attr('class','small').text('No data to render.');
    return;
  }

  // Summary card first
  renderSummary(container, parsed);

  (parsed.software||[]).forEach(swLabel=>{
    const hasAny = parsed.entries.some(e => e.values[swLabel]!=null && !Number.isNaN(e.values[swLabel]));
    if (!hasAny) return;

    const card = container.append('div').attr('class','chart-card');
    const w = 680;

    // Download button
    card.append('button').attr('class','download').text('Download PNG').on('click',()=>{
      const svg = card.select('svg').node();
      const url = URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(svg)], {type:'image/svg+xml'}));
      const img = new Image();
      const W = svg.viewBox?.baseVal?.width || svg.width.baseVal.value;
      const H = svg.viewBox?.baseVal?.height || svg.height.baseVal.value;
      img.onload = ()=>{
        const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
        ctx.drawImage(img,0,0);
        const a=document.createElement('a'); a.download = `${swLabel.replaceAll(' ','_')}.png`; a.href = canvas.toDataURL('image/png'); a.click();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    /* --- Layout constants --- */
    const radarH = 540;
    const scoreTopPad = 28;
    const rowH = 22, headerH = 24, tableSidePad = 12, colGap = 8;
    const legW = 160, legOffset = 12;

    const centerX = (w - (legW + legOffset)) / 2; // leaves room for legend
    const centerY = radarH / 2;
    const rMax    = Math.min(centerX, centerY) - 16;

    // Build table data
    const rows = parsed.entries
      .filter(e => e.values[swLabel] != null && !Number.isNaN(e.values[swLabel]))
      .map(e => ({ kpi: e.kpi, func: e.func, target: e.target, max: e.max, events: e.values[swLabel] }));

    // text measurement
    function measureMaxWidth(texts, fontSize=11, fontWeight=400){
      const tmp = d3.select('body').append('svg')
        .attr('width',0).attr('height',0)
        .style('position','absolute').style('left','-9999px').style('top','-9999px');
      let max = 0;
      texts.forEach(t=>{
        const node = tmp.append('text')
          .attr('font-size', fontSize)
          .attr('font-weight', fontWeight)
          .text(t==null ? '' : String(t))
          .node();
        max = Math.max(max, node.getComputedTextLength());
      });
      tmp.remove();
      return max;
    }

    const kpiTexts  = rows.map(r=>r.kpi);
    const funcTexts = rows.map(r=>r.func);
    const tgtTexts  = rows.map(r=>fmtCell(r.target));
    const maxTexts  = rows.map(r=>fmtCell(r.max));
    const evtTexts  = rows.map(r=>fmtCell(r.events));

    const kpiW  = measureMaxWidth(kpiTexts , 11, 400) + 16;
    const funcW = Math.max(90, Math.min(180, measureMaxWidth(funcTexts, 11, 400) + 16));
    let col2W   = Math.max(50, Math.min(120, measureMaxWidth(tgtTexts , 11, 400) + 16));
    let col3W   = Math.max(60, Math.min(140, measureMaxWidth(maxTexts , 11, 400) + 16));
    let col4W   = Math.max(60, Math.min(140, measureMaxWidth(evtTexts , 11, 700) + 16));

    const tableWUsed = kpiW + funcW + col2W + col3W + col4W + colGap*4;
    const x0 = tableSidePad;                 // KPI start
    const x1 = x0 + kpiW + colGap;           // Function start
    const x2 = x1 + funcW + colGap;          // Target start
    const x3 = x2 + col2W + colGap;          // Max start
    const x4 = x3 + col3W + colGap;          // Events start

    const svg = card.append('svg').attr('width', w);

    // defs: unique glow
    const defs = svg.append('defs');
    const glowId = `glow-${Math.random().toString(36).slice(2)}`;
    const glow = defs.append('filter').attr('id',glowId).attr('x','-30%').attr('y','-50%').attr('width','160%').attr('height','220%');
    glow.append('feGaussianBlur').attr('in','SourceGraphic').attr('stdDeviation','4');
    glow.append('feMerge').html('<feMergeNode/><feMergeNode in="SourceGraphic"/>');

    // Title & Legend
    svg.append('text').attr('x', w/2).attr('y', 20).attr('text-anchor','middle').attr('font-weight',700).text(swLabel);
    const legendItems = [
      {label:'Green = Good',  color: GREEN},
      {label:'Yellow = OK',   color: YELLOW},
      {label:'Red = NOK',     color: RED},
      {label:'Black = No function', color: BLACK},
    ];
    const legendG = svg.append('g').attr('transform', `translate(${w - 160 - 12}, 32)`);
    legendG.append('rect').attr('rx',8).attr('ry',8).attr('width',160).attr('height',8*2 + 18*legendItems.length).attr('fill','#ffffff').attr('fill-opacity',0.85);
    legendItems.forEach((it, i)=>{
      const y = 8 + i*18 + 12;
      legendG.append('rect').attr('x',8).attr('y',y-7).attr('width',12).attr('height',12).attr('fill',it.color);
      legendG.append('text').attr('x',26).attr('y',y).attr('dominant-baseline','middle').attr('font-size',12).text(it.label);
    });

    // ---- Radar chart ----
    const g = svg.append('g').attr('transform', `translate(${centerX},${centerY})`);

    const functions = [];
    parsed.entries.forEach(e=>{
      const v = e.values[swLabel];
      if (v!=null && !Number.isNaN(v) && !functions.includes(e.func)) functions.push(e.func);
    });
    if (!functions.length){
      card.append('div').attr('class','small').text('No KPI values for this software.');
      return;
    }

    const linearPortion = 0.55;
    const rLinear = rMax * linearPortion;
    const logMin = 10, logMax = 1000;
    const logDen = Math.log10(logMax) - Math.log10(logMin);
    function toR(v){
      if (v==null || Number.isNaN(v)) return null;
      if (v <= 0) return 0;
      const vv = Math.min(v, logMax);
      if (vv < logMin) return (vv / logMin) * rLinear;
      return rLinear + ((Math.log10(vv) - Math.log10(logMin)) / logDen) * (rMax - rLinear);
    }

    const ringGrid = [1,2,3,4,5,6,7,8,9,10,30,100,300,1000];
    g.selectAll('.ring').data(ringGrid).enter().append('circle')
      .attr('r', d=>toR(d)).attr('fill','none').attr('stroke','#999').attr('stroke-opacity',0.22);
    g.selectAll('.rlabel').data(ringGrid).enter().append('text')
      .attr('x', 6).attr('y', d=> -toR(d))
      .attr('dominant-baseline','middle').attr('font-size', 11).attr('fill', '#666')
      .text(d=>d);

    const axisY = -rMax * 0.70;
    g.append('text').attr('x', -8).attr('y', axisY).attr('transform', `rotate(-90, 0, ${axisY})`)
      .attr('text-anchor','end').attr('font-size', 11).text('Number of events');

    const F = functions.length;
    const wedge = (Math.PI*2) / F;
    const innerFrac = 0.98;
    const spread = wedge * innerFrac;
    const arc = d3.arc();
    const FUNC_LABEL_OFFSET = 16;

    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const end = start + wedge;
      g.append('path')
        .attr('d', arc({innerRadius:0, outerRadius:rMax, startAngle:start, endAngle:end}))
        .attr('fill', idx % 2 ? '#f6f7fb' : '#eef2ff').attr('fill-opacity', 0.06);
      g.append('line')
        .attr('x1',0).attr('y1',0).attr('x2', Math.cos(start)*rMax).attr('y2', Math.sin(start)*rMax)
        .attr('stroke','#000').attr('stroke-opacity',0.25);
      const cen = (start + end) / 2;
      g.append('text')
        .attr('x', Math.cos(cen)*(rMax+FUNC_LABEL_OFFSET)).attr('y', Math.sin(cen)*(rMax+FUNC_LABEL_OFFSET))
        .attr('text-anchor','middle').attr('font-weight',700).attr('fill','#1f3de3').text(f);
    });

    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const center = start + wedge/2;
      const items = parsed.entries.filter(e=>e.func===f);
      const K = items.length;
      const avail = spread * 0.96;
      const baseOffs = (K===1) ? [0] : d3.range(K).map(i => (i-(K-1)/2)/(K-1) * (avail/2));
      const placed = [];
      const minSep = wedge * 0.09;
      const radBin = rMax * 0.12;
      const labelAvoid = wedge * 0.18;

      items.forEach((e, i)=>{
        const v = e.values[swLabel]; if (v==null || Number.isNaN(v)) return;
        let r = toR(v);
        let ang = center + baseOffs[i];
        const isBlack = (v === 1000);

        if (isBlack && Math.abs(ang - center) < labelAvoid){
          const dir = (ang >= center) ? 1 : -1;
          ang = center + dir * (labelAvoid + wedge*0.02);
        }
        ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
        let tries = 0;
        while (placed.some(p => Math.abs(p.ang - ang) < minSep && Math.abs(p.r - r) < radBin) && tries < 120){
          const dir = (tries % 2 === 0) ? 1 : -1;
          ang += dir * (minSep * 0.65);
          ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
          tries++;
        }
        if (tries >= 120){ r = Math.min(r + 8, rMax * 0.98); }
        placed.push({ang, r});

        const cx = Math.cos(ang)*r, cy = Math.sin(ang)*r;
        const fill = colorFor(v, e.target, e.max);
        if (!fill) return;

        g.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 7).attr('fill', fill)
          .append('title').text(`${f} — ${e.kpi}: ${v}`);

        const rLabel = Math.min(r + 18, rMax * 0.98);
        const lx = Math.cos(ang)*rLabel, ly = Math.sin(ang)*rLabel;
        g.append('text').attr('x', lx).attr('y', ly).attr('text-anchor','middle')
          .attr('font-size', 11).attr('paint-order','stroke').attr('stroke','white').attr('stroke-width',3)
          .text(e.kpi);
      });
    });

    /* ---------- KPI TABLE ---------- */
    const tableY = centerY + rMax + FUNC_LABEL_OFFSET + 2;
    const tableG = svg.append('g').attr('transform', `translate(0, ${tableY})`);
    const tableH = headerH + rows.length * rowH + 8;

    // compact background sized to content
    tableG.append('rect')
      .attr('x', 12-4).attr('y', 2)
      .attr('width', tableWUsed + 8).attr('height', tableH)
      .attr('rx', 8).attr('ry', 8).attr('fill', '#ffffff').attr('stroke', '#e4e7f3');

    // header row background
    tableG.append('rect')
      .attr('x', x0).attr('y', 4)
      .attr('width', tableWUsed).attr('height', headerH)
      .attr('rx', 6).attr('ry', 6).attr('fill', '#f6f7fb');

    const hdrYmid = 4 + headerH/2;

    // Headers
    tableG.append('text')
      .attr('x', x0+6).attr('y', hdrYmid)
      .attr('dominant-baseline','middle').attr('font-size',12).attr('font-weight',700)
      .text('KPI');

    tableG.append('text')
      .attr('x', x1+6).attr('y', hdrYmid)
      .attr('dominant-baseline','middle').attr('font-size',12).attr('font-weight',700)
      .text('Function');

    tableG.append('text')
      .attr('x', x2 + col2W - 6).attr('y', hdrYmid)
      .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size',12).attr('font-weight',700)
      .text('Target');

    const hMax = tableG.append('text')
      .attr('x', x3 + col3W - 6).attr('y', 4 + 8)
      .attr('text-anchor','end').attr('font-size',12).attr('font-weight',700);
    hMax.append('tspan').text('Max').attr('x', x3 + col3W - 6).attr('dy', 0);
    hMax.append('tspan').text('allowed').attr('x', x3 + col3W - 6).attr('dy', 12);

    const hEvt = tableG.append('text')
      .attr('x', x4 + col4W - 6).attr('y', 4 + 8)
      .attr('text-anchor','end').attr('font-size',12).attr('font-weight',700);
    hEvt.append('tspan').text('Number of').attr('x', x4 + col4W - 6).attr('dy', 0);
    hEvt.append('tspan').text('events').attr('x', x4 + col4W - 6).attr('dy', 12);

    // rows
    rows.forEach((r, i)=>{
      const y = 4 + headerH + i*rowH;
      // zebra
      tableG.append('rect')
        .attr('x', x0).attr('y', y)
        .attr('width', tableWUsed).attr('height', rowH)
        .attr('fill', i%2 ? '#fafbff' : '#ffffff');

      // KPI
      tableG.append('text')
        .attr('x', x0+6).attr('y', y + rowH/2)
        .attr('dominant-baseline','middle').attr('font-size', 11)
        .text(r.kpi);

      // Function
      tableG.append('text')
        .attr('x', x1+6).attr('y', y + rowH/2)
        .attr('dominant-baseline','middle').attr('font-size', 11)
        .text(r.func);

      // Target
      tableG.append('text')
        .attr('x', x2 + col2W - 6).attr('y', y + rowH/2)
        .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11)
        .text(fmtCell(r.target));

      // Max allowed
      tableG.append('text')
        .attr('x', x3 + col3W - 6).attr('y', y + rowH/2)
        .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11)
        .text(fmtCell(r.max));

      // Number of events
      tableG.append('text')
        .attr('x', x4 + col4W - 6).attr('y', y + rowH/2)
        .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11).attr('font-weight',600)
        .text(fmtCell(r.events));
    });

    // subtle guides at gaps
    [x1 - colGap/2, x2 - colGap/2, x3 - colGap/2, x4 - colGap/2].forEach(xx=>{
      tableG.append('line')
        .attr('x1', xx).attr('x2', xx)
        .attr('y1', 4 + headerH).attr('y2', 4 + headerH + rows.length*rowH)
        .attr('stroke', '#eef1fb');
    });

    /* ---------- Scoring band ---------- */
    const valuesForAvg = parsed.entries.map(e => e.values[swLabel]).filter(v => v != null && !Number.isNaN(v));
    const avgEvents = valuesForAvg.length ? d3.mean(valuesForAvg.map(v => Math.min(v, 1000))) : null;
    const score = avgEvents==null ? null : scoreFromAvg(avgEvents, T);

    const barMargin = 20, boxH2 = 42;
    const barW = w - barMargin*2;
    const boxW = barW / 10;

    const scoreBandY = tableY + (headerH + rows.length * rowH + 8) + scoreTopPad;
    const scoreG = svg.append('g').attr('transform', `translate(0, ${scoreBandY})`);

    const caption = (avgEvents==null)
      ? 'Average per 1000km:  n/a (only "No function" or missing values)'
      : `Average per 1000km:  ${avgEvents.toFixed(1)} events → Score: ${score} (${scoreText[score-1]})`;
    scoreG.append('text').attr('x', barMargin).attr('y', 14).attr('font-size', 12).text(caption);

    const ranges = rangeLabels;
    for (let i=0;i<10;i++){
      const x = barMargin + i*boxW;
      const isSel = (score === i+1);

      if (isSel){
        scoreG.append('rect')
          .attr('x', x - 6).attr('y', 22)
          .attr('width', boxW + 12).attr('height', boxH2 + 14)
          .attr('rx', 6).attr('ry', 6)
          .attr('fill', scoreColors[i]).attr('fill-opacity', 0.30)
          .attr('filter', `url(#${glowId})`);
      }

      const r = scoreG.append('rect')
        .attr('x', x).attr('y', 28)
        .attr('width', boxW).attr('height', boxH2)
        .attr('fill', scoreColors[i])
        .attr('stroke', isSel ? '#000' : '#111')
        .attr('stroke-width', isSel ? 3 : 0.4);

      r.append('title').text(`Score ${i+1}: ${scoreText[i]} — ${ranges[i]}`);

      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 28 + 14)
        .attr('text-anchor','middle')
        .attr('font-weight', isSel ? 950 : 750)
        .attr('font-size', 13)
        .text(i+1);

      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 28 + 14 + 16)
        .attr('text-anchor','middle')
        .attr('font-weight', isSel ? 850 : 550)
        .attr('font-size', 11)
        .text(scoreText[i]);

      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 28 + boxH2 + 14)
        .attr('text-anchor','middle')
        .attr('font-size', 10)
        .text(ranges[i]);
    }

    // finalize height
    const totalHeight = scoreBandY + 28 + boxH2 + 26 + 16;
    svg.attr('height', totalHeight);
  });

  if (!container.node().children.length){
    container.append('div').attr('class','small').text('No software columns with values found.');
  }
}

/* ---------- CSV Loading ---------- */
async function loadCsvAndRender(){
  const file = (document.getElementById('csvFile').value || '').trim() || 'weekly_kpi_data.csv';
  try{
    const res = await fetch(file + '?t=' + Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    LAST_RAW = text;
    const parsed = parseTable(text);
    renderCharts(parsed);
  }catch(err){
    d3.select('#charts').html('');
    alert(`Could not load "${file}". Make sure it sits next to this HTML and that you're serving over http(s).\n\nError: ${err.message}`);
  }
}

/* ---------- Wire up UI ---------- */
function initialThresholds(){
  const ls = localStorage.getItem(LS_KEY);
  const t = parseThresholds(ls) || parseThresholds(DEFAULT_THRESH_STR);
  setThresholdsToUI(t);
}

document.addEventListener('DOMContentLoaded', ()=>{
  initialThresholds();
  // auto-load default CSV on start
  loadCsvAndRender();
});

document.getElementById('btnLoad').onclick = ()=> loadCsvAndRender();

document.getElementById('btnRenderText').onclick = ()=>{
  const text = (document.getElementById('dataIn').value || '').trim();
  if (!text){
    alert('Paste some data first.');
    return;
  }
  LAST_RAW = text;
  const parsed = parseTable(text);
  renderCharts(parsed);
};

document.getElementById('delimiter').addEventListener('change', ()=>{
  if (LAST_RAW.trim()) renderCharts(parseTable(LAST_RAW));
});
document.getElementById('btnApply').onclick = ()=>{
  if (!saveThresholdsFromUI()) return;
  if (LAST_RAW.trim()) renderCharts(parseTable(LAST_RAW));
};
document.getElementById('btnReset').onclick = ()=>{
  resetThresholds();
  if (LAST_RAW.trim()) renderCharts(parseTable(LAST_RAW));
};
</script>
</body>
</html>
