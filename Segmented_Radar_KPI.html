<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Segmented Radar KPI — Multi-Software (with Scoring)</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#111; --muted:#666; --card:#f6f7fb;
      --good:#0a9910; --ok:#ffd000; --nok:#d43b3b; --nofunc:#000000;
    }
    html,body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--ink); background:var(--bg);}
    h1{font-size:18px; margin:14px 0 8px;}
    .wrap{display:grid; grid-template-columns: 380px 1fr; gap:16px; padding:16px; align-items:start;}
    .panel{background:#f6f7fb; border-radius:14px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06);} 
    .controls{display:grid; gap:8px; grid-template-columns:minmax(0,1fr) auto auto; align-items:center; margin-bottom:8px;}
    .controls label{font-size:12px; color:var(--muted)}
    textarea{width:100%; min-height:220px; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px;}
    button{appearance:none; border:none; background:#111; color:white; padding:8px 12px; border-radius:10px; cursor:pointer}
    button.secondary{background:#e9ecf5; color:#111}
    .charts{display:grid; grid-template-columns:repeat(auto-fit,minmax(420px,1fr)); gap:16px;}
    .chart-card{background:white; border-radius:14px; padding:10px; box-shadow:0 3px 12px rgba(0,0,0,.08); position:relative}
    .download{position:absolute; left:12px; top:12px; font-size:12px; background:#f0f2f8; color:#222; padding:6px 8px; border-radius:8px; cursor:pointer}
    .small{font-size:12px; color:#666}
    .row{display:grid; gap:8px; grid-template-columns: 1fr auto auto;}
    .hint{font-size:11px; color:#555; margin-top:4px}
    input[type="text"]{width:100%; padding:8px 10px; border-radius:10px; border:1px solid #d7dcef; font-size:12px; background:#fff}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>Input (paste TSV/CSV)</h1>
      <div class="controls">
        <div>
          <label>Delimiter:</label>
          <select id="delimiter">
            <option value="auto" selected>Auto-detect</option>
            <option value=",">Comma</option>
            <option value="\t">Tab</option>
            <option value=";">Semicolon</option>
          </select>
        </div>
        <button id="btnRender">Generate charts</button>
      </div>

      <label style="font-size:12px; color:var(--muted); display:block; margin:8px 0 4px">Scoring thresholds (comma-separated; lower bounds for scores 1→10)</label>
      <div class="row" style="grid-template-columns: 1fr auto auto; align-items:center">
        <input id="scoreThresholds" type="text" spellcheck="false" />
        <button class="secondary" id="btnApply">Apply</button>
        <button class="secondary" id="btnReset">Reset defaults</button>
      </div>
      <div class="hint">Format: <code>50,30,20,15,10,7,5,2,1,0</code> means<br>
        1: ≥50 (Worst), 2: ≥30, 3: ≥20, 4: ≥15, 5: ≥10, 6: ≥7, 7: ≥5, 8: ≥2, 9: ≥1, 10: &lt;1 (including 0). The value 1000 counts in the average.</div>

      <textarea id="dataIn" spellcheck="false" placeholder="Paste data with headers:  Function — KPI,  Target,  Max allowed,  0824(TO),  0830(TO), ..."></textarea>
      <div class="small">Rules: ≤Target = <b>Green</b>, Target…(Max allowed) = <b>Yellow</b>, &gt;Max allowed = <b>Red</b>, value = 1000 = <b>Black</b>.</div>
    </div>

    <div class="panel">
      <div id="charts" class="charts"></div>
    </div>
  </div>

<script>
/* ---------- Colors & helpers ---------- */
const GREEN = '#0a9910', YELLOW = '#ffd000', RED = '#d43b3b', BLACK = '#000';
const DEFAULT_THRESH_STR = '50,30,20,15,10,7,5,2,1,0';
const LS_KEY = 'segRadarKPI.thresholds';

function colorFor(v, tgt, max){
  if (v == null || Number.isNaN(v)) return null;
  if (v === 1000) return BLACK;         // No function
  if (v <= tgt) return GREEN;           // Good
  if (v < (max + 1)) return YELLOW;     // OK (Target..Max)
  return RED;                           // NOK
}
function parseNumber(x){
  if (x==null) return null;
  const t = (""+x).trim();
  if (!t) return null;
  const v = Number(t.replace(',', '.'));
  return isNaN(v) ? null : v;
}
function detectDelimiter(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return '\t';
  const sel = document.getElementById('delimiter').value;
  if (sel !== 'auto') return sel;
  const cand = ['\t', ',', ';'];
  let best = '\t', bestCnt = 0;
  for (const d of cand){ const c = lines[0].split(d).length; if (c > bestCnt){ bestCnt = c; best = d; } }
  return best;
}
function splitFuncKpi(s){
  if (!s) return {func:'', kpi:''};
  const em = s.split('—'); if (em.length>=2) return {func:em[0].trim(), kpi:em.slice(1).join('—').trim()};
  const dash = s.split(' - '); if (dash.length>=2) return {func:dash[0].trim(), kpi:dash.slice(1).join(' - ').trim()};
  const sp = s.split(' ');
  return {func: sp[0]||'', kpi: s};
}
function normalizeHeader(h){
  if(!h) return '';
  return h.toLowerCase()
    .replace(/\u00a0/g,' ')      // NBSP → space
    .replace(/\s+/g,' ')         // collapse spaces
    .replace(/[^a-z0-9 ]/g,'')   // strip punctuation
    .trim();
}

/* ---------- Thresholds ---------- */
function parseThresholds(str){
  const arr = (str||'').split(',').map(s=>s.trim()).filter(s=>s!=='').map(Number);
  if (arr.length !== 10 || arr.some(n=>Number.isNaN(n))) return null;
  // require non-increasing order (e.g., 50 ≥ 30 ≥ ... ≥ 0)
  for (let i=1;i<arr.length;i++){
    if (arr[i] > arr[i-1]) return null;
  }
  return arr;
}
function getThresholds(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  let t = parseThresholds(ui);
  if (t) return t;
  // try localStorage
  const ls = localStorage.getItem(LS_KEY);
  t = parseThresholds(ls);
  if (t) return t;
  // defaults
  return parseThresholds(DEFAULT_THRESH_STR);
}
function setThresholdsToUI(arr){
  const s = (arr && arr.length===10) ? arr.join(',') : DEFAULT_THRESH_STR;
  document.getElementById('scoreThresholds').value = s;
}
function saveThresholdsFromUI(){
  const ui = document.getElementById('scoreThresholds').value.trim();
  const t = parseThresholds(ui);
  if (!t){
    alert('Please enter 10 comma-separated numbers in non-increasing order (e.g., '+DEFAULT_THRESH_STR+').');
    return false;
  }
  localStorage.setItem(LS_KEY, t.join(','));
  return true;
}
function resetThresholds(){
  localStorage.setItem(LS_KEY, DEFAULT_THRESH_STR);
  setThresholdsToUI(parseThresholds(DEFAULT_THRESH_STR));
}

/* ---------- Parse table ---------- */
function parseTable(text){
  const selectVal = document.getElementById('delimiter').value;
  const tryParse = (d)=> text.split(/\r?\n/)
      .filter(r=>r.trim().length>0)
      .map(r=>r.split(d));

  let delim = (selectVal==='auto') ? detectDelimiter(text) : selectVal;
  let rows = tryParse(delim);
  if (!rows.length) return {headers:[], entries:[], software:[]};

  let headers = rows[0].map(h=>h.trim());
  let norm = headers.map(normalizeHeader);
  let idxTarget = norm.findIndex(h=> h==='target');
  let idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');

  // fallback to auto if user forced wrong delimiter
  if ((idxTarget<0 || idxMax<0) && selectVal!=='auto'){
    const auto = detectDelimiter(text);
    if (auto !== delim){
      delim = auto; rows = tryParse(delim); headers = rows[0].map(h=>h.trim()); norm = headers.map(normalizeHeader);
      idxTarget = norm.findIndex(h=> h==='target');
      idxMax = norm.findIndex(h=> h==='max allowed' || h==='maxallowed');
    }
  }
  if (idxTarget<0 || idxMax<0){
    alert("Missing required columns: 'Target' and 'Max allowed'. Try Auto-detect delimiter.\nHeaders seen: " + headers.join(', '));
    return {headers, entries:[], software:[]};
  }

  // software columns (dedupe identical names like 0830(TO))
  const swCols = [];
  for (let i = idxMax+1; i < headers.length; i++){
    const base = headers[i].trim();
    const countPrev = swCols.filter(s => s.base===base).length;
    const label = countPrev ? `${base} — ${countPrev+1}` : base;
    swCols.push({idx:i, base, label: label.replace('(TO)', ' (TO)')});
  }

  const entries = [];
  for (let r=1; r<rows.length; r++){
    const row = rows[r];
    if (!row || row.length===0) continue;
    const {func, kpi} = splitFuncKpi((row[0]||'').trim());
    if (!func && !kpi) continue;
    const target = parseNumber(row[idxTarget]);
    const max = parseNumber(row[idxMax]);
    const values = {};
    for (const sw of swCols){ values[sw.label] = parseNumber(row[sw.idx]); }
    entries.push({func, kpi, target, max, values});
  }
  return {headers, entries, software: swCols.map(s=>s.label)};
}

/* ---------- Renderer ---------- */
function renderCharts(parsed){
  const T = getThresholds(); // thresholds for scoring (1..10)
  const container = d3.select('#charts').html('');
  if (!parsed || !parsed.entries || !parsed.entries.length){
    container.append('div').attr('class','small').text('No data to render.');
    return;
  }

  (parsed.software||[]).forEach(swLabel=>{
    // Only render chart if this software has at least one numeric value
    const hasAny = parsed.entries.some(e => e.values[swLabel]!=null && !Number.isNaN(e.values[swLabel]));
    if (!hasAny) return;

    const card = container.append('div').attr('class','chart-card');

    // Download button
    card.append('button').attr('class','download').text('Download PNG').on('click',()=>{
      const svg = card.select('svg').node();
      const url = URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(svg)], {type:'image/svg+xml'}));
      const img = new Image();
      const w = svg.viewBox.baseVal && svg.viewBox.baseVal.width ? svg.viewBox.baseVal.width : svg.width.baseVal.value;
      const h = svg.viewBox.baseVal && svg.viewBox.baseVal.height ? svg.viewBox.baseVal.height : svg.height.baseVal.value;
      img.onload = ()=>{
        const canvas = document.createElement('canvas'); canvas.width=w; canvas.height=h;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
        ctx.drawImage(img,0,0);
        const a=document.createElement('a'); a.download = `${swLabel.replaceAll(' ','_')}.png`; a.href = canvas.toDataURL('image/png'); a.click();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    /* --- Layout: reserve space for legend on the right, and scoring band below --- */
    const w = 600, baseH = 560, scoreH = 110, h = baseH + scoreH;
    const legW = 160, legPad = 8, legItemH = 18;
    const centerX = (w - (legW + 12)) / 2;
    const centerY = baseH / 2;
    const rMax = Math.min(centerX, centerY) - 16;

    const svg = card.append('svg').attr('width', w).attr('height', h);
    const g = svg.append('g').attr('transform', `translate(${centerX},${centerY})`);

    // Title inside SVG (exports)
    svg.append('text')
      .attr('x', w/2).attr('y', 20)
      .attr('text-anchor', 'middle').attr('font-weight', 700)
      .text(swLabel);

    // SVG Legend (exports)
    const legendItems = [
      {label:'Green = Good',  color: GREEN},
      {label:'Yellow = OK',   color: YELLOW},
      {label:'Red = NOK',     color: RED},
      {label:'Black = No function', color: BLACK},
    ];
    const legendG = svg.append('g')
      .attr('class','svg-legend')
      .attr('transform', `translate(${w - legW - 12}, 32)`);
    legendG.append('rect')
      .attr('rx',8).attr('ry',8)
      .attr('width', legW)
      .attr('height', legPad*2 + legItemH*legendItems.length)
      .attr('fill', '#ffffff').attr('fill-opacity', 0.85)
      .attr('stroke', 'none');
    legendItems.forEach((it, i)=>{
      const y = legPad + i*legItemH + 12;
      legendG.append('rect').attr('x', legPad).attr('y', y-7)
        .attr('width',12).attr('height',12).attr('fill', it.color);
      legendG.append('text').attr('x', legPad+18).attr('y', y)
        .attr('dominant-baseline','middle').attr('font-size', 12)
        .text(it.label);
    });

    // Functions for THIS software (skip functions with no values)
    const functions = [];
    parsed.entries.forEach(e=>{
      const v = e.values[swLabel];
      if (v!=null && !Number.isNaN(v) && !functions.includes(e.func)) functions.push(e.func);
    });
    if (!functions.length){
      card.append('div').attr('class','small').text('No KPI values for this software.');
      return;
    }

    // Piecewise radius: 0–10 linear, 10–1000 log
    const linearPortion = 0.55;             // fraction of radius
    const rLinear = rMax * linearPortion;
    const logMin = 10, logMax = 1000;
    const logDen = Math.log10(logMax) - Math.log10(logMin);
    function toR(v){
      if (v==null || Number.isNaN(v)) return null;
      if (v <= 0) return 0;
      const vv = Math.min(v, logMax);
      if (vv < logMin) return (vv / logMin) * rLinear;
      return rLinear + ((Math.log10(vv) - Math.log10(logMin)) / logDen) * (rMax - rLinear);
    }

    // Grid rings & labels (1..10 plus 30, 100, 300, 1000)
    const ringGrid = [1,2,3,4,5,6,7,8,9,10,30,100,300,1000];
    g.selectAll('.ring').data(ringGrid).enter().append('circle')
      .attr('class','ring')
      .attr('r', d=>toR(d))
      .attr('fill','none')
      .attr('stroke','#999')
      .attr('stroke-opacity',0.22);
    g.selectAll('.rlabel').data(ringGrid).enter().append('text')
      .attr('class','rlabel')
      .attr('x', 6)
      .attr('y', d=> -toR(d))
      .attr('dominant-baseline','middle')
      .attr('font-size', 11)
      .attr('fill', '#666')
      .text(d=>d);

    // Axis label
    const axisY = -rMax * 0.70;
    g.append('text')
      .attr('x', -8)
      .attr('y', axisY)
      .attr('transform', `rotate(-90, 0, ${axisY})`)
      .attr('text-anchor','end')
      .attr('font-size', 11)
      .text('Number of events');

    // Segment backgrounds + boundaries + function labels
    const F = functions.length;
    const wedge = (Math.PI*2) / F;
    const innerFrac = 0.98;
    const spread = wedge * innerFrac;

    const arc = d3.arc();
    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const end = start + wedge;
      // subtle background
      g.append('path')
        .attr('d', arc({innerRadius:0, outerRadius:rMax, startAngle:start, endAngle:end}))
        .attr('fill', idx % 2 ? '#f6f7fb' : '#eef2ff')
        .attr('fill-opacity', 0.06)
        .attr('stroke', 'none');
      // boundary
      g.append('line')
        .attr('x1',0).attr('y1',0)
        .attr('x2', Math.cos(start)*rMax)
        .attr('y2', Math.sin(start)*rMax)
        .attr('stroke','#000').attr('stroke-opacity',0.25);
      // function label (blue)
      const cen = (start + end) / 2;
      g.append('text')
        .attr('x', Math.cos(cen)*(rMax+16))
        .attr('y', Math.sin(cen)*(rMax+16))
        .attr('text-anchor','middle')
        .attr('font-weight',700)
        .attr('fill','#1f3de3')
        .text(f);
    });

    // Per-function KPI dots (spread + collision avoidance + black-dot avoidance)
    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const center = start + wedge/2;

      const items = parsed.entries.filter(e=>e.func===f);
      const K = items.length;
      const avail = spread * 0.96;
      const baseOffs = (K===1) ? [0] : d3.range(K).map(i => (i-(K-1)/2)/(K-1) * (avail/2));

      const placed = [];
      const minSep = wedge * 0.09;
      const radBin = rMax * 0.12;
      const labelAvoid = wedge * 0.18;

      items.forEach((e, i)=>{
        const v = e.values[swLabel]; if (v==null || Number.isNaN(v)) return;
        let r = toR(v);
        let ang = center + baseOffs[i];
        const isBlack = (v === 1000);

        if (isBlack && Math.abs(ang - center) < labelAvoid){
          const dir = (ang >= center) ? 1 : -1;
          ang = center + dir * (labelAvoid + wedge*0.02);
        }
        ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));

        // collision resolution
        {
          let tries = 0;
          while (placed.some(p => Math.abs(p.ang - ang) < minSep && Math.abs(p.r - r) < radBin) && tries < 120){
            const dir = (tries % 2 === 0) ? 1 : -1;
            ang += dir * (minSep * 0.65);
            ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
            tries++;
          }
          if (tries >= 120){
            r = Math.min(r + 8, rMax * 0.98); // last-resort radial nudge
          }
        }
        placed.push({ang, r});

        const cx = Math.cos(ang)*r, cy = Math.sin(ang)*r;
        const fill = colorFor(v, e.target, e.max);
        if (!fill) return;

        // dot (smaller)
        g.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 10).attr('fill', fill)
          .append('title').text(`${f} — ${e.kpi}: ${v}`);

        // label above dot
        const rLabel = Math.min(r + 18, rMax * 0.98);
        const lx = Math.cos(ang)*rLabel, ly = Math.sin(ang)*rLabel;
        g.append('text')
          .attr('x', lx).attr('y', ly)
          .attr('text-anchor','middle')
          .attr('font-size', 11)
          .attr('paint-order', 'stroke')
          .attr('stroke', 'white').attr('stroke-width', 3)
          .text(e.kpi);
      });
    });

    // ---- Scoring band (inside SVG so it exports) ----
    const valuesForAvg = parsed.entries
      .map(e => e.values[swLabel])
      .filter(v => v != null && !Number.isNaN(v));
    const avgEvents = valuesForAvg.length ? d3.mean(valuesForAvg.map(v => Math.min(v, 1000))) : null;

    function scoreFromAvg(a, thresholds){
      if (a == null || Number.isNaN(a)) return null;
      // thresholds = [t1, t2, ..., t10] non-increasing; score i if a >= t_i (for i=1..9); score 10 if a < t9 (or a===0)
      if (a === 0) return 10; // Explicit: 0 = Exceptional
      for (let i=0;i<9;i++){ if (a >= thresholds[i]) return i+1; }
      // if 0 < a < thresholds[8] (typically 1), we treat as 10 to mirror your earlier intention
      return 10;
    }

    const scoreColors = ['#e60000','#ff1e1e','#ff6a00','#ffa000','#ffe07a','#ffff33','#9acd32','#66bb6a','#00a878','#2e7d32'];
    const scoreText   = ['Worst','Too bad','Bad','Not good','Unacceptable','Marginal','Acceptable','Good','Impressive','Exceptional'];
    const score = avgEvents==null ? null : scoreFromAvg(avgEvents, T);

    const scoreG = svg.append('g').attr('class','score-band').attr('transform', `translate(0, ${baseH})`);
    const barMargin = 20, barH = 42;
    const barW = w - barMargin*2;
    const boxW = barW / 10;

    const caption = (avgEvents==null)
      ? 'Average: n/a (only "No function" or missing values)'
      : `Average: ${avgEvents.toFixed(1)} events → Score: ${score} (${scoreText[score-1]})`;
    scoreG.append('text')
      .attr('x', barMargin)
      .attr('y', 12)
      .attr('font-size', 12)
      .text(caption);

    for (let i=0;i<10;i++){
      const x = barMargin + i*boxW;
      scoreG.append('rect')
        .attr('x', x).attr('y', 20)
        .attr('width', boxW).attr('height', barH)
        .attr('fill', scoreColors[i])
        .attr('stroke', (score === i+1) ? '#000' : '#111')
        .attr('stroke-width', (score === i+1) ? 2 : 0.4);
      // number
      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 20 + 14)
        .attr('text-anchor','middle')
        .attr('font-weight',700)
        .attr('font-size', 12)
        .text(i+1);
      // label
      scoreG.append('text')
        .attr('x', x + boxW/2).attr('y', 20 + 14 + 16)
        .attr('text-anchor','middle')
        .attr('font-size', 10)
        .text(scoreText[i]);
    }

    // Optional: show the current thresholds as a tiny note (not exported)
    card.append('div').attr('class','small').style('margin-top','6px')
      .text('Scoring thresholds (1→10): '+T.join(', '));
  });

  if (!container.node().children.length){
    container.append('div').attr('class','small').text('No software columns with values found.');
  }
}

/* ---------- Wire up UI ---------- */
function initialThresholds(){
  const ls = localStorage.getItem(LS_KEY);
  const t = parseThresholds(ls) || parseThresholds(DEFAULT_THRESH_STR);
  setThresholdsToUI(t);
}
initialThresholds();

document.getElementById('btnRender').onclick = ()=>{
  const parsed = parseTable(document.getElementById('dataIn').value);
  renderCharts(parsed);
};
document.getElementById('btnApply').onclick = ()=>{
  if (!saveThresholdsFromUI()) return;
  // re-render with current data if any
  const parsed = parseTable(document.getElementById('dataIn').value);
  renderCharts(parsed);
};
document.getElementById('btnReset').onclick = ()=>{
  resetThresholds();
  // re-render with current data if any
  const parsed = parseTable(document.getElementById('dataIn').value);
  renderCharts(parsed);
};
</script>
</body>
</html>
