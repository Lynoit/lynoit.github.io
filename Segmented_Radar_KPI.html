<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KPI Scoring Visualizer</title>
  <!-- Prevent favicon 404 -->
  <link rel="icon" href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'/%3e">
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{
      --bg:#ffffff; --ink:#111; --muted:#666; --card:#f6f7fb;
    }
    html,body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--ink); background:var(--bg);}
    .container{padding:16px;}
    .charts{display:grid; grid-template-columns:repeat(auto-fit,minmax(680px,1fr)); gap:16px;}
    .panel{background:#f6f7fb; border-radius:14px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06);}
    .chart-card{background:white; border-radius:14px; padding:10px; box-shadow:0 3px 12px rgba(0,0,0,.08); position:relative}
    .summary-card{ grid-column: 1 / -1; display:grid; justify-content:center; }
    .download{position:absolute; left:12px; top:12px; font-size:12px; background:#f0f2f8; color:#222; padding:6px 8px; border-radius:8px; cursor:pointer}
    .small{font-size:12px; color:#666}
    .link{ color:#1f3de3; text-decoration:underline; cursor:pointer; }

    /* Summary table */
    .summary-title{font-weight:700; font-size:16px; margin:4px 0 8px 0; text-align:center}
    .summary-table{ display:inline-table; margin:6px 0 10px; table-layout:auto; border-collapse:separate; border-spacing:0; font-size:12px; }
    .summary-table th, .summary-table td{ padding:8px 10px; text-align:left; border-bottom:1px solid #eef1fb; vertical-align:middle; }
    .summary-table th{ background:#f6f7fb; font-weight:700; }
    .summary-table th:nth-child(2), .summary-table td:nth-child(2){ text-align:center; white-space:nowrap; }
    .summary-table th:nth-child(3), .summary-table td:nth-child(3){ text-align:right; white-space:nowrap; }
    .summary-table th:nth-child(4), .summary-table td:nth-child(4){ text-align:center; white-space:nowrap; width:1%; }
    .summary-table th:nth-child(5), .summary-table td:nth-child(5){ white-space:nowrap; }
    .summary-table th:nth-child(6), .summary-table td:nth-child(6){ text-align:center; white-space:nowrap; }
    .software-cell{ display:inline-block; max-width:min(52vw, 680px); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; vertical-align:bottom; }
    .summary-chip{ display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #e9ecf5; font-weight:600; }

    /* Modal */
    .modal-backdrop{ position:fixed; inset:0; background:rgba(0,0,0,.45); display:none; align-items:center; justify-content:center; z-index:1000; }
    .modal{ background:#fff; color:#111; border-radius:12px; box-shadow:0 20px 70px rgba(0,0,0,.35);
      width:min(760px, 92vw); max-height:80vh; overflow:auto; padding:16px 16px 8px; }
    .modal header{ display:flex; align-items:center; justify-content:space-between; gap:12px; }
    .modal h2{ margin:0; font-size:16px; }
    .modal .close{ background:#e9ecf5; color:#111; border:none; border-radius:10px; padding:6px 10px; cursor:pointer; }
    .modal .content{ margin:12px 2px 8px; }
    .modal .content ul{ margin:0; padding-left:18px; }
    .modal .content li{ margin:6px 0; line-height:1.35; }
    .modal .empty{ color:#666; font-style:italic; }
  </style>
</head>
<body>
  <div class="container">
    <div class="panel">
      <div id="charts" class="charts"></div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modalBackdrop" class="modal-backdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <header>
        <h2 id="modalTitle">Release Note</h2>
        <button class="close" id="modalClose" aria-label="Close">Close</button>
      </header>
      <div class="content" id="modalContent"></div>
    </div>
  </div>

<script>
/* ==================== CONFIG ==================== */
// Main KPI CSV (Excel export) — file must sit next to this HTML
const DATA_CSV = 'weekly_kpi_data.csv';

/*
  Release-note CSV fetching:
  'auto'     → try <software base>.csv for every software (one bullet per line). Missing files just get ignored.
  'manifest' → only fetch files listed in release_notes_manifest.json (avoids 404 noise).
  'off'      → never fetch file-based notes. (Inline "Release note" row in DATA_CSV still works.)
*/
const RN_FETCH_MODE = 'auto';
const RN_MANIFEST_FILE = 'release_notes_manifest.json'; // used only if RN_FETCH_MODE === 'manifest'

/*
  Scoring thresholds — lower bounds for scores 1→10. If you want to hard-wire your own, set SCORE_THRESHOLDS to a 10-number array.
  By default we read from localStorage (key below) or fall back to DEFAULT_THRESH_STR.
*/
const DEFAULT_THRESH_STR = '100,60,40,30,20,15,10,5,3,2';
const SCORE_THRESHOLDS = null; // e.g., [100,60,40,30,20,15,10,5,3,2]
const LS_KEY = 'segRadarKPI.thresholds';

/* ==================== Helpers & Scoring ==================== */
const GREEN = '#0a9910', YELLOW = '#ffd000', RED = '#d43b3b', BLACK = '#000';
const scoreColors = ['#e60000','#ff1e1e','#ff6a00','#ffa000','#ffe07a','#ffff33','#9acd32','#66bb6a','#00a878','#2e7d32'];
const scoreText   = ['Worst','Too bad','Bad','Not good','Unacceptable','Marginal','Acceptable','Good','Impressive','Exceptional'];
let LAST_RAW = '';

const fmtCell = v =>
  (v==null || Number.isNaN(v)) ? '—'
  : (Number.isInteger(v) ? String(v)
  : String(parseFloat(v.toFixed(2)).replace(/\.00$/,'')));

function parseThresholds(str){
  const arr = (str||'').split(',').map(s=>s.trim()).filter(s=>s!=='').map(Number);
  if (arr.length !== 10 || arr.some(n=>Number.isNaN(n))) return null;
  for (let i=1;i<arr.length;i++){ if (arr[i] > arr[i-1]) return null; }
  return arr;
}
function getThresholds(){
  if (Array.isArray(SCORE_THRESHOLDS) && SCORE_THRESHOLDS.length===10) return SCORE_THRESHOLDS;
  const ls = localStorage.getItem(LS_KEY);
  let t = parseThresholds(ls);
  if (t) return t;
  return parseThresholds(DEFAULT_THRESH_STR);
}
const fmtNum = n => Number.isInteger(n) ? String(n) : String(parseFloat(n.toFixed(2)));
function scoreRangeLabels(T){
  const lab = [];
  for (let i=0;i<9;i++) lab.push('≥ ' + fmtNum(T[i]));
  lab.push('< ' + fmtNum(T[8]) + (T[9] === 0 ? ' (incl. 0)' : ''));
  return lab;
}
function scoreFromAvg(a, thresholds){
  if (a == null || Number.isNaN(a)) return null;
  if (a === 0) return 10;
  for (let i=0;i<9;i++){ if (a >= thresholds[i]) return i+1; }
  return 10;
}
function colorFor(v, tgt, max){
  if (v == null || Number.isNaN(v)) return null;
  if (v === 1000) return BLACK;
  if (v <= tgt) return GREEN;
  if (v < (max + 1)) return YELLOW;
  return RED;
}
function parseNumber(x){
  if (x==null) return null;
  const t = (""+x).trim();
  if (!t) return null;
  const v = Number(t.replace(',', '.'));
  return isNaN(v) ? null : v;
}
function detectDelimiter(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return '\t';
  const cand = ['\t', ',', ';'];
  let best = '\t', bestCnt = 0;
  for (const d of cand){ const c = lines[0].split(d).length; if (c > bestCnt){ bestCnt = c; best = d; } }
  return best;
}
function splitFuncKpi(s){
  if (!s) return {func:'', kpi:''};
  const em = s.split('—'); if (em.length>=2) return {func:em[0].trim(), kpi:em.slice(1).join('—').trim()};
  const dash = s.split(' - '); if (dash.length>=2) return {func:dash[0].trim(), kpi:dash.slice(1).join(' - ').trim()};
  const sp = s.split(' ');
  return {func: sp[0]||'', kpi: s};
}
function normalizeHeader(h){
  if(!h) return '';
  return h.toLowerCase().replace(/\u00a0/g,' ').replace(/\s+/g,' ').replace(/[^a-z0-9 ]/g,'').trim();
}

/* ==================== Parse table (dates + inline "Release note") ==================== */
function parseTable(text){
  const tryParse = (d)=> text
    .split(/\r?\n/)
    .filter(r => r.trim().length > 0)
    .map(r => r.split(d));

  let delim = detectDelimiter(text);
  let rows = tryParse(delim);
  if (!rows.length) return { headers: [], entries: [], software: [], releaseNotes: {} };

  let headers = rows[0].map(h => h.trim());

  // Auto-insert missing first header cell if needed
  if (rows.length > 1 && rows[1].length === headers.length + 1) {
    const firstCell = (rows[1][0] || '').trim();
    const looksText = parseNumber(firstCell) == null;
    const normH = headers.map(normalizeHeader);
    const hasTarget = normH.includes('target');
    const hasMax = normH.includes('max allowed') || normH.includes('maxallowed');
    if (looksText && hasTarget && hasMax) headers = ['Function — KPI', ...headers];
  }

  let norm = headers.map(normalizeHeader);
  let idxTarget = norm.findIndex(h => h === 'target');
  let idxMax    = norm.findIndex(h => (h === 'max allowed' || h === 'maxallowed'));

  if (idxTarget < 0 || idxMax < 0) {
    alert("Missing required columns: 'Target' and 'Max allowed'.\nHeaders seen: " + headers.join(', '));
    return { headers, entries: [], software: [], releaseNotes: {} };
  }

  // Software columns (strip optional [YYYY-MM-DD])
  const swCols = [];
  for (let i = idxMax + 1; i < headers.length; i++) {
    const raw = headers[i].trim();
    const m = raw.match(/\[(\d{4}-\d{2}-\d{2})\]\s*$/);
    const date = m ? m[1] : null;
    const baseNoDate = m ? raw.replace(/\s*\[\d{4}-\d{2}-\d{2}\]\s*$/, '') : raw;
    const basePretty = baseNoDate.replace('(TO)', ' (TO)');
    const countPrev = swCols.filter(s => s.base === basePretty).length;
    const label = countPrev ? `${basePretty} — ${countPrev + 1}` : basePretty;
    swCols.push({ idx: i, base: basePretty, label, date });
  }

  const releaseNotes = {};
  const entries = [];

  for (let r = 1; r < rows.length; r++) {
    const row = rows[r];
    if (!row || row.length === 0) continue;

    const firstCellRaw = (row[0] || '').trim();
    const firstNorm = normalizeHeader(firstCellRaw);

    if (firstNorm === 'releasenote' || firstCellRaw.toLowerCase() === 'release note') {
      // Inline style: collect notes in matching software columns (bullets separated by literal \n)
      for (const sw of swCols) {
        const raw = (row[sw.idx] ?? '').trim();
        if (raw) {
          releaseNotes[sw.label] = (releaseNotes[sw.label] ? (releaseNotes[sw.label] + '\\n' + raw) : raw);
        }
      }
      continue;
    }

    const { func, kpi } = splitFuncKpi(firstCellRaw);
    const target = parseNumber(row[idxTarget]);
    const max    = parseNumber(row[idxMax]);

    const values = {};
    for (const sw of swCols) values[sw.label] = parseNumber(row[sw.idx]);

    entries.push({ func, kpi, target, max, values });
  }

  return { headers, entries, software: swCols, releaseNotes };
}

/* ==================== Modal ==================== */
function openReleaseNoteModal(title, noteText){
  const backdrop = document.getElementById('modalBackdrop');
  const titleEl  = document.getElementById('modalTitle');
  const content  = document.getElementById('modalContent');

  titleEl.textContent = title || 'Release Note';

  const parts = String(noteText || '')
    .replace(/\r/g,'')
    .split(/\\n|\n/g)
    .map(s => s.trim())
    .filter(s => s.length);

  content.innerHTML = '';
  if (parts.length === 0){
    const p = document.createElement('p'); p.className = 'empty'; p.textContent = 'No release note provided.'; content.appendChild(p);
  } else {
    const ul = document.createElement('ul');
    parts.forEach(t => { const li = document.createElement('li'); li.textContent = t; ul.appendChild(li); });
    content.appendChild(ul);
  }

  backdrop.style.display = 'flex';
  backdrop.setAttribute('aria-hidden', 'false');
}
function closeReleaseNoteModal(){
  const backdrop = document.getElementById('modalBackdrop');
  backdrop.style.display = 'none';
  backdrop.setAttribute('aria-hidden', 'true');
}
document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeReleaseNoteModal(); });
document.getElementById('modalBackdrop').addEventListener('click', (e)=>{ if (e.target.id === 'modalBackdrop') closeReleaseNoteModal(); });
document.getElementById('modalClose').addEventListener('click', closeReleaseNoteModal);

/* ==================== Release-note files ==================== */
async function readTextOrNull(path){
  try{
    const res = await fetch(encodeURI(path) + '?t=' + Date.now(), {cache:'no-store'});
    if (!res.ok) return null;
    return await res.text();
  }catch{ return null; }
}
async function loadReleaseNotesManifest(){
  if (RN_FETCH_MODE !== 'manifest') return null;
  try{
    const res = await fetch(RN_MANIFEST_FILE + '?t=' + Date.now(), {cache:'no-store'});
    if (!res.ok) return null;
    const list = await res.json();
    if (!Array.isArray(list)) return null;
    return new Set(list.map(s => String(s).toLowerCase()));
  }catch{ return null; }
}
// Loads "<base>.csv" for each software (base = header without date). One bullet per line.
async function loadReleaseNotesFromFiles(swCols, manifestSet){
  if (RN_FETCH_MODE === 'off') return {};
  const out = {};
  for (const sw of (swCols||[])){
    const file = `${sw.base}.csv`;
    if (RN_FETCH_MODE === 'manifest' && (!manifestSet || !manifestSet.has(file.toLowerCase()))) continue;
    const txt = await readTextOrNull(file);
    if (!txt) continue;
    const lines = txt.replace(/\r/g,'').split('\n').map(s=>s.trim()).filter(Boolean);
    if (lines.length){
      const joined = lines.join('\n'); // real newlines; modal handles both \n and \\n inputs
      out[sw.label] = (out[sw.label] ? (out[sw.label] + '\n' + joined) : joined);
    }
  }
  return out;
}

/* ==================== Summary ==================== */
function renderSummary(container, parsed){
  const T = getThresholds();
  if (!parsed || !parsed.software || !parsed.software.length) return;

  const rowsRaw = parsed.software.map(sw => {
    const swLabel = sw.label;
    const vals = parsed.entries.map(e => e.values[swLabel]).filter(v => v != null && !Number.isNaN(v));
    const avg = vals.length ? d3.mean(vals.map(v => Math.min(v, 1000))) : null;
    const score = avg == null ? null : scoreFromAvg(avg, T);
    return {
      sw: swLabel,
      date: sw.date,
      avg,
      score,
      text: score == null ? 'n/a' : scoreText[score - 1],
      note: (parsed.releaseNotes?.[swLabel] || '').trim()
    };
  });

  const hasAnyNotes = rowsRaw.some(r => r.note.length > 0);

  const rows = rowsRaw.slice().sort((a,b)=>{
    const sa = a.score ?? -1, sb = b.score ?? -1;
    if (sa !== sb) return sb - sa;
    if (a.avg == null && b.avg == null) return 0;
    if (a.avg == null) return 1;
    if (b.avg == null) return -1;
    return a.avg - b.avg;
  });

  const chartData = rows.filter(r => r.avg != null);
  if (!rows.length) return;

  const card = container.append('div').attr('class', 'chart-card summary-card');
  card.append('div').attr('class','summary-title').text('Summary Weekly KPI');

  // Table
  const table = card.append('table').attr('class', 'summary-table');
  const colgroup = hasAnyNotes
    ? `<col class="col-sw"><col class="col-date"><col class="col-avg"><col class="col-score"><col class="col-rating"><col class="col-note">`
    : `<col class="col-sw"><col class="col-date"><col class="col-avg"><col class="col-score"><col class="col-rating">`;
  table.append('colgroup').html(colgroup);

  const thead = table.append('thead').append('tr');
  thead.html(
    hasAnyNotes
      ? `<th>Software</th><th>Test date</th><th>Average events per 1000 km</th><th>Score</th><th>Rating</th><th>Release Note</th>`
      : `<th>Software</th><th>Test date</th><th>Average events per 1000 km</th><th>Score</th><th>Rating</th>`
  );

  const tbody = table.append('tbody');
  rows.forEach(r=>{
    const tr = tbody.append('tr');
    tr.append('td').append('span').attr('class','software-cell').attr('title', r.sw).text(r.sw);
    tr.append('td').text(r.date || '—');
    tr.append('td').text(r.avg == null ? '—' : r.avg.toFixed(1));

    const scoreCell = tr.append('td');
    if (r.score == null){
      scoreCell.text('—'); tr.append('td').text('n/a');
    } else {
      scoreCell.append('span')
        .attr('class', 'summary-chip')
        .attr('style', `background:${scoreColors[r.score-1]}22; border-color:${scoreColors[r.score-1]}66; color:#111`)
        .text(r.score);
      tr.append('td').text(r.text);
    }

    if (hasAnyNotes){
      const tdNote = tr.append('td');
      if (r.note){
        const a = tdNote.append('span').attr('class','link').text('Release Note');
        a.on('click', ()=> openReleaseNoteModal(`${r.sw}${r.date ? ' — ' + r.date : ''}`, r.note));
      } else {
        tdNote.text('');
      }
    }
  });

  // Bars
  if (chartData.length){
    card.append('div').attr('class','small').style('margin','8px 0 4px').text('Average events per 1000 km (bar color = score)');

    const yLabels = chartData.map(d => d.date ? `${d.sw}  (${d.date})` : d.sw);
    const measureTextWidth = (texts, fontSize=12, fontWeight=400)=>{
      const tmp = d3.select('body').append('svg').attr('width',0).attr('height',0).style('position','absolute').style('left','-9999px').style('top','-9999px');
      let max = 0;
      texts.forEach(t=>{
        const node = tmp.append('text').attr('font-size', fontSize).attr('font-weight', fontWeight).text(t==null ? '' : String(t)).node();
        max = Math.max(max, node.getComputedTextLength());
      });
      tmp.remove(); return max;
    };

    const labelW = Math.ceil(measureTextWidth(yLabels, 12, 400));
    const cardW = Math.max(0, Math.ceil(card.node().getBoundingClientRect().width) - 20);
    const cw = Math.max(560, Math.min(1000, cardW));
    const leftPad = Math.min(Math.floor(cw * 0.48), Math.max(160, labelW + 14));
    const rightPad = 16, topPad = 8, barH = 22, gap = 6;

    const svg = card.append('svg').style('display','block').style('margin','0 auto 6px').attr('width', cw).attr('height', topPad + chartData.length * (barH + gap) + 34);
    const g = svg.append('g').attr('transform', `translate(0, ${topPad})`);

    const maxAvg = d3.max(chartData, d => Math.min(1000, d.avg));
    const x = d3.scaleLinear().domain([0, Math.max(1, maxAvg)]).range([leftPad, cw - rightPad]);

    chartData.forEach((d,i)=> d._y = i * (barH + gap));

    g.selectAll('.ylabel').data(chartData).enter().append('text')
      .attr('class','ylabel').attr('x', leftPad - 10).attr('y', d => d._y + barH/2)
      .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 12)
      .text((d,i)=> yLabels[i]).append('title').text(d => d.sw);

    g.selectAll('.bar').data(chartData).enter().append('rect')
      .attr('class','bar').attr('x', x(0)).attr('y', d => d._y)
      .attr('width', d => x(Math.min(1000, d.avg)) - x(0)).attr('height', barH)
      .attr('fill', d => scoreColors[(d.score || 10) - 1]).attr('fill-opacity', 0.9)
      .append('title').text(d => `Score ${d.score}: ${d.text} — ${d.avg.toFixed(1)} /1000km`);

    g.selectAll('.val').data(chartData).enter().append('text')
      .attr('x', d => x(Math.min(1000, d.avg)) + 6).attr('y', d => d._y + barH/2)
      .attr('dominant-baseline','middle').attr('font-size', 12).text(d => d.avg.toFixed(1));

    const axisY = chartData.length * (barH + gap);
    g.append('g').attr('transform', `translate(0, ${axisY})`).call(d3.axisBottom(x).ticks(6));
  }

  // Scoring legend
  const ranges = scoreRangeLabels(T);
  const legCw = Math.max(560, Math.min(1000, Math.max(0, Math.ceil(card.node().getBoundingClientRect().width) - 20)));
  const legend = card.append('svg').style('display','block').style('margin','6px auto 2px').attr('width', legCw);
  const bandMargin = 20, boxH = 42;
  const barW = legCw - bandMargin*2, boxW = barW / 10;
  legend.append('text').attr('x', 12).attr('y', 12).attr('font-size', 12).attr('fill', '#555').text('Scoring legend (1 = worst, 10 = best)');
  for (let i=0;i<10;i++){
    const x0 = bandMargin + i*boxW; const gBox = legend.append('g');
    gBox.append('rect').attr('x', x0).attr('y', 20).attr('width', boxW).attr('height', boxH).attr('fill', scoreColors[i]).attr('stroke', '#111').attr('stroke-width', 0.4)
      .append('title').text(`Score ${i+1}: ${scoreText[i]} — ${ranges[i]}`);
    gBox.append('text').attr('x', x0 + boxW/2).attr('y', 20 + 14).attr('text-anchor','middle').attr('font-weight', 800).attr('font-size', 13).text(i+1);
    gBox.append('text').attr('x', x0 + boxW/2).attr('y', 20 + 14 + 16).attr('text-anchor','middle').attr('font-size', 11).text(scoreText[i]);
    gBox.append('text').attr('x', x0 + boxW/2).attr('y', 20 + boxH + 14).attr('text-anchor','middle').attr('font-size', 10).text(ranges[i]);
  }
  legend.attr('height', 20 + boxH + 28 + 6);
}

/* ==================== Per-software cards ==================== */
function renderSoftwareCards(container, parsed){
  const T = getThresholds();
  (parsed.software||[]).forEach(sw=>{
    const swLabel = sw.label;
    const hasAny = parsed.entries.some(e => e.values[swLabel]!=null && !Number.isNaN(e.values[swLabel]));
    if (!hasAny) return;

    const card = container.append('div').attr('class','chart-card');
    const w = 680;

    // Download PNG
    card.append('button').attr('class','download').text('Download PNG').on('click',()=>{
      const svg = card.select('svg').node();
      const url = URL.createObjectURL(new Blob([new XMLSerializer().serializeToString(svg)], {type:'image/svg+xml'}));
      const img = new Image();
      const W = svg.viewBox?.baseVal?.width || svg.width.baseVal.value;
      const H = svg.viewBox?.baseVal?.height || svg.height.baseVal.value;
      img.onload = ()=>{
        const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
        ctx.drawImage(img,0,0);
        const a=document.createElement('a'); a.download = `${swLabel.replaceAll(' ','_')}.png`; a.href = canvas.toDataURL('image/png'); a.click();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    // Layout constants
    const radarH = 540;
    const scoreTopPad = 28;
    const rowH = 22, headerH = 24, tableSidePad = 12, colGap = 8;
    const TITLE_Y = 26, TITLE_TO_RADAR_GAP = 50, RADAR_PAD_LEFT = 30, MIN_SIDE_MARGIN = 8, FUNC_LABEL_OFFSET = 16;

    const svg = card.append('svg').attr('width', w);

    // Title (include test date when available)
    const titleText = sw.date ? `${swLabel}. ${sw.date}` : swLabel;
    svg.append('text')
      .attr('x', w/2)
      .attr('y', TITLE_Y)
      .attr('text-anchor','middle')
      .attr('font-weight',700)
      .text(titleText);

    // Legend (top-right)
    const legendItems = [
      {label:'Green = Good',  color: GREEN},
      {label:'Yellow = OK',   color: YELLOW},
      {label:'Red = NOK',     color: RED},
      {label:'Black = No function', color: BLACK},
    ];
    const legendG = svg.append('g').attr('class','legend');
    legendItems.forEach((it, i)=>{
      const y = 8 + i*18 + 12;
      legendG.append('rect').attr('x',8).attr('y',y-7).attr('width',12).attr('height',12).attr('fill',it.color);
      legendG.append('text').attr('x',26).attr('y',y).attr('dominant-baseline','middle').attr('font-size',12).text(it.label);
    });
    const pad = 8;
    const lb = legendG.node().getBBox();
    const legW = Math.ceil(lb.width) + pad*2;
    const legH = Math.ceil(lb.height) + pad*2;
    legendG.insert('rect',':first-child')
      .attr('x', lb.x - pad).attr('y', lb.y - pad)
      .attr('rx',8).attr('ry',8)
      .attr('width', legW).attr('height', legH)
      .attr('fill','#ffffff').attr('fill-opacity',0.85);
    legendG.attr('transform', `translate(${w - legW - 12}, 32)`);

    // Radar geometry
    const leftAreaWidth = w - legW - 12;
    const radarTop = TITLE_Y + TITLE_TO_RADAR_GAP;
    const availableW = Math.max(120, leftAreaWidth - RADAR_PAD_LEFT - MIN_SIDE_MARGIN);
    const centerX = RADAR_PAD_LEFT + availableW / 2;
    const rMaxCandidateW = Math.max(10, availableW/2 - FUNC_LABEL_OFFSET);
    const rMaxCandidateH = (radarH - radarTop) - 16;
    const rMax = Math.max(80, Math.min(rMaxCandidateW, rMaxCandidateH));
    const centerY = radarTop + rMax;

    const g = svg.append('g').attr('transform', `translate(${centerX},${centerY})`);

    const functions = [];
    parsed.entries.forEach(e=>{
      const v = e.values[swLabel];
      if (v!=null && !Number.isNaN(v) && !functions.includes(e.func)) functions.push(e.func);
    });
    if (!functions.length){
      card.append('div').attr('class','small').text('No KPI values for this software.');
      return;
    }

    const linearPortion = 0.55;
    const rLinear = rMax * linearPortion;
    const logMin = 10, logMax = 1000;
    const logDen = Math.log10(logMax) - Math.log10(logMin);
    function toR(v){
      if (v==null || Number.isNaN(v)) return null;
      if (v <= 0) return 0;
      const vv = Math.min(v, logMax);
      if (vv < logMin) return (vv / logMin) * rLinear;
      return rLinear + ((Math.log10(vv) - Math.log10(logMin)) / logDen) * (rMax - rLinear);
    }

    const ringGrid = [1,2,3,4,5,6,7,8,9,10,30,100,300,1000];
    g.selectAll('.ring').data(ringGrid).enter().append('circle')
      .attr('r', d=>toR(d)).attr('fill','none').attr('stroke','#999').attr('stroke-opacity',0.22);
    g.selectAll('.rlabel').data(ringGrid).enter().append('text')
      .attr('x', 6).attr('y', d=> -toR(d))
      .attr('dominant-baseline','middle').attr('font-size', 11).attr('fill', '#666')
      .text(d=>d);

    const axisY = -rMax * 0.70;
    g.append('text').attr('x', -8).attr('y', axisY).attr('transform', `rotate(-90, 0, ${axisY})`)
      .attr('text-anchor','end').attr('font-size', 11).text('Number of events');

    const F = functions.length;
    const wedge = (Math.PI*2) / F;
    const innerFrac = 0.98;
    const spread = wedge * innerFrac;
    const arc = d3.arc();

    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const end = start + wedge;
      g.append('path')
        .attr('d', arc({innerRadius:0, outerRadius:rMax, startAngle:start, endAngle:end}))
        .attr('fill', idx % 2 ? '#f6f7fb' : '#eef2ff').attr('fill-opacity', 0.06);
      g.append('line')
        .attr('x1',0).attr('y1',0).attr('x2', Math.cos(start)*rMax).attr('y2', Math.sin(start)*rMax)
        .attr('stroke','#000').attr('stroke-opacity',0.25);
      const cen = (start + end) / 2;
      g.append('text')
        .attr('x', Math.cos(cen)*(rMax+16)).attr('y', Math.sin(cen)*(rMax+16))
        .attr('text-anchor','middle').attr('font-weight',700).attr('fill','#1f3de3').text(f);
    });

    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const center = start + wedge/2;
      const items = parsed.entries.filter(e=>e.func===f);
      const K = items.length;
      const avail = spread * 0.96;
      const baseOffs = (K===1) ? [0] : d3.range(K).map(i => (i-(K-1)/2)/(K-1) * (avail/2));
      const placed = [];
      const minSep = wedge * 0.09;
      const radBin = rMax * 0.12;
      const labelAvoid = wedge * 0.18;

      items.forEach((e, i)=>{
        const v = e.values[swLabel]; if (v==null || Number.isNaN(v)) return;
        let r = toR(v);
        let ang = center + baseOffs[i];
        const isBlack = (v === 1000);

        if (isBlack && Math.abs(ang - center) < labelAvoid){
          const dir = (ang >= center) ? 1 : -1;
          ang = center + dir * (labelAvoid + wedge*0.02);
        }
        ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
        let tries = 0;
        while (placed.some(p => Math.abs(p.ang - ang) < minSep && Math.abs(p.r - r) < radBin) && tries < 120){
          const dir = (tries % 2 === 0) ? 1 : -1;
          ang += dir * (minSep * 0.65);
          ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
          tries++;
        }
        if (tries >= 120){ r = Math.min(r + 8, rMax * 0.98); }
        placed.push({ang, r});

        const cx = Math.cos(ang)*r, cy = Math.sin(ang)*r;
        const fill = colorFor(v, e.target, e.max);
        if (!fill) return;

        g.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 7).attr('fill', fill)
          .append('title').text(`${f} — ${e.kpi}: ${v}`);

        const rLabel = Math.min(r + 18, rMax * 0.98);
        const lx = Math.cos(ang)*rLabel, ly = Math.sin(ang)*rLabel;
        g.append('text').attr('x', lx).attr('y', ly).attr('text-anchor','middle')
          .attr('font-size', 11).attr('paint-order','stroke').attr('stroke','white').attr('stroke-width',3)
          .text(e.kpi);
      });
    });

    // Table caption
    const RADAR_TO_TABLE_GAP = 50;
    const tableCaptionY = centerY + rMax + RADAR_TO_TABLE_GAP;
    const tableSidePad = 12, colGap = 8;
    svg.append('text').attr('x', tableSidePad).attr('y', tableCaptionY).attr('font-size', 12).attr('fill', '#555').text('KPI summary per 1000 km');

    const TABLE_CAPTION_GAP = 8;
    const tableY = tableCaptionY + TABLE_CAPTION_GAP;
    const tableG = svg.append('g').attr('transform', `translate(0, ${tableY})`);

    // Build table rows
    const rows = parsed.entries
      .filter(e => e.values[swLabel] != null && !Number.isNaN(e.values[swLabel]))
      .map(e => ({ kpi: e.kpi, func: e.func, target: e.target, max: e.max, events: e.values[swLabel] }));

    // Measure widths
    function measureMaxWidth(texts, fontSize=11, fontWeight=400){
      const tmp = d3.select('body').append('svg')
        .attr('width',0).attr('height',0)
        .style('position','absolute').style('left','-9999px').style('top','-9999px');
      let max = 0;
      texts.forEach(t=>{
        const node = tmp.append('text')
          .attr('font-size', fontSize)
          .attr('font-weight', fontWeight)
          .text(t==null ? '' : String(t))
          .node();
        max = Math.max(max, node.getComputedTextLength());
      });
      tmp.remove();
      return max;
    }
    const kpiTexts  = rows.map(r=>r.kpi);
    const funcTexts = rows.map(r=>r.func);
    const tgtTexts  = rows.map(r=>fmtCell(r.target));
    const maxTexts  = rows.map(r=>fmtCell(r.max));
    const evtTexts  = rows.map(r=>fmtCell(r.events));
    const kpiW  = measureMaxWidth(kpiTexts , 11, 400) + 16;
    const funcW = Math.max(90, Math.min(180, measureMaxWidth(funcTexts, 11, 400) + 16));
    let col2W   = Math.max(50, Math.min(120, measureMaxWidth(tgtTexts , 11, 400) + 16));
    let col3W   = Math.max(60, Math.min(140, measureMaxWidth(maxTexts , 11, 400) + 16));
    let col4W   = Math.max(60, Math.min(140, measureMaxWidth(evtTexts , 11, 700) + 16));
    const x0 = tableSidePad;
    const x1 = x0 + kpiW + colGap;
    const x2 = x1 + funcW + colGap;
    const x3 = x2 + col2W + colGap;
    const x4 = x3 + col3W + colGap;
    const tableWUsed = x4 - x0 + col4W;
    const headerH = 24, rowH2 = 22;

    const tableH = headerH + rows.length * rowH2 + 8;
    tableG.append('rect')
      .attr('x', 12-4).attr('y', 2)
      .attr('width', tableWUsed + 8).attr('height', tableH)
      .attr('rx', 8).attr('ry', 8).attr('fill', '#ffffff').attr('stroke', '#e4e7f3');

    tableG.append('rect')
      .attr('x', x0).attr('y', 4)
      .attr('width', tableWUsed).attr('height', headerH)
      .attr('rx', 6).attr('ry', 6).attr('fill', '#f6f7fb');

    const hdrYmid = 4 + headerH/2;
    tableG.append('text').attr('x', x0+6).attr('y', hdrYmid).attr('dominant-baseline','middle').attr('font-size',12).attr('font-weight',700).text('KPI');
    tableG.append('text').attr('x', x1+6).attr('y', hdrYmid).attr('dominant-baseline','middle').attr('font-size',12).attr('font-weight',700).text('Function');
    tableG.append('text').attr('x', x2 + col2W - 6).attr('y', hdrYmid).attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size',12).attr('font-weight',700).text('Target');

    const hMax = tableG.append('text').attr('x', x3 + col3W - 6).attr('y', 4 + 8).attr('text-anchor','end').attr('font-size',12).attr('font-weight',700);
    hMax.append('tspan').text('Max').attr('x', x3 + col3W - 6).attr('dy', 0);
    hMax.append('tspan').text('allowed').attr('x', x3 + col3W - 6).attr('dy', 12);

    const hEvt = tableG.append('text').attr('x', x4 + col4W - 6).attr('y', 4 + 8).attr('text-anchor','end').attr('font-size',12).attr('font-weight',700);
    hEvt.append('tspan').text('Number of').attr('x', x4 + col4W - 6).attr('dy', 0);
    hEvt.append('tspan').text('events').attr('x', x4 + col4W - 6).attr('dy', 12);

    rows.forEach((r, i)=>{
      const y = 4 + headerH + i*rowH2;
      tableG.append('rect').attr('x', x0).attr('y', y).attr('width', tableWUsed).attr('height', rowH2).attr('fill', i%2 ? '#fafbff' : '#ffffff');

      tableG.append('text').attr('x', x0+6).attr('y', y + rowH2/2).attr('dominant-baseline','middle').attr('font-size', 11).text(r.kpi);
      tableG.append('text').attr('x', x1+6).attr('y', y + rowH2/2).attr('dominant-baseline','middle').attr('font-size', 11).text(r.func);
      tableG.append('text').attr('x', x2 + col2W - 6).attr('y', y + rowH2/2).attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11).text(fmtCell(r.target));
      tableG.append('text').attr('x', x3 + col3W - 6).attr('y', y + rowH2/2).attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11).text(fmtCell(r.max));
      tableG.append('text').attr('x', x4 + col4W - 6).attr('y', y + rowH2/2).attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 11).attr('font-weight',600).text(fmtCell(r.events));
    });

    [x1 - colGap/2, x2 - colGap/2, x3 - colGap/2, x4 - colGap/2].forEach(xx=>{
      tableG.append('line').attr('x1', xx).attr('x2', xx).attr('y1', 4 + headerH).attr('y2', 4 + headerH + rows.length*rowH2).attr('stroke', '#eef1fb');
    });

    // Scoring band
    const valuesForAvg = parsed.entries.map(e => e.values[swLabel]).filter(v => v != null && !Number.isNaN(v));
    const avgEvents = valuesForAvg.length ? d3.mean(valuesForAvg.map(v => Math.min(v, 1000))) : null;
    const score = avgEvents==null ? null : scoreFromAvg(avgEvents, T);

    const barMargin = 20, boxH2 = 42;
    const barW = w - barMargin*2;
    const boxW = barW / 10;
    const scoreBandY = tableY + (headerH + rows.length * rowH2 + 8) + scoreTopPad;
    const scoreG = svg.append('g').attr('transform', `translate(0, ${scoreBandY})`);

    const caption = (avgEvents==null)
      ? 'Average per 1000km:  n/a (only "No function" or missing values)'
      : `Average per 1000km:  ${avgEvents.toFixed(1)} events → Score: ${score} (${scoreText[score-1]})`;
    scoreG.append('text').attr('x', barMargin).attr('y', 14).attr('font-size', 12).text(caption);

    const ranges = scoreRangeLabels(T);
    for (let i=0;i<10;i++){
      const x = barMargin + i*boxW;
      const isSel = (score === i+1);
      scoreG.append('rect')
        .attr('x', x).attr('y', 28)
        .attr('width', boxW).attr('height', boxH2)
        .attr('fill', scoreColors[i])
        .attr('stroke', isSel ? '#000' : '#111')
        .attr('stroke-width', isSel ? 3 : 0.4)
        .append('title').text(`Score ${i+1}: ${scoreText[i]} — ${ranges[i]}`);

      scoreG.append('text').attr('x', x + boxW/2).attr('y', 28 + 14).attr('text-anchor','middle').attr('font-weight', isSel ? 950 : 750).attr('font-size', 13).text(i+1);
      scoreG.append('text').attr('x', x + boxW/2).attr('y', 28 + 14 + 16).attr('text-anchor','middle').attr('font-weight', isSel ? 850 : 550).attr('font-size', 11).text(scoreText[i]);
      scoreG.append('text').attr('x', x + boxW/2).attr('y', 28 + boxH2 + 14).attr('text-anchor','middle').attr('font-size', 10).text(ranges[i]);
    }

    const totalHeight = scoreBandY + 28 + boxH2 + 26 + 16;
    svg.attr('height', totalHeight);
  });
}

/* ==================== Main renderer ==================== */
function renderCharts(parsed){
  const container = d3.select('#charts').html('');
  if (!parsed || !parsed.entries || !parsed.entries.length){
    container.append('div').attr('class','small').text('No data to render.');
    return;
  }
  renderSummary(container, parsed);
  renderSoftwareCards(container, parsed);
}

/* ==================== Loader (CSV + release notes) ==================== */
async function loadCsvAndRender(){
  try{
    const res = await fetch(DATA_CSV + '?t=' + Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    LAST_RAW = text;

    let parsed = parseTable(text);
    const manifestSet = await loadReleaseNotesManifest(); // only used in 'manifest' mode
    const fileNotes = await loadReleaseNotesFromFiles(parsed.software, manifestSet);
    parsed = { ...parsed, releaseNotes: { ...(parsed.releaseNotes||{}), ...fileNotes } };

    renderCharts(parsed);
  }catch(err){
    d3.select('#charts').html('');
    alert(`Could not load "${DATA_CSV}". Make sure it sits next to this HTML and that you're serving over http(s).\n\nError: ${err.message}`);
  }
}

/* ==================== Boot ==================== */
document.addEventListener('DOMContentLoaded', ()=>{
  loadCsvAndRender();
});
</script>
</body>
</html>
