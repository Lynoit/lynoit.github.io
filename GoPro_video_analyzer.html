<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>GoPro Telemetry Viewer (GPS + Speed + Accelerometer)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <!-- GPMF: extract raw telemetry from MP4, then parse it -->
  <script src="https://unpkg.com/gpmf-extract@0.2.3/dist/gpmf-extract.min.js"></script>
  <script src="https://unpkg.com/gopro-telemetry@1.5.3/dist/gopro-telemetry.min.js"></script>

  <style>
    :root { --bg:#111; --fg:#eee; --muted:#999; --accent:#3aa7ff; --card:#1a1a1a; --border:#2a2a2a; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, Arial, sans-serif; }
    header { padding:14px 16px; border-bottom:1px solid var(--border); background:var(--card); position:sticky; top:0; z-index:10 }
    h1 { font-size:18px; margin:0 0 8px; font-weight:600 }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #map { height:50vh; width:100%; border-radius:12px; border:1px solid var(--border); }
    .wrap { max-width:1200px; margin:0 auto; padding:12px; display:grid; gap:14px }
    label.btn { display:inline-block; padding:8px 12px; border:1px dashed var(--border); border-radius:10px; cursor:pointer; }
    input[type=file] { display:none; }
    .kv { font-size:13px; color:var(--muted) }
    .grid { display:grid; gap:14px }
    canvas { background:#0d0d0d; border-radius:12px; border:1px solid var(--border); }
    progress { width:260px; height:10px; }
    .bad { color:#ff6b6b } .ok{ color:#7dff9b }
    a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <h1 style="flex:1">GoPro MP4 ‚Üí GPS route + Speed + Accelerometer</h1>
      <label class="btn">üìÅ Choose GoPro .MP4
        <input id="fileInput" type="file" accept="video/mp4,video/*">
      </label>
      <div class="kv" id="status">No file loaded.</div>
    </div>
    <div class="row" style="margin-top:8px">
      <progress id="progress" value="0" max="1" style="display:none"></progress>
      <div class="kv" id="meta"></div>
    </div>
  </header>

  <div class="wrap">
    <div id="map" class="card"></div>

    <div class="grid">
      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline;">
          <div class="kv">Speed (km/h)</div>
          <div class="kv" id="speedInfo"></div>
        </div>
        <canvas id="speedChart" height="150"></canvas>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline;">
          <div class="kv">Accelerometer (m/s¬≤)</div>
          <div class="kv" id="accInfo"></div>
        </div>
        <canvas id="accChart" height="180"></canvas>
      </div>
    </div>
  </div>

  <script>
    // --- Leaflet map setup ---
    const map = L.map('map', { zoomControl: true, scrollWheelZoom: true }).setView([0,0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    let routeLayer = null, startMarker = null, endMarker = null;

    // --- Charts ---
    const speedCtx = document.getElementById('speedChart').getContext('2d');
    const accCtx   = document.getElementById('accChart').getContext('2d');

    const speedChart = new Chart(speedCtx, {
      type: 'line',
      data: { datasets: [{ label:'Speed', data: [], borderWidth:2, pointRadius:0, tension:0.2 }] },
      options: {
        animation:false, responsive:true, maintainAspectRatio:false,
        scales:{ x:{ title:{display:true,text:'Time (s)'}, grid:{color:'#222'}, ticks:{color:'#bbb'} },
                y:{ title:{display:true,text:'km/h'}, grid:{color:'#222'}, ticks:{color:'#bbb'} } },
        plugins:{ legend:{ labels:{ color:'#ddd' } } }
      }
    });

    const accChart = new Chart(accCtx, {
      type: 'line',
      data: {
        datasets: [
          { label:'Ax', data: [], borderWidth:1.8, pointRadius:0, tension:0.15 },
          { label:'Ay', data: [], borderWidth:1.8, pointRadius:0, tension:0.15 },
          { label:'Az', data: [], borderWidth:1.8, pointRadius:0, tension:0.15 }
        ]
      },
      options: {
        animation:false, responsive:true, maintainAspectRatio:false,
        scales:{ x:{ title:{display:true,text:'Time (s)'}, grid:{color:'#222'}, ticks:{color:'#bbb'} },
                y:{ title:{display:true,text:'m/s¬≤'}, grid:{color:'#222'}, ticks:{color:'#bbb'} } },
        plugins:{ legend:{ labels:{ color:'#ddd' } } }
      }
    });

    // --- UI refs ---
    const fileInput = document.getElementById('fileInput');
    const statusEl  = document.getElementById('status');
    const progressEl= document.getElementById('progress');
    const metaEl    = document.getElementById('meta');
    const speedInfo = document.getElementById('speedInfo');
    const accInfo   = document.getElementById('accInfo');

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      resetUI();
      statusEl.textContent = `Extracting "${file.name}"‚Ä¶`;
      progressEl.style.display = 'inline-block';
      progressEl.value = 0;

      try {
        // 1) Extract GPMF from the MP4 (browser-friendly). Returns { rawData, timing }
        const extracted = await window.gpmfExtract(file, (p) => {
          // progress callback (0..1) when available
          if (typeof p === 'number') progressEl.value = p;
        });

        statusEl.textContent = 'Parsing telemetry‚Ä¶';

        // 2) Parse telemetry streams from the extracted payload
        const telemetry = await window.goproTelemetry(
          extracted,
          {
            stream: ['GPS5','GPSF','GPSU','ACCL'], // GPS fixes, fix-type, GPS time, Accelerometer
            raw: false,
            groupTimes: 0,     // keep highest resolution
            repeat: false,
            tolerant: true,
            timeOut: 120000
          }
        );

        handleTelemetry(telemetry, file);
        statusEl.innerHTML = `<span class="ok">Done.</span>`;
      } catch (err) {
        console.error(err);
        statusEl.innerHTML = `<span class="bad">Failed: ${String(err.message || err)}</span>`;
      } finally {
        progressEl.style.display = 'none';
      }
    });

    function resetUI() {
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer=null; }
      if (startMarker){ map.removeLayer(startMarker); startMarker=null; }
      if (endMarker)  { map.removeLayer(endMarker); endMarker=null; }

      speedChart.data.datasets[0].data = [];
      speedChart.update();
      accChart.data.datasets.forEach(d=>d.data=[]);
      accChart.update();

      metaEl.textContent = '';
      speedInfo.textContent = '';
      accInfo.textContent = '';
    }

    function handleTelemetry(telemetry, file) {
      const deviceKey = Object.keys(telemetry)[0];
      const dev = telemetry[deviceKey] || {};
      metaEl.textContent = summarize(dev, file);

      // --- GPS path & speed ---
      const gps = dev?.streams?.GPS5;
      let gpsPoints = [];
      let speedSeries = [];
      if (gps?.samples?.length) {
        const t0 = gps.samples[0].cts ?? 0;
        const ts = gps.timescale || 1000;
        gps.samples.forEach(s => {
          const v = s.value; // [lat, lon, alt, speed(m/s), ...] scaled
          const lat = v?.[0], lon = v?.[1];
          const spd_mps = v?.[3];
          const tSec = toSeconds(s.cts, t0, ts);
          if (Number.isFinite(lat) && Number.isFinite(lon)) gpsPoints.push([lat, lon]);
          if (Number.isFinite(spd_mps)) speedSeries.push({ x: tSec, y: spd_mps * 3.6 });
        });
      }

      if ((!speedSeries.length || speedSeries.every(p => !Number.isFinite(p.y))) && gps?.samples?.length > 2) {
        speedSeries = deriveSpeedFromGPS(gps).series;
      }

      // --- Accelerometer ---
      const acc = dev?.streams?.ACCL;
      const ax=[], ay=[], az=[];
      if (acc?.samples?.length) {
        const t0a = acc.samples[0].cts ?? 0;
        const ts  = acc.timescale || 1000;
        acc.samples.forEach(s => {
          const v = s.value; // [ax, ay, az] in m/s¬≤ (scaled)
          const tSec = toSeconds(s.cts, t0a, ts);
          if (v && v.length >= 3) {
            ax.push({x:tSec, y:v[0]});
            ay.push({x:tSec, y:v[1]});
            az.push({x:tSec, y:v[2]});
          }
        });
      }

      // --- Draw route ---
      if (gpsPoints.length) {
        if (routeLayer) map.removeLayer(routeLayer);
        routeLayer = L.polyline(gpsPoints, { color:'#3aa7ff', weight:3 }).addTo(map);
        map.fitBounds(routeLayer.getBounds(), { padding:[20,20] });

        if (startMarker) map.removeLayer(startMarker);
        if (endMarker) map.removeLayer(endMarker);
        startMarker = L.circleMarker(gpsPoints[0], { radius:5, color:'#7dff9b' }).addTo(map).bindTooltip('Start');
        endMarker   = L.circleMarker(gpsPoints[gpsPoints.length-1], { radius:5, color:'#ff6b6b' }).addTo(map).bindTooltip('End');
      } else {
        map.setView([0,0], 2);
      }

      // --- Update charts ---
      speedChart.data.datasets[0].data = speedSeries;
      speedChart.update();
      if (speedSeries.length) {
        const maxKph = Math.max(...speedSeries.map(p => p.y||0));
        const avgKph = speedSeries.reduce((a,b)=>a+(b.y||0),0) / speedSeries.length;
        speedInfo.textContent = `points: ${speedSeries.length} ‚Ä¢ max: ${maxKph.toFixed(1)} ‚Ä¢ avg: ${avgKph.toFixed(1)} km/h`;
      } else {
        speedInfo.textContent = 'No speed track available.';
      }

      accChart.data.datasets[0].data = ax;
      accChart.data.datasets[1].data = ay;
      accChart.data.datasets[2].data = az;
      accChart.update();
      accInfo.textContent = (ax.length+ay.length+az.length) ? `samples: ${Math.max(ax.length, ay.length, az.length)}` : 'No accelerometer data found.';
    }

    function summarize(dev, file) {
      const parts = [];
      parts.push(`Size: ${(file.size/1e6).toFixed(1)} MB`);
      const gps = dev?.streams?.GPS5, acc = dev?.streams?.ACCL;
      parts.push(gps ? 'GPS ‚úì' : 'GPS ‚úó');
      parts.push(acc ? 'ACC ‚úì' : 'ACC ‚úó');
      if (gps?.samples?.length) {
        const first = gps.samples[0]?.date || null;
        const last  = gps.samples[gps.samples.length-1]?.date || null;
        if (first && last) parts.push(`Time: ${fmtDate(first)} ‚Üí ${fmtDate(last)}`);
      }
      return parts.join(' ‚Ä¢ ');
    }

    function fmtDate(d){ try{const dt=(d instanceof Date)?d:new Date(d); return dt.toISOString().replace('T',' ').replace('Z','');}catch{ return ''; } }
    function toSeconds(cts, t0, timescale){ const s=(cts-(t0||0))/(timescale||1000); return Number.isFinite(s)?s:0; }
    function haversine(lat1, lon1, lat2, lon2){
      const R=6371000, toRad=(d)=>d*Math.PI/180;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a)); // meters
    }
    function deriveSpeedFromGPS(gpsStream){
      const s=gpsStream?.samples||[]; if (s.length<2) return {series:[]};
      const ts=gpsStream.timescale||1000; const t0=s[0].cts||0; const series=[];
      for (let i=1;i<s.length;i++){
        const v1=s[i-1].value, v2=s[i].value; if (!v1||!v2) continue;
        const [lat1,lon1]=[v1[0],v1[1]], [lat2,lon2]=[v2[0],v2[1]];
        const dt=((s[i].cts||0)-(s[i-1].cts||0))/ts; if (!Number.isFinite(lat1)||!Number.isFinite(lon1)||!Number.isFinite(lat2)||!Number.isFinite(lon2)||dt<=0) continue;
        const d=haversine(lat1,lon1,lat2,lon2); const mps=d/dt;
        series.push({ x: ((s[i].cts||0)-t0)/ts, y: mps*3.6 });
      }
      return { series };
    }
  </script>
</body>
</html>
