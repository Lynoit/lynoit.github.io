<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GoPro GPS → Leaflet Map</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Telemetry libs (UMD builds expose window.gpmfExtract & window.goproTelemetry) -->
  <script src="https://unpkg.com/mp4box@0.5.4/dist/mp4box.all.min.js"></script>
  <script src="https://unpkg.com/gpmf-extract@0.3.2/dist/gpmf-extract.umd.js"></script>
  <script src="https://unpkg.com/gopro-telemetry@4.2.2/dist/gopro-telemetry.umd.js"></script>

  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif;
      display: grid; grid-template-rows: auto 1fr auto; min-height: 100vh;
      background: #111; color: #eee;
    }
    header, footer {
      padding: 10px 14px; background: #1b1b1b; border-bottom: 1px solid #2a2a2a;
    }
    header h1 { font-size: 1.1rem; margin: 0 0 6px; }
    #controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    #status { font-size: 0.95rem; opacity: 0.85 }
    #map { height: calc(100vh - 150px); }
    .dropzone {
      border: 2px dashed #3a3a3a; border-radius: 10px; padding: 12px 14px;
      display: inline-flex; gap: 10px; align-items: center; background: #151515;
    }
    .dropzone.dragover { border-color: #6fa8ff; background: #0f1725; }
    input[type=file] { accent-color: #6fa8ff; }
    button { background: #2a2a2a; color: #eee; border: 1px solid #3a3a3a; border-radius: 8px; padding: 8px 10px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    footer { border-top: 1px solid #2a2a2a; border-bottom: 0; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; }
    a { color: #9ec5ff; }
  </style>
</head>
<body>
  <header>
    <h1>GoPro MP4 → GPS track on OpenStreetMap</h1>
    <div id="controls">
      <label class="dropzone" id="dropzone">
        <strong>Drop MP4 here</strong> or
        <input id="file" type="file" accept=".mp4,video/mp4" />
      </label>
      <button id="demoBtn" title="Loads a tiny built-in demo track to test the UI" type="button">Quick demo</button>
      <span id="status">No file loaded.</span>
    </div>
  </header>

  <div id="map"></div>

  <footer>
    <div>© OpenStreetMap contributors · Tiles by OSM</div>
    <div>Tip: On HERO10 Black, enable <em>GPS</em> in Preferences. Start recording after GPS lock.</div>
  </footer>

<script>
/* ========= Leaflet map setup ========= */
let map = L.map('map', { zoomControl: true, attributionControl: true }).setView([20, 0], 2);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let trackLayer; // polyline + markers group
const statusEl = document.getElementById('status');
const fileEl = document.getElementById('file');
const dropzone = document.getElementById('dropzone');
const demoBtn = document.getElementById('demoBtn');

function setStatus(msg) { statusEl.textContent = msg; }

/* ========= UI: file input & drag-drop ========= */
fileEl.addEventListener('change', async (e) => {
  const f = e.target.files && e.target.files[0];
  if (f) await handleFile(f);
});
['dragenter','dragover'].forEach(evt =>
  dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover'); })
);
['dragleave','drop'].forEach(evt =>
  dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover'); })
);
dropzone.addEventListener('drop', async (e) => {
  const f = e.dataTransfer.files && e.dataTransfer.files[0];
  if (f) await handleFile(f);
});

/* ========= Core: parse GoPro telemetry & plot ========= */
async function handleFile(file) {
  try {
    if (typeof window.gpmfExtract !== 'function' || typeof window.goproTelemetry !== 'function') {
      setStatus('Libraries not loaded. Check the <script> URLs for gpmf-extract & gopro-telemetry (UMD builds).');
      return;
    }
    setStatus(`Reading "${file.name}"… (${(file.size/1048576).toFixed(1)} MB)`);
    const buffer = await file.arrayBuffer();

    setStatus('Extracting GPMF telemetry…');
    // Extract the GPMF payload from MP4 (browser-friendly)
    const gpmf = await window.gpmfExtract(buffer); // mp4box is used under the hood

    setStatus('Decoding telemetry…');
    // Keep the default parsing; we mainly want GPS streams
    const telemetry = await window.goproTelemetry(gpmf, { /* e.g., streams: ['GPS5'] */ });

    const points = extractGpsPoints(telemetry);
    if (!points.length) {
      setStatus('No GPS points found. Ensure GPS was enabled and locked before recording.');
      return;
    }

    drawTrack(points);
    const distKm = totalDistanceKm(points).toFixed(2);
    setStatus(`Plotted ${points.length.toLocaleString()} points · ${distKm} km`);
  } catch (err) {
    console.error(err);
    setStatus('Failed: ' + (err && err.message ? err.message : err));
  }
}

/* Extract GPS samples with [lat, lon] */
function extractGpsPoints(telemetry) {
  const pts = [];

  function dig(obj) {
    if (!obj || typeof obj !== 'object') return;

    if (Array.isArray(obj.samples)) {
      for (const s of obj.samples) {
        const v = s?.value ?? s?.Values ?? s;
        if (Array.isArray(v) && v.length >= 2) {
          const lat = Number(v[0]), lon = Number(v[1]);
          if (Number.isFinite(lat) && Number.isFinite(lon) &&
              Math.abs(lat) <= 90 && Math.abs(lon) <= 180 &&
              !(lat === 0 && lon === 0)) {
            pts.push([lat, lon]);
          }
        }
      }
    }
    for (const k in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, k)) dig(obj[k]);
    }
  }
  dig(telemetry);

  // Deduplicate & thin if huge
  const deduped = [];
  let last;
  const THIN = pts.length > 20000 ? 3 : pts.length > 5000 ? 2 : 1;
  for (let i = 0; i < pts.length; i += THIN) {
    const p = pts[i];
    if (!last || last[0] !== p[0] || last[1] !== p[1]) {
      deduped.push(p);
      last = p;
    }
  }
  return deduped;
}

/* Draw the polyline and start/end markers */
function drawTrack(latlngs) {
  if (trackLayer) {
    trackLayer.remove();
    trackLayer = null;
  }
  trackLayer = L.layerGroup().addTo(map);

  const line = L.polyline(latlngs, { weight: 4, opacity: 0.9 }).addTo(trackLayer);
  const start = latlngs[0];
  const end = latlngs[latlngs.length - 1];
  L.circleMarker(start, { radius: 6, color: '#1ec31e', weight: 2, fillOpacity: 0.8 })
    .addTo(trackLayer).bindPopup('Start');
  L.circleMarker(end, { radius: 6, color: '#ff4d4f', weight: 2, fillOpacity: 0.8 })
    .addTo(trackLayer).bindPopup('End');
  map.fitBounds(line.getBounds(), { padding: [20, 20] });
}

/* Haversine total distance (km) */
function totalDistanceKm(latlngs) {
  const R = 6371;
  let d = 0;
  for (let i = 1; i < latlngs.length; i++) {
    const [lat1, lon1] = latlngs[i-1], [lat2, lon2] = latlngs[i];
    const φ1 = lat1 * Math.PI/180, φ2 = lat2 * Math.PI/180;
    const Δφ = (lat2-lat1) * Math.PI/180, Δλ = (lon2-lon1) * Math.PI/180;
    const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
    d += 2*R*Math.asin(Math.sqrt(a));
  }
  return d;
}

/* Tiny built-in demo polyline */
demoBtn.addEventListener('click', () => {
  const demo = [
    [37.807, -122.475], [37.8076, -122.472], [37.8088, -122.469],
    [37.81, -122.466], [37.811, -122.463], [37.812, -122.460],
  ];
  drawTrack(demo);
  setStatus(`Demo: plotted ${demo.length} points · ${(totalDistanceKm(demo)).toFixed(2)} km`);
});
</script>
</body>
</html>
