<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GoPro MP4 → GPS on Leaflet (GPS5/GPS9 only)</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif;
      display: grid; grid-template-rows: auto 1fr auto; min-height: 100vh;
      background: #111; color: #eee;
    }
    header, footer { padding: 10px 14px; background: #1b1b1b; border-bottom: 1px solid #2a2a2a; }
    header h1 { font-size: 1.1rem; margin: 0 0 6px; }
    #controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    #status { font-size: 0.95rem; opacity: 0.85 }
    #map { height: calc(100vh - 150px); }
    .dropzone { border: 2px dashed #3a3a3a; border-radius: 10px; padding: 12px 14px; display: inline-flex; gap: 10px; align-items: center; background: #151515; }
    .dropzone.dragover { border-color: #6fa8ff; background: #0f1725; }
    input[type=file] { accent-color: #6fa8ff; }
    button { background: #2a2a2a; color: #eee; border: 1px solid #3a3a3a; border-radius: 8px; padding: 8px 10px; cursor: pointer; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    footer { border-top: 1px solid #2a2a2a; border-bottom: 0; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center; }
    a { color: #9ec5ff; }
    .warn { color: #ffd36b }
    .err { color: #ff8b8b }
  </style>
</head>
<body>
  <header>
    <h1>GoPro MP4 → GPS track on OpenStreetMap</h1>
    <div id="controls">
      <label class="dropzone" id="dropzone">
        <strong>Drop MP4 here</strong> or
        <input id="file" type="file" accept=".mp4,video/mp4" />
      </label>
      <button id="demoBtn" type="button">Quick demo</button>
      <span id="status">Loading modules…</span>
    </div>
  </header>

  <div id="map"></div>

  <footer>
    <div>© OpenStreetMap contributors</div>
    <div>Tip: On HERO10 Black, enable <em>GPS</em> and start recording after GPS lock.</div>
  </footer>

<script type="module">
  // ESM imports (no globals needed)
  import gpmfExtract from "https://esm.sh/gpmf-extract@latest";
  import goproTelemetry from "https://esm.sh/gopro-telemetry@latest";

  // Leaflet map
  const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([20, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  let trackLayer;
  const statusEl = document.getElementById('status');
  const fileEl = document.getElementById('file');
  const dropzone = document.getElementById('dropzone');
  const demoBtn = document.getElementById('demoBtn');
  const setStatus = (m) => statusEl.textContent = m;

  setStatus('Modules ready. Load an .MP4 to extract GPS.');

  // UI: file input & drag-drop
  fileEl.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) await handleFile(f);
  });
  ['dragenter','dragover'].forEach(evt =>
    dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover'); })
  );
  ['dragleave','drop'].forEach(evt =>
    dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover'); })
  );
  dropzone.addEventListener('drop', async (e) => {
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (f) await handleFile(f);
  });

  // Core: parse GoPro telemetry & plot
  async function handleFile(file) {
    try {
      setStatus(`Reading "${file.name}"… (${(file.size/1048576).toFixed(1)} MB)`);
      // Extract GPMF from the actual File in browser mode
      setStatus('Extracting GPMF telemetry…');
      const gpmf = await gpmfExtract(file, { browserMode: true });

      setStatus('Decoding telemetry (GPS only)…');
      // IMPORTANT: request ONLY GPS streams to avoid grabbing accelerometer/gyro, etc.
      const telemetry = await goproTelemetry(gpmf, { stream: ['GPS5', 'GPS9'] });

      const { points, usedStreams, unitsOk, swapped } = collectGpsPointsStrict(telemetry);

      if (!usedStreams.length) {
        setStatus('No GPS streams (GPS5/GPS9) found. Is GPS enabled & locked in camera?');
        return;
      }
      if (!points.length) {
        setStatus('GPS found but no valid positions. Wait a few seconds after GPS lock before recording.');
        return;
      }

      drawTrack(points);
      const distKm = totalDistanceKm(points).toFixed(2);
      const unitNote = unitsOk ? '' : ' (unit check failed)';
      const swapNote = swapped ? ' [auto-fixed lon/lat order]' : '';
      setStatus(`Plotted ${points.length.toLocaleString()} points · ${distKm} km · streams: ${usedStreams.join(', ')}${swapNote}${unitNote}`);
    } catch (err) {
      console.error(err);
      setStatus('Failed: ' + (err && err.message ? err.message : err));
    }
  }

  /**
   * Strict GPS extractor:
   * - Only accepts GPS5/GPS9 streams.
   * - Verifies units are degrees for lat/lon when available.
   * - Accepts both array format [lat, lon, ...] and object format {lat, lon, ...}.
   * - Auto-fixes swapped lon/lat if detected in majority of samples.
   */
  function collectGpsPointsStrict(telemetry) {
    const gpsKeys = ['GPS5','GPS9'];
    const usedStreams = [];
    let unitsOk = false;
    const rawPts = [];

    // Iterate device blocks
    for (const devId in telemetry) {
      const dev = telemetry[devId];
      const streams = dev && dev.streams;
      if (!streams) continue;

      for (const key of Object.keys(streams)) {
        if (!gpsKeys.includes(key)) continue;
        usedStreams.push(key);

        const stream = streams[key];
        // Try to verify units if present
        const u = stream && stream.units && stream.units.value;
        if (Array.isArray(u) && u.length >= 2) {
          const latUnit = String(u[0] ?? '').toLowerCase();
          const lonUnit = String(u[1] ?? '').toLowerCase();
          if (latUnit.includes('deg') && lonUnit.includes('deg')) unitsOk = true;
        }

        const samples = Array.isArray(stream?.samples) ? stream.samples : [];
        for (const s of samples) {
          const v = s?.value;
          if (Array.isArray(v) && v.length >= 2) {
            rawPts.push([Number(v[0]), Number(v[1])]);
          } else if (v && typeof v === 'object') {
            const lat = Number(v.lat ?? v.latitude);
            const lon = Number(v.lon ?? v.longitude);
            if (Number.isFinite(lat) && Number.isFinite(lon)) rawPts.push([lat, lon]);
          }
        }
      }
    }

    // Filter invalids
    let pts = rawPts.filter(([lat, lon]) =>
      Number.isFinite(lat) && Number.isFinite(lon) &&
      Math.abs(lat) <= 90 && Math.abs(lon) <= 180 &&
      !(lat === 0 && lon === 0)
    );

    // Heuristic: detect if most samples look swapped (lon in [-90,90] but lat often outside ±90)
    let swapped = false;
    if (pts.length) {
      const outOfRangeLat = pts.filter(([lat]) => Math.abs(lat) > 90).length;
      const inRangeLon = pts.filter(([, lon]) => Math.abs(lon) <= 90).length;
      // If many lats are out of range but most lons are "lat-like", assume swap
      if (outOfRangeLat > pts.length * 0.2 && inRangeLon > pts.length * 0.8) {
        swapped = true;
        pts = pts.map(([lat, lon]) => [lon, lat]); // swap
        // Re-filter after swap
        pts = pts.filter(([lat, lon]) =>
          Math.abs(lat) <= 90 && Math.abs(lon) <= 180 && !(lat === 0 && lon === 0)
        );
      }
    }

    // Deduplicate & simple thinning
    const deduped = [];
    let last;
    const THIN = pts.length > 20000 ? 3 : pts.length > 5000 ? 2 : 1;
    for (let i = 0; i < pts.length; i += THIN) {
      const p = pts[i];
      if (!last || last[0] !== p[0] || last[1] !== p[1]) {
        deduped.push(p); last = p;
      }
    }

    return { points: deduped, usedStreams, unitsOk, swapped };
  }

  // Draw polyline and markers
  function drawTrack(latlngs) {
    if (trackLayer) { trackLayer.remove(); trackLayer = null; }
    trackLayer = L.layerGroup().addTo(map);

    const line = L.polyline(latlngs, { weight: 4, opacity: 0.9 }).addTo(trackLayer);
    const start = latlngs[0];
    const end = latlngs[latlngs.length - 1];
    L.circleMarker(start, { radius: 6, color: '#1ec31e', weight: 2, fillOpacity: 0.8 }).addTo(trackLayer).bindPopup('Start');
    L.circleMarker(end, { radius: 6, color: '#ff4d4f', weight: 2, fillOpacity: 0.8 }).addTo(trackLayer).bindPopup('End');
    map.fitBounds(line.getBounds(), { padding: [20, 20] });
  }

  // Haversine total distance (km)
  function totalDistanceKm(latlngs) {
    const R = 6371; let d = 0;
    for (let i = 1; i < latlngs.length; i++) {
      const [lat1, lon1] = latlngs[i-1], [lat2, lon2] = latlngs[i];
      const φ1 = lat1 * Math.PI/180, φ2 = lat2 * Math.PI/180;
      const Δφ = (lat2-lat1) * Math.PI/180, Δλ = (lon2-lon1) * Math.PI/180;
      const a = Math.sin(Δφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)**2;
      d += 2*R*Math.asin(Math.sqrt(a));
    }
    return d;
  }

  // Quick demo track (sanity check UI)
  demoBtn.addEventListener('click', () => {
    const demo = [
      [37.807, -122.475], [37.8076, -122.472], [37.8088, -122.469],
      [37.81, -122.466], [37.811, -122.463], [37.812, -122.460],
    ];
    drawTrack(demo);
    setStatus(`Demo: plotted ${demo.length} points · ${totalDistanceKm(demo).toFixed(2)} km`);
  });
</script>
</body>
</html>
