<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>GoPro Telemetry ‚Äì MP4 Debugger & Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <style>
    :root { --bg:#111; --fg:#eee; --muted:#aaa; --accent:#3aa7ff; --card:#1a1a1a; --border:#2a2a2a; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, Arial, sans-serif; }
    header { padding:14px 16px; border-bottom:1px solid var(--border); background:var(--card); position:sticky; top:0; z-index:10 }
    h1 { font-size:18px; margin:0 0 8px; font-weight:600 }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center }
    .card { background:var(--card); border:1px solid var(--border); border-radius:12px; padding:12px; }
    #map { height:45vh; width:100%; border-radius:12px; border:1px solid var(--border); }
    .wrap { max-width:1200px; margin:0 auto; padding:12px; display:grid; gap:14px }
    label.btn { display:inline-block; padding:8px 12px; border:1px dashed var(--border); border-radius:10px; cursor:pointer; }
    input[type=file] { display:none; }
    .kv { font-size:13px; color:var(--muted) }
    .grid { display:grid; gap:14px }
    canvas { background:#0d0d0d; border-radius:12px; border:1px solid var(--border); }
    progress { width:260px; height:10px; }
    .bad { color:#ff6b6b } .ok { color:#7dff9b } .warn { color:#ffd166 }
    pre.log { background:#0b0b0b; border:1px solid #222; padding:10px; border-radius:8px; overflow:auto; max-height:30vh }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <h1 style="flex:1">GoPro MP4 ‚Üí Telemetry debugger (GPS, Speed, Accelerometer)</h1>
      <label class="btn">üìÅ Choose GoPro .MP4 (original)
        <input id="fileInput" type="file" accept="video/mp4,video/*">
      </label>
      <div class="kv" id="status">No file loaded.</div>
    </div>
    <div class="row" style="margin-top:8px">
      <progress id="progress" value="0" max="1" style="display:none"></progress>
      <div class="kv" id="meta"></div>
    </div>
  </header>

  <div class="wrap">
    <div id="map" class="card"></div>

    <div class="grid">
      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline;">
          <div class="kv">Speed (km/h)</div>
          <div class="kv" id="speedInfo"></div>
        </div>
        <canvas id="speedChart" height="150"></canvas>
      </div>

      <div class="card">
        <div class="row" style="justify-content:space-between; align-items:baseline;">
          <div class="kv">Accelerometer (m/s¬≤)</div>
          <div class="kv" id="accInfo"></div>
        </div>
        <canvas id="accChart" height="180"></canvas>
      </div>

      <div class="card">
        <div class="kv" style="margin-bottom:6px">Extraction log (for troubleshooting)</div>
        <pre class="log" id="log"></pre>
      </div>
    </div>
  </div>

  <script type="module">
    import gpmfExtract from "https://cdn.jsdelivr.net/npm/gpmf-extract@0.2.3/+esm";
    import goproTelemetry from "https://cdn.jsdelivr.net/npm/gopro-telemetry@1.5.3/+esm";

    // --- Leaflet map ---
    const map = L.map('map', { zoomControl: true, scrollWheelZoom: true }).setView([0,0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
      { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);
    let routeLayer = null, startMarker = null, endMarker = null;

    // --- Charts ---
    const speedCtx = document.getElementById('speedChart').getContext('2d');
    const accCtx   = document.getElementById('accChart').getContext('2d');
    const speedChart = new Chart(speedCtx, {
      type: 'line',
      data: { datasets: [{ label:'Speed', data: [], borderWidth:2, pointRadius:0, tension:0.2 }] },
      options: {
        animation:false, responsive:true, maintainAspectRatio:false,
        scales:{ x:{ title:{display:true,text:'Time (s)'}, grid:{color:'#222'}, ticks:{color:'#bbb'} },
                y:{ title:{display:true,text:'km/h'}, grid:{color:'#222'}, ticks:{color:'#bbb'} } },
        plugins:{ legend:{ labels:{ color:'#ddd' } } }
      }
    });
    const accChart = new Chart(accCtx, {
      type: 'line',
      data: {
        datasets: [
          { label:'Ax', data: [], borderWidth:1.8, pointRadius:0, tension:0.15 },
          { label:'Ay', data: [], borderWidth:1.8, pointRadius:0, tension:0.15 },
          { label:'Az', data: [], borderWidth:1.8, pointRadius:0, tension:0.15 }
        ]
      },
      options: {
        animation:false, responsive:true, maintainAspectRatio:false,
        scales:{ x:{ title:{display:true,text:'Time (s)'}, grid:{color:'#222'}, ticks:{color:'#bbb'} },
                y:{ title:{display:true,text:'m/s¬≤'}, grid:{color:'#222'}, ticks:{color:'#bbb'} } },
        plugins:{ legend:{ labels:{ color:'#ddd' } } }
      }
    });

    // --- UI refs ---
    const fileInput = document.getElementById('fileInput');
    const statusEl  = document.getElementById('status');
    const progressEl= document.getElementById('progress');
    const metaEl    = document.getElementById('meta');
    const speedInfo = document.getElementById('speedInfo');
    const accInfo   = document.getElementById('accInfo');
    const logEl     = document.getElementById('log');

    // Logging helpers
    function log(msg, obj){
      const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
      console.log(line, obj ?? '');
      logEl.textContent += line + (obj ? ' ' + safeJSON(obj) : '') + '\n';
      logEl.scrollTop = logEl.scrollHeight;
    }
    const safeJSON = (o)=>{ try{ return JSON.stringify(o, null, 2); }catch{ return ''; } };

    // Small helpers
    const fmtDate = (d)=>{ try{const dt=(d instanceof Date)?d:new Date(d); return dt.toISOString().replace('T',' ').replace('Z','');}catch{return '';} };
    const toSeconds = (cts,t0,ts)=>{ const s=(cts-(t0||0))/(ts||1000); return Number.isFinite(s)?s:0; };

    function haversine(lat1, lon1, lat2, lon2){
      const R=6371000, toRad=(d)=>d*Math.PI/180;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }
    function deriveSpeedFromGPS(gpsStream){
      const s=gpsStream?.samples||[]; if (s.length<2) return {series:[]};
      const ts=gpsStream.timescale||1000; const t0=s[0].cts||0; const series=[];
      for (let i=1;i<s.length;i++){
        const v1=s[i-1].value, v2=s[i].value; if(!v1||!v2) continue;
        const [lat1,lon1]=[v1[0],v1[1]], [lat2,lon2]=[v2[0],v2[1]];
        const dt=((s[i].cts||0)-(s[i-1].cts||0))/ts;
        if (!Number.isFinite(lat1)||!Number.isFinite(lon1)||!Number.isFinite(lat2)||!Number.isFinite(lon2)||dt<=0) continue;
        const d=haversine(lat1,lon1,lat2,lon2); const mps=d/dt;
        series.push({ x: ((s[i].cts||0)-t0)/ts, y: mps*3.6 });
      }
      return { series };
    }

    // Map reset
    function resetUI(){
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer=null; }
      if (startMarker){ map.removeLayer(startMarker); startMarker=null; }
      if (endMarker)  { map.removeLayer(endMarker); endMarker=null; }
      speedChart.data.datasets[0].data = []; speedChart.update();
      accChart.data.datasets.forEach(d=>d.data=[]); accChart.update();
      metaEl.textContent = ''; speedInfo.textContent = ''; accInfo.textContent = '';
      logEl.textContent = '';
    }

    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      resetUI();
      statusEl.textContent = `Reading "${file.name}" (${(file.size/1e6).toFixed(1)} MB)‚Ä¶`;
      progressEl.style.display = 'inline-block';
      progressEl.value = 0;

      try {
        log('Step 1: starting gpmfExtract');
        // 1) Extract GPMF (telemetry) track from MP4
        const extracted = await gpmfExtract(file, {
          browserMode: true,
          progress: (p) => {
            // p is 0..100
            if (typeof p === 'number') {
              progressEl.value = p/100;
              if (p % 10 === 0) log(`gpmfExtract progress: ${p}%`);
            }
          }
        });

        log('Step 1.1: extraction metadata', { duration: extracted?.duration, tracks: Object.keys(extracted || {}) });
        if (!extracted || (!extracted.rawData && !extracted.data)) {
          statusEl.innerHTML = `<span class="bad">No GPMF track found in this file.</span>`;
          log('No GPMF present. Possible causes: re-encoded/exported file, GPS off, indoor no lock, or not an original in-camera MP4.');
          return;
        }

        statusEl.textContent = 'Parsing telemetry‚Ä¶';
        log('Step 2: starting goproTelemetry');

        // 2) Parse streams with gopro-telemetry
        const telemetry = await goproTelemetry(extracted, {
          stream: ['GPS5','GPSF','GPSU','ACCL'],
          raw: false,
          groupTimes: 0,
          tolerant: true,
          timeOut: 120000
        });

        const deviceKey = Object.keys(telemetry)[0];
        const dev = telemetry[deviceKey] || {};
        const streamKeys = dev?.streams ? Object.keys(dev.streams) : [];
        log('Step 2.1: telemetry parsed; streams present', streamKeys);

        // If *no* requested streams are present, tell the user why
        const hasGPS = !!dev?.streams?.GPS5?.samples?.length;
        const hasACC = !!dev?.streams?.ACCL?.samples?.length;
        if (!hasGPS && !hasACC) {
          statusEl.innerHTML = `<span class="warn">Telemetry parsed, but no GPS/ACC samples found.</span>`;
          log('Parsed OK, but streams missing. This can happen if GPS was OFF, or this clip didn‚Äôt get satellite lock.');
        }

        handleTelemetry(dev, file);
        statusEl.innerHTML = `<span class="ok">Done.</span>`;
      } catch (err) {
        console.error(err);
        statusEl.innerHTML = `<span class="bad">Failed: ${String(err.message || err)}</span>`;
        log('Error', { message: String(err.message || err), stack: err?.stack });
      } finally {
        progressEl.style.display = 'none';
      }
    });

    function handleTelemetry(dev, file){
      // Summary line
      const gps = dev?.streams?.GPS5, acc = dev?.streams?.ACCL;
      const parts = [];
      parts.push(`Size: ${(file.size/1e6).toFixed(1)} MB`);
      parts.push(gps ? 'GPS ‚úì' : 'GPS ‚úó');
      parts.push(acc ? 'ACC ‚úì' : 'ACC ‚úó');
      if (gps?.samples?.length){
        const first=gps.samples[0]?.date||null; const last=gps.samples[gps.samples.length-1]?.date||null;
        if (first && last) parts.push(`Time: ${fmtDate(first)} ‚Üí ${fmtDate(last)}`);
      }
      metaEl.textContent = parts.join(' ‚Ä¢ ');

      // GPS points + speed series
      let gpsPoints = [];
      let speedSeries = [];
      if (gps?.samples?.length){
        const t0 = gps.samples[0].cts ?? 0;
        const ts = gps.timescale || 1000;
        gps.samples.forEach(s => {
          const v = s.value; // [lat, lon, alt, speed(m/s), ...]
          const lat = v?.[0], lon = v?.[1];
          const spd_mps = v?.[3];
          const tSec = toSeconds(s.cts, t0, ts);
          if (Number.isFinite(lat) && Number.isFinite(lon)) gpsPoints.push([lat, lon]);
          if (Number.isFinite(spd_mps)) speedSeries.push({ x:tSec, y: spd_mps*3.6 });
        });
      }
      if ((!speedSeries.length || speedSeries.every(p => !Number.isFinite(p.y))) && gps?.samples?.length>2){
        speedSeries = deriveSpeedFromGPS(gps).series;
        log('Speed derived from GPS distance/time because speed channel missing.');
      }

      // Accelerometer
      const ax=[], ay=[], az=[];
      if (acc?.samples?.length){
        const t0a = acc.samples[0].cts ?? 0;
        const ts  = acc.timescale || 1000;
        acc.samples.forEach(s=>{
          const v=s.value; const tSec=toSeconds(s.cts, t0a, ts);
          if (v && v.length>=3){ ax.push({x:tSec,y:v[0]}); ay.push({x:tSec,y:v[1]}); az.push({x:tSec,y:v[2]}); }
        });
      }

      // Map route
      if (gpsPoints.length){
        if (routeLayer) map.removeLayer(routeLayer);
        routeLayer = L.polyline(gpsPoints, { color:'#3aa7ff', weight:3 }).addTo(map);
        map.fitBounds(routeLayer.getBounds(), { padding:[20,20] });
        if (startMarker) map.removeLayer(startMarker);
        if (endMarker) map.removeLayer(endMarker);
        startMarker = L.circleMarker(gpsPoints[0], { radius:5, color:'#7dff9b' }).addTo(map).bindTooltip('Start');
        endMarker   = L.circleMarker(gpsPoints[gpsPoints.length-1], { radius:5, color:'#ff6b6b' }).addTo(map).bindTooltip('End');
      } else {
        map.setView([0,0], 2);
      }

      // Charts
      speedChart.data.datasets[0].data = speedSeries; speedChart.update();
      if (speedSeries.length){
        const maxKph = Math.max(...speedSeries.map(p=>p.y||0));
        const avgKph = speedSeries.reduce((a,b)=>a+(b.y||0),0)/speedSeries.length;
        speedInfo.textContent = `points: ${speedSeries.length} ‚Ä¢ max: ${maxKph.toFixed(1)} ‚Ä¢ avg: ${avgKph.toFixed(1)} km/h`;
      } else speedInfo.textContent = 'No speed track available.';

      accChart.data.datasets[0].data = ax;
      accChart.data.datasets[1].data = ay;
      accChart.data.datasets[2].data = az;
      accChart.update();
      accInfo.textContent = (ax.length+ay.length+az.length) ? `samples: ${Math.max(ax.length,ay.length,az.length)}` : 'No accelerometer data found.';
    }
  </script>
</body>
</html>
