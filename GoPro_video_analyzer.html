<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GoPro MP4 → Map + Speed + Accelerometer</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif;
      display: grid; grid-template-rows: auto 56vh auto; min-height: 100vh;
      background: #111; color: #eee;
    }
    header, footer { padding: 10px 14px; background: #1b1b1b; border-bottom: 1px solid #2a2a2a; }
    footer { border-top: 1px solid #2a2a2a; border-bottom: 0; display:flex; justify-content:space-between; align-items:center; }
    header h1 { font-size: 1.1rem; margin: 0 0 6px; }
    #controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    #status { font-size: 0.95rem; opacity: 0.85 }
    #map { height: 100%; }
    .dropzone { border: 2px dashed #3a3a3a; border-radius: 10px; padding: 12px 14px; display: inline-flex; gap: 10px; align-items: center; background: #151515; }
    .dropzone.dragover { border-color: #6fa8ff; background: #0f1725; }
    input[type=file] { accent-color: #6fa8ff; }

    #plots { padding: 8px 12px 14px; background:#0f0f0f; border-top:1px solid #2a2a2a; display:grid; gap:10px; }
    .chart-wrap { background:#151515; border:1px solid #262626; border-radius:10px; padding:8px; }
    .chart-wrap h3 { margin:4px 0 10px; font-size:0.95rem; font-weight:600; color:#ddd; }
    .placeholder { padding: 12px; color:#bbb; font-size: 0.9rem; }
    canvas { width:100%; height:220px; }

    details { background:#151515; border:1px solid #2a2a2a; border-radius:8px; padding:8px 10px; max-width: 1400px; margin: 8px 12px; }
    pre { margin:0; white-space:pre-wrap; word-break:break-word; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color:#ddd; }
  </style>
</head>
<body>
  <header>
    <h1>GoPro MP4 → Map + Speed + Accelerometer</h1>
    <div id="controls">
      <label class="dropzone" id="dropzone">
        <strong>Drop MP4 here</strong> or
        <input id="file" type="file" accept=".mp4,video/mp4" />
      </label>
      <span id="status">Loading modules…</span>
    </div>
  </header>

  <div id="map"></div>

  <section id="plots">
    <div class="chart-wrap">
      <h3>Speed (km/h)</h3>
      <div id="speedPlaceholder" class="placeholder" style="display:none;">No speed data found.</div>
      <canvas id="speedChart"></canvas>
    </div>
    <div class="chart-wrap">
      <h3>Accelerometer (m/s²)</h3>
      <div id="accPlaceholder" class="placeholder" style="display:none;">No accelerometer data found.</div>
      <canvas id="accChart"></canvas>
    </div>
  </section>

  <details id="debugBox" style="display:none;">
    <summary>Debug (auto-opens when few points are found)</summary>
    <pre id="debugPre"></pre>
  </details>

  <footer>
    <div>© OpenStreetMap contributors</div>
    <div>Tip: On HERO10 Black, enable <em>GPS</em> and start recording after GPS lock.</div>
  </footer>

<script type="module">
  import gpmfExtract from "https://esm.sh/gpmf-extract@latest";
  import goproTelemetry from "https://esm.sh/gopro-telemetry@latest";
  import Chart from "https://esm.sh/chart.js@4.4.4/auto";

  // ---------- helpers ----------
  const isArr = (x) => Array.isArray(x);
  const len = (x) => (Array.isArray(x) ? x.length : 0);
  const numberOrNull = (x) => Number.isFinite(Number(x)) ? Number(x) : null;

  // Normalize timestamp arrays to seconds (detect ms and divide by 1000)
  function normalizeTimesToSeconds(arr) {
    const t = (Array.isArray(arr) ? arr.slice() : []).map(x => Number.isFinite(+x) ? +x : null);
    const diffs = [];
    for (let i = 1; i < t.length; i++) {
      const a = t[i-1], b = t[i];
      if (Number.isFinite(a) && Number.isFinite(b)) diffs.push(b - a);
    }
    if (!diffs.length) return t;
    diffs.sort((a,b)=>a-b);
    const med = diffs[Math.floor(diffs.length/2)];
    if (med > 5) {
      for (let i = 0; i < t.length; i++) if (Number.isFinite(t[i])) t[i] = t[i] / 1000;
    }
    return t;
  }

  // Leaflet
  const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([20, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  let trackLayer;
  let speedChart, accChart;

  const statusEl = document.getElementById('status');
  const fileEl = document.getElementById('file');
  const dropzone = document.getElementById('dropzone');
  const debugBox = document.getElementById('debugBox');
  const debugPre = document.getElementById('debugPre');
  const speedPH = document.getElementById('speedPlaceholder');
  const accPH = document.getElementById('accPlaceholder');
  const setStatus = (m) => statusEl.textContent = m;

  setStatus('Modules ready. Load an .MP4 to extract GPS, speed and accelerometer.');

  // UI
  fileEl.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) await handleFile(f);
  });
  ['dragenter','dragover'].forEach(evt =>
    dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover'); })
  );
  ['dragleave','drop'].forEach(evt =>
    dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover'); })
  );
  dropzone.addEventListener('drop', async (e) => {
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (f) await handleFile(f);
  });

  // Main
  async function handleFile(file) {
    try {
      debugBox.style.display = 'none';
      debugPre.textContent = '';
      destroyCharts();
      speedPH.style.display = 'none';
      accPH.style.display = 'none';

      setStatus(`Reading "${file?.name ?? 'file'}"… (${file && Number.isFinite(file.size) ? (file.size/1048576).toFixed(1) : '?' } MB)`);

      setStatus('Extracting GPMF telemetry…');
      const gpmf = await gpmfExtract(file, { browserMode: true });
      if (!gpmf) throw new Error('gpmfExtract returned nothing (file may have no telemetry)');

      setStatus('Decoding telemetry (GPS + ACC)…');
      const telemetry = (await goproTelemetry(gpmf, {
        stream: ['GPS', 'ACCL'],
        repeatHeaders: true,
        tolerant: true,
        decimalPlaces: 7
      })) || {};

      // 1) GPS path
      const gps = collectGps(telemetry) || { used: [], latlngs: [], times: [], speedsRaw: [], preview: [] };
      if (Array.isArray(gps.latlngs) && gps.latlngs.length >= 2) {
        drawTrack(gps.latlngs);
      }

      // 2) Speed series
      const speed = buildSpeedSeries(gps) || { t: [], v: [] };

      // 3) ACC series
      const acc = collectAcc(telemetry) || { used: false, t: [], ax: [], ay: [], az: [] };

      // If GPS didn’t decode, show a helpful debug dump
      if (!Array.isArray(gps.latlngs) || gps.latlngs.length === 0) {
        const streamList = await goproTelemetry(gpmf, { streamList: true });
        debugPre.textContent =
          'No GPS points decoded.\n\nStream list:\n' + JSON.stringify(streamList, null, 2) +
          '\n\nGPS preview (first 10 samples):\n' + JSON.stringify((Array.isArray(gps.preview) ? gps.preview.slice(0,10) : []), null, 2);
        debugBox.style.display = 'block';
        debugBox.open = true;
      }

      // Charts (with guards)
      if (Array.isArray(speed.t) && Array.isArray(speed.v) && speed.t.length && speed.v.length) {
        drawSpeedChart(speed);
      } else {
        speedPH.style.display = 'block';
      }

      if (Array.isArray(acc.t) && acc.t.length) {
        drawAccChart(acc);
      } else {
        accPH.style.display = 'block';
      }

      // Footer status
      const distKm = (Array.isArray(gps.latlngs) && gps.latlngs.length ? totalDistanceKm(gps.latlngs).toFixed(2) : '0.00');
      const streamsUsed = [];
      if (Array.isArray(gps.used) && gps.used.length) streamsUsed.push('GPS');
      if (acc.used) streamsUsed.push('ACCL');
      setStatus(`Points: ${Array.isArray(gps.latlngs) ? gps.latlngs.length : 0} · Dist: ${distKm} km · Streams: ${streamsUsed.join(', ') || '—'}`);
    } catch (err) {
      console.error(err);
      setStatus('Failed: ' + (err && err.message ? err.message : err));
    }
  }

  // --- GPS extraction (returns arrays) ---
  function collectGps(telemetry) {
    const latlngs = [];
    const times = [];
    const speedsRaw = [];
    const preview = [];
    const used = [];

    for (const devId in (telemetry || {})) {
      const dev = telemetry[devId];
      const streams = dev && dev.streams;
      if (!streams) continue;

      for (const key of Object.keys(streams)) {
        if (!/^GPS/i.test(key)) continue;
        used.push(key);

        const stream = streams[key];
        const samples = isArr(stream?.samples) ? stream.samples : [];

        for (let i = 0; i < len(samples); i++) {
          const s = samples[i];
          if (len(preview) < 10) preview.push(s);
          const v = s?.value;

          let t = numberOrNull(s?.cts ?? s?.time ?? s?.Time ?? s?.timestamp ?? s?.Timestamp);
          if (t == null) t = i;

          let lat = null, lon = null, speedMs = null;
          if (v && typeof v === 'object' && !Array.isArray(v)) {
            for (const k of Object.keys(v)) {
              const nk = k.toLowerCase();
              if (lat === null && /(^|[^a-z])lat(itude)?/.test(nk)) lat = numberOrNull(v[k]);
              if (lon === null && /(^|[^a-z])lon(gitude)?/.test(nk)) lon = numberOrNull(v[k]);
              if (speedMs === null && /speed/.test(nk)) {
                const val = numberOrNull(v[k]);
                if (val != null) speedMs = /km\/?h|kph/.test(nk) ? (val / 3.6) : val;
              }
            }
          } else if (Array.isArray(v) && v.length >= 2) {
            lat = numberOrNull(v[0]);
            lon = numberOrNull(v[1]);
          }

          if (isFiniteLatLon(lat, lon)) {
            latlngs.push([lat, lon]);
            times.push(t);
            speedsRaw.push(speedMs);
          }
        }
      }
    }

    return { used: [...new Set(used)], latlngs, times, speedsRaw, preview };
  }

  // --- Speed series (km/h) ---
  function buildSpeedSeries(gps) {
    const Traw = isArr(gps?.times) ? gps.times : [];
    const P = isArr(gps?.latlngs) ? gps.latlngs : [];
    const S = isArr(gps?.speedsRaw) ? gps.speedsRaw : [];

    const T = normalizeTimesToSeconds(Traw);

    const t = [];
    const vKph = [];

    for (let i = 0; i < len(P); i++) {
      const tNow = numberOrNull(T[i]);
      if (S[i] != null) {
        t.push(tNow ?? i);
        vKph.push(S[i] * 3.6); // S is m/s -> km/h
      } else if (i > 0) {
        const tPrev = numberOrNull(T[i-1]) ?? (i-1);
        const dt = (tNow ?? i) - tPrev;
        const dMeters = haversineMeters(P[i-1], P[i]);
        const speedMs = (dt > 0.001) ? (dMeters / dt) : 0;
        t.push(tNow ?? i);
        vKph.push(speedMs * 3.6);
      } else {
        t.push(tNow ?? i);
        vKph.push(0);
      }
    }

    // Clean
    const tC = [], vC = [];
    for (let i = 0; i < len(t); i++) {
      if (Number.isFinite(t[i]) && Number.isFinite(vKph[i])) {
        tC.push(t[i]); vC.push(vKph[i]);
      }
    }

    return decimateSeries(tC, vC, 6000);
  }

  // --- Accelerometer (m/s²) ---
  function collectAcc(telemetry) {
    const t = [], ax = [], ay = [], az = [];
    let used = false;
    let unitType = 'm/s^2';

    for (const devId in (telemetry || {})) {
      const dev = telemetry[devId];
      const streams = dev && dev.streams;
      if (!streams) continue;

      for (const key of Object.keys(streams)) {
        if (!/^ACCL/i.test(key)) continue;
        used = true;

        const stream = streams[key];
        const units = stream?.units?.value;
        if (isArr(units) && units.some(u => typeof u === 'string' && /(^|[^a-z])g([^a-z]|$)/i.test(u))) {
          unitType = 'g';
        }

        const samples = isArr(stream?.samples) ? stream.samples : [];
        for (let i = 0; i < len(samples); i++) {
          const s = samples[i];
          const v = s?.value;
          const time = numberOrNull(s?.cts ?? s?.time ?? s?.Time ?? s?.timestamp);

          let x=null,y=null,z=null;
          if (v && typeof v === 'object' && !Array.isArray(v)) {
            for (const k of Object.keys(v)) {
              const nk = k.toLowerCase();
              if (x===null && /\bx\b/.test(nk)) x = numberOrNull(v[k]);
              if (y===null && /\by\b/.test(nk)) y = numberOrNull(v[k]);
              if (z===null && /\bz\b/.test(nk)) z = numberOrNull(v[k]);
            }
          } else if (Array.isArray(v) && v.length >= 3) {
            x = numberOrNull(v[0]); y = numberOrNull(v[1]); z = numberOrNull(v[2]);
          }

          if (x!=null && y!=null && z!=null) {
            const conv = (unitType === 'g') ? 9.80665 : 1;
            t.push(time ?? i);
            ax.push(x * conv);
            ay.push(y * conv);
            az.push(z * conv);
          }
        }
      }
    }

    // Clean NaNs
    const tC=[], axC=[], ayC=[], azC=[];
    for (let i=0; i<len(t); i++) {
      if ([t[i], ax[i], ay[i], az[i]].every(Number.isFinite)) {
        tC.push(t[i]); axC.push(ax[i]); ayC.push(ay[i]); azC.push(az[i]);
      }
    }

    // Normalize time base to seconds before decimation
    const tSec = normalizeTimesToSeconds(tC);
    const dec = decimateMultiSeries(tSec, [axC, ayC, azC], 6000);
    return { used, t: dec.t, ax: dec.series[0] || [], ay: dec.series[1] || [], az: dec.series[2] || [] };
  }

  // --- Drawing ---
  function drawTrack(latlngs) {
    if (trackLayer) { trackLayer.remove(); trackLayer = null; }
    trackLayer = L.layerGroup().addTo(map);

    const line = L.polyline(latlngs, { weight: 4, opacity: 0.9 }).addTo(trackLayer);
    const start = latlngs[0];
    const end = latlngs[len(latlngs) - 1];
    L.circleMarker(start, { radius: 6, color: '#1ec31e', weight: 2, fillOpacity: 0.8 }).addTo(trackLayer).bindPopup('Start');
    L.circleMarker(end, { radius: 6, color: '#ff4d4f', weight: 2, fillOpacity: 0.8 }).addTo(trackLayer).bindPopup('End');
    map.fitBounds(line.getBounds(), { padding: [20, 20] });
  }

  function drawSpeedChart(speed) {
    const ctx = document.getElementById('speedChart');
    if (speedChart) { speedChart.destroy(); speedChart = null; }
    const N = Math.min(len(speed.t), len(speed.v));
    const data = Array.from({length: N}, (_,i)=>({ x: speed.t[i], y: speed.v[i] }));
    speedChart = new Chart(ctx, {
      type: 'line',
      data: { datasets: [{ label: 'Speed', data, pointRadius: 0, borderWidth: 2, tension: 0.1 }] },
      options: {
        animation: false, responsive: true, maintainAspectRatio: false,
        scales: {
          x: { type: 'linear', title: { text: 'Time (s)', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } },
          y: { title: { text: 'km/h', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } }
        },
        plugins: { legend: { labels: { color:'#ddd' } } }
      }
    });
  }

  function drawAccChart(acc) {
    const ctx = document.getElementById('accChart');
    if (accChart) { accChart.destroy(); accChart = null; }
    const mk = (label, arr) => ({ label, data: acc.t.map((x,i)=>({x, y: arr[i]})), pointRadius: 0, borderWidth: 2, tension: 0.1 });
    accChart = new Chart(ctx, {
      type: 'line',
      data: { datasets: [ mk('Ax', acc.ax), mk('Ay', acc.ay), mk('Az', acc.az) ] },
      options: {
        animation: false, responsive: true, maintainAspectRatio: false,
        scales: {
          x: { type: 'linear', title: { text: 'Time (s)', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } },
          y: { title: { text: 'm/s²', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } }
        },
        plugins: { legend: { labels: { color:'#ddd' } } }
      }
    });
  }

  function destroyCharts() {
    if (speedChart) { speedChart.destroy(); speedChart = null; }
    if (accChart) { accChart.destroy(); accChart = null; }
  }

  // --- Utility helpers ---
  function haversineMeters(a, b) {
    if (!isArr(a) || !isArr(b) || len(a) < 2 || len(b) < 2) return 0;
    const R = 6371000;
    const φ1 = a[0]*Math.PI/180, φ2 = b[0]*Math.PI/180;
    const dφ = (b[0]-a[0])*Math.PI/180, dλ = (b[1]-a[1])*Math.PI/180;
    const s = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
    return 2*R*Math.asin(Math.sqrt(s));
  }
  function totalDistanceKm(latlngs) {
    let d = 0;
    for (let i=1;i<len(latlngs);i++) d += haversineMeters(latlngs[i-1], latlngs[i]);
    return d/1000;
  }
  function decimateSeries(tIn, yIn, maxPts) {
    const t = isArr(tIn) ? tIn : [];
    const y = isArr(yIn) ? yIn : [];
    const n = Math.min(len(t), len(y));
    if (n <= 0) return { t: [], v: [] };
    if (!Number.isFinite(maxPts) || maxPts <= 0 || n <= maxPts) return { t: t.slice(0,n), v: y.slice(0,n) };
    const step = Math.max(1, Math.ceil(n / maxPts));
    const td=[], yd=[];
    for (let i=0; i<n; i+=step) { td.push(t[i]); yd.push(y[i]); }
    return { t: td, v: yd };
  }
  function decimateMultiSeries(tIn, seriesIn, maxPts) {
    const t = isArr(tIn) ? tIn : [];
    const series = isArr(seriesIn) ? seriesIn.map(a => isArr(a) ? a : []) : [];
    const lengths = [len(t), ...series.map(a => len(a))].filter(n => Number.isFinite(n));
    const n = lengths.length ? Math.min(...lengths) : 0;
    if (n <= 0) return { t: [], series: series.map(()=>[]) };
    if (!Number.isFinite(maxPts) || maxPts <= 0 || n <= maxPts) {
      return { t: t.slice(0,n), series: series.map(a=>a.slice(0,n)) };
    }
    const step = Math.max(1, Math.ceil(n / maxPts));
    const td=[]; const out = series.map(()=>[]);
    for (let i=0;i<n;i+=step) {
      td.push(t[i]);
      for (let k=0;k<series.length;k++) out[k].push(series[k][i]);
    }
    return { t: td, series: out };
  }
  function isFiniteLatLon(lat, lon) {
    return Number.isFinite(lat) && Number.isFinite(lon) &&
           Math.abs(lat) <= 90 && Math.abs(lon) <= 180 &&
           !(lat === 0 && lon === 0);
  }
</script>
</body>
</html>
