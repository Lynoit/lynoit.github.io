<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GoPro MP4 → Map + Speed + Accelerometer</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Suppress favicon 404 -->
  <link rel="icon" href="data:,">

  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0; font-family: system-ui, Arial, sans-serif;
      display: grid; grid-template-rows: auto 56vh auto; min-height: 100vh;
      background: #111; color: #eee;
    }
    header, footer { padding: 10px 14px; background: #1b1b1b; border-bottom: 1px solid #2a2a2a; }
    footer { border-top: 1px solid #2a2a2a; border-bottom: 0; display:flex; justify-content:space-between; align-items:center; }
    header h1 { font-size: 1.1rem; margin: 0 0 6px; }
    #controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    #status { font-size: 0.95rem; opacity: 0.85 }
    #map { height: 100%; }
    .dropzone { border: 2px dashed #3a3a3a; border-radius: 10px; padding: 12px 14px; display: inline-flex; gap: 10px; align-items: center; background: #151515; }
    .dropzone.dragover { border-color: #6fa8ff; background: #0f1725; }
    input[type=file] { accent-color: #6fa8ff; }

    #plots { padding: 8px 12px 14px; background:#0f0f0f; border-top:1px solid #2a2a2a; display:grid; gap:10px; }
    .chart-wrap { background:#151515; border:1px solid #262626; border-radius:10px; padding:8px; }
    .chart-wrap h3 { margin:4px 0 10px; font-size:0.95rem; font-weight:600; color:#ddd; }
    .placeholder { padding: 12px; color:#bbb; font-size: 0.9rem; }
    canvas { width:100%; height:220px; }

    details { background:#151515; border:1px solid #2a2a2a; border-radius:8px; padding:8px 10px; max-width: 1400px; margin: 8px 12px; }
    pre { margin:0; white-space:pre-wrap; word-break:break-word; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color:#ddd; }
  </style>
</head>
<body>
  <header>
    <h1>GoPro MP4 → Map + Speed + Accelerometer</h1>
    <div id="controls">
      <label class="dropzone" id="dropzone">
        <strong>Drop MP4 here</strong> or
        <input id="file" type="file" accept=".mp4,video/mp4" />
      </label>
      <span id="status">Loading modules…</span>
    </div>
  </header>

  <div id="map"></div>

  <section id="plots">
    <div class="chart-wrap">
      <h3>Speed (km/h)</h3>
      <div id="speedPlaceholder" class="placeholder" style="display:none;">No speed data found.</div>
      <canvas id="speedChart"></canvas>
    </div>
    <div class="chart-wrap">
      <h3>Accelerometer (m/s²)</h3>
      <div id="accPlaceholder" class="placeholder" style="display:none;">No accelerometer data found.</div>
      <canvas id="accChart"></canvas>
    </div>
  </section>

  <details id="debugBox" style="display:none;">
    <summary>Debug (auto-opens when few points are found)</summary>
    <pre id="debugPre"></pre>
  </details>

  <footer>
    <div>© OpenStreetMap contributors</div>
    <div>Tip: On HERO10 Black, enable <em>GPS</em> and start recording after GPS lock.</div>
  </footer>

<script type="module">
  // ——— pinned, real versions ———
  const gpmfExtract = (await import("https://esm.sh/gpmf-extract@0.3.2?bundle")).default;
  const goproTelemetry = (await import("https://esm.sh/gopro-telemetry@1.2.9?bundle")).default;
  const Chart = (await import("https://esm.sh/chart.js@4.4.4/auto?bundle")).default;

  // ---------- helpers ----------
  const isArr = (x) => Array.isArray(x);
  const len  = (x) => (Array.isArray(x) ? x.length : 0);
  const numberOrNull = (x) => Number.isFinite(Number(x)) ? Number(x) : null;
  const safeSlice = (arr, n) => (isArr(arr) ? arr.slice(0, n) : []);
  const safeJoin  = (arr, sep) => (isArr(arr) && len(arr) ? arr.join(sep) : '');

  function normalizeTimesToSeconds(arr) {
    const t = (isArr(arr) ? arr.slice() : []).map(x => Number.isFinite(+x) ? +x : null);
    const diffs = [];
    for (let i = 1; i < t.length; i++) {
      const a = t[i-1], b = t[i];
      if (Number.isFinite(a) && Number.isFinite(b)) diffs.push(b - a);
    }
    if (!len(diffs)) return t;
    diffs.sort((a,b)=>a-b);
    const med = diffs[Math.floor(diffs.length/2)];
    if (med > 5) {
      for (let i = 0; i < t.length; i++) if (Number.isFinite(t[i])) t[i] = t[i] / 1000;
    }
    return t;
  }

  // ---------- Leaflet ----------
  const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([20, 0], 2);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  let trackLayer;
  let speedChart, accChart;

  const statusEl = document.getElementById('status');
  const fileEl   = document.getElementById('file');
  const dropzone = document.getElementById('dropzone');
  const debugBox = document.getElementById('debugBox');
  const debugPre = document.getElementById('debugPre');
  const speedPH  = document.getElementById('speedPlaceholder');
  const accPH    = document.getElementById('accPlaceholder');
  const setStatus = (m) => { try { statusEl.textContent = String(m ?? ''); } catch {} };

  setStatus('Modules ready. Load an .MP4 to extract GPS, speed and accelerometer.');

  // ---------- UI ----------
  fileEl.addEventListener('change', async (e) => {
    const f = e.target.files && e.target.files[0];
    if (f) await handleFile(f);
  });
  ['dragenter','dragover'].forEach((evt) =>
    dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.add('dragover'); })
  );
  ['dragleave','drop'].forEach((evt) =>
    dropzone.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); dropzone.classList.remove('dragover'); })
  );
  dropzone.addEventListener('drop', async (e) => {
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (f) await handleFile(f);
  });

  // ---------- Main ----------
  async function handleFile(file) {
    try {
      debugBox.style.display = 'none';
      debugPre.textContent = '';
      destroyCharts();
      speedPH.style.display = 'none';
      accPH.style.display = 'none';

      const fname = (file && typeof file.name === 'string') ? file.name : 'file';
      const fmb   = (file && Number.isFinite(file.size)) ? (file.size/1048576).toFixed(1) : '?';
      setStatus(`Reading "${fname}"… (${fmb} MB)`);

      setStatus('Extracting GPMF telemetry…');
      const gpmf = await gpmfExtract(file, { browserMode: true });
      if (!gpmf) throw new Error('gpmfExtract returned nothing (file may have no telemetry)');

      setStatus('Decoding telemetry (GPS + ACC)…');

      let telemetry = null;
      try {
        telemetry = await goproTelemetry(gpmf, {
          stream: ['GPS', 'ACCL'],
          repeatHeaders: true,
          tolerant: true
        });
      } catch (e) {
        console.warn('Primary decode failed, retrying with minimal options:', e);
        telemetry = await goproTelemetry(gpmf, { tolerant: true });
      }
      if (!telemetry || typeof telemetry !== 'object') throw new Error('Telemetry decode produced no object');

      // GPS
      const gps = collectGps(telemetry) || { used: [], latlngs: [], times: [], speedsRaw: [], preview: [] };
      if (len(gps.latlngs) >= 2) drawTrack(gps.latlngs);

      // Speed
      const speed = buildSpeedSeries(gps) || { t: [], v: [] };

      // ACC
      const acc = collectAcc(telemetry) || { used: false, t: [], ax: [], ay: [], az: [] };

      // Debug info if missing/short
      const wantDebug = (len(gps.latlngs) < 2) || (len(speed.t) === 0) || (len(acc.t) === 0);
      if (wantDebug) {
        let streamList = null;
        try { streamList = await goproTelemetry(gpmf, { streamList: true }); } catch {}
        const dbgA = [
          `GPS points: ${len(gps.latlngs)}`,
          `Speed samples: ${len(speed.t)}`,
          `ACC samples: ${len(acc.t)}`,
          '',
          'Streams present (from streamList):',
          JSON.stringify(streamList ?? '(failed to read)', null, 2),
          '',
          'GPS preview (first 10 decoded samples):',
          JSON.stringify(safeSlice(gps.preview, 10), null, 2),
          '',
          'ACC preview (first 10 decoded samples):',
          JSON.stringify(safeSlice(acc.preview ?? [], 10), null, 2)
        ];
        debugPre.textContent = dbgA.join('\n');
        debugBox.style.display = 'block';
        debugBox.open = true;
      }

      // Charts (guarded)
      if (len(speed.t) && len(speed.v)) drawSpeedChart(speed); else speedPH.style.display = 'block';
      if (len(acc.t)) drawAccChart(acc); else accPH.style.display = 'block';

      // Footer status
      const distKm = (len(gps.latlngs) ? totalDistanceKm(gps.latlngs).toFixed(2) : '0.00');
      const streamsUsed = [];
      if (len(gps.used)) streamsUsed.push('GPS');
      if (acc.used) streamsUsed.push('ACCL');
      const streamsUsedStr = safeJoin(streamsUsed, ', ');
      setStatus(`Points: ${len(gps.latlngs)} · Dist: ${distKm} km · Streams: ${streamsUsedStr || '—'}`);
    } catch (err) {
      console.error(err);
      setStatus('Failed: ' + (err && err.message ? err.message : err));
    }
  }

  // ---------- Stream traversal helpers ----------
  function asSamples(stream) {
    // Accept: array of samples OR object with .samples array OR object that itself is a sample
    if (isArr(stream)) return stream;
    if (isArr(stream?.samples)) return stream.samples;
    if (stream && typeof stream === 'object') return [stream]; // single sample object fallback
    return [];
  }
  function streamEntries(streams) {
    // Accept: object map {name: stream} OR array [{name, samples}] OR array of streams (no names)
    const out = [];
    if (!streams) return out;
    if (isArr(streams)) {
      for (const s of streams) {
        if (s && typeof s === 'object' && ('name' in s || 'label' in s)) {
          out.push({ name: String(s.name ?? s.label ?? 'UNKNOWN'), stream: s });
        } else {
          out.push({ name: 'UNKNOWN', stream: s });
        }
      }
    } else if (typeof streams === 'object') {
      for (const k of Object.keys(streams)) out.push({ name: k, stream: streams[k] });
    }
    return out;
  }

  // ---------- Telemetry extractors ----------
  function collectGps(telemetry) {
    const latlngs = [];
    const times = [];
    const speedsRaw = [];
    const preview = [];
    const used = [];

    for (const devId in (telemetry || {})) {
      const dev = telemetry[devId];
      const streams = dev && dev.streams;
      if (!streams) continue;

      for (const { name, stream } of streamEntries(streams)) {
        if (!/^gps/i.test(name)) continue;
        used.push(name);

        const samples = asSamples(stream);
        for (let i = 0; i < len(samples); i++) {
          const s = samples[i];
          if (s && len(preview) < 10) preview.push(s);

          const v = s?.value ?? s?.vals ?? s?.val ?? s; // tolerate raw object/array
          let t = numberOrNull(s?.cts ?? s?.time ?? s?.Time ?? s?.timestamp ?? s?.Timestamp);
          if (t == null) t = i;

          let lat = null, lon = null, speedMs = null;

          if (v && typeof v === 'object' && !Array.isArray(v)) {
            for (const k of Object.keys(v)) {
              const nk = k.toLowerCase();
              if (lat === null && /(^|[^a-z])lat(itude)?/.test(nk)) lat = numberOrNull(v[k]);
              if (lon === null && /(^|[^a-z])lon(gitude)?/.test(nk)) lon = numberOrNull(v[k]);
              if (speedMs === null && /(^|[^a-z])(?:2d|3d)?\s*speed/.test(nk)) {
                const val = numberOrNull(v[k]);
                if (val != null) speedMs = /km\/?h|kph/.test(nk) ? (val / 3.6) : val; // normalize to m/s
              }
            }
          } else if (isArr(v)) {
            // Typical GPS array: [lat, lon, alt, 2D speed, 3D speed, ...]
            lat = numberOrNull(v[0]);
            lon = numberOrNull(v[1]);
            // Prefer 2D speed if present, else 3D
            const s2d = numberOrNull(v[3]);
            const s3d = numberOrNull(v[4]);
            speedMs = s2d ?? s3d ?? null;
          }

          if (isFiniteLatLon(lat, lon)) {
            latlngs.push([lat, lon]);
            times.push(t);
            speedsRaw.push(speedMs);
          }
        }
      }
    }

    return { used: [...new Set(used)], latlngs, times, speedsRaw, preview };
  }

  function buildSpeedSeries(gps) {
    const Traw = isArr(gps?.times) ? gps.times : [];
    const P    = isArr(gps?.latlngs) ? gps.latlngs : [];
    const S    = isArr(gps?.speedsRaw) ? gps.speedsRaw : [];

    const T = normalizeTimesToSeconds(Traw);

    const t = [];
    const vKph = [];

    for (let i = 0; i < len(P); i++) {
      const tNow = numberOrNull(T[i]);
      if (S[i] != null && Number.isFinite(S[i])) {
        t.push(tNow ?? i);
        vKph.push(S[i] * 3.6); // m/s → km/h
      } else if (i > 0) {
        const tPrev = numberOrNull(T[i-1]) ?? (i-1);
        const dt = (tNow ?? i) - tPrev;
        const dMeters = haversineMeters(P[i-1], P[i]);
        const speedMs = (dt > 0.001) ? (dMeters / dt) : 0;
        t.push(tNow ?? i);
        vKph.push(speedMs * 3.6);
      } else {
        t.push(tNow ?? i);
        vKph.push(0);
      }
    }

    // Clean & decimate
    const tC = [], vC = [];
    for (let i = 0; i < len(t); i++) {
      if (Number.isFinite(t[i]) && Number.isFinite(vKph[i])) {
        tC.push(t[i]); vC.push(vKph[i]);
      }
    }
    return decimateSeries(tC, vC, 6000);
  }

  function collectAcc(telemetry) {
    const t = [], ax = [], ay = [], az = [];
    let used = false;
    let unitType = 'm/s^2';
    const preview = [];

    for (const devId in (telemetry || {})) {
      const dev = telemetry[devId];
      const streams = dev && dev.streams;
      if (!streams) continue;

      for (const { name, stream } of streamEntries(streams)) {
        if (!/^accl/i.test(name)) continue;
        used = true;

        // units hint (if present)
        const units = stream?.units?.value ?? stream?.units;
        if (isArr(units) && units.some(u => typeof u === 'string' && /(^|[^a-z])g([^a-z]|$)/i.test(u))) {
          unitType = 'g';
        } else if (typeof units === 'string' && /(^|[^a-z])g([^a-z]|$)/i.test(units)) {
          unitType = 'g';
        }

        const samples = asSamples(stream);
        for (let i = 0; i < len(samples); i++) {
          const s = samples[i];
          if (s && len(preview) < 10) preview.push(s);
          const v = s?.value ?? s?.vals ?? s?.val ?? s;
          const time = numberOrNull(s?.cts ?? s?.time ?? s?.Time ?? s?.timestamp);

          let x=null,y=null,z=null;
          if (v && typeof v === 'object' && !Array.isArray(v)) {
            for (const k of Object.keys(v)) {
              const nk = k.toLowerCase();
              if (x===null && /\bx\b/.test(nk)) x = numberOrNull(v[k]);
              if (y===null && /\by\b/.test(nk)) y = numberOrNull(v[k]);
              if (z===null && /\bz\b/.test(nk)) z = numberOrNull(v[k]);
            }
          } else if (isArr(v)) {
            // Typical ACCL array: [Ax, Ay, Az]
            x = numberOrNull(v[0]); y = numberOrNull(v[1]); z = numberOrNull(v[2]);
          }

          if (x!=null && y!=null && z!=null) {
            const conv = (unitType === 'g') ? 9.80665 : 1;
            t.push(time ?? i);
            ax.push(x * conv);
            ay.push(y * conv);
            az.push(z * conv);
          }
        }
      }
    }

    // Clean
    const tC=[], axC=[], ayC=[], azC=[];
    for (let i=0; i<len(t); i++) {
      if ([t[i], ax[i], ay[i], az[i]].every(Number.isFinite)) {
        tC.push(t[i]); axC.push(ax[i]); ayC.push(ay[i]); azC.push(az[i]);
      }
    }

    const tSec = normalizeTimesToSeconds(tC);
    const dec  = decimateMultiSeries(tSec, [axC, ayC, azC], 6000);
    return { used, t: dec.t, ax: dec.series[0] || [], ay: dec.series[1] || [], az: dec.series[2] || [], preview };
  }

  // ---------- Drawing ----------
  function drawTrack(latlngs) {
    if (trackLayer) { trackLayer.remove(); trackLayer = null; }
    trackLayer = L.layerGroup().addTo(map);

    const line = L.polyline(latlngs, { weight: 4, opacity: 0.9 }).addTo(trackLayer);
    const start = latlngs[0];
    const end   = latlngs[len(latlngs) - 1];
    L.circleMarker(start, { radius: 6, color: '#1ec31e', weight: 2, fillOpacity: 0.8 }).addTo(trackLayer).bindPopup('Start');
    L.circleMarker(end,   { radius: 6, color: '#ff4d4f', weight: 2, fillOpacity: 0.8 }).addTo(trackLayer).bindPopup('End');
    map.fitBounds(line.getBounds(), { padding: [20, 20] });
  }

  function drawSpeedChart(speed) {
    const ctx = document.getElementById('speedChart');
    if (speedChart) { speedChart.destroy(); speedChart = null; }
    const N = Math.min(len(speed.t), len(speed.v));
    const data = Array.from({length: N}, (_,i)=>({ x: speed.t[i], y: speed.v[i] }));
    speedChart = new Chart(ctx, {
      type: 'line',
      data: { datasets: [{ label: 'Speed', data, pointRadius: 0, borderWidth: 2, tension: 0.1 }] },
      options: {
        animation: false, responsive: true, maintainAspectRatio: false,
        scales: {
          x: { type: 'linear', title: { text: 'Time (s)', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } },
          y: { title: { text: 'km/h', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } }
        },
        plugins: { legend: { labels: { color:'#ddd' } } }
      }
    });
  }

  function drawAccChart(acc) {
    const ctx = document.getElementById('accChart');
    if (accChart) { accChart.destroy(); accChart = null; }
    const mk = (label, arr) => ({ label, data: acc.t.map((x,i)=>({x, y: arr[i]})), pointRadius: 0, borderWidth: 2, tension: 0.1 });
    accChart = new Chart(ctx, {
      type: 'line',
      data: { datasets: [ mk('Ax', acc.ax), mk('Ay', acc.ay), mk('Az', acc.az) ] },
      options: {
        animation: false, responsive: true, maintainAspectRatio: false,
        scales: {
          x: { type: 'linear', title: { text: 'Time (s)', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } },
          y: { title: { text: 'm/s²', display: true }, ticks: { color:'#bbb' }, grid: { color:'#222' } }
        },
        plugins: { legend: { labels: { color:'#ddd' } } }
      }
    });
  }

  function destroyCharts() {
    if (speedChart) { speedChart.destroy(); speedChart = null; }
    if (accChart)   { accChart.destroy();   accChart   = null; }
  }

  // ---------- Utilities ----------
  function haversineMeters(a, b) {
    if (!isArr(a) || !isArr(b) || len(a) < 2 || len(b) < 2) return 0;
    const R = 6371000;
    const φ1 = a[0]*Math.PI/180, φ2 = b[0]*Math.PI/180;
    const dφ = (b[0]-a[0])*Math.PI/180, dλ = (b[1]-a[1])*Math.PI/180;
    const s = Math.sin(dφ/2)**2 + Math.cos(φ1)*Math.cos(φ2)*Math.sin(dλ/2)**2;
    return 2*R*Math.asin(Math.sqrt(s));
  }
  function totalDistanceKm(latlngs) {
    let d = 0;
    for (let i=1;i<len(latlngs);i++) d += haversineMeters(latlngs[i-1], latlngs[i]);
    return d/1000;
  }
  function decimateSeries(tIn, yIn, maxPts) {
    const t = isArr(tIn) ? tIn : [];
    const y = isArr(yIn) ? yIn : [];
    const n = Math.min(len(t), len(y));
    if (n <= 0) return { t: [], v: [] };
    if (!Number.isFinite(maxPts) || maxPts <= 0 || n <= maxPts) return { t: t.slice(0,n), v: y.slice(0,n) };
    const step = Math.max(1, Math.ceil(n / maxPts));
    const td=[], yd=[];
    for (let i=0; i<n; i+=step) { td.push(t[i]); yd.push(y[i]); }
    return { t: td, v: yd };
  }
  function decimateMultiSeries(tIn, seriesIn, maxPts) {
    const t = isArr(tIn) ? tIn : [];
    const series = isArr(seriesIn) ? seriesIn.map(a => isArr(a) ? a : []) : [];
    const lengths = [len(t), ...series.map(a => len(a))].filter(n => Number.isFinite(n));
    const n = lengths.length ? Math.min(...lengths) : 0;
    if (n <= 0) return { t: [], series: series.map(()=>[]) };
    if (!Number.isFinite(maxPts) || maxPts <= 0 || n <= maxPts) {
      return { t: t.slice(0,n), series: series.map(a=>a.slice(0,n)) };
    }
    const step = Math.max(1, Math.ceil(n / maxPts));
    const td=[]; const out = series.map(()=>[]);
    for (let i=0;i<n;i+=step) {
      td.push(t[i]);
      for (let k=0;k<series.length;k++) out[k].push(series[k][i]);
    }
    return { t: td, series: out };
  }
  function isFiniteLatLon(lat, lon) {
    return Number.isFinite(lat) && Number.isFinite(lon) &&
           Math.abs(lat) <= 90 && Math.abs(lon) <= 180 &&
           !(lat === 0 && lon === 0);
  }
</script>
</body>
</html>
