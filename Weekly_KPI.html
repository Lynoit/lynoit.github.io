<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>KPI Scoring Visualizer</title>
  <link rel="icon" href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg'/%3e">
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    :root{ --bg:#ffffff; --ink:#111; --muted:#666; --card:#f6f7fb; }
    html,body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,Arial; color:var(--ink); background:var(--bg);}

    /* Top tabs */
    .topbar{ position:sticky; top:0; z-index:5; background:#fff; border-bottom:1px solid #eef1fb; }
    .tabs{ display:flex; gap:8px; padding:10px 16px; }
    .tab{ appearance:none; border:none; border-radius:999px; padding:8px 14px; cursor:pointer; font-weight:600; background:#e9ecf5; }
    .tab.active{ background:#111; color:#fff; }

    .container{padding:16px;}
    .charts{display:grid; grid-template-columns:repeat(auto-fit,minmax(680px,1fr)); gap:16px;}
    .panel{background:#f6f7fb; border-radius:14px; padding:12px; box-shadow:0 4px 16px rgba(0,0,0,.06);}
    .chart-card{background:white; border-radius:14px; padding:10px; box-shadow:0 3px 12px rgba(0,0,0,.08); position:relative}
    .summary-card{ grid-column: 1 / -1; display:grid; justify-content:center; }
    .download{position:absolute; left:12px; top:12px; font-size:12px; background:#f0f2f8; color:#222; padding:6px 8px; border-radius:8px; cursor:pointer}
    .small{font-size:12px; color:#666}
    .link{ color:#1f3de3; text-decoration:underline; cursor:pointer; }

    /* Summary table */
    .summary-title{font-weight:700; font-size:16px; margin:4px 0 8px 0; text-align:center}
    .summary-table{ display:inline-table; margin:6px 0 10px; table-layout:auto; border-collapse:separate; border-spacing:0; font-size:12px; }
    .summary-table th, .summary-table td{ padding:8px 10px; text-align:left; border-bottom:1px solid #eef1fb; vertical-align:middle; }
    .summary-table th{ background:#f6f7fb; font-weight:700; }
    .software-cell{ display:inline-block; max-width:min(52vw, 680px); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; vertical-align:bottom; }
    .summary-chip{ display:inline-block; padding:2px 8px; border-radius:999px; border:1px solid #e9ecf5; font-weight:600; }

    /* Column alignment via classes */
    .summary-table th.col-date,    .summary-table td.col-date    { text-align:center; white-space:nowrap; }
    .summary-table th.col-weather, .summary-table td.col-weather { text-align:center; white-space:nowrap; }
    .summary-table th.col-avg,     .summary-table td.col-avg     { text-align:right;  white-space:nowrap; }
    .summary-table th.col-score,   .summary-table td.col-score   { text-align:center; white-space:nowrap; width:1%; }
    .summary-table th.col-rating,  .summary-table td.col-rating  { white-space:nowrap; }
    .summary-table th.col-note,    .summary-table td.col-note    { text-align:center; white-space:nowrap; }

    /* KPI × Software matrix tables */
    .matrix-wrap{ margin:6px 0 6px; overflow:auto; max-width:100%; }
    .matrix-title{ font-weight:700; font-size:16px; text-align:center; margin:2px 0 6px; }
    .matrix-sub{ font-weight:600; font-size:12px; color:#555; margin:0 0 10px; text-align:center; }
    .matrix-table{ border-collapse:separate; border-spacing:0; font-size:12px; min-width:520px; margin:0 auto; }
    .matrix-table th, .matrix-table td{ padding:6px 8px; border-bottom:1px solid #eef1fb; }
    .matrix-table th{ background:#f6f7fb; position:sticky; top:0; z-index:1; }
    .matrix-table th.software{ text-align:center; white-space:nowrap; }
    .matrix-table td.num{ text-align:right; white-space:nowrap; }
    .matrix-table td.target, .matrix-table th.target{ text-align:right; white-space:nowrap; }

    /* Calendar trio (simple layout helpers) */
    .cal-title{ font-weight:700; font-size:14px; margin:2px 0 8px; text-align:center; }
    .cal-grid{ display:grid; grid-template-columns:repeat(3, minmax(220px, 1fr)); gap:16px; padding:6px 10px 12px; }
    .cal-col-title{ font-weight:600; font-size:13px; margin:0 0 4px; }

    /* HTML KPI table wrapper */
    .kpi-table-wrap{ margin-top:8px; }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="tabs">
      <button class="tab active" data-mode="internal" aria-pressed="true">Internal</button>
      <button class="tab" data-mode="external" aria-pressed="false">External</button>
    </div>
  </div>

  <div class="container">
    <div class="panel">
      <div id="charts" class="charts"></div>
    </div>
  </div>

  <!-- Modal -->
  <div id="modalBackdrop" class="modal-backdrop" aria-hidden="true" style="display:none">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <header>
        <h2 id="modalTitle">Release Note</h2>
        <button class="close" id="modalClose" aria-label="Close">Close</button>
      </header>
      <div class="content" id="modalContent"></div>
    </div>
  </div>

<script>
/* ==================== CONFIG ==================== */
const DATA_CSV = 'weekly_kpi_data.csv';
const RN_FETCH_MODE = 'auto';                 // 'auto' | 'manifest' | 'off'
const RN_MANIFEST_FILE = 'release_notes_manifest.json';
const DEFAULT_THRESH_STR = '100,60,40,30,20,15,10,5,3,2';
const SCORE_THRESHOLDS = [100,50,20,10,5,2,1.5,1,0.5,0];
const LS_KEY = 'segRadarKPI.thresholds';

const MODES = { INTERNAL:'internal', EXTERNAL:'external' };
let CURRENT_MODE = MODES.INTERNAL;

// Optional: ?mode=external in URL
const urlMode = new URLSearchParams(location.search).get('mode');
if (urlMode && (urlMode.toLowerCase() in MODES)) CURRENT_MODE = urlMode.toLowerCase();

// Which cards are shown when mode = EXTERNAL (hard-coded)
const EXTERNAL_CARD_VISIBILITY = {
  summary: false,              // Summary Weekly KPI
  calendar: false,             // Activity & weather statistics (calendar trio)
  ccMatrix: true,            // KPI × Software matrix (CC-only)
  nonCCPlusLatestCC: true,    // KPI × Software matrix (Non-CC + latest CC)
  softwareCards: false         // Per-software cards
};

const EXTERNAL_WHITELIST = [
  'ACC — False brake',
  'LCC — False brake',
  'TSI — Wrong speed detected',
  'LDW — False positive',
  'LDP — False positive',
  'ELKA — False positive'
];

// Normalize "Function — KPI" keys: case-insensitive, unify dashes, collapse spaces
function normKey(s){
  return String(s || '')
    .toLowerCase()
    .replace(/[\u2013\u2014-]/g, '—')   // en/em/ASCII hyphen -> em dash
    .replace(/\s+/g, ' ')               // collapse spaces
    .trim();
}
const EXTERNAL_WL_KEYS = new Set(EXTERNAL_WHITELIST.map(normKey));

/* Weather (Open-Meteo archive, hourly aggregated 10–14 local) */
const GOTHENBURG = { lat: 57.7089, lon: 11.9746, tz: 'Europe/Stockholm' };
const WEATHER_LS_KEY = 'segRadarKPI.weather.GOT.10to14';
const H_START = 10, H_END = 14; // inclusive hours (local time)
const WMO_TEXT = {
  0:'Clear',1:'Mainly clear',2:'Partly cloudy',3:'Overcast',
  45:'Fog',48:'Depositing rime fog',
  51:'Drizzle: light',53:'Drizzle: moderate',55:'Drizzle: dense',
  56:'Freezing drizzle: light',57:'Freezing drizzle: dense',
  61:'Rain: slight',63:'Rain: moderate',65:'Rain: heavy',
  66:'Freezing rain: light',67:'Freezing rain: heavy',
  71:'Snow fall: slight',73:'Snow fall: moderate',75:'Snow fall: heavy',
  77:'Snow grains',
  80:'Rain showers: slight',81:'Rain showers: moderate',82:'Rain showers: violent',
  85:'Snow showers: slight',86:'Snow showers: heavy',
  95:'Thunderstorm',96:'Thunderstorm w/ hail',99:'Thunderstorm w/ heavy hail'
};

// === NEW: for averaging by total number of KPIs (from KPI_buttons.csv) ===
const KPI_BUTTONS_CSV = 'KPI_buttons.csv';
let TOTAL_KPI_COUNT = null;  // will be filled by reading KPI_buttons.csv

/* Unified font sizes for score-boxes */
const SCORE_FONTS = { number:13, label:11, range:10 };

/* ==================== Helpers & Scoring ==================== */
const GREEN = '#0a9910', YELLOW = '#ffd000', RED = '#d43b3b', BLACK = '#000';
const DARK_GREEN = '#2e7d32';
const scoreColors = ['#e60000','#ff1e1e','#ff6a00','#ffa000','#ffe07a','#ffff33','#9acd32','#66bb6a','#00a878','#2e7d32'];
const scoreText   = ['Worst','Too bad','Bad','Not good','Unacceptable','Marginal','Acceptable','Good','Impressive','Exceptional'];
let LAST_RAW = '';
let LAST_PARSED = null; // parsed + merged release notes + weather

const fmtCell = v =>
  (v==null || Number.isNaN(v)) ? '—'
  : (Number.isInteger(v) ? String(v)
  : String(parseFloat(v.toFixed(2))).replace(/\.00$/,''));

function parseThresholds(str){
  const arr = (str||'')
    .split(',')
    .map(s => s.trim())
    .filter(s => s !== '')
    .map(Number);
  if (arr.length !== 10 || arr.some(n=>Number.isNaN(n))) return null;
  for (let i=1;i<arr.length;i++){ if (arr[i] > arr[i-1]) return null; }
  return arr;
}
function getThresholds(){
  if (Array.isArray(SCORE_THRESHOLDS) && SCORE_THRESHOLDS.length===10) return SCORE_THRESHOLDS;
  let t = null;
  try { t = parseThresholds(localStorage.getItem(LS_KEY)); } catch {}
  if (t) return t;
  return parseThresholds(DEFAULT_THRESH_STR);
}
const fmtNum = n => Number.isInteger(n) ? String(n) : String(parseFloat(n.toFixed(2)));
function scoreRangeLabels(T){
  const lab = [];
  for (let i=0;i<9;i++) lab.push('≥ ' + fmtNum(T[i]));
  lab.push('< ' + fmtNum(T[8]) + (T[9] === 0 ? ' (incl. 0)' : ''));
  return lab;
}
function scoreFromAvg(a, thresholds){
  if (a == null || Number.isNaN(a)) return null;
  if (a === 0) return 10;
  for (let i=0;i<9;i++){ if (a >= thresholds[i]) return i+1; }
  return 10;
}
function colorFor(v, tgt, max){
  if (v == null || Number.isNaN(v)) return null;
  if (v === 1000) return BLACK;
  if (v <= tgt) return GREEN;
  if (v < (max + 1)) return YELLOW;
  return RED;
}
function parseNumber(x){
  if (x==null) return null;
  const t = (""+x).trim();
  if (!t) return null;
  const v = Number(t.replace(',', '.'));
  return isNaN(v) ? null : v;
}
function detectDelimiter(text){
  const lines = text.split(/\r?\n/).filter(Boolean);
  if (!lines.length) return '\t';
  const cand = ['\t', ',', ';'];
  let best = '\t', bestCnt = 0;
  for (const d of cand){ const c = lines[0].split(d).length; if (c > bestCnt){ bestCnt = c; best = d; } }
  return best;
}
function splitFuncKpi(s){
  if (!s) return {func:'', kpi:''};
  for (const sep of ['—', '–', ' - ']){
    const parts = s.split(sep);
    if (parts.length >= 2) return { func: parts[0].trim(), kpi: parts.slice(1).join(sep).trim() };
  }
  const idx = s.indexOf('-');
  if (idx > 0) return { func: s.slice(0, idx).trim(), kpi: s.slice(idx+1).trim() };
  const sp = s.split(' ');
  return {func: sp[0]||'', kpi: s};
}
function normalizeHeader(h){
  if(!h) return '';
  return h.toLowerCase().replace(/\u00a0/g,' ').replace(/\s+/g,' ').replace(/[^a-z0-9 ]/g,'').trim();
}

/* ==================== Parse table (dates + inline "Release note") ==================== */
function parseTable(text){
  const tryParse = (d)=> text
    .replace(/^\uFEFF/, '') // strip BOM
    .split(/\r?\n/)
    .filter(r => r.trim().length > 0)
    .map(r => r.split(d));

  let delim = detectDelimiter(text);
  let rows = tryParse(delim);
  if (!rows.length) return { headers: [], entries: [], software: [], releaseNotes: {}, weatherByDate:{} };

  let headers = rows[0].map(h => h.trim());

  // Auto-insert missing first header cell if needed
  if (rows.length > 1 && rows[1].length === headers.length + 1) {
    const firstCell = (rows[1][0] || '').trim();
    const looksText = parseNumber(firstCell) == null;
    const normH = headers.map(normalizeHeader);
    const hasTarget = normH.includes('target');
    const hasMax = normH.includes('max allowed') || normH.includes('maxallowed');
    if (looksText && hasTarget && hasMax) headers = ['Function — KPI', ...headers];
  }

  let norm = headers.map(normalizeHeader);
  let idxTarget = norm.findIndex(h => h === 'target');
  let idxMax    = norm.findIndex(h => (h === 'max allowed' || h === 'maxallowed'));

  if (idxTarget < 0 || idxMax < 0) {
    alert("Missing required columns: 'Target' and 'Max allowed'.\nHeaders seen: " + headers.join(', '));
    return { headers, entries: [], software: [], releaseNotes: {}, weatherByDate:{} };
  }

  // Software columns (strip optional [YYYY-MM-DD])
  const swCols = [];
  for (let i = idxMax + 1; i < headers.length; i++) {
    const raw = headers[i].trim();
    const theDate = raw.match(/\[(\d{4}-\d{2}-\d{2})\]\s*$/);
    const date = theDate ? theDate[1] : null;
    const baseNoDate = theDate ? raw.replace(/\s*\[\d{4}-\d{2}-\d{2}\]\s*$/, '') : raw;
    const basePretty = baseNoDate.replace('(TO)', ' (TO)');
    const countPrev = swCols.filter(s => s.base === basePretty).length;
    const label = countPrev ? `${basePretty} — ${countPrev + 1}` : basePretty;
    swCols.push({ idx: i, base: basePretty, label, date });
  }

  const releaseNotes = {};
  const entries = [];

  for (let r = 1; r < rows.length; r++) {
    const row = rows[r];
    if (!row || row.length === 0) continue;

    const firstCellRaw = (row[0] || '').trim();
    const firstNorm = normalizeHeader(firstCellRaw);

    if (firstNorm === 'releasenote' || firstCellRaw.toLowerCase() === 'release note') {
      for (const sw of swCols) {
        const raw = (row[sw.idx] ?? '').trim();
        if (raw) {
          releaseNotes[sw.label] = (releaseNotes[sw.label] ? (releaseNotes[sw.label] + '\n' + raw) : raw);
        }
      }
      continue;
    }

    const { func, kpi } = splitFuncKpi(firstCellRaw);
    const target = parseNumber(row[idxTarget]);
    const max    = parseNumber(row[idxMax]);

    const values = {};
    for (const sw of swCols) values[sw.label] = parseNumber(row[sw.idx]);

    entries.push({ func, kpi, target, max, values });
  }

  return { headers, entries, software: swCols, releaseNotes, weatherByDate:{} };
}
  
/* ==================== Modal ==================== */
function openReleaseNoteModal(title, noteText){
  const backdrop = document.getElementById('modalBackdrop');
  const titleEl  = document.getElementById('modalTitle');
  const content  = document.getElementById('modalContent');

  titleEl.textContent = title || 'Release Note';

  const parts = String(noteText || '')
    .replace(/\r/g,'')
    .split(/\n/g)
    .map(s => s.trim())
    .filter(s => s.length);

  content.innerHTML = '';
  if (parts.length === 0){
    const p = document.createElement('p'); p.className = 'empty'; p.textContent = 'No release note provided.'; content.appendChild(p);
  } else {
    const ul = document.createElement('ul');
    parts.forEach(t => { const li = document.createElement('li'); li.textContent = t; ul.appendChild(li); });
    content.appendChild(ul);
  }

  backdrop.style.display = 'flex';
  backdrop.setAttribute('aria-hidden', 'false');
}
function closeReleaseNoteModal(){
  const backdrop = document.getElementById('modalBackdrop');
  backdrop.style.display = 'none';
  backdrop.setAttribute('aria-hidden', 'true');
}
document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeReleaseNoteModal(); });
document.getElementById('modalBackdrop').addEventListener('click', (e)=>{ if (e.target.id === 'modalBackdrop') closeReleaseNoteModal(); });
document.getElementById('modalClose').addEventListener('click', closeReleaseNoteModal);

/* ==================== Release-note files ==================== */
async function readTextOrNull(path){
  try{
    const res = await fetch(encodeURI(path) + '?t=' + Date.now(), {cache:'no-store'});
    if (!res.ok) return null;
    return await res.text();
  }catch{ return null; }
}
async function loadReleaseNotesManifest(){
  if (RN_FETCH_MODE !== 'manifest') return null;
  try{
    const res = await fetch(RN_MANIFEST_FILE + '?t=' + Date.now(), {cache:'no-store'});
    if (!res.ok) return null;
    const list = await res.json();
    if (!Array.isArray(list)) return null;
    return new Set(list.map(s => String(s).toLowerCase()));
  }catch{ return null; }
}

// === NEW: read KPI_buttons.csv and count lines that contain "redButton" ===
async function loadTotalKpiCount(){
  try{
    const res = await fetch(KPI_BUTTONS_CSV + '?t=' + Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    // Count *lines* that contain "redButton" (case-sensitive per your spec)
    return text.replace(/\r/g,'').split('\n').filter(l => l.includes('redButton')).length;
  }catch(e){
    console.warn('Could not load KPI_buttons.csv to count KPIs:', e);
    return null; // will fallback to "measured count" if null
  }
}
  
async function loadReleaseNotesFromFiles(swCols, manifestSet){
  if (RN_FETCH_MODE === 'off') return {};
  const out = {};
  for (const sw of (swCols||[])){
    const file = `${sw.base}.csv`;
    if (RN_FETCH_MODE === 'manifest' && (!manifestSet || !manifestSet.has(file.toLowerCase()))) continue;
    const txt = await readTextOrNull(file);
    if (!txt) continue;
    const lines = txt.replace(/\r/g,'').split('\n').map(s=>s.trim()).filter(Boolean);
    if (lines.length){
      const joined = lines.join('\n');
      out[sw.label] = (out[sw.label] ? (out[sw.label] + '\n' + joined) : joined);
    }
  }
  return out;
}

/* ==================== Weather (hourly, aggregate 10–14 local) ==================== */
function loadWeatherCache(){
  try{ return JSON.parse(localStorage.getItem(WEATHER_LS_KEY) || '{}'); }catch{ return {}; }
}
function saveWeatherCache(cache){
  try{ localStorage.setItem(WEATHER_LS_KEY, JSON.stringify(cache)); }catch{}
}
function isoMinMax(dates){
  let min = null, max = null;
  dates.forEach(d=>{
    if (!d) return;
    if (!min || d < min) min = d;
    if (!max || d > max) max = d;
  });
  return {min, max};
}
function mode(arr){
  const m = new Map();
  let bestVal = null, bestCnt = -1;
  for (const v of arr){
    const c = (m.get(v)||0)+1; m.set(v,c);
    if (c > bestCnt || (c===bestCnt && v>bestVal)){ bestCnt=c; bestVal=v; }
  }
  return bestVal;
}
async function fetchWeatherForDates(dates){
  const wanted = Array.from(new Set(dates.filter(Boolean)));
  const cache = loadWeatherCache();
  const missing = wanted.filter(d => !cache[d] || cache[d].tmax == null || cache[d].tmin == null);

  if (!missing.length) return cache;

  const {min, max} = isoMinMax(missing);
  if (!min || !max) return cache;

  const url = `https://archive-api.open-meteo.com/v1/archive?latitude=${GOTHENBURG.lat}&longitude=${GOTHENBURG.lon}`+
              `&start_date=${min}&end_date=${max}`+
              `&hourly=temperature_2m,weathercode&timezone=${encodeURIComponent(GOTHENBURG.tz)}`;

  try{
    const res = await fetch(url, {cache:'no-store'});
    if (!res.ok) throw new Error('weather HTTP ' + res.status);
    const data = await res.json();
    const times = (data.hourly && data.hourly.time) || [];
    const temps = (data.hourly && data.hourly.temperature_2m) || [];
    const codes = (data.hourly && data.hourly.weathercode) || [];

    const byDate = new Map();
    for (let i=0;i<times.length;i++){
      const t = times[i];
      const day = t.slice(0,10);
      const hr = parseInt(t.slice(11,13),10);
      if (hr >= H_START && hr <= H_END){
        if (!byDate.has(day)) byDate.set(day, []);
        byDate.get(day).push(i);
      }
    }

    for (const [day, idxs] of byDate.entries()){
      if (!idxs.length) continue;
      const tvals = idxs.map(i => temps[i]).filter(v => v!=null);
      const cvals = idxs.map(i => codes[i]).filter(v => v!=null);
      if (!tvals.length){
        cache[day] = { tmax:null, tmin:null, code:null, text:'—', hours:'10–14' };
        continue;
      }
      const tmax = Math.round(Math.max(...tvals));
      const tmin = Math.round(Math.min(...tvals));
      const c = cvals.length ? mode(cvals) : null;
      cache[day] = { tmax, tmin, code: c, text: (c!=null && (c in WMO_TEXT)) ? WMO_TEXT[c] : '—', hours:'10–14' };
    }

    // Ensure all requested days exist even if no 10–14 samples
    missing.forEach(day=>{
      if (!cache[day] && !byDate.has(day)){
        cache[day] = { tmax:null, tmin:null, code:null, text:'—', hours:'10–14' };
      }
    });

    saveWeatherCache(cache);
  }catch(e){
    console.warn('Weather fetch failed:', e);
  }
  return cache;
}

/* ==================== Filtering for External view ==================== */
function filterEntriesForMode(parsed){
  if (CURRENT_MODE === MODES.INTERNAL) return parsed;
  const filteredEntries = (parsed.entries || []).filter(e =>
    EXTERNAL_WL_KEYS.has(normKey(`${e.func} — ${e.kpi}`))
  );
  return { ...parsed, entries: filteredEntries };
}

/* ==================== Summary (with Weather column) ==================== */
function renderSummary(container, parsed){
  const T = getThresholds();
  if (!parsed || !parsed.software || !parsed.software.length) return;

  // Build rows with avg = (sum of KPI values) / (TOTAL_KPI_COUNT or measured count)
  const rowsRaw = parsed.software.map(sw => {
    const swLabel = sw.label;

    const vals = parsed.entries
      .map(e => e.values[swLabel])
      .filter(v => v != null && !Number.isNaN(v));

    const sumVals = vals.length ? d3.sum(vals.map(v => Math.min(v, 1000))) : 0;
    const denom = (TOTAL_KPI_COUNT && TOTAL_KPI_COUNT > 0) ? TOTAL_KPI_COUNT : vals.length;

    const avg = denom ? (sumVals / denom) : null;
    const score = avg == null ? null : scoreFromAvg(avg, T);
    const note = (parsed.releaseNotes?.[swLabel] || '').trim();
    const wx = (sw.date && parsed.weatherByDate) ? parsed.weatherByDate[sw.date] : null;

    return {
      sw: swLabel,
      date: sw.date,
      avg,
      score,
      text: score == null ? 'n/a' : scoreText[score - 1],
      note,
      weatherText: wx ? `${wx.tmax ?? '—'}°/${wx.tmin ?? '—'}°, ${wx.text}` : '—'
    };
  });

  const hasAnyNotes = rowsRaw.some(r => r.note.length > 0);

  // Sort: best score first; then by lowest avg
  const rows = rowsRaw.slice().sort((a,b)=>{
    const sa = a.score ?? -1, sb = b.score ?? -1;
    if (sa !== sb) return sb - sa;
    if (a.avg == null && b.avg == null) return 0;
    if (a.avg == null) return 1;
    if (b.avg == null) return -1;
    return a.avg - b.avg;
  });

  const chartData = rows.filter(r => r.avg != null);
  if (!rows.length) return;

  const card = container.append('div').attr('class', 'chart-card summary-card');
  const modeLabel = (CURRENT_MODE === MODES.EXTERNAL)
    ? 'Summary Weekly KPI — External (whitelisted)'
    : 'Summary Weekly KPI';
  card.append('div').attr('class','summary-title').text(modeLabel);

  // ===== Summary table =====
  const table = card.append('table').attr('class', 'summary-table');
  const theadRow = table.append('thead').append('tr');
  theadRow.append('th').attr('class','col-sw').text('Software');
  theadRow.append('th').attr('class','col-date').text('Test date');
  theadRow.append('th').attr('class','col-weather').text('Weather (Göteborg, 10–14)');
  theadRow.append('th').attr('class','col-avg').text('Average per 1000 km (÷ total KPIs)');
  theadRow.append('th').attr('class','col-score').text('Score');
  theadRow.append('th').attr('class','col-rating').text('Rating');
  if (hasAnyNotes) theadRow.append('th').attr('class','col-note').text('Release Note');

  const tbody = table.append('tbody');
  rows.forEach(r=>{
    const tr = tbody.append('tr');
    tr.append('td').attr('class','col-sw').append('span').attr('class','software-cell').attr('title', r.sw).text(r.sw);
    tr.append('td').attr('class','col-date').text(r.date || '—');
    tr.append('td').attr('class','col-weather').text(r.date ? r.weatherText : '—');
    tr.append('td').attr('class','col-avg').text(r.avg == null ? '—' : r.avg.toFixed(1));

    const scoreCell = tr.append('td').attr('class','col-score');
    if (r.score == null){
      scoreCell.text('—'); tr.append('td').attr('class','col-rating').text('n/a');
    } else {
      scoreCell.append('span')
        .attr('class', 'summary-chip')
        .attr('style', `background:${scoreColors[r.score-1]}22; border-color:${scoreColors[r.score-1]}66; color:#111`)
        .text(r.score);
      tr.append('td').attr('class','col-rating').text(r.text);
    }

    if (hasAnyNotes){
      const tdNote = tr.append('td').attr('class','col-note');
      if (r.note){
        const a = tdNote.append('span').attr('class','link').text('Release Note');
        a.on('click', ()=> openReleaseNoteModal(`${r.sw}${r.date ? ' — ' + r.date : ''}`, r.note));
      } else {
        tdNote.text('');
      }
    }
  });

  // ===== Horizontal bars (all softwares) =====
  if (chartData.length){
    card.append('div').attr('class','small').style('margin','8px 0 4px')
      .text('Average per 1000 km (bar color = score)');

    const yLabels = chartData.map(d => d.date ? `${d.sw}  (${d.date})` : d.sw);
    const measureTextWidth = (texts, fontSize=12, fontWeight=400)=>{
      const tmp = d3.select('body').append('svg').attr('width',0).attr('height',0)
        .style('position','absolute').style('left','-9999px').style('top','-9999px').style('visibility','hidden');
      let max = 0;
      texts.forEach(t=>{
        const node = tmp.append('text').attr('font-size', fontSize).attr('font-weight', fontWeight)
          .text(t==null ? '' : String(t)).node();
        max = Math.max(max, node.getComputedTextLength());
      });
      tmp.remove(); return max;
    };

    const labelW = Math.ceil(measureTextWidth(yLabels, 12, 400));
    const cardW = Math.max(0, Math.ceil(card.node().getBoundingClientRect().width) - 20);
    const cw = Math.max(560, Math.min(1000, cardW));
    const leftPad = Math.min(Math.floor(cw * 0.48), Math.max(160, labelW + 14));
    const rightPad = 16, topPad = 8, barH = 22, gap = 6;

    const svg = card.append('svg')
      .style('display','block').style('margin','0 auto 6px')
      .attr('width', cw)
      .attr('height', topPad + chartData.length * (barH + gap) + 34);

    const g = svg.append('g').attr('transform', `translate(0, ${topPad})`);

    const maxAvg = d3.max(chartData, d => Math.min(1000, d.avg));
    const x = d3.scaleLinear().domain([0, Math.max(1, maxAvg)]).range([leftPad, cw - rightPad]);

    chartData.forEach((d,i)=> d._y = i * (barH + gap));

    g.selectAll('.ylabel').data(chartData).enter().append('text')
      .attr('class','ylabel').attr('x', leftPad - 10).attr('y', d => d._y + barH/2)
      .attr('text-anchor','end').attr('dominant-baseline','middle').attr('font-size', 12)
      .text((d,i)=> yLabels[i]).append('title').text(d => d.sw);

    g.selectAll('.bar').data(chartData).enter().append('rect')
      .attr('class','bar').attr('x', x(0)).attr('y', d => d._y)
      .attr('width', d => x(Math.min(1000, d.avg)) - x(0)).attr('height', barH)
      .attr('fill', d => scoreColors[(d.score || 10) - 1]).attr('fill-opacity', 0.9)
      .append('title').text(d => `Score ${d.score}: ${d.text} — ${d.avg.toFixed(1)} /1000km`);

    g.selectAll('.val').data(chartData).enter().append('text')
      .attr('x', d => x(Math.min(1000, d.avg)) + 6).attr('y', d => d._y + barH/2)
      .attr('dominant-baseline','middle').attr('font-size', 12).text(d => d.avg.toFixed(1));

    const axisY = chartData.length * (barH + gap);
    g.append('g').attr('transform', `translate(0, ${axisY})`).call(d3.axisBottom(x).ticks(6));
  }

  // ===== CC-only vertical bars by test date (+ running-mean trend line) =====
  const ccLabelSet = new Set((parsed.software || [])
    .filter(sw => /^CC\b/i.test(sw.base))
    .map(sw => sw.label));

  const ccRows = rows.filter(r => r.avg != null && r.date && ccLabelSet.has(r.sw));
  if (ccRows.length){
    card.append('div')
      .attr('class','small')
      .style('margin','8px 0 4px')
      .text('CC — Average per 1000 km by test date (bar color = score)');

    const byDate = d3.group(ccRows, d => d.date);
    const dates = Array.from(byDate.keys()).sort();   // chronological
    const groups = dates.map(d => byDate.get(d));
    const maxGroup = Math.max(...groups.map(g => g.length));

    const cardW2 = Math.max(0, Math.ceil(card.node().getBoundingClientRect().width) - 20);
    const cw2 = Math.max(560, Math.min(1000, cardW2));
    const leftPadV = 46, rightPadV = 12, topPadV = 6, bottomPadV = 56;
    const plotH = 240;

    const svg2 = card.append('svg')
      .style('display','block')
      .style('margin','0 auto 6px')
      .attr('width', cw2)
      .attr('height', topPadV + plotH + bottomPadV);

    const g2 = svg2.append('g').attr('transform', `translate(0,${topPadV})`);

    const maxAvgV = d3.max(ccRows, d => Math.min(1000, d.avg));
    const y = d3.scaleLinear().domain([0, Math.max(1, maxAvgV)]).nice().range([plotH, 0]);

    const x0 = d3.scaleBand()
      .domain(dates)
      .range([leftPadV, cw2 - rightPadV])
      .paddingInner(0.2)
      .paddingOuter(0.05);

    const x1 = d3.scaleBand()
      .domain(d3.range(maxGroup))
      .range([0, x0.bandwidth()])
      .padding(0.12);

    // Flatten data for drawing
    const flat = [];
    dates.forEach(d => {
      const arr = byDate.get(d);
      arr.forEach((r, i) => flat.push({ ...r, _date: d, _idx: i }));
    });

    // Axes
    g2.append('g')
      .attr('transform', `translate(${0},${plotH})`)
      .call(d3.axisBottom(x0).tickSizeOuter(0))
      .selectAll('text')
        .attr('transform','rotate(35)')
        .style('text-anchor','start')
        .attr('dx','0.6em')
        .attr('dy','0.25em');

    g2.append('g')
      .attr('transform', `translate(${leftPadV},0)`)
      .call(d3.axisLeft(y).ticks(6));

    // Bars
    g2.selectAll('.ccbar').data(flat).enter().append('rect')
      .attr('class','ccbar')
      .attr('x', d => x0(d._date) + x1(d._idx))
      .attr('y', d => y(Math.min(1000, d.avg)))
      .attr('width', x1.bandwidth())
      .attr('height', d => y(0) - y(Math.min(1000, d.avg)))
      .attr('fill', d => scoreColors[(d.score || 10) - 1])
      .attr('fill-opacity', 0.9)
      .append('title')
      .text(d => `${d._date} — ${d.sw}\nScore ${d.score}: ${d.text}\n${d.avg.toFixed(1)} /1000km`);

    // Value labels on each bar
g2.selectAll('.ccval').data(flat).enter().append('text')
  .attr('class','ccval')
  .attr('x', d => x0(d._date) + x1(d._idx) + x1.bandwidth()/2)
  .attr('y', d => {
    const v = Math.min(1000, d.avg ?? 0);
    const top = y(v);
    const h = y(0) - top;            // bar height in px
    return (h > 16) ? top + 12 : top - 4;   // inside if tall, else above
  })
  .attr('text-anchor','middle')
  .attr('font-size', 11)
  .attr('font-weight', 600)
  .attr('fill', '#111') 
  .text(d => {
    const v = d.avg;
    return (v != null && !Number.isNaN(v)) ? Math.min(1000, v).toFixed(1) : '—';
  });

    // Software labels below the number (always black text)
g2.selectAll('.ccsoft').data(flat).enter().append('text')
  .attr('class','ccsoft')
  .attr('x', d => x0(d._date) + x1(d._idx) + x1.bandwidth()/2)
  .attr('y', d => {
    const v = Math.min(1000, d.avg ?? 0);
    const top = y(v), h = y(0) - top;
    const yNum = (h > 16) ? top + 12 : top - 4;  // same anchor as the value
    return Math.max(10, yNum + 12);              // 12px below the value; clamp a bit
  })
  .attr('text-anchor','middle')
  .attr('font-size', 10)
  .attr('fill', '#111')
  .text(d => {
    const s = d.sw || '';
    return s.length > 22 ? s.slice(0,22) + '…' : s; // keep tidy; full in title
  })
  .append('title').text(d => d.sw || '');

    // --- Running mean trend line (mean of historical date means) ---
    const dateMeans = dates.map(d => {
      const arr = byDate.get(d);
      const m = d3.mean(arr, r => Math.min(1000, r.avg));
      return { dateStr: d, date: new Date(d), mean: m };
    }).filter(p => p.mean != null);

    if (dateMeans.length >= 2){
      // cumulative mean over time
      let runSum = 0;
      const running = dateMeans.map((p, i) => {
        runSum += p.mean;
        return { date: p.date, y: runSum / (i + 1) };
      });

      // time scale aligned to same left/right padding as bars
      const xTime = d3.scaleTime()
        .domain(d3.extent(running, d => d.date))
        .range([leftPadV, cw2 - rightPadV]);

      // draw the line
      g2.append('path')
        .datum(running)
        .attr('fill','none')
        .attr('stroke','#222')
        .attr('stroke-width',2)
        .attr('stroke-dasharray','6,4')
        .attr('d', d3.line()
          .x(d => xTime(d.date))
          .y(d => y(d.y))
        );

// optional small endpoint label with value
const last = running[running.length - 1];
const lastVal = (last && Number.isFinite(last.y)) ? last.y.toFixed(1) : '—';
g2.append('text')
  .attr('x', xTime(last.date) - 6)
  .attr('y', y(last.y) - 6)
  .attr('text-anchor','end')
  .attr('font-size', 11)
  .attr('fill', '#333')
  .text(`Running average:  ${lastVal}`);
    }
  }

  // ===== Scoring legend =====
  const ranges = scoreRangeLabels(getThresholds());
  const legCw = Math.max(560, Math.min(1000, Math.max(0, Math.ceil(card.node().getBoundingClientRect().width) - 20)));
  const legend = card.append('svg').style('display','block').style('margin','6px auto 2px').attr('width', legCw);
  const bandMargin = 20, boxH = 42;
  const barW = legCw - bandMargin*2, boxW = barW / 10;
  legend.append('text').attr('x', 12).attr('y', 12).attr('font-size', 12).attr('fill', '#555').text('Scoring legend (1 = worst, 10 = best)');
  for (let i=0;i<10;i++){
    const x = bandMargin + i*boxW; const g = legend.append('g');
    g.append('rect').attr('x', x).attr('y', 20).attr('width', boxW).attr('height', boxH).attr('fill', scoreColors[i]).attr('stroke', '#111').attr('stroke-width', 0.4)
      .append('title').text(`Score ${i+1}: ${scoreText[i]} — ${ranges[i]}`);
    g.append('text').attr('x', x + boxW/2).attr('y', 20 + 14).attr('text-anchor','middle').attr('font-weight', 800).attr('font-size', SCORE_FONTS.number).text(i+1);
    g.append('text').attr('x', x + boxW/2).attr('y', 20 + 14 + 16).attr('text-anchor','middle').attr('font-size', SCORE_FONTS.label).text(scoreText[i]);
    g.append('text').attr('x', x + boxW/2).attr('y', 20 + boxH + 14).attr('text-anchor','middle').attr('font-size', SCORE_FONTS.range).text(ranges[i]);
  }
  legend.attr('height', 20 + boxH + 28 + 6);

// ---- KPI × Software heatmap in calendar style ----
renderFunctionKpiCalendarHeatmap(card, parsed);
}

/* ==================== Calendar trio helpers ==================== */
function measureTextWidthCal(texts, fontSize=11, fontWeight=600){
  const tmp = d3.select('body').append('svg')
    .attr('width',0).attr('height',0)
    .style('position','absolute').style('left','-9999px').style('top','-9999px').style('visibility','hidden');
  let max = 0;
  (texts||[]).forEach(t=>{
    const n = tmp.append('text').attr('font-size', fontSize).attr('font-weight', fontWeight).text(t==null ? '' : String(t)).node();
    max = Math.max(max, n.getComputedTextLength());
  });
  tmp.remove();
  return Math.ceil(max);
}
const WEATHER_LABELS = ['Clear/Clouds','Fog/Drizzle','Rain/Snow','Heavy precip','Thunderstorm'];
function weatherCategoryForWMO(code){
  if (code==null) return null;
  if (code>=95) return 'Thunderstorm';
  if (code===66 || code===67 || code===85 || code===86) return 'Heavy precip';
  if ((code>=61 && code<=65) || (code>=71 && code<=77) || (code>=80 && code<=82)) return 'Rain/Snow';
  if (code===45 || code===48 || (code>=51 && code<=57)) return 'Fog/Drizzle';
  return 'Clear/Clouds';
}

// Calendar-style heatmap: Y = all KPIs; X = software; cell color = function score for that software
function renderFunctionKpiCalendarHeatmap(card, parsed){
  const T = getThresholds();
  const softwares = parsed.software || [];
  if (!softwares.length) return;

  const swLabels = softwares.map(sw => sw.label);

  // Fallback denominator per software if TOTAL_KPI_COUNT isn't available
  const measuredCountBySW = new Map(swLabels.map(l => [l, 0]));
  (parsed.entries || []).forEach(e => {
    swLabels.forEach(l => {
      const v = e.values[l];
      if (v != null && !Number.isNaN(v)) measuredCountBySW.set(l, measuredCountBySW.get(l) + 1);
    });
  });

  // Unique functions and KPI rows (keep original order)
  const functions = Array.from(new Set((parsed.entries || []).map(e => e.func)));
  const kpiRows  = (parsed.entries || []).map(e => ({ func: e.func, kpi: e.kpi }));
  const cols = swLabels.length, rows = kpiRows.length;
  if (!rows) return;

  // Sum of events per (function, software)
  const sumByFuncSW = new Map(); // key = `${func}||${swLabel}`
  functions.forEach(f => swLabels.forEach(l => sumByFuncSW.set(`${f}||${l}`, 0)));
  (parsed.entries || []).forEach(e => {
    const f = e.func;
    swLabels.forEach(l => {
      const v = e.values[l];
      if (v != null && !Number.isNaN(v)) {
        sumByFuncSW.set(`${f}||${l}`, (sumByFuncSW.get(`${f}||${l}`) || 0) + Math.min(1000, v));
      }
    });
  });

  // Per-function avg & score per software
  const funcScore = new Map(); // func -> Map(swLabel -> {avg, score})
  functions.forEach(f => {
    const inner = new Map();
    swLabels.forEach(l => {
      const sum = sumByFuncSW.get(`${f}||${l}`) || 0;
      const denom = (TOTAL_KPI_COUNT && TOTAL_KPI_COUNT > 0)
        ? TOTAL_KPI_COUNT
        : (measuredCountBySW.get(l) || 0);
      const avg = denom ? (sum / denom) : null;
      const sc  = (avg == null) ? null : scoreFromAvg(avg, T);
      inner.set(l, { avg, score: sc });
    });
    funcScore.set(f, inner);
  });

  // ======= Calendar-style layout =======
  const cell = 12, gap = 2;
  const topPad = 22;

  // Left KPI labels width
  const leftLabels = kpiRows.map(r => `${r.func} — ${r.kpi}`);
  const leftPad = Math.max(140, measureTextWidthCal(leftLabels, 11, 600) + 14);

  // Top software labels height (vertical labels -> need max label "height")
  const maxTopLabel = measureTextWidthCal(swLabels, 11, 600); // width in px when horizontal ≈ height when vertical
  const colLabH = maxTopLabel + 16;                           // headroom above grid

  const gridW = leftPad + cols*(cell+gap) + 6;
  const gridH = topPad + colLabH + rows*(cell+gap) + 6;

  const wrap = card.append('div').attr('class', 'chart-card').style('grid-column','1 / -1');
  wrap.append('div').attr('class','cal-title').text('Function score per software (calendar style)');

  // allow horizontal scroll when many columns
  const scroller = wrap.append('div').style('overflow','auto');
  const svg = scroller.append('svg')
    .attr('width', gridW)
    .attr('height', gridH)
    .style('display','block')
    .style('margin','0 auto 10px');

  // ---- Left KPI labels
  const gLeft = svg.append('g');
  kpiRows.forEach((r, ri) => {
    const y = topPad + colLabH + ri*(cell+gap) + cell*0.75;
    const label = `${r.func} — ${r.kpi}`;
    gLeft.append('text')
      .attr('x', leftPad - 8)
      .attr('y', y)
      .attr('font-size', 11)
      .attr('font-weight', 600)
      .attr('fill', '#666')
      .attr('text-anchor','end')
      .text(label.length > 60 ? (label.slice(0,60) + '…') : label)
      .append('title').text(label);
  });

  // ---- Grid cells (drawn BEFORE top labels so labels can be on top)
  const gGrid = svg.append('g');
  for (let ri = 0; ri < rows; ri++) {
    const { func, kpi } = kpiRows[ri];
    for (let ci = 0; ci < cols; ci++) {
      const sw = swLabels[ci];
      const fs = (funcScore.get(func) || new Map()).get(sw) || { avg:null, score:null };
      const sc = fs.score;
      const fill = sc ? scoreColors[sc-1] : '#f1f3f8';
      const x = leftPad + ci*(cell+gap);
      const y = topPad + colLabH + ri*(cell+gap);

      gGrid.append('rect')
        .attr('x', x).attr('y', y)
        .attr('width', cell).attr('height', cell)
        .attr('fill', fill)
        .attr('fill-opacity', sc ? 0.95 : 1)
        .attr('stroke', '#fff').attr('stroke-width', 0.8)
        .append('title')
        .text(`${func} — ${kpi}\n${sw}\nAvg/1000km: ${fs.avg==null ? 'n/a' : fs.avg.toFixed(1)}\nScore: ${sc==null?'n/a':sc}${sc==null?'':' — ' + scoreText[sc-1]}`);
    }
  }

// ---- Column (software) labels on top, vertical and centered over each column (DRAW LAST)
const gTop = svg.append('g'); // appended last -> on top of cells

const gridTopY = topPad + colLabH;   // first row of cells begins here

// Fine-tune offsets (negative = up/left, positive = down/right)
const LABEL_X_NUDGE = -5;   // move a touch LEFT
const LABEL_Y_NUDGE = -50;   // move a touch UP

const labelBaseline = gridTopY + LABEL_Y_NUDGE;

swLabels.forEach((lab, c) => {
  // center of cell column c
  const cx = leftPad + c*(cell+gap) + cell/2 + LABEL_X_NUDGE;

  // place a group at (cx, labelBaseline) and rotate the text around that point
  const gl = gTop.append('g')
    .attr('transform', `translate(${cx}, ${labelBaseline}) rotate(-90)`);

  gl.append('text')
    .attr('x', 0)
    .attr('y', 0)
    .attr('text-anchor', 'middle')          // horizontally center over column center
    .attr('dominant-baseline', 'hanging')   // top of vertical text sits at the baseline
    .attr('font-size', 11)
    .attr('fill', '#111')
    .text(lab)
    .append('title').text(lab);
});
}

/* ==================== Calendar trio (Activity, Temperature, Weather) ==================== */
function renderCalendarTrio(container, parsed){
  const sw = parsed.software || [];
  const dateCounts = {};
  const datesList = [];
  sw.forEach(s => {
    if (!s.date) return;
    datesList.push(s.date);
    dateCounts[s.date] = (dateCounts[s.date] || 0) + 1;
  });
  if (!datesList.length) return;

  const toDate = s => new Date(s+'T00:00:00');
  const minDateStr = datesList.reduce((a,b)=> a<b?a:b);
  const maxDateStr = datesList.reduce((a,b)=> a>b?a:b);
  const minDate = toDate(minDateStr);
  const maxDate = toDate(maxDateStr);

  // Snap to full weeks (Mon..Sun)
  const start = new Date(minDate);
  const wdStart = (start.getDay()+6)%7; start.setDate(start.getDate() - wdStart);
  const end = new Date(maxDate);
  const wdEnd = (end.getDay()+6)%7; end.setDate(end.getDate() + (6 - wdEnd));

  // Weather aggregates already used by summary
  const wx = parsed.weatherByDate || {};
  const tempByDate = {};
  const catRowByDate = {};
  Object.keys(wx).forEach(d=>{
    const w = wx[d]; if (!w) return;
    const avgT = (w.tmin==null || w.tmax==null) ? null : Math.round((w.tmin + w.tmax)/2);
    tempByDate[d] = avgT;
    const cat = weatherCategoryForWMO(w.code);
    const row = (cat==null) ? null : WEATHER_LABELS.indexOf(cat);
    catRowByDate[d] = (row>=0? row : null);
  });

  const tVals = Object.values(tempByDate).filter(v=>v!=null);
  const tMin = tVals.length ? Math.min(...tVals) : null;
  const tMax = tVals.length ? Math.max(...tVals) : null;

  function drawCalendar(holder, caption, options){
    const { numRows, rowForDate, hasValue, leftLabels, labelMode='explicit' } = options;
    const EMPTY = '#f1f3f8';
    const cell = 12, gap = 2;
    const topPad = 18, monthPad = 12;

    const visibleLabels = Array.isArray(leftLabels) ? leftLabels.filter(x=>x && x.length) : [];
    const leftPadBase = (labelMode==='weekdays') ? 30 : 40;
    const leftPad = Math.max(leftPadBase, measureTextWidthCal(visibleLabels, 11, 600) + 14);

    const days = Math.floor((end - start)/(24*3600*1000)) + 1;
    const weeks = Math.ceil(days / 7);
    const w = leftPad + weeks*(cell+gap) + 6;
    const h = topPad + monthPad + numRows*(cell+gap) + 6;

    holder.append('div').attr('class','cal-col-title').text(caption);
    const svg = holder.append('svg').attr('width', w).attr('height', h);
    const monthFmt = new Intl.DateTimeFormat('sv-SE', { month: 'short' });

    const monthCols = new Map();
    for (let d = new Date(start), idx=0; d<=end; d.setDate(d.getDate()+1), idx++){
      if (d.getDate() === 1){
        const col = Math.floor(idx/7);
        monthCols.set(col, monthFmt.format(d));
      }
    }
    monthCols.forEach((lab, col)=>{
      svg.append('text').attr('x', leftPad + col*(cell+gap)).attr('y', topPad+8).attr('font-size', 11).text(lab);
    });

    const ax = svg.append('g');
    const yTop = topPad + monthPad;
    const axX  = leftPad - 6;
    if (labelMode==='weekdays'){
      const yNames = ['Mon','','Wed','','Fri','',''];
      yNames.forEach((lab, r)=>{
        if (!lab) return;
        ax.append('text').attr('x', axX).attr('y', yTop + r*(cell+gap) + cell*0.75).attr('font-size', 11).attr('fill', '#666').attr('text-anchor','end').text(lab);
      });
    } else if (Array.isArray(leftLabels) && leftLabels.length){
      leftLabels.forEach((lab, r)=>{
        if (!lab) return;
        ax.append('text').attr('x', axX).attr('y', yTop + r*(cell+gap) + cell*0.75).attr('font-size', 11).attr('fill', '#666').attr('text-anchor','end').text(lab);
      });
    }

    const g = svg.append('g').attr('transform', `translate(${leftPad},${yTop})`);
    for (let d = new Date(start), idx=0; d<=end; d.setDate(d.getDate()+1), idx++){
      const ds = d.toISOString().slice(0,10);
      let row = null;
      if (labelMode==='weekdays'){
        row = (d.getDay()+6)%7; // Mon=0..Sun=6
      } else {
        row = rowForDate(ds);
      }
      const col = Math.floor(idx/7);
      const fill = (row==null || !hasValue(ds)) ? EMPTY : DARK_GREEN;
      const y = (row==null ? 0 : row*(cell+gap));
      g.append('rect').attr('x', col*(cell+gap)).attr('y', y).attr('width', cell).attr('height', cell).attr('fill', fill);
    }
  }

  const card = container.append('div').attr('class','chart-card').style('grid-column','1 / -1');
  card.append('div').attr('class','cal-title').text('Activity & weather statistics');
  const grid = card.append('div').attr('class','cal-grid');

  drawCalendar(grid.append('div'),'Test activity',{
    numRows: 7, labelMode: 'weekdays', leftLabels: null,
    hasValue: (ds)=> (dateCounts[ds] || 0) > 0
  });

  const TEMP_ROWS = 7;
  let tempLabels = Array(TEMP_ROWS).fill('');
  if (tMin!=null && tMax!=null){
    const span = Math.max(1, tMax - tMin);
    for (let r=0;r<TEMP_ROWS;r++){
      const fracTop = 1 - r/(TEMP_ROWS-1);
      const val = Math.round(tMin + fracTop*span);
      if (r===0 || r===Math.floor((TEMP_ROWS-1)/2) || r===TEMP_ROWS-1 || r===2 || r===TEMP_ROWS-3){
        tempLabels[r] = `${val}°`;
      }
    }
  }
  drawCalendar(grid.append('div'),'Temperature',{
    numRows: TEMP_ROWS, labelMode:'explicit', leftLabels: tempLabels,
    rowForDate: (ds)=>{
      const v = tempByDate[ds];
      if (v==null || tMin==null || tMax==null) return null;
      if (tMax===tMin) return Math.floor(TEMP_ROWS/2);
      const ratio = (v - tMin) / (tMax - tMin);
      const idx = (TEMP_ROWS-1) - Math.max(0, Math.min(TEMP_ROWS-1, Math.floor(ratio*(TEMP_ROWS-1)+1e-6)));
      return idx;
    },
    hasValue: (ds)=> tempByDate[ds] != null
  });

  drawCalendar(grid.append('div'),'Weather condition',{
    numRows: WEATHER_LABELS.length, labelMode:'explicit', leftLabels: WEATHER_LABELS,
    rowForDate: (ds)=> {
      const r = catRowByDate[ds];
      return (r==null ? null : r);
    },
    hasValue: (ds)=> catRowByDate[ds] != null
  });
}

/* ==================== KPI × Software matrix (CC-only) ==================== */
function renderCCMatrix(container, parsed){
  const ccSoftwares = (parsed.software || []).filter(sw => /^CC\b/i.test(sw.base));
  if (!ccSoftwares.length) return;

  const kpiNames = [];
  parsed.entries.forEach(e=>{
    const name = `${e.func} — ${e.kpi}`;
    if (!kpiNames.includes(name)) kpiNames.push(name);
  });
  if (!kpiNames.length) return;

  const entryByName = new Map();
  parsed.entries.forEach(e => entryByName.set(`${e.func} — ${e.kpi}`, e));

  const card = container.append('div').attr('class', 'chart-card');
  card.append('div').attr('class','matrix-title').text('KPI × Software matrix');
  card.append('div').attr('class','matrix-sub').text('CC-only');

  const wrap = card.append('div').attr('class','matrix-wrap');
  const mtable = wrap.append('table').attr('class','matrix-table');

  const thead = mtable.append('thead').append('tr');
  thead.append('th').text('KPI');
  thead.append('th').attr('class','target').text('Target');
  ccSoftwares.forEach(sw => thead.append('th').attr('class','software').text(sw.label));

  const tbody = mtable.append('tbody');
  kpiNames.forEach(name=>{
    const tr = tbody.append('tr');
    tr.append('td').text(name);
    const e = entryByName.get(name);
    tr.append('td').attr('class','target').text(fmtCell(e ? e.target : null));
    ccSoftwares.forEach(sw=>{
      const v = e ? e.values[sw.label] : null;
      const td = tr.append('td').attr('class','num').attr('title', `Events: ${fmtCell(v)}  |  Target: ${fmtCell(e ? e.target : null)}`);
      td.text(fmtCell(v));
    });
  });
}

/* ==================== KPI × Software matrix (Non-CC + latest CC) ==================== */
function renderNonCCPlusLatestCCMatrix(container, parsed){
  const allSoft = parsed.software || [];
  const ccList = allSoft.filter(sw => /^CC\b/i.test(sw.base));
  const nonCC  = allSoft.filter(sw => !/^CC\b/i.test(sw.base));

  if (!nonCC.length && !ccList.length) return;

  let latestCC = null;
  if (ccList.length){
     const withDate = ccList.filter(sw => !!sw.date);
     if (withDate.length){
       latestCC = withDate.reduce((best, cur)=> (best==null || cur.date > best.date) ? cur : best, null);
     } else {
       latestCC = ccList[ccList.length - 1];
     }
  }

  const cols = nonCC.slice();
  if (latestCC) cols.push({...latestCC, _latest:true});
  if (!cols.length) return;

  const kpiNames = [];
  parsed.entries.forEach(e=>{
    const name = `${e.func} — ${e.kpi}`;
    if (!kpiNames.includes(name)) kpiNames.push(name);
  });
  if (!kpiNames.length) return;

  const entryByName = new Map();
  parsed.entries.forEach(e => entryByName.set(`${e.func} — ${e.kpi}`, e));

  const card = container.append('div').attr('class', 'chart-card');
  card.append('div').attr('class','matrix-title').text('KPI × Software matrix');
  card.append('div').attr('class','matrix-sub').text('Non-CC + latest CC');

  const wrap = card.append('div').attr('class','matrix-wrap');
  const mtable = wrap.append('table').attr('class','matrix-table');

  const thead = mtable.append('thead').append('tr');
  thead.append('th').text('KPI');
  thead.append('th').attr('class','target').text('Target');
  cols.forEach(sw => {
    const th = thead.append('th').attr('class','software');
    th.text(sw._latest ? `${sw.label} (latest CC)` : sw.label);
  });

  const tbody = mtable.append('tbody');
  kpiNames.forEach(name=>{
    const tr = tbody.append('tr');
    const e = entryByName.get(name);
    tr.append('td').text(name);
    tr.append('td').attr('class','target').text(fmtCell(e ? e.target : null));
    cols.forEach(sw=>{
      const v = e ? e.values[sw.label] : null;
      const td = tr.append('td').attr('class','num').attr('title', `Events: ${fmtCell(v)}  |  Target: ${fmtCell(e ? e.target : null)}`);
      td.text(fmtCell(v));
    });
  });
}

/* ==================== Per-software cards ==================== */
function renderSoftwareCards(container, parsed){
  const T = getThresholds();
  (parsed.software||[]).forEach(sw=>{
    const swLabel = sw.label;

    // Any value for this SW after (possible) external filtering?
    const hasAny = parsed.entries.some(e => e.values[swLabel]!=null && !Number.isNaN(e.values[swLabel]));
    if (!hasAny) return;

    const card = container.append('div').attr('class','chart-card');
    const w = 680;

    // Title SVG (radar sits inside same SVG)
    const radarH = 540;
    const TITLE_Y = 26, TITLE_TO_RADAR_GAP = 50, RADAR_PAD_LEFT = 30, MIN_SIDE_MARGIN = 8, FUNC_LABEL_OFFSET = 16;

    const svg = card.append('svg').attr('width', w);

    const titleText = (CURRENT_MODE === MODES.EXTERNAL ? 'External — ' : '') + (sw.date ? `${swLabel}. ${sw.date}` : swLabel);
    svg.append('text').attr('x', w/2).attr('y', TITLE_Y).attr('text-anchor','middle').attr('font-weight',700).text(titleText);

    // Download PNG
    card.append('button').attr('class','download').text('Download PNG').on('click',()=>{
      const s = new XMLSerializer().serializeToString(svg.node());
      const url = URL.createObjectURL(new Blob([s], {type:'image/svg+xml'}));
      const vb = svg.node().viewBox && svg.node().viewBox.baseVal;
      const bbox = svg.node().getBBox ? svg.node().getBBox() : null;
      const W = (vb && vb.width)  || (svg.node().width?.baseVal?.value)  || Math.ceil((bbox?.width  || 800));
      const H = (vb && vb.height) || (svg.node().height?.baseVal?.value) || Math.ceil((bbox?.height || 600));
      const img = new Image();
      img.onload = ()=>{
        const canvas = document.createElement('canvas'); canvas.width=W; canvas.height=H;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,W,H);
        ctx.drawImage(img,0,0);
        const a=document.createElement('a'); a.download = `${swLabel.replaceAll(' ','_')}.png`; a.href = canvas.toDataURL('image/png'); a.click();
        URL.revokeObjectURL(url);
      };
      img.src = url;
    });

    // Build surviving rows first (prevents empty KPI table later)
    const rows = parsed.entries
      .filter(e => e.values[swLabel] != null && !Number.isNaN(e.values[swLabel]))
      .map(e => ({ kpi: e.kpi, func: e.func, target: e.target, max: e.max, events: e.values[swLabel] }));

    if (rows.length === 0) {
      card.append('div').attr('class','small').style('margin','8px 10px 12px')
        .text(CURRENT_MODE === MODES.EXTERNAL
          ? 'No KPIs remain for this software after External whitelist filtering.'
          : 'No KPI values for this software.');
      svg.remove();
      return;
    }

    // ===== Radar geometry (functions derived from surviving rows) =====
    const leftAreaWidth = w;
    const radarTop = TITLE_Y + TITLE_TO_RADAR_GAP;
    const availableW = Math.max(120, leftAreaWidth - RADAR_PAD_LEFT - MIN_SIDE_MARGIN);
    const centerX = RADAR_PAD_LEFT + availableW / 2;
    const rMaxCandidateW = Math.max(10, availableW/2 - FUNC_LABEL_OFFSET);
    const rMaxCandidateH = (radarH - radarTop) - 16;
    const rMax = Math.max(80, Math.min(rMaxCandidateW, rMaxCandidateH));
    const centerY = radarTop + rMax;

    const g = svg.append('g').attr('transform', `translate(${centerX},${centerY})`);

    const functions = Array.from(new Set(rows.map(r => r.func)));
    if (!functions.length){
      card.append('div').attr('class','small')
        .text(CURRENT_MODE === MODES.EXTERNAL
          ? 'No KPIs remain for this software after External whitelist filtering.'
          : 'No KPI values for this software.');
      svg.remove();
      return;
    }

    const linearPortion = 0.55;
    const rLinear = rMax * linearPortion;
    const logMin = 10, logMax = 1000;
    const logDen = Math.log10(logMax) - Math.log10(logMin);
    function toR(v){
      if (v==null || Number.isNaN(v)) return null;
      if (v <= 0) return 0;
      const vv = Math.min(v, logMax);
      if (vv < logMin) return (vv / logMin) * rLinear;
      return rLinear + ((Math.log10(vv) - Math.log10(logMin)) / logDen) * (rMax - rLinear);
    }

    const ringGrid = [1,2,3,4,5,6,7,8,9,10,30,100,300,1000];
    g.selectAll('.ring').data(ringGrid).enter().append('circle')
      .attr('r', d=>toR(d)).attr('fill','none').attr('stroke','#999').attr('stroke-opacity',0.22);
    g.selectAll('.rlabel').data(ringGrid).enter().append('text')
      .attr('x', 6).attr('y', d=> -toR(d))
      .attr('dominant-baseline','middle').attr('font-size', 11).attr('fill', '#666')
      .text(d=>d);

    const axisY = -rMax * 0.70;
    g.append('text').attr('x', -8).attr('y', axisY).attr('transform', `rotate(-90, 0, ${axisY})`)
      .attr('text-anchor','end').attr('font-size', 11).text('Number of events');

    const F = functions.length;
    const wedge = (Math.PI*2) / F;
    const innerFrac = 0.98;
    const spread = wedge * innerFrac;
    const arc = d3.arc();

    // Alternating background and labels
    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const end = start + wedge;
      g.append('path').attr('d', arc({innerRadius:0, outerRadius:rMax, startAngle:start, endAngle:end}))
        .attr('fill', idx % 2 ? '#f6f7fb' : '#eef2ff').attr('fill-opacity', 0.06);
      g.append('line').attr('x1',0).attr('y1',0).attr('x2', Math.cos(start)*rMax).attr('y2', Math.sin(start)*rMax)
        .attr('stroke','#000').attr('stroke-opacity',0.25);
      const cen = (start + end) / 2;
      g.append('text').attr('x', Math.cos(cen)*(rMax+16)).attr('y', Math.sin(cen)*(rMax+16))
        .attr('text-anchor','middle').attr('font-weight',700).attr('fill','#1f3de3').text(f);
    });

    // Plot KPIs for each function using surviving rows
    functions.forEach((f, idx)=>{
      const start = -Math.PI/2 + idx*wedge;
      const center = start + wedge/2;
      const items = rows.filter(r=>r.func===f);
      const K = items.length;
      const avail = spread * 0.96;
      const baseOffs = (K===1) ? [0] : d3.range(K).map(i => (i-(K-1)/2)/(K-1) * (avail/2));
      const placed = [];
      const minSep = wedge * 0.09;
      const radBin = rMax * 0.12;
      const labelAvoid = wedge * 0.18;

      items.forEach((e, i)=>{
        const v = e.events; if (v==null || Number.isNaN(v)) return;
        let r = toR(v);
        let ang = center + baseOffs[i];
        const isBlack = (v === 1000);

        if (isBlack && Math.abs(ang - center) < labelAvoid){
          const dir = (ang >= center) ? 1 : -1;
          ang = center + dir * (labelAvoid + wedge*0.02);
        }
        ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
        let tries = 0;
        while (placed.some(p => Math.abs(p.ang - ang) < minSep && Math.abs(p.r - r) < radBin) && tries < 120){
          const dir = (tries % 2 === 0) ? 1 : -1;
          ang += dir * (minSep * 0.65);
          ang = Math.max(center - avail/2, Math.min(center + avail/2, ang));
          tries++;
        }
        if (tries >= 120){ r = Math.min(r + 8, rMax * 0.98); }
        placed.push({ang, r});

        const cx = Math.cos(ang)*r, cy = Math.sin(ang)*r;
        const fill = colorFor(v, e.target, e.max);
        if (!fill) return;

        g.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 7).attr('fill', fill)
          .append('title').text(`${f} — ${e.kpi}: ${v}`);

        const rLabel = Math.min(r + 18, rMax * 0.98);
        const lx = Math.cos(ang)*rLabel, ly = Math.sin(ang)*rLabel;
        g.append('text').attr('x', lx).attr('y', ly).attr('text-anchor','middle')
          .attr('font-size', 11).attr('paint-order','stroke').attr('stroke','white').attr('stroke-width',3)
          .text(e.kpi);
      });
    });

    // ===== KPI summary table (HTML table version — robust) =====
    const htmlCaption = document.createElement('div');
    htmlCaption.className = 'small';
    htmlCaption.style.margin = '18px 0 6px';
    htmlCaption.textContent = 'KPI summary per 1000 km';
    card.node().appendChild(htmlCaption);

    const wrapDiv = d3.select(card.node()).append('div').attr('class','kpi-table-wrap');
    const t = wrapDiv.append('table').attr('class','summary-table');

    const thead = t.append('thead').append('tr');
    thead.append('th').text('KPI');
    thead.append('th').text('Function');
    thead.append('th').style('text-align','right').text('Target');
    thead.append('th').style('text-align','right').text('Max allowed');
    thead.append('th').style('text-align','right').text('Number of events');

    const tbody = t.append('tbody');
    rows.forEach(r=>{
      const tr = tbody.append('tr');
      tr.append('td').text(r.kpi);
      tr.append('td').text(r.func);
      tr.append('td').style('text-align','right').text(fmtCell(r.target));
      tr.append('td').style('text-align','right').text(fmtCell(r.max));
      tr.append('td').style('text-align','right').style('font-weight','600').text(fmtCell(r.events));
    });

    // ===== Scoring band (SVG below the table) =====
    const scoreBand = d3.select(card.node()).append('svg').attr('width', w);
    const valuesForAvg = rows.map(r => r.events).filter(v => v != null && !Number.isNaN(v));
const sumVals = valuesForAvg.length ? d3.sum(valuesForAvg.map(v => Math.min(v, 1000))) : 0;
const denom = (TOTAL_KPI_COUNT && TOTAL_KPI_COUNT > 0) ? TOTAL_KPI_COUNT : valuesForAvg.length;
const avgEvents = denom ? (sumVals / denom) : null;
    const score = avgEvents==null ? null : scoreFromAvg(avgEvents, T);

    const barMargin = 20, boxH2 = 42;
    const barW = w - barMargin*2;
    const boxW = barW / 10;
    const caption = (avgEvents==null)
      ? 'Average per 1000km:  n/a (only "No function" or missing values)'
      : `Average per 1000km:  ${avgEvents.toFixed(1)} events → Score: ${score} (${scoreText[score-1]})`;

    scoreBand.append('text').attr('x', barMargin).attr('y', 16).attr('font-size', 12).text(caption);
    const ranges = scoreRangeLabels(T);

    for (let i=0;i<10;i++){
      const x = barMargin + i*boxW;
      const isSel = (score === i+1);
      const g2 = scoreBand.append('g');
      g2.append('rect')
        .attr('x', x).attr('y', 30)
        .attr('width', boxW).attr('height', boxH2)
        .attr('fill', scoreColors[i])
        .attr('stroke', isSel ? '#000' : '#111')
        .attr('stroke-width', isSel ? 3 : 0.4)
        .append('title').text(`Score ${i+1}: ${scoreText[i]} — ${ranges[i]}`);
      g2.append('text').attr('x', x + boxW/2).attr('y', 30 + 14).attr('text-anchor','middle')
        .attr('font-weight', isSel ? 950 : 750).attr('font-size', SCORE_FONTS.number).text(i+1);
      g2.append('text').attr('x', x + boxW/2).attr('y', 30 + 14 + 16).attr('text-anchor','middle')
        .attr('font-weight', isSel ? 850 : 550).attr('font-size', SCORE_FONTS.label).text(scoreText[i]);
      g2.append('text').attr('x', x + boxW/2).attr('y', 30 + boxH2 + 14).attr('text-anchor','middle')
        .attr('font-size', SCORE_FONTS.range).text(ranges[i]);
    }
    scoreBand.attr('height', 30 + boxH2 + 28 + 8);

    // Final SVG height (for PNG export to include radar only)
    const RADAR_BOTTOM_PADDING = 20;
    const totalRadarHeight = centerY + rMax + RADAR_BOTTOM_PADDING;
    svg.attr('height', totalRadarHeight);
  });
}

/* ==================== Main renderer ==================== */
function renderCharts(parsedFull){
  const parsed = filterEntriesForMode(parsedFull);
  const container = d3.select('#charts').html('');
  if (!parsed || !parsed.entries || !parsed.entries.length){
    container.append('div').attr('class','small').text('No data to render.');
    return;
  }

  const ext = (CURRENT_MODE === MODES.EXTERNAL);

  if (!ext || EXTERNAL_CARD_VISIBILITY.summary)               renderSummary(container, parsed);
  if (!ext || EXTERNAL_CARD_VISIBILITY.calendar)              renderCalendarTrio(container, parsed);
  if (!ext || EXTERNAL_CARD_VISIBILITY.ccMatrix)              renderCCMatrix(container, parsed);
  if (!ext || EXTERNAL_CARD_VISIBILITY.nonCCPlusLatestCC)     renderNonCCPlusLatestCCMatrix(container, parsed);
  if (!ext || EXTERNAL_CARD_VISIBILITY.softwareCards)         renderSoftwareCards(container, parsed);
}

/* ==================== Loader (CSV + release notes + weather) ==================== */
async function loadCsvAndRender(){
  try{
    const res = await fetch(DATA_CSV + '?t=' + Date.now(), {cache:'no-store'});
    if(!res.ok) throw new Error(`HTTP ${res.status}`);
    const text = await res.text();
    LAST_RAW = text;

    // Parse the main KPI table
    let parsed = parseTable(text);

    // Release notes (files / optional manifest)
    const manifestSet = await loadReleaseNotesManifest();
    const fileNotes = await loadReleaseNotesFromFiles(parsed.software, manifestSet);

    // Weather: collect unique dates, fetch archive weather, merge
    const dates = Array.from(new Set((parsed.software||[]).map(sw => sw.date).filter(Boolean)));
    const weatherByDate = await fetchWeatherForDates(dates);

    // === NEW: load total KPI count from KPI_buttons.csv (lines containing "redButton") ===
    TOTAL_KPI_COUNT = await loadTotalKpiCount();

    // Merge everything into the parsed object
    parsed = { 
      ...parsed, 
      releaseNotes: { ...(parsed.releaseNotes||{}), ...fileNotes }, 
      weatherByDate 
    };

    LAST_PARSED = parsed;
    renderCharts(LAST_PARSED);
  }catch(err){
    d3.select('#charts').html('');
    alert(`Could not load "${DATA_CSV}". Make sure it sits next to this HTML and that you're serving over http(s).\n\nError: ${err.message}`);
  }
}

/* ==================== Tabs wiring ==================== */
function updateTabsUI(){
  document.querySelectorAll('.tab').forEach(btn=>{
    const on = (btn.dataset.mode === CURRENT_MODE);
    btn.classList.toggle('active', on);
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
  });
}
document.querySelectorAll('.tab').forEach(btn=>{
  btn.addEventListener('click', (e)=>{
    e.preventDefault();
    const mode = btn.dataset.mode;
    if (!mode || mode === CURRENT_MODE) return;
    CURRENT_MODE = mode;
    updateTabsUI();
    if (LAST_PARSED) renderCharts(LAST_PARSED);
  });
  // a11y: keyboard toggle
  btn.setAttribute('role','tab'); btn.setAttribute('tabindex','0');
  btn.addEventListener('keydown', (e)=>{
    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); btn.click(); }
  });
});

/* ==================== Boot ==================== */
document.addEventListener('DOMContentLoaded', ()=>{
  updateTabsUI();
  loadCsvAndRender();
});
</script>
</body>
</html>
