<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BTC & ETH — Sentence Sentiment + Scatter (Last N Days)</title>
<style>
  :root{--bg:#0f1220;--card:#171a2b;--ink:#e7e9ff;--muted:#9aa3b2;--accent:#6ea8ff;--good:#2ecc71;--bad:#ff5c5c;--border:#272a3d}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial;background:var(--bg);color:var(--ink)}
  header{padding:18px 16px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,#14172a,#0f1220)}
  h1{margin:0;font-size:20px}
  .muted{color:var(--muted)}
  main{max-width:1200px;margin:18px auto;padding:0 12px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:14px}
  .controls>*{background:var(--card);border:1px solid var(--border);color:var(--ink);border-radius:10px;padding:10px 12px}
  .controls input[type="text"]{min-width:340px}
  button{cursor:pointer}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px}
  .card h2{margin:4px 0 10px;font-size:16px;display:flex;gap:10px;align-items:baseline}
  .priceTag{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;font-variant-numeric:tabular-nums}
  th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left;vertical-align:top}
  th{color:var(--muted);font-weight:600}
  td.num{text-align:right}
  .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#1d2136;border:1px solid var(--border);color:var(--muted);font-size:12px;margin-right:6px}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .status{min-height:24px}
  .good{color:var(--good);font-weight:600}
  .bad{color:var(--bad);font-weight:600}
  .spinner{display:inline-block;width:16px;height:16px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;vertical-align:-3px}
  @keyframes spin{to{transform:rotate(360deg)}}
  .foot{margin-top:16px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>Bitcoin & Ethereum — Sentence-Level Sentiment + Scatter (last N days)</h1>
  <div class="muted small">Counts sentences (negation-aware) per day for BTC & ETH; shows price and % vs previous day. Scatter plot: net sentences vs daily % change. Prices via CoinGecko with Binance fallback.</div>
</header>

<main>
  <div class="controls">
    <label>Worker URL:
      <input id="workerUrl" type="text" placeholder="https://your-name.workers.dev"/>
    </label>
    <button id="saveWorker">Save</button>
    <span class="muted small">Leave empty to attempt direct fetch.</span>
  </div>

  <div class="controls">
    <label>Days:
      <input id="days" type="number" min="7" max="120" value="60" style="width:90px;margin-left:6px;background:transparent;border:none;outline:none;color:var(--ink);">
    </label>
    <label><input id="includeCryptoSub" type="checkbox" checked> Include r/CryptoCurrency</label>
    <label><input id="includeNews" type="checkbox" checked> Include News RSS</label>
    <label><input id="titlesOnly" type="checkbox"> Titles only (faster)</label>
    <button id="runBtn">Run</button>
    <span id="status" class="status"></span>
  </div>

  <div class="row" style="margin-bottom:8px;">
    <span class="tag">Reddit: r/Bitcoin, r/Ethereum <span id="srcExtra"></span></span>
    <span class="tag" id="newsTag">RSS: CoinDesk, CoinTelegraph, Bitcoin Magazine, Google News</span>
    <span class="tag">Sentence-level, negation-aware</span>
    <span class="tag">Aggregation: per UTC date</span>
  </div>

  <div class="grid">
    <section class="card">
      <h2>Bitcoin <span id="btcPrice" class="priceTag"></span></h2>
      <table id="btcTable">
        <thead>
          <tr>
            <th>Date (UTC)</th>
            <th class="good">Positive sentences</th>
            <th class="bad">Negative sentences</th>
            <th>Price (USD)</th>
            <th>% vs prev day</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div style="margin-top:10px">
        <canvas id="btcScatter" height="260"></canvas>
      </div>
    </section>

    <section class="card">
      <h2>Ethereum <span id="ethPrice" class="priceTag"></span></h2>
      <table id="ethTable">
        <thead>
          <tr>
            <th>Date (UTC)</th>
            <th class="good">Positive sentences</th>
            <th class="bad">Negative sentences</th>
            <th>Price (USD)</th>
            <th>% vs prev day</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div style="margin-top:10px">
        <canvas id="ethScatter" height="260"></canvas>
      </div>
    </section>
  </div>

  <div class="foot">
    Tip: If counts look low, untick “Titles only” and increase “Days”. Ensure your Worker allows: <code>www.reddit.com</code>, <code>api.coingecko.com</code>, <code>api.binance.com</code>, and (for news) <code>coindesk.com</code>, <code>cointelegraph.com</code>, <code>bitcoinmagazine.com</code>, <code>news.google.com</code>.
  </div>
</main>

<!-- Chart.js for the scatter plots -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<script>
/* ==================== Config ==================== */
const SUBS_CORE = ["Bitcoin","Ethereum"];
const SUB_CRYPTOCURRENCY = "CryptoCurrency";
const REDDIT_PAGE_LIMIT = 100;
const REDDIT_MAX_PAGES = 10;

const RSS_SOURCES = [
  "https://www.coindesk.com/arc/outboundfeeds/rss/",
  "https://cointelegraph.com/rss",
  "https://bitcoinmagazine.com/.rss",
  "https://news.google.com/rss/search?q=bitcoin",
  "https://news.google.com/rss/search?q=ethereum"
];

const KEYWORDS = {
  btc: /(bitcoin|btc|\$btc|\bxbt\b)/i,
  eth: /(ethereum|eth|\$eth)/i
};

const MAP_CG_TO_BINANCE = { bitcoin:"BTCUSDT", ethereum:"ETHUSDT" };

/* ==================== UX helpers ==================== */
function getWorker(){ return (localStorage.getItem("workerEndpoint") || "").trim(); }
function setWorker(url){
  if(url && !/^https?:\/\//i.test(url)) throw new Error("Worker URL must start with http(s)://");
  localStorage.setItem("workerEndpoint", (url||"").replace(/\/+$/,""));
}
function setStatus(msg, spin=false){
  const el = document.getElementById('status');
  el.innerHTML = spin ? `<span class="spinner"></span> ${msg}` : msg;
}
const delay = (ms)=> new Promise(r=>setTimeout(r, ms));
function fmtUSD(n){ return (n==null||!isFinite(n)) ? "—" : `$${Number(n).toLocaleString(undefined,{maximumFractionDigits:2})}`; }
function utcDateStr(tsSec){ return new Date(tsSec*1000).toISOString().slice(0,10); }

/* ==================== Fetch (Worker → direct fallback) ==================== */
async function fetchJSONSmart(targetUrl){
  const worker = getWorker();
  const tryDirect = async ()=>{
    const r = await fetch(targetUrl, { headers:{ "Accept":"application/json" }});
    if(!r.ok) throw new Error(`Direct ${r.status} ${r.statusText} for ${targetUrl}`);
    return await r.json();
  };
  if(worker){
    try{
      // accept /?url=... or /proxy?url=... styles
      const via = `${worker}${worker.endsWith('/proxy')?'':'/proxy'}?url=${encodeURIComponent(targetUrl)}`;
      const r = await fetch(via, { headers:{ "Accept":"application/json" }});
      if(!r.ok) throw new Error(`Worker ${r.status} ${r.statusText} for ${targetUrl}`);
      return await r.json();
    }catch(e){
      console.warn("Worker JSON failed, trying direct:", e);
      return await tryDirect();
    }
  }else{
    return await tryDirect();
  }
}
async function fetchTextSmart(targetUrl){
  const worker = getWorker();
  const tryDirect = async ()=>{
    const r = await fetch(targetUrl);
    if(!r.ok) throw new Error(`Direct ${r.status} ${r.statusText} for ${targetUrl}`);
    return await r.text();
  };
  if(worker){
    try{
      const via = `${worker}${worker.endsWith('/proxy')?'':'/proxy'}?url=${encodeURIComponent(targetUrl)}`;
      const r = await fetch(via);
      if(!r.ok) throw new Error(`Worker ${r.status} ${r.statusText} for ${targetUrl}`);
      return await r.text();
    }catch(e){
      console.warn("Worker TEXT failed, trying direct:", e);
      return await tryDirect();
    }
  }else{
    return await tryDirect();
  }
}

/* ==================== Reddit ==================== */
async function fetchSubNew(sub, after=null){
  const url = new URL(`https://www.reddit.com/r/${sub}/new.json`);
  url.searchParams.set('limit', REDDIT_PAGE_LIMIT);
  if(after) url.searchParams.set('after', after);
  return await fetchJSONSmart(url.toString());
}

async function fetchPosts(days, titlesOnly, includeCrypto){
  const cutoff = Date.now()/1000 - days*86400;
  let all = [];
  const subs = [...SUBS_CORE, ...(includeCrypto ? [SUB_CRYPTOCURRENCY] : [])];

  for(const sub of subs){
    let after=null, pages=0;
    while(pages < REDDIT_MAX_PAGES){
      const data = await fetchSubNew(sub, after);
      const children = data?.data?.children || [];
      if(children.length===0) break;

      const posts = children.map(c => c.data).map(p => ({
        title: p.title || "",
        selftext: titlesOnly ? "" : (p.selftext || ""),
        created_utc: p.created_utc || 0
      }));

      const fresh = posts.filter(p => p.created_utc >= cutoff);
      all.push(...fresh);

      after = data?.data?.after || null;
      pages++;
      const lastTs = posts[posts.length-1]?.created_utc || 0;
      if(!after || lastTs < cutoff) break;
      await delay(220);
    }
  }
  return all;
}

/* ==================== RSS (optional) ==================== */
function parseRssItems(xmlText){
  const doc = new DOMParser().parseFromString(xmlText, "text/xml");
  let items = Array.from(doc.querySelectorAll("item"));
  if(items.length === 0){ items = Array.from(doc.querySelectorAll("entry")); }
  return items.map(el => {
    const title = (el.querySelector("title")?.textContent || "").trim();
    const desc = (el.querySelector("description, summary, content")?.textContent || "").trim();
    const pub = (el.querySelector("pubDate, updated, published")?.textContent || "").trim();
    const ts = pub ? Math.floor(Date.parse(pub)/1000) : Math.floor(Date.now()/1000);
    return { title, selftext: desc, created_utc: isFinite(ts) ? ts : Math.floor(Date.now()/1000) };
  });
}
async function fetchRSS(days){
  const cutoff = Date.now()/1000 - days*86400;
  const out = [];
  for(const url of RSS_SOURCES){
    try{
      const text = await fetchTextSmart(url);
      const items = parseRssItems(text);
      for(const it of items){
        if(it.created_utc >= cutoff) out.push(it);
      }
      await delay(160);
    }catch(e){ console.warn("RSS fail", url, e); }
  }
  return out;
}

/* ==================== Prices (CG → Binance; inject today if missing) ==================== */
async function fetchCurrent(symbol){ // "bitcoin" | "ethereum"
  try{
    const data = await fetchJSONSmart(`https://api.coingecko.com/api/v3/simple/price?ids=${symbol}&vs_currencies=usd`);
    const v = data?.[symbol]?.usd;
    if(v!=null) return Number(v);
  }catch{}
  try{
    const bin = MAP_CG_TO_BINANCE[symbol];
    const url = new URL("https://api.binance.com/api/v3/ticker/price");
    url.searchParams.set("symbol", bin);
    const data = await fetchJSONSmart(url.toString());
    return Number(data?.price ?? NaN);
  }catch{}
  return NaN;
}
async function fetchDaily(symbol, days){
  try{
    const data = await fetchJSONSmart(`https://api.coingecko.com/api/v3/coins/${symbol}/market_chart?vs_currency=usd&days=${days+2}&interval=daily`);
    const out = {};
    for(const [ts, price] of (data?.prices || [])){
      out[new Date(ts).toISOString().slice(0,10)] = Number(price);
    }
    return out;
  }catch{}
  try{
    const bin = MAP_CG_TO_BINANCE[symbol];
    const url = new URL("https://api.binance.com/api/v3/klines");
    url.searchParams.set("symbol", bin);
    url.searchParams.set("interval", "1d");
    url.searchParams.set("limit", String(days+2));
    const data = await fetchJSONSmart(url.toString());
    const out = {};
    for(const k of data){
      out[new Date(k[0]).toISOString().slice(0,10)] = Number(k[4]);
    }
    return out;
  }catch{}
  return {};
}
function injectToday(prices, live){
  const today = new Date().toISOString().slice(0,10);
  if(live!=null && isFinite(live) && prices[today]==null) prices[today] = Number(live);
  return prices;
}

/* ==================== Sentence-level sentiment (negation-aware) ==================== */
const NEGATORS = new Set([
  "not","no","never","without","isnt","arent","wasnt","werent","dont","doesnt","didnt","wont","cant","cannot",
  "inte","ej","aldrig","utan",
  "ikke","aldri","uden",
  "nicht","nie","ohne","kein","keine",
  "ne","pas","jamais","sans",
  "no","nunca","sin","ningun","ninguna",
  "nao","n\u00e3o","nunca","sem",
  "non","mai","senza",
  "niet","nooit","zonder","geen",
  "degil","asla","hic","olmadan",
  "ne","net","nikogda","bez"
]);
const BOOSTERS = new Set([
  "very","so","really","extremely","highly","super","ultra","insanely","crazy","mega",
  "väldigt","mycket","svært","meget","sehr","très","muy","muito","molto","heel","çok","ochen","очень"
]);
const VALENCE_POS = new Set([
  "bull","bullish","buy","accumulate","long","support","breakout","rally","bounce",
  "moon","pump","surge","spike","squeeze","green","uptrend","ath","rebound","recovery",
  "strong","undervalued","cheap","oversold","momentum","rocket","hodl","wagmi","lfg",
  "till månen","til månen","kuuhun","zum mond","vers la lune","a la luna","à la lune","alla luna","naar de maan"
]);
const VALENCE_NEG = new Set([
  "bear","bearish","sell","dump","crash","plunge","collapse","capitulation","liquidation",
  "resistance","overvalued","weak","downtrend","red","fear","panic","fraud","scam",
  "rug","rug pull","ponzi","exploit","hack","ban","crackdown","rekt","ngmi","paper hands"
]);
const EMOJI_POS = /🚀|📈|🟢|✅|💎🙌|💎|✨/g;
const EMOJI_NEG = /📉|🟥|🔻|❌|😱|😭|💀|⚠️/g;

function normText(s){ return (s||"").toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,""); }
function tokenize(s){
  return normText(s).split(/[^0-9a-z$#\u0400-\u04FF]+/i).filter(Boolean);
}
function splitSentences(text){
  return (text||"").replace(/\r/g," ").split(/[.!?…\n]+/g).map(s=>s.trim()).filter(s=>s.length>2);
}
function scoreSentence(sentence){
  if(!sentence) return 0;
  const s = sentence;
  const emojisPos = (s.match(EMOJI_POS)||[]).length;
  const emojisNeg = (s.match(EMOJI_NEG)||[]).length;

  const toks = tokenize(s);
  if(!toks.length) return emojisPos - emojisNeg;

  let score = (emojisPos - emojisNeg); // emoji hint

  for(let i=0;i<toks.length;i++){
    const w = toks[i];
    let delta = 0;
    if (VALENCE_POS.has(w)) delta = 1;
    else if (VALENCE_NEG.has(w)) delta = -1;

    if (delta !== 0){
      const prev = toks.slice(Math.max(0,i-3), i);
      if (prev.some(p=>BOOSTERS.has(p))) delta *= 1.2;   // emphasis
      if (prev.some(p=>NEGATORS.has(p))) delta *= -1;     // negation flip
      score += delta;
    }
  }

  const bangs = Math.min(3, (s.match(/!/g)||[]).length);
  if (bangs) score += 0.1*bangs * Math.sign(score||1);

  if (Math.abs(score) < 0.35) return 0; // neutral
  return score;
}

function sentenceSentimentCountsForAsset(posts, which){
  const kw = which==='btc' ? KEYWORDS.btc : KEYWORDS.eth;
  const byDate = {}; // {date: {pos:n, neg:n}}
  for(const p of posts){
    const text = `${p.title} ${p.selftext||""}`.trim();
    const sentences = splitSentences(text);
    const date = utcDateStr(p.created_utc);
    for(const sent of sentences){
      if(!kw.test(sent)) continue; // sentence must mention the asset
      const val = scoreSentence(sent);
      if(val===0) continue;
      if(!byDate[date]) byDate[date] = {pos:0, neg:0};
      if(val>0) byDate[date].pos++; else byDate[date].neg++;
    }
  }
  return byDate;
}

/* ==================== Tables ==================== */
function fillTable(tbody, byDate, prices){
  tbody.innerHTML = "";
  const dates = Object.keys(byDate).sort().reverse(); // newest first
  for(let i=0;i<dates.length;i++){
    const d = dates[i];
    const {pos, neg} = byDate[d];

    const priceVal = prices ? prices[d] : null;
    const priceText = fmtUSD(priceVal);

    let changeText = "—";
    if (prices && priceVal != null) {
      const prevDate = (function nearestPrev(dates, idx){
        for(let j=idx+1;j<dates.length;j++){ const dd = dates[j]; if(prices[dd]!=null) return dd; }
        return null;
      })(dates, i);
      const prevVal = prevDate ? prices[prevDate] : null;
      if (prevVal != null && prevVal !== 0){
        const change = ((priceVal - prevVal)/prevVal)*100;
        const color = change>0 ? "var(--good)" : change<0 ? "var(--bad)" : "var(--muted)";
        const sign = change>0 ? "+" : (change<0 ? "" : "");
        changeText = `<span style="color:${color}">${sign}${change.toFixed(2)}%</span>`;
      }
    }

    const tr = document.createElement('tr');
    tr.innerHTML =
      `<td>${d}</td>`+
      `<td class="num good">${pos||0}</td>`+
      `<td class="num bad">${neg||0}</td>`+
      `<td class="num">${priceText}</td>`+
      `<td class="num">${changeText}</td>`;
    tbody.appendChild(tr);
  }
}

/* ==================== Scatter plot helpers ==================== */
// Build per-day scatter points: x = pos - neg, y = % vs prev day.
function buildScatterPoints(byDate, prices){
  const dates = Object.keys(byDate).sort().reverse(); // newest first
  const pts = [];

  function prevDateWithPrice(idx){
    for(let j=idx+1;j<dates.length;j++){
      const d = dates[j];
      if(prices && prices[d] != null) return d;
    }
    return null;
  }

  for(let i=0;i<dates.length;i++){
    const d = dates[i];
    const {pos=0, neg=0} = byDate[d] || {};
    const x = (pos - neg);
    let y = null;

    if (prices && prices[d] != null){
      const prevD = prevDateWithPrice(i);
      const prevVal = prevD ? prices[prevD] : null;
      if (prevVal != null && prevVal !== 0){
        y = ((prices[d] - prevVal) / prevVal) * 100;
      }
    }
    if (y == null || !isFinite(y)) continue;

    pts.push({
      x, y,
      date: d,
      pos, neg,
      price: prices ? prices[d] : null,
      color: y > 0 ? "#2ecc71" : y < 0 ? "#ff5c5c" : "#9aa3b2"
    });
  }
  return pts;
}

let __btcChart, __ethChart;

function drawScatter(canvasId, points, title){
  const ctx = document.getElementById(canvasId)?.getContext('2d');
  if(!ctx) return;

  if(canvasId === "btcScatter" && __btcChart){ __btcChart.destroy(); }
  if(canvasId === "ethScatter" && __ethChart){ __ethChart.destroy(); }

  const data = {
    datasets: [{
      label: title,
      data: points.map(p => ({ x:p.x, y:p.y })),
      pointBackgroundColor: points.map(p => p.color),
      pointBorderColor: points.map(p => p.color),
      pointRadius: 4,
      showLine: false
    }]
  };

  const chart = new Chart(ctx, {
    type: 'scatter',
    data,
    options: {
      animation: false,
      scales: {
        x: {
          title: { display:true, text: 'Positive − Negative sentences' },
          grid: { color: 'rgba(255,255,255,0.08)' },
          ticks: { color: '#9aa3b2' },
          zeroLineColor: 'rgba(255,255,255,0.3)'
        },
        y: {
          title: { display:true, text: '% vs previous day' },
          grid: { color: 'rgba(255,255,255,0.08)' },
          ticks: { color: '#9aa3b2', callback: (v)=> `${v}%` }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const p = points[ctx.dataIndex];
              const pct = (p.y>0?"+":"") + p.y.toFixed(2) + "%";
              return [
                `Date: ${p.date}`,
                `Net sentences: ${p.x} ( +${p.pos} / -${p.neg} )`,
                `Price: ${p.price!=null ? `$${Number(p.price).toLocaleString()}` : "—"}`,
                `Δ vs prev: ${pct}`
              ];
            }
          }
        }
      }
    }
  });

  if(canvasId === "btcScatter") __btcChart = chart;
  if(canvasId === "ethScatter") __ethChart = chart;
}

/* ==================== Main ==================== */
async function run(){
  const days = Math.max(7, Math.min(120, Number(document.getElementById('days').value || 60)));
  const titlesOnly = document.getElementById('titlesOnly').checked;
  const includeCrypto = document.getElementById('includeCryptoSub').checked;
  const includeNews = document.getElementById('includeNews').checked;

  document.getElementById('srcExtra').textContent = includeCrypto ? ", r/CryptoCurrency" : "";
  document.getElementById('newsTag').style.display = includeNews ? "inline-block" : "none";
  setStatus(`Fetching posts & prices for last ${days} day(s)…`, true);

  try{
    // 1) Fetch posts
    let posts = await fetchPosts(days, titlesOnly, includeCrypto);
    if(includeNews){
      const rss = await fetchRSS(days);
      posts.push(...rss);
    }

    // 2) Sentence-level counts per asset/day
    const btcByDate = sentenceSentimentCountsForAsset(posts, 'btc');
    const ethByDate = sentenceSentimentCountsForAsset(posts, 'eth');

    // 3) Prices
    const [btcDaily, ethDaily] = await Promise.all([fetchDaily("bitcoin", days), fetchDaily("ethereum", days)]);
    const [btcLive,  ethLive ] = await Promise.all([fetchCurrent("bitcoin"),   fetchCurrent("ethereum")]);

    const btcPrices = injectToday(btcDaily, btcLive);
    const ethPrices = injectToday(ethDaily, ethLive);

    if (isFinite(btcLive)) document.getElementById('btcPrice').textContent = fmtUSD(btcLive);
    if (isFinite(ethLive)) document.getElementById('ethPrice').textContent = fmtUSD(ethLive);

    // 4) Fill tables
    fillTable(document.querySelector('#btcTable tbody'), btcByDate, btcPrices);
    fillTable(document.querySelector('#ethTable tbody'), ethByDate, ethPrices);

    // 5) Build scatter data and render charts
    const btcPoints = buildScatterPoints(btcByDate, btcPrices);
    const ethPoints = buildScatterPoints(ethByDate, ethPrices);

    drawScatter("btcScatter", btcPoints, "BTC: net sentences vs daily % change");
    drawScatter("ethScatter", ethPoints, "ETH: net sentences vs daily % change");

    // 6) Status
    const totalSentences =
      Object.values(btcByDate).reduce((a,x)=>a+x.pos+x.neg,0) +
      Object.values(ethByDate).reduce((a,x)=>a+x.pos+x.neg,0);

    setStatus(`Done. Classified ${totalSentences} sentences across BTC & ETH. Points: BTC ${btcPoints.length}, ETH ${ethPoints.length}.`, false);
  }catch(err){
    console.error(err);
    setStatus(`Error: ${err.message}`, false);
  }
}

document.getElementById('runBtn').addEventListener('click', run);

// persist Worker URL
const workerInput = document.getElementById('workerUrl');
workerInput.value = getWorker();
document.getElementById('saveWorker').addEventListener('click', ()=>{
  try{ setWorker(workerInput.value||""); setStatus("Worker URL saved.", false); }
  catch(e){ setStatus(e.message, false); }
});

// autorun
run();
</script>
</body>
</html>
