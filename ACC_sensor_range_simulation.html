<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ACC Approach Simulator — IDM Controller (Full History)</title>
<style>
  :root{
    --bg:#0f1220; --panel:#151a2e; --ink:#e9ecff; --muted:#a6add6;
    --accent:#5aa7ff; --ok:#18a558; --bad:#ff5252;
    --grid:16px; --card-radius:18px;
  }
  html,body{margin:0; background:var(--bg); color:var(--ink); font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  .wrap{display:grid; grid-template-columns: 360px 1fr; gap:var(--grid); padding:var(--grid)}
  .card{background:var(--panel); border-radius:var(--card-radius); box-shadow:0 16px 40px rgba(0,0,0,.35)}
  .card .hd{padding:14px 16px; font-weight:600; border-bottom:1px solid rgba(255,255,255,.06)}
  .card .bd{padding:14px 16px}
  .row{display:grid; grid-template-columns: 1fr 120px; gap:10px; align-items:center; margin:8px 0}
  .row small{color:var(--muted)}
  input, select {width:120px; padding:8px 10px; border-radius:10px; border:1px solid rgba(255,255,255,.15); background:#0c1020; color:#e9ecff}
  button{appearance:none; border:0; background:var(--accent); color:#041021; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer}
  button.ghost{background:transparent; color:#e9ecff; border:1px solid rgba(255,255,255,.15)}
  .btnrow{display:flex; gap:10px; flex-wrap:wrap; margin-top:6px}
  table{width:100%; border-collapse:collapse; font-size:14px}
  th,td{padding:10px 8px; border-bottom:1px solid rgba(255,255,255,.08); text-align:right}
  th:first-child, td:first-child{text-align:left}
  th{color:#cfd6ff; font-weight:600; background:rgba(255,255,255,.03)}
  .meta{color:var(--muted); font-size:13px}
  .simWrap{padding:12px 12px 16px}
  .lane{position:relative; width:100%; height:340px; background:
      repeating-linear-gradient(90deg, #202744 0 3px, transparent 3px 100%),
      linear-gradient(#0d1224,#0b1020);
      border-radius:16px; overflow:hidden; border:1px solid rgba(255,255,255,.08)}
  .roadMark{position:absolute; left:50%; top:0; width:4px; height:100%;
            background:repeating-linear-gradient(#e6ecff 0 20px, transparent 20px 40px);
            transform:translateX(-50%); opacity:.35}
  .car{position:absolute; width:46px; height:24px; border-radius:6px}
  .car.lead{background:#ffd95e; box-shadow:0 0 18px rgba(255,217,94,.55)}
  .car.ego{background:#59f; box-shadow:0 0 18px rgba(90,167,255,.55)}
  .infoRow{display:flex; gap:14px; flex-wrap:wrap; margin-top:10px}
  .pill{background:#0c1226; border:1px solid rgba(255,255,255,.08); padding:8px 10px; border-radius:999px; font-size:13px}
  .ruler{position:absolute; bottom:10px; left:10px; right:10px; height:26px; pointer-events:none}
  .tick{position:absolute; bottom:0; width:1px; height:12px; background:#8fa6ff55}
  .tiny{font-size:12px; color:var(--muted)}
  .charts{display:grid; grid-template-columns: 1fr; gap:12px; margin-top:12px}
  canvas{background:#0d1224; border:1px solid rgba(255,255,255,.06); border-radius:12px; display:block; width:100%; height:150px}
</style>
</head>
<body>
  <div class="wrap">
    <!-- Inputs -->
    <div class="card">
      <div class="hd">Inputs</div>
      <div class="bd">
        <div class="row">
          <label>Initial detection distance (m)<br><small>Gap at t=0</small></label>
          <input id="inpStartDist" type="number" min="0" step="10" value="200" />
        </div>
        <div class="row">
          <label>Ego set speed v₀ (km/h)</label>
          <input id="inpVset" type="number" min="0" step="1" value="180" />
        </div>
        <div class="row">
          <label>Time gap T (s)</label>
          <input id="inpTgap" type="number" min="0" step="0.1" value="1" />
        </div>
        <div class="row">
          <label>Standstill gap s₀ (m)</label>
          <input id="inpS0" type="number" min="0" step="0.1" value="2" />
        </div>
        <div class="row">
          <label>Max accel a (m/s²)</label>
          <input id="inpAmaxAccel" type="number" min="0.1" step="0.1" value="2" />
        </div>
        <div class="row">
          <label>Comfort brake b (m/s²)</label>
          <input id="inpBcomfort" type="number" min="0.1" step="0.1" value="2.5" />
        </div>
        <div class="row">
          <label>Hard brake limit (m/s²)</label>
          <input id="inpAmaxBrake" type="number" min="0.1" step="0.1" value="5" />
        </div>
        <div class="row">
          <label>Lead speed for sim (km/h)</label>
          <select id="selLead">
            <option>0</option><option>10</option><option>20</option>
            <option>30</option><option>40</option><option>50</option>
            <option>60</option><option>70</option><option>80</option><option selected>90</option>
            <option>100</option><option>110</option><option>120</option><option>130</option>
            <option>140</option><option>150</option>
          </select>
        </div>
        <div class="btnrow">
          <button id="btnCompute">Compute Table</button>
          <button class="ghost" id="btnReset">Reset</button>
        </div>
        <p class="meta" style="margin-top:8px">
          Required distance (worst-case const brake): <code>D = T·v<sub>lead</sub> + (Δv)²/(2·a<sub>brake,max</sub>)</code>
        </p>
      </div>
    </div>

    <!-- Results + Simulation -->
    <div class="card">
      <div class="hd">Results & Simulation</div>
      <div class="bd">
        <div style="overflow:auto; max-height:220px; border:1px solid rgba(255,255,255,.08); border-radius:12px">
          <table id="tbl">
            <thead>
              <tr>
                <th>Slower vehicle speed (km/h)</th>
                <th>Required detection distance D<sub>req</sub> (m)</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="simWrap">
          <div class="lane" id="lane">
            <div class="roadMark"></div>
            <div class="car lead" id="lead"></div>
            <div class="car ego" id="ego"></div>
            <div class="ruler" id="ruler"></div>
          </div>

          <div class="infoRow">
            <div class="pill" id="pillGap">Gap: –</div>
            <div class="pill" id="pillTGap">Time gap: –</div>
            <div class="pill" id="pillVego">Ego v: –</div>
            <div class="pill" id="pillVlead">Lead v: –</div>
            <div class="pill" id="pillA">Ego a: –</div>
          </div>

          <div class="btnrow" style="margin-top:12px">
            <button id="btnStart">▶ Play</button>
            <button class="ghost" id="btnPause">⏸ Pause</button>
            <button class="ghost" id="btnStep">⏭ Step 0.1 s</button>
            <button class="ghost" id="btnRestart">⟲ Restart</button>
            <label class="pill">Sim speed ×
              <input id="inpSimSpeed" type="number" value="1" step="0.5" min="0.1" style="width:70px; margin-left:6px" />
            </label>
          </div>

          <div class="charts">
            <canvas id="accCanvas" width="1200" height="150"></canvas>
            <canvas id="spdCanvas" width="1200" height="150"></canvas>
          </div>

          <div id="status" class="tiny" style="margin-top:8px"></div>
        </div>
      </div>
    </div>
  </div>

<script>
(function(){
  // --- config ---
  const STOP_TGAP = 0.1; // seconds: stop sim if live time gap falls below this
  const speedsKph = [0,10,20,30,40,50,60,70,80,90,100,110,120,130,140,150];

  // UI helpers
  const q = id => document.getElementById(id);
  const inpStartDist = q('inpStartDist');
  const inpVset      = q('inpVset');
  const inpTgap      = q('inpTgap');
  const inpS0        = q('inpS0');
  const inpAmaxAccel = q('inpAmaxAccel');
  const inpBcomfort  = q('inpBcomfort');
  const inpAmaxBrake = q('inpAmaxBrake');
  const selLead      = q('selLead');
  const btnCompute   = q('btnCompute');
  const btnReset     = q('btnReset');

  const tblBody = document.querySelector('#tbl tbody');

  const lane   = q('lane');
  const leadEl = q('lead');
  const egoEl  = q('ego');
  const ruler  = q('ruler');

  const pillGap   = q('pillGap');
  const pillTGap  = q('pillTGap');
  const pillVego  = q('pillVego');
  const pillVlead = q('pillVlead');
  const pillA     = q('pillA');
  const statusEl  = q('status');

  const btnStart  = q('btnStart');
  const btnPause  = q('btnPause');
  const btnStep   = q('btnStep');
  const btnRestart= q('btnRestart');
  const inpSimSpeed = q('inpSimSpeed');

  // Canvases
  const accCv = q('accCanvas'), accCtx = accCv.getContext('2d');
  const spdCv = q('spdCanvas'), spdCtx = spdCv.getContext('2d');

  // Helpers
  const kph2mps = v => v * (1000/3600);
  const mps2kph = v => v * 3.6;
  const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));
  const fmt = (n,d=1)=>Number(n).toFixed(d);

  // Required distance formula
  function requiredDistance(vSet_kph, vLead_kph, T, a_brake){
    const vEgo  = kph2mps(vSet_kph);
    const vLead = kph2mps(vLead_kph);
    if (vEgo <= vLead) return T * vLead;
    const dv = vEgo - vLead;
    return T * vLead + 0.5 * (dv*dv) / a_brake;
  }

  function rebuildTable(){
    const vSet = Number(inpVset.value);
    const T = Number(inpTgap.value);
    const aBrake = Number(inpAmaxBrake.value);

    tblBody.innerHTML = '';
    speedsKph.forEach(vLead=>{
      const Dreq = requiredDistance(vSet, vLead, T, aBrake);
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td>${vLead}</td>
        <td>${fmt(Dreq,1)}</td>
      `;
      tblBody.appendChild(tr);
    });
  }

  // Simulation state (IDM)
  let sim = {
    vLead_kph: Number(selLead.value),
    v0_kph: Number(inpVset.value),          // desired free-flow speed
    T: Number(inpTgap.value),
    s0: Number(inpS0.value),
    aMax: Number(inpAmaxAccel.value),
    bComfort: Number(inpBcomfort.value),
    aBrakeMax: Number(inpAmaxBrake.value),

    startGap: Number(inpStartDist.value),

    // dynamic
    t: 0,
    xGap: 0,
    vEgo: 0,
    vLead: 0,
    aEgo: 0,
    running: false,
    raf: null,

    // history (kept in full; no trimming)
    histT: [],
    histA: [],
    histV: []
  };

  function resetSim(fromInputs=true){
    if (fromInputs){
      sim.vLead_kph = Number(selLead.value);
      sim.v0_kph    = Number(inpVset.value);
      sim.T         = Number(inpTgap.value);
      sim.s0        = Number(inpS0.value);
      sim.aMax      = Number(inpAmaxAccel.value);
      sim.bComfort  = Number(inpBcomfort.value);
      sim.aBrakeMax = Number(inpAmaxBrake.value);
      sim.startGap  = Number(inpStartDist.value);
    }
    sim.vLead = kph2mps(sim.vLead_kph);
    sim.vEgo  = kph2mps(sim.v0_kph); // start at set speed
    sim.xGap = sim.startGap;
    sim.t = 0; sim.aEgo = 0;
    sim.running = false;
    if (sim.raf){ cancelAnimationFrame(sim.raf); sim.raf=null; }

    // full history from t=0
    sim.histT = [0];
    sim.histA = [0];
    sim.histV = [mps2kph(sim.vEgo)];

    layoutCars(); drawRuler(); updatePills();
    rebuildTable(); // keep table in sync when restarting
    drawPlots();
  }

  // IDM controller
  function idmAcceleration(){
    const v = sim.vEgo;
    const v0 = kph2mps(sim.v0_kph);
    const s = Math.max(sim.xGap, 0.1);
    const dv = v - sim.vLead; // positive if ego faster
    const a = sim.aMax;
    const b = sim.bComfort;
    const delta = 4;

    const sStar = sim.s0 + sim.T * v + (v * dv) / (2 * Math.sqrt(a*b));
    let acc = a * (1 - Math.pow(v / Math.max(v0,0.1), delta) - Math.pow(sStar / s, 2));

    // clamp to hard limits
    acc = clamp(acc, -sim.aBrakeMax, sim.aMax);
    return acc;
  }

  // Integration step
  function step(dt){
    // Update acceleration from IDM
    sim.aEgo = idmAcceleration();

    // Integrate ego speed and gap
    sim.vEgo = Math.max(0, sim.vEgo + sim.aEgo*dt);
    sim.xGap += (sim.vLead - sim.vEgo) * dt;
    sim.xGap = Math.max(sim.xGap, 0.01); // avoid negative
    sim.t += dt;

    // Safety stop on too-low time gap
    const tgapNow = sim.vEgo > 0 ? sim.xGap / sim.vEgo : Infinity;
    if (tgapNow < STOP_TGAP){
      sim.running = false;
      statusEl.style.color = '#ff9d9d';
      statusEl.textContent = `Stopped: time gap ${tgapNow.toFixed(2)} s < ${STOP_TGAP.toFixed(1)} s`;
    } else {
      statusEl.style.color = '#7ff2a8';
      statusEl.textContent = `t = ${fmt(sim.t,1)} s  •  time gap ${fmt(tgapNow,2)} s`;
    }

    layoutCars();
    updatePills();

    // Save history (FULL history – no trimming)
    sim.histT.push(sim.t);
    sim.histA.push(sim.aEgo);
    sim.histV.push(mps2kph(sim.vEgo));

    drawPlots();
  }

  // Birdview layout
  function m2px(m){
    const visibleM = Math.max(sim.xGap, 200) + 60;
    const pad = 24;
    const w = lane.clientWidth - pad*2;
    return (m / visibleM) * w;
  }
function layoutCars(){
  const pad = 24, midY = lane.clientHeight/2 - 12, laneWidth = lane.clientWidth;
  const leadX = laneWidth - pad - 60;              // lead's left edge
  const egoW  = egoEl.clientWidth;                 // width of ego car (46px)
  const egoX  = leadX - m2px(sim.xGap) - egoW;     // ensure bumper-to-bumper gap

  leadEl.style.left = `${leadX}px`; leadEl.style.top = `${midY}px`;
  egoEl.style.left  = `${egoX}px`;  egoEl.style.top  = `${midY}px`;
}
  function drawRuler(){
    ruler.innerHTML = '';
    const visibleM = Math.max(sim.xGap, 200) + 60;
    const step = niceTick(visibleM/6);
    for(let x=0; x<=visibleM; x+=step){
      const tick = document.createElement('div');
      tick.className='tick';
      const px = m2px(x) + 24;
      tick.style.left = `${px}px`;
      const lab = document.createElement('div');
      lab.textContent = `${Math.round(x)} m`;
      lab.style.position='absolute'; lab.style.left='0'; lab.style.bottom='12px';
      lab.style.transform='translateX(-50%)'; lab.style.color='#9fb2ff'; lab.style.fontSize='11px';
      tick.appendChild(lab);
      ruler.appendChild(tick);
    }
  }
  function niceTick(range){
    const pow10 = Math.pow(10, Math.floor(Math.log10(range)));
    const fr = range / pow10;
    if (fr < 1.5) return 1*pow10;
    if (fr < 3)   return 2*pow10;
    if (fr < 7)   return 5*pow10;
    return 10*pow10;
  }

  function updatePills(){
    pillGap.textContent  = `Gap: ${fmt(sim.xGap,1)} m`;
    const tgap = sim.vEgo>0 ? sim.xGap / sim.vEgo : Infinity;
    pillTGap.textContent = `Time gap: ${isFinite(tgap)? fmt(tgap,2)+' s' : '–'}`;
    pillVego.textContent = `Ego v: ${fmt(mps2kph(sim.vEgo),1)} km/h`;
    pillVlead.textContent= `Lead v: ${fmt(mps2kph(sim.vLead),1)} km/h`;
    pillA.textContent    = `Ego a: ${fmt(sim.aEgo,2)} m/s²`;
  }

  // Simple canvas line plotter
  function drawLine(ctx, xs, ys, xmin, xmax, ymin, ymax, labelY){
    const w = ctx.canvas.width, h = ctx.canvas.height;
    ctx.clearRect(0,0,w,h);
    // axes
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(40,10); ctx.lineTo(40,h-24); ctx.lineTo(w-8,h-24); ctx.stroke();
    ctx.fillStyle = '#cfe'; ctx.font = '12px system-ui';
    ctx.fillText(labelY, 8, 14);

    if (xs.length<2) return;

    const toX = t => 40 + ( (t - xmin) / (xmax - xmin || 1) ) * (w-48);
    const toY = y => (h-24) - ( (y - ymin) / (ymax - ymin || 1) ) * (h-34);

    // grid ticks
    const xticks = 5, yticks = 4;
    for(let i=0;i<=xticks;i++){
      const tx = xmin + i*(xmax-xmin)/xticks;
      const px = toX(tx);
      ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.beginPath(); ctx.moveTo(px,10); ctx.lineTo(px,h-24); ctx.stroke();
      ctx.fillStyle='#9fd'; ctx.fillText(tx.toFixed(1), px-8, h-6);
    }
    for(let j=0;j<=yticks;j++){
      const ty = ymin + j*(ymax-ymin)/yticks;
      const py = toY(ty);
      ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.beginPath(); ctx.moveTo(40,py); ctx.lineTo(w-8,py); ctx.stroke();
      ctx.fillStyle='#9fd'; ctx.fillText(ty.toFixed(1), 6, py+4);
    }

    // line
    ctx.strokeStyle = '#7fb3ff';
    ctx.lineWidth = 2; ctx.beginPath();
    for(let i=0;i<xs.length;i++){
      const px = toX(xs[i]), py = toY(ys[i]);
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
  }

  function drawPlots(){
    const xs = sim.histT;
    const xmin = 0;                                // <-- full history
    const xmax = Math.max(5, xs[xs.length-1] || 5);

    const aMin = -Number(inpAmaxBrake.value) * 1.1, aMax = Number(inpAmaxAccel.value) * 1.1;
    drawLine(accCtx, xs, sim.histA, xmin, xmax, aMin, aMax, 'a (m/s²)');

    const vMax = Math.max(Number(inpVset.value), Number(selLead.value), ...sim.histV) * 1.05;
    drawLine(spdCtx, xs, sim.histV, xmin, xmax, 0, Math.max(10, vMax), 'v (km/h)');
  }

  // Loop
  function loop(lastTs){
    sim.raf = requestAnimationFrame((ts)=>{
      if (!lastTs) lastTs = ts;
      const simSpeed = Math.max(0.1, Number(inpSimSpeed.value)||1);
      let dt = (ts - lastTs)/1000 * simSpeed;
      dt = clamp(dt, 0, 0.05);
      if (sim.running) { step(dt); loop(ts); }
    });
  }

  // Events
  btnCompute.addEventListener('click', rebuildTable);
  btnReset.addEventListener('click', ()=>{
    inpStartDist.value = 200; inpVset.value = 180; inpTgap.value = 1; inpS0.value = 2;
    inpAmaxAccel.value = 2; inpBcomfort.value = 2.5; inpAmaxBrake.value = 5; selLead.value = '90';
    rebuildTable(); resetSim(true);
  });
  [inpStartDist, inpVset, inpTgap, inpS0, inpAmaxAccel, inpBcomfort, inpAmaxBrake, selLead]
    .forEach(el => el.addEventListener('change', ()=>{ rebuildTable(); resetSim(true); }));

  btnStart.addEventListener('click', ()=>{ if (!sim.running){ sim.running = true; loop(); } });
  btnPause.addEventListener('click', ()=>{ sim.running = false; });
  btnStep.addEventListener('click', ()=>{ sim.running = false; step(0.1); });
  btnRestart.addEventListener('click', ()=>{ resetSim(true); });

  window.addEventListener('resize', ()=>{ layoutCars(); drawRuler(); drawPlots(); });

  // Boot
  rebuildTable();
  resetSim(true);
})();
</script>
</body>
</html>
