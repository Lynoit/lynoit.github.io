<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Lane-Change Simulator</title>
  <style>
    :root { --bg:#0f1117; --panel:#151924; --text:#e8eaf2; --muted:#9aa4b2; --accent:#4da3ff; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif }
    .wrap { display:grid; grid-template-columns: 340px 1fr; grid-template-rows:auto 1fr; height:100vh; gap:12px; padding:12px; box-sizing:border-box }
    header { grid-column:1 / -1; display:flex; align-items:center; justify-content:space-between }
    header h1 { font-size:18px; margin:0; letter-spacing:0.3px }
    #controls { background:var(--panel); padding:12px; border-radius:14px; display:flex; flex-direction:column; gap:12px }
    #controls .row { display:flex; align-items:center; gap:8px; flex-wrap:wrap }
    #controls label { font-size:13px; color:var(--muted); min-width:120px }
    #controls input[type="range"] { width:160px }
    #controls input[type="number"] { width:90px; background:#0c0f16; color:var(--text); border:1px solid #26304a; border-radius:8px; padding:6px }
    #controls select { background:#0c0f16; color:var(--text); border:1px solid #26304a; border-radius:8px; padding:6px }
    #controls button { background:var(--accent); color:#08111c; border:0; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer }
    #controls button.secondary { background:#22314d; color:var(--text) }
    #readout { background:var(--panel); padding:12px; border-radius:14px; display:grid; grid-template-columns:1fr 1fr; gap:8px; font-variant-numeric:tabular-nums }
    #readout .cell { color:var(--muted) }
    #readout b { color:var(--text) }
    #chartWrap { background:var(--panel); padding:10px; border-radius:14px; height:220px }
    #stageWrap { position:relative; background:var(--panel); border-radius:14px; overflow:hidden; height: calc(100vh - 170px); min-height: 560px; }
    canvas { width:100%; height:100%; display:block }
    #hint { position:absolute; right:10px; top:10px; background:#0c1324cc; padding:6px 10px; border-radius:10px; font-size:12px; color:var(--muted) }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Live Lane-Change Simulator</h1>
      <div style="color:var(--muted); font-size:12px">Start parallel at 90 km/h. Hold 3 s, then indicator → speed adaptation (≤1 m/s²) → merge behind.</div>
    </header>

    <section id="controls">
      <div class="row">
        <button id="playBtn">▶ Play</button>
        <button id="resetBtn" class="secondary">↺ Reset</button>
        <label><input id="trailChk" type="checkbox" checked> Show trails</label>
      </div>
      <div class="row">
        <label for="gapMode">Gap criterion</label>
        <select id="gapMode">
          <option value="behind">Behind (rear − front ≥ buffer)</option>
          <option value="fit">Fit behind (vehicle length + buffer)</option>
        </select>
      </div>
      <div class="row">
        <label for="buffer">Buffer behind (m)</label>
        <input id="buffer" type="range" min="0" max="25" step="0.5" value="10" />
        <input id="bufferNum" type="number" step="0.5" value="10" />
      </div>
      <div class="row">
        <label for="lcDur">Lane-change duration (s)</label>
        <input id="lcDur" type="range" min="2" max="8" step="0.1" value="4" />
        <input id="lcDurNum" type="number" step="0.1" value="4" />
      </div>
      <div class="row">
        <label>Vehicle length / width (m)</label>
        <input id="lenNum" type="number" step="0.1" value="4.5" />
        <input id="widNum" type="number" step="0.1" value="1.8" />
      </div>
      <div class="row">
        <label>Lane width (m)</label>
        <input id="laneW" type="number" step="0.1" value="3.7" />
      </div>
    </section>

    <section id="readout">
      <div class="cell">t = <b id="tOut">0.00</b> s</div>
      <div class="cell">State = <b id="stateOut">init</b></div>
      <div class="cell">v<sub>ego</sub> = <b id="vEgoOut">90.0</b> km/h</div>
      <div class="cell">v<sub>other</sub> = <b id="vOthOut">90.0</b> km/h</div>
      <div class="cell">Clearance (rear<sub>other</sub> − front<sub>ego</sub>) = <b id="clrOut">-4.5</b> m</div>
      <div class="cell">LC progress = <b id="lcProg">0%</b></div>
    </section>

    <section id="chartWrap">
      <canvas id="chart"></canvas>
    </section>

    <section id="stageWrap">
      <div id="hint">Space: Play/Pause • R: Reset</div>
      <canvas id="stage"></canvas>
    </section>
  </div>

<script>
(function(){
  // ---------- Parameters (defaults) ----------
  const PX_PER_M = 12;              // scaling (px per meter)
  const MAX_DECEL = 1.0;            // m/s^2
  const V0 = 25.0;                  // m/s (90 km/h)
  const DT_SIM = 1/120;             // fixed physics step (s)

  // DOM
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const chart = document.getElementById('chart');
  const cctx = chart.getContext('2d');
  const playBtn = document.getElementById('playBtn');
  const resetBtn = document.getElementById('resetBtn');
  const trailChk = document.getElementById('trailChk');
  const tOut = document.getElementById('tOut');
  const stateOut = document.getElementById('stateOut');
  const vEgoOut = document.getElementById('vEgoOut');
  const vOthOut = document.getElementById('vOthOut');
  const clrOut = document.getElementById('clrOut');
  const lcProg = document.getElementById('lcProg');
  const gapMode = document.getElementById('gapMode');
  const buffer = document.getElementById('buffer');
  const bufferNum = document.getElementById('bufferNum');
  const lcDur = document.getElementById('lcDur');
  const lcDurNum = document.getElementById('lcDurNum');
  const lenNum = document.getElementById('lenNum');
  const widNum = document.getElementById('widNum');
  const laneWNum = document.getElementById('laneW');

  // HiDPI crisp pixels
  function resizeCanvas(){
    const pr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width * pr; canvas.height = rect.height * pr;
    canvas.style.width = rect.width + 'px'; canvas.style.height = rect.height + 'px';
    ctx.setTransform(pr,0,0,pr,0,0);

    const cr = chart.parentElement.getBoundingClientRect();
    chart.width = cr.width * pr; chart.height = cr.height * pr;
    chart.style.width = cr.width + 'px'; chart.style.height = cr.height + 'px';
    cctx.setTransform(pr,0,0,pr,0,0);
  }
  new ResizeObserver(resizeCanvas).observe(document.getElementById('stageWrap'));
  new ResizeObserver(resizeCanvas).observe(document.getElementById('chartWrap'));

  // World state
  let world;
  function reset(){
    const laneW = +laneWNum.value;
    const L = +lenNum.value, W = +widNum.value;
    world = {
      t:0,
      state:'cruise', // cruise (90 km/h for 3s) -> buildGap -> laneChange -> done
      laneW, L, W,
      buffer: +buffer.value,
      lcDur: +lcDur.value,
      mode: gapMode.value, // 'behind' or 'fit'
      indicatorOn: false,
      // cars start parallel at same speed 25 m/s
      ego:   { x:0, y:0, v:V0, ax:0 },
      other: { x:0, y:laneW, v:V0, ax:0 },
      // for LC
      lcStartT: null,
      lcStartY: 0,
      lcEndT: null,
      trail: [],
      // logs for plotting
      logT: [], logVego: [], logVoth: []
    };
    updateReadout();
  }

  // Utility
  function kmh(ms){ return ms*3.6; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function clearanceRearMinusFront(){
    const L = world.L;
    const otherRear = world.other.x - L/2;
    const egoFront = world.ego.x + L/2;
    return otherRear - egoFront; // m
  }

  function clearanceNeeded(){
    const base = (world.mode === 'fit') ? world.L : 0; // include vehicle length if 'fit'
    return base + world.buffer;
  }

  // Physics step
  function step(dt){
    const w = world; if(!w) return;
    w.t += dt;

    // State transitions
    if(w.state === 'cruise' && w.t >= 3){
      w.indicatorOn = true; // indicator toggles on at 3s
      w.state = 'buildGap';
    }

    // --- Longitudinal control ---
    if (w.state === 'buildGap') {
      w.ego.ax = -MAX_DECEL; // start speed adaptation
    } else if ((w.state === 'laneChange' || w.state === 'done') && w.ego.v < V0) {
      // keep re-accelerating during lane change AND after merge until we hit 90 km/h
      w.ego.ax = +MAX_DECEL;
    } else {
      w.ego.ax = 0; // hold speed
    }

    // Integrate longitudinal motion
    w.ego.v = Math.max(0, Math.min(V0, w.ego.v + w.ego.ax * dt));
    w.ego.x += w.ego.v * dt;

    w.other.v = V0; // constant
    w.other.x += w.other.v * dt;

    // --- Check gap condition ---
    const need = clearanceNeeded();
    const clr = clearanceRearMinusFront();
    if(w.state === 'buildGap' && clr >= need){
      w.state = 'laneChange';
      w.lcStartT = w.t; w.lcStartY = w.ego.y; w.lcEndT = w.lcStartT + w.lcDur;
    }

    // --- Lateral lane change (half-sine) ---
    if(w.state === 'laneChange'){
      const tau = clamp((w.t - w.lcStartT)/w.lcDur, 0, 1);
      w.ego.y = w.lcStartY + 0.5*w.laneW*(1 - Math.cos(Math.PI * tau));
      if(tau >= 1){ w.state = 'done'; w.indicatorOn = false; }
    }

    // Trail
    if(trailChk.checked){
      if(w.trail.length>1200) w.trail.shift();
      w.trail.push({ x:w.ego.x, y:w.ego.y });
    } else w.trail.length = 0;

    // Logging for chart
    w.logT.push(w.t);
    w.logVego.push(kmh(w.ego.v));
    w.logVoth.push(kmh(w.other.v));
    if(w.logT.length>2400){ w.logT.shift(); w.logVego.shift(); w.logVoth.shift(); }
  }

  // Draw top-down scene
  function draw(){
    const w = world; if(!w) return;
    const cw = canvas.width, ch = canvas.height; // device pixels (transform set)
    ctx.clearRect(0,0,cw,ch);

    // Camera follow ego
    const camX = w.ego.x; // center on ego
    const camY = w.laneW/2; // midway between lanes

    function toScreen(xm, ym){
      const x = (cw/2) + (xm - camX) * PX_PER_M;
      const y = (ch/2) - (ym - camY) * PX_PER_M;
      return [x,y];
    }

    // Road background
    ctx.fillStyle = '#0c1020'; ctx.fillRect(0,0,cw,ch);

    // Center dashed line between lanes
    ctx.strokeStyle = '#d6d9e6'; ctx.setLineDash([16,16]); ctx.lineWidth = 2;
    ctx.beginPath();
    let [sx,sy] = toScreen(camX - (cw/PX_PER_M), w.laneW/2);
    ctx.moveTo(sx, sy);
    [sx,sy] = toScreen(camX + (cw/PX_PER_M), w.laneW/2);
    ctx.lineTo(sx, sy);
    ctx.stroke(); ctx.setLineDash([]);

    // Trail
    if(w.trail.length > 1){
      ctx.strokeStyle = 'rgba(77,163,255,0.35)'; ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<w.trail.length;i++){
        const p = w.trail[i]; const [x,y] = toScreen(p.x,p.y);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // Draw cars (rects)
    function drawCar(car, color){
      const [cx,cy] = toScreen(car.x, car.y);
      const Lpx = w.L * PX_PER_M; const Wpx = w.W * PX_PER_M;
      ctx.fillStyle = color; ctx.strokeStyle = '#0008';
      ctx.beginPath(); ctx.rect(cx - Lpx/2, cy - Wpx/2, Lpx, Wpx); ctx.fill(); ctx.stroke();
      // Indicator blink for ego
      if(color === '#4da3ff' && w.indicatorOn){
        const blink = ((w.t*2)|0)%2 === 0; // ~2 Hz
        if(blink){
          ctx.fillStyle = '#ffd166';
          ctx.beginPath(); ctx.moveTo(cx + Lpx/2 - 6, cy); ctx.lineTo(cx + Lpx/2 + 12, cy + 10); ctx.lineTo(cx + Lpx/2 + 12, cy - 10); ctx.closePath(); ctx.fill();
        }
      }
    }

    drawCar(w.other, '#ff9f43'); // target-lane car (orange)
    drawCar(w.ego,   '#4da3ff'); // ego (blue)

    // Clearance indicator
    const otherRearX = w.other.x - w.L/2;
    const egoFrontX  = w.ego.x   + w.L/2;
    const yLine = w.ego.y; // draw near ego's current y
    const [xr1, yr] = toScreen(egoFrontX, yLine + w.W*0.9);
    const [xr2, _]  = toScreen(otherRearX, yLine + w.W*0.9);
    ctx.strokeStyle = '#8fb8ff'; ctx.lineWidth = 2; ctx.setLineDash([6,6]);
    ctx.beginPath(); ctx.moveTo(xr1, yr); ctx.lineTo(xr2, yr); ctx.stroke(); ctx.setLineDash([]);

    const need = clearanceNeeded();
    const [needEndX, needY] = toScreen(egoFrontX + need, yLine + w.W*0.9);
    ctx.strokeStyle = '#00d07e'; ctx.beginPath(); ctx.moveTo(xr1, needY+6); ctx.lineTo(needEndX, needY+6); ctx.stroke();

    ctx.fillStyle = '#c9d2e6'; ctx.font = '14px system-ui,Segoe UI,Roboto,Arial';
    const clr = clearanceRearMinusFront();
    ctx.fillText(`clearance: ${clr.toFixed(2)} m`, xr1 + 6, yr - 6);
    ctx.fillStyle = '#79e2b1'; ctx.fillText(`needed: ${need.toFixed(2)} m`, xr1 + 6, needY + 22);

    // HUD text
    ctx.fillStyle = '#9aa4b2';
    const stateStr = (w.state==='cruise')?'Cruise (90 km/h)':(w.state==='buildGap')?'Building gap':(w.state==='laneChange')?'Lane change':'Done';
    ctx.fillText(stateStr, 10, 24);

    // Draw speed chart
    drawChart();
  }

  // Simulation loop (fixed dt with accumulator)
  let running = false, lastT = 0, acc = 0;
  function loop(ts){
    if(!running){ lastT = ts; draw(); return requestAnimationFrame(loop); }
    const dtms = ts - lastT; lastT = ts; acc += dtms/1000;
    while(acc >= DT_SIM){ step(DT_SIM); acc -= DT_SIM; }
    draw(); updateReadout();
    requestAnimationFrame(loop);
  }

  function updateReadout(){
    const w = world; if(!w) return;
    tOut.textContent = w.t.toFixed(2);
    stateOut.textContent = w.state;
    vEgoOut.textContent = kmh(w.ego.v).toFixed(1);
    vOthOut.textContent = kmh(w.other.v).toFixed(1);
    clrOut.textContent = clearanceRearMinusFront().toFixed(2);
    if(w.state === 'laneChange'){
      const tau = clamp((w.t - w.lcStartT)/w.lcDur,0,1);
      lcProg.textContent = Math.round(tau*100) + '%';
    } else if(w.state === 'done') lcProg.textContent = '100%'; else lcProg.textContent = '0%';
  }

  // Controls wiring & syncing paired inputs
  function linkRangeNumber(rangeEl, numEl, onChange){
    const sync = v=>{ rangeEl.value = v; numEl.value = v; if (typeof onChange === 'function' && world) onChange(+v); };
    rangeEl.addEventListener('input', ()=> sync(rangeEl.value));
    numEl.addEventListener('input', ()=> sync(numEl.value));
  }

  // Wire listeners that don't depend on world existing
  gapMode.addEventListener('change', ()=>{ if(world) world.mode = gapMode.value; });
  lenNum.addEventListener('change', reset);
  widNum.addEventListener('change', reset);
  laneWNum.addEventListener('change', reset);

  playBtn.addEventListener('click', ()=>{ running = !running; playBtn.textContent = running ? '❚❚ Pause' : '▶ Play'; });
  resetBtn.addEventListener('click', ()=>{ reset(); });

  // ----- Speed chart drawing -----
  function drawChart(){
    const w = world; if(!w) return;
    const cw = chart.width, ch = chart.height; cctx.clearRect(0,0,cw,ch);
    // axes
    cctx.fillStyle = '#c9d2e6'; cctx.font = '12px system-ui,Segoe UI,Roboto,Arial';
    const padL=40, padR=10, padT=10, padB=20; const iw = cw - padL - padR, ih = ch - padT - padB;
    cctx.strokeStyle = '#2b3656'; cctx.strokeRect(padL, padT, iw, ih);

    const span = 20; // seconds visible
    const tmax = w.logT.length? w.logT[w.logT.length-1]:0;
    const tmin = Math.max(0, tmax - span);

    const yMin = 0, yMax = 120; // km/h scale
    const xPix = t=> padL + ( (t - tmin)/(span) ) * iw;
    const yPix = v=> padT + ih - ( (v - yMin)/(yMax - yMin) ) * ih;

    // grid lines
    cctx.strokeStyle = '#1e2740'; cctx.setLineDash([4,8]);
    for(let v=0; v<=120; v+=20){ cctx.beginPath(); cctx.moveTo(padL, yPix(v)); cctx.lineTo(padL+iw, yPix(v)); cctx.stroke(); }
    cctx.setLineDash([]);

    // series
    function line(series, color){
      cctx.strokeStyle = color; cctx.lineWidth = 2; cctx.beginPath();
      let moved=false;
      for(let i=0;i<w.logT.length;i++){
        const t=w.logT[i]; if(t<tmin) continue; const v=series[i];
        const x=xPix(t), y=yPix(v); if(!moved){ cctx.moveTo(x,y); moved=true; } else cctx.lineTo(x,y);
      }
      cctx.stroke();
    }
    line(w.logVoth, '#ff9f43'); // other
    line(w.logVego, '#4da3ff'); // ego

    // labels
    cctx.fillStyle='#9aa4b2';
    cctx.fillText('Speed (km/h)', padL, padT-2);
    cctx.fillText('time (last 20 s)', cw-130, ch-4);
    // legend
    cctx.fillStyle='#ff9f43'; cctx.fillRect(padL+6, padT+6, 10,10); cctx.fillStyle='#c9d2e6'; cctx.fillText('v_other', padL+22, padT+15);
    cctx.fillStyle='#4da3ff'; cctx.fillRect(padL+90, padT+6, 10,10); cctx.fillStyle='#c9d2e6'; cctx.fillText('v_ego', padL+106, padT+15);
  }

  // Init
  resizeCanvas();
  reset(); // ensure `world` exists before binding control syncs

  // Now that world exists, perform initial syncs which also push values into world
  linkRangeNumber(buffer, bufferNum, v => { world.buffer = v; });
  linkRangeNumber(lcDur, lcDurNum, v => { world.lcDur = v; if(world.state==='laneChange'){ world.lcEndT = world.lcStartT + world.lcDur; } });
  // Manually sync once to initialize
  buffer.dispatchEvent(new Event('input'));
  lcDur.dispatchEvent(new Event('input'));
  gapMode.dispatchEvent(new Event('change'));

  updateReadout();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
