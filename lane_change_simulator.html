<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Lane-Change Simulator</title>
  <style>
    :root { --bg:#0f1117; --panel:#151924; --text:#e8eaf2; --muted:#9aa4b2; --accent:#4da3ff; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif }
    .wrap {
      display:grid;
      /*grid-template-columns: 340px 1fr;     /* left controls + right birdview */
      grid-template-columns: minmax(380px, 480px) 1fr;
      grid-auto-rows: auto;
      gap:12px; padding:12px; height:100vh; box-sizing:border-box;
    }
    header { grid-column:1 / -1; display:flex; align-items:center; justify-content:space-between }
    header h1 { font-size:18px; margin:0; letter-spacing:0.3px }

    /* Left column cards */
    #controls, #readout, #chartWrap, #milestones {
      grid-column: 1;
      background:var(--panel); border-radius:14px;
    }
#controls {
  padding:6px;                 /* tighter padding */
  display:flex;
  flex-direction:column;
  gap:6px;                     /* less vertical gap between rows */
}

#controls .row { gap:6px }      /* compress gaps inside rows */

#controls label { 
  font-size:12px;              /* smaller font */
  min-width:110px;             /* narrower labels */
}

#controls input[type="range"] { width:120px }   /* shorter sliders */
#controls input[type="number"], #controls select {
  width:80px; 
  font-size:12px;
  padding:4px;                 /* tighter boxes */
  border-radius:6px;
}
#controls button {
  padding:6px 10px;            /* smaller buttons */
  font-size:12px;
  border-radius:8px;
}
    #controls select { width:auto }
    #controls button { background:var(--accent); color:#08111c; border:0; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer }
    #controls button.secondary { background:#22314d; color:var(--text) }

    #readout {
  padding:6px;                  /* was 12px */
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:4px;                      /* was 8px */
  font-size:12px;               /* smaller text */
  line-height:1.2;              /* tighter spacing */
  font-variant-numeric:tabular-nums
}
    #readout .cell { color:var(--muted) }
    #readout b { color:var(--text) }

    #chartWrap { padding:10px; height:120px }
    #milestones { padding:12px; }
    #milestones h3 { margin:0 0 10px 0; font-size:14px; color:var(--muted); font-weight:600; letter-spacing:0.2px }
    table.mtab { width:100%; border-collapse:collapse; font-size:13px }
    table.mtab th, table.mtab td { border-bottom:1px solid #26304a; padding:6px 8px; text-align:left }
    table.mtab th { color:#aab3c2; font-weight:600 }
    table.mtab td.time { font-variant-numeric:tabular-nums; color:#e8eaf2 }
    table.mtab td.evt { color:#d6d9e6 }

    /* Right column: bird-view */
    #stageWrap {
      grid-column: 2;
      grid-row: 2;        /* puts birdview at the top row under the header */
      align-self: start;
      background: var(--panel);
      border-radius: 14px;
      position: relative;
      overflow: hidden;
      height: auto;
      min-height: 0;
    }

    canvas { width:100%; height:100%; display:block }
    #hint { position:absolute; right:10px; top:10px; background:#0c1324cc; padding:6px 10px; border-radius:10px; font-size:12px; color:var(--muted) }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Live Lane-Change Simulator</h1>
      <div style="color:var(--muted); font-size:12px">Start parallel at target speed. Hold 3 s, then indicator → speed adaptation (≤|a|max) → merge behind. During/after LC, ego returns to target speed.</div>
    </header>

    <!-- Left column -->
    <section id="controls">
      <div class="row">
        <button id="playBtn">▶ Play</button>
        <button id="resetBtn" class="secondary">↺ Reset</button>
        <label><input id="trailChk" type="checkbox" checked> Show trails</label>
      </div>

      <div class="row">
        <label for="speedKmh">Scenario speed (km/h)</label>
        <input id="speedKmh" type="range" min="30" max="130" step="1" value="90" />
        <input id="speedKmhNum" type="number" min="0" step="1" value="90" />
      </div>

      <div class="row">
        <label for="maxA">Max |a| (m/s²)</label>
        <input id="maxA" type="range" min="0.2" max="3.0" step="0.1" value="1.0" />
        <input id="maxANum" type="number" min="0.1" step="0.1" value="1.0" />
      </div>

      <div class="row">
        <label for="bufSec">Buffer behind (s)</label>
        <input id="bufSec" type="range" min="0" max="3.0" step="0.1" value="1.0" />
        <input id="bufSecNum" type="number" min="0" step="0.1" value="1.0" />
      </div>

      <div class="row">
        <label for="gapMode">Gap criterion</label>
        <select id="gapMode">
          <option value="behind">Behind (rear − front ≥ time gap × v)</option>
          <option value="fit">Fit behind (vehicle length + time gap × v)</option>
        </select>
      </div>

      <div class="row">
        <label for="lcDur">Lane-change duration (s)</label>
        <input id="lcDur" type="range" min="2" max="8" step="0.1" value="4" />
        <input id="lcDurNum" type="number" step="0.1" value="4" />
      </div>

      <div class="row">
        <label>Vehicle length / width (m)</label>
        <input id="lenNum" type="number" step="0.1" value="4.5" />
        <input id="widNum" type="number" step="0.1" value="1.8" />
      </div>

      <div class="row">
        <label>Lane width (m)</label>
        <input id="laneW" type="number" step="0.1" value="3.7" />
      </div>
    </section>

    <section id="readout">
      <div class="cell">t = <b id="tOut">0.00</b> s</div>
      <div class="cell">State = <b id="stateOut">init</b></div>
      <div class="cell">v<sub>ego</sub> = <b id="vEgoOut">90.0</b> km/h</div>
      <div class="cell">v<sub>other</sub> = <b id="vOthOut">90.0</b> km/h</div>
      <div class="cell">Clearance (rear<sub>other</sub> − front<sub>ego</sub>) = <b id="clrOut">-4.5</b> m</div>
      <div class="cell">LC progress = <b id="lcProg">0%</b></div>
    </section>

    <section id="chartWrap"><canvas id="chart"></canvas></section>

    <section id="milestones">
      <h3>Milestones</h3>
      <table class="mtab">
        <thead>
          <tr><th style="width:120px">Time (s)</th><th>Event</th></tr>
        </thead>
        <tbody id="milestonesBody"></tbody>
      </table>
    </section>

    <!-- Right column -->
    <section id="stageWrap">
      <div id="hint">Space: Play/Pause • R: Reset</div>
      <canvas id="stage"></canvas>
    </section>
  </div>

<script>
(function(){
  // --- Params (defaults via controls) ---
  const DT_SIM = 1/120;

  // Birdview margins/padding & scaling
  const VERTICAL_MARGIN_M   = 0.3;  // tiny top/bottom space in meters
  const VERTICAL_PAD_PX     = 8;
  const HORIZONTAL_MARGIN_M = 6;    // left/right space in meters so both cars fit
  const HORIZONTAL_PAD_PX   = 12;   // left/right padding in px
  const CAR_VISUAL_SCALE    = 1.0; // drawn rectangles only (visual)

  // DOM
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d');
  const chart = document.getElementById('chart');
  const cctx = chart.getContext('2d');

  const playBtn = document.getElementById('playBtn');
  const resetBtn = document.getElementById('resetBtn');
  const trailChk = document.getElementById('trailChk');

  const tOut = document.getElementById('tOut');
  const stateOut = document.getElementById('stateOut');
  const vEgoOut = document.getElementById('vEgoOut');
  const vOthOut = document.getElementById('vOthOut');
  const clrOut = document.getElementById('clrOut');
  const lcProg = document.getElementById('lcProg');

  const speedKmh = document.getElementById('speedKmh');
  const speedKmhNum = document.getElementById('speedKmhNum');
  const maxA = document.getElementById('maxA');
  const maxANum = document.getElementById('maxANum');
  const bufSec = document.getElementById('bufSec');
  const bufSecNum = document.getElementById('bufSecNum');

  const gapMode = document.getElementById('gapMode');
  const lcDur = document.getElementById('lcDur');
  const lcDurNum = document.getElementById('lcDurNum');
  const lenNum = document.getElementById('lenNum');
  const widNum = document.getElementById('widNum');
  const laneWNum = document.getElementById('laneW');

  const milestones = document.getElementById('milestones');
  const milestonesBody = document.getElementById('milestonesBody');
  const stageWrap = document.getElementById('stageWrap');
  const chartWrap = document.getElementById('chartWrap');

  // HiDPI & layout
  function syncStageHeight(){
    // make birdview height ≈ milestones table height (left)
    const h = Math.round(milestones.getBoundingClientRect().height);
    stageWrap.style.height = Math.max(160, h) + 'px';
  }
  function resizeCanvas(){
    syncStageHeight();

    const pr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const rect = stageWrap.getBoundingClientRect();
    canvas.width  = Math.max(1, Math.floor(rect.width  * pr));
    canvas.height = Math.max(1, Math.floor(rect.height * pr));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(pr,0,0,pr,0,0);

    const cr = chartWrap.getBoundingClientRect();
    chart.width  = Math.max(1, Math.floor(cr.width  * pr));
    chart.height = Math.max(1, Math.floor(cr.height * pr));
    chart.style.width = cr.width + 'px';
    chart.style.height = cr.height + 'px';
    cctx.setTransform(pr,0,0,pr,0,0);
  }
  new ResizeObserver(()=>{ syncStageHeight(); resizeCanvas(); }).observe(milestones);
  new ResizeObserver(resizeCanvas).observe(stageWrap);
  new ResizeObserver(resizeCanvas).observe(chartWrap);
  new ResizeObserver(resizeCanvas).observe(document.body);

  // World
  let world;
  function initWorldFromControls(){
    const V0_ms   = (+speedKmh.value) / 3.6;
    const maxAms2 = +maxA.value;
    const bufS    = +bufSec.value;

    const laneW = +laneWNum.value;
    const L = +lenNum.value, W = +widNum.value;

    return {
      t:0,
      state:'cruise', // 3s cruise → buildGap → laneChange → done
      laneW, L, W,
      V0: V0_ms,     // target scenario speed (m/s)
      maxA: maxAms2, // |a|max (m/s^2) used for decel and re-accel
      bufferSec: bufS, // time gap (s)
      lcDur: +lcDur.value,
      mode: gapMode.value,
      indicatorOn: false,
      ego:   { x:0, y:0,      v:V0_ms, ax:0 },
      other: { x:0, y:laneW,  v:V0_ms, ax:0 },
      lcStartT: null, lcStartY: 0, lcEndT: null,
      trail: [],
      logT: [], logVego: [], logVoth: [],
      ms: { start: 0, indicator: null, speedAdapt: null, lateralStart: null, lateralDone: null }
    };
  }
  function reset(){
    world = initWorldFromControls();
    renderMilestones();
    updateReadout();
    resizeCanvas();
  }

  // Utils
  const kmh = ms => ms*3.6;
  const clamp = (v,a,b)=> Math.max(a, Math.min(b, v));
  const sign = x => (x>0)-(x<0);

  function clearanceRearMinusFront(){
    const L = world.L;
    return (world.other.x - L/2) - (world.ego.x + L/2);
  }
  function clearanceNeeded(){
    const base = (world.mode === 'fit') ? world.L : 0;          // add vehicle length if "fit"
    const dyn  = world.bufferSec * world.ego.v;                 // seconds × current ego speed (m)
    return base + dyn;
  }

  // Physics
  function step(dt){
    const w = world; if(!w) return;
    w.t += dt;

    // Turn indicator & transition after 3s cruise
    if(w.state === 'cruise' && w.t >= 3){
      w.indicatorOn = true;
      w.state = 'buildGap';
      if(w.ms.indicator   === null) w.ms.indicator   = +w.t;
      if(w.ms.speedAdapt  === null) w.ms.speedAdapt  = +w.t;
      renderMilestones();
    }

    // --- Longitudinal control toward target speed w.V0 ---
    if (w.state === 'buildGap') {
      // Actively decelerate to create the gap (up to |a|max)
      w.ego.ax = -w.maxA;
    } else if (w.state === 'laneChange' || w.state === 'done' || w.state === 'cruise') {
      // Track target speed in cruise, during LC, and after
      const dv = w.V0 - w.ego.v;
      if (Math.abs(dv) < 0.02) w.ego.ax = 0;
      else w.ego.ax = clamp(sign(dv) * w.maxA, -w.maxA, w.maxA);
    } else {
      w.ego.ax = 0;
    }

    // Integrate ego; clamp to >=0
    w.ego.v = Math.max(0, w.ego.v + w.ego.ax * dt);
    w.ego.x += w.ego.v * dt;

    // Other car tracks scenario speed constantly
    w.other.v = w.V0;
    w.other.x += w.other.v * dt;

    // Gap check → start LC
    if(w.state === 'buildGap' && clearanceRearMinusFront() >= clearanceNeeded()){
      w.state = 'laneChange';
      w.lcStartT = w.t; w.lcStartY = w.ego.y; w.lcEndT = w.lcStartT + w.lcDur;
      if(w.ms.lateralStart === null) w.ms.lateralStart = +w.t;
      renderMilestones();
    }

    // Lateral (half-sine)
    if(w.state === 'laneChange'){
      const tau = clamp((w.t - w.lcStartT)/w.lcDur, 0, 1);
      w.ego.y = w.lcStartY + 0.5*w.laneW*(1 - Math.cos(Math.PI * tau));
if (tau >= 1){
  w.state = 'done';
  w.indicatorOn = false;
  if (w.ms.lateralDone === null) {
    w.ms.lateralDone = +w.t;
    w.simEndT = w.t + 3;   // schedule sim end 3s later
  }
  renderMilestones();
}
    }

    // Trail
    if(trailChk.checked){
      if(w.trail.length>1200) w.trail.shift();
      w.trail.push({ x:w.ego.x, y:w.ego.y });
    } else w.trail.length = 0;

    // Logs
    w.logT.push(w.t); w.logVego.push(kmh(w.ego.v)); w.logVoth.push(kmh(w.other.v));
    if(w.logT.length>2400){ w.logT.shift(); w.logVego.shift(); w.logVoth.shift(); }

    if (w.state === 'done' && w.simEndT && w.t >= w.simEndT) {
  running = false;
  playBtn.textContent = '▶ Play';
}
    
  }

  // Milestones table
  function renderMilestones(){
    if(!world) return;
    const fmt = t => (t===null ? '—' : t.toFixed(2));
    milestonesBody.innerHTML = [
      `<tr><td class="time">${fmt(world.ms.start)}</td><td class="evt">Simulation start</td></tr>`,
      `<tr><td class="time">${fmt(world.ms.indicator)}</td><td class="evt">Turn indicator deployed</td></tr>`,
      `<tr><td class="time">${fmt(world.ms.speedAdapt)}</td><td class="evt">Longitudinal speed adaptation start</td></tr>`,
      `<tr><td class="time">${fmt(world.ms.lateralStart)}</td><td class="evt">Lateral maneuver start</td></tr>`,
      `<tr><td class="time">${fmt(world.ms.lateralDone)}</td><td class="evt">Lateral maneuver completed</td></tr>`
    ].join('');
    syncStageHeight(); // keep right pane matched to table height
  }

  // Bird-view render (auto-zoom to keep both cars visible)
  function draw(){
    const w = world; if(!w) return;
    const cw = canvas.width, ch = canvas.height;
    ctx.clearRect(0,0,cw,ch);

    // Vertical scale based on lane span + margins
    const mSpanV = w.laneW + 2*VERTICAL_MARGIN_M;
    const pxPerM_vert = Math.max(1, (ch - 2*VERTICAL_PAD_PX) / mSpanV);

    // Horizontal span that fully includes both cars (+ margins)
    const egoFront   = w.ego.x   + w.L/2;
    const egoRear    = w.ego.x   - w.L/2;
    const otherFront = w.other.x + w.L/2;
    const otherRear  = w.other.x - w.L/2;

    const minX = Math.min(egoRear, otherRear)  - HORIZONTAL_MARGIN_M;
    const maxX = Math.max(egoFront, otherFront) + HORIZONTAL_MARGIN_M;
    const mSpanH = Math.max(8, maxX - minX); // prevent tiny span → huge zoom
    const pxPerM_horiz = Math.max(1, (cw - 2*HORIZONTAL_PAD_PX) / mSpanH);

    // Use the tighter scale so both horizontal and vertical fit
    const pxPerM = Math.min(pxPerM_vert, pxPerM_horiz);

    // Camera center between the two cars horizontally; vertically mid-lanes
    const camX = (minX + maxX) / 2;
    const camY = (w.ego.y + w.other.y) / 2; // typically laneW/2

    const toScreen = (xm, ym) => {
      const x = (cw/2) + (xm - camX) * pxPerM;
      const y = (ch/2) - (ym - camY) * pxPerM;
      return [x, y];
    };

    // Road background + center dashed
    ctx.fillStyle = '#0c1020'; ctx.fillRect(0,0,cw,ch);
    ctx.strokeStyle = '#d6d9e6'; ctx.setLineDash([16,16]); ctx.lineWidth = 2;
    ctx.beginPath();
    let [sx,sy] = toScreen(camX - (cw/pxPerM), w.laneW/2);
    ctx.moveTo(sx, sy);
    [sx,sy] = toScreen(camX + (cw/pxPerM), w.laneW/2);
    ctx.lineTo(sx, sy);
    ctx.stroke(); ctx.setLineDash([]);

    // Trail
    if(w.trail.length > 1){
      ctx.strokeStyle = 'rgba(77,163,255,0.35)'; ctx.lineWidth = 2;
      ctx.beginPath();
      for(let i=0;i<w.trail.length;i++){
        const p = w.trail[i]; const [x,y] = toScreen(p.x,p.y);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.stroke();
    }

    // Cars (visual scale only)
    function drawCar(car, color){
      const [cx,cy] = toScreen(car.x, car.y);
      const Lpx = w.L * pxPerM * CAR_VISUAL_SCALE;
      const Wpx = w.W * pxPerM * CAR_VISUAL_SCALE;
      ctx.fillStyle = color; ctx.strokeStyle = '#0008';
      ctx.beginPath(); ctx.rect(cx - Lpx/2, cy - Wpx/2, Lpx, Wpx); ctx.fill(); ctx.stroke();
      if(color === '#4da3ff' && w.indicatorOn){
        const blink = ((w.t*2)|0)%2 === 0;
        if(blink){
          ctx.fillStyle = '#ffd166';
          ctx.beginPath(); ctx.moveTo(cx + Lpx/2 - 6, cy);
          ctx.lineTo(cx + Lpx/2 + 12, cy + 10);
          ctx.lineTo(cx + Lpx/2 + 12, cy - 10);
          ctx.closePath(); ctx.fill();
        }
      }
    }
    drawCar(w.other, '#ff9f43');
    drawCar(w.ego,   '#4da3ff');

    // Clearance guide (based on true geometry)
    const otherRearX = w.other.x - w.L/2;
    const egoFrontX  = w.ego.x   + w.L/2;
    const yLine = w.ego.y;
    const [xr1, yr] = toScreen(egoFrontX, yLine + w.W*0.9);
    const [xr2, _]  = toScreen(otherRearX, yLine + w.W*0.9);
    ctx.strokeStyle = '#8fb8ff'; ctx.lineWidth = 2; ctx.setLineDash([6,6]);
    ctx.beginPath(); ctx.moveTo(xr1, yr); ctx.lineTo(xr2, yr); ctx.stroke(); ctx.setLineDash([]);
    const need = clearanceNeeded();
    const [needEndX, needY] = toScreen(egoFrontX + need, yLine + w.W*0.9);
    ctx.strokeStyle = '#00d07e'; ctx.beginPath(); ctx.moveTo(xr1, needY+6); ctx.lineTo(needEndX, needY+6); ctx.stroke();

    ctx.fillStyle = '#c9d2e6'; ctx.font = '14px system-ui,Segoe UI,Roboto,Arial';
    const clr = clearanceRearMinusFront();
    ctx.fillText(`clearance: ${clr.toFixed(2)} m`, xr1 + 6, yr - 6);
    ctx.fillStyle = '#79e2b1'; ctx.fillText(`needed: ${need.toFixed(2)} m`, xr1 + 6, needY + 22);

    // HUD
    ctx.fillStyle = '#9aa4b2';
    const stateStr = (w.state==='cruise')?'Cruise (target speed)':(w.state==='buildGap')?'Building gap':(w.state==='laneChange')?'Lane change':'Done';
    ctx.fillText(stateStr, 10, 24);

    // Chart
    drawChart();
  }

  // Speed chart
  function drawChart(){
    const w = world; if(!w) return;
    const cw = chart.width, ch = chart.height; cctx.clearRect(0,0,cw,ch);
    cctx.fillStyle = '#c9d2e6'; cctx.font = '12px system-ui,Segoe UI,Roboto,Arial';
    const padL=48, padR=10, padT=14, padB=22; const iw = cw - padL - padR, ih = ch - padT - padB;
    cctx.strokeStyle = '#2b3656'; cctx.strokeRect(padL, padT, iw, ih);

    const span = 20;
    const tmax = w.logT.length? w.logT[w.logT.length-1]:0;
    const tmin = Math.max(0, tmax - span);

    const yMin = 0, yMax = 130; // match UI upper bound
    const xPix = t=> padL + ( (t - tmin)/(span) ) * iw;
    const yPix = v=> padT + ih - ( (v - yMin)/(yMax - yMin) ) * ih;

    // grid
    cctx.strokeStyle = '#1e2740'; cctx.setLineDash([4,8]);
    for(let v=0; v<=130; v+=10){ cctx.beginPath(); cctx.moveTo(padL, yPix(v)); cctx.lineTo(padL+iw, yPix(v)); cctx.stroke(); }
    cctx.setLineDash([]);

    // series
    function line(series, color){
      cctx.strokeStyle = color; cctx.lineWidth = 2; cctx.beginPath();
      let moved=false;
      for(let i=0;i<w.logT.length;i++){
        const t=w.logT[i]; if(t<tmin) continue; const v=series[i];
        const x=xPix(t), y=yPix(v); if(!moved){ cctx.moveTo(x,y); moved=true; } else cctx.lineTo(x,y);
      }
      cctx.stroke();
    }
    line(w.logVoth, '#ff9f43');
    line(w.logVego, '#4da3ff');

    // labels & legend
    cctx.fillStyle='#9aa4b2';
    cctx.fillText('Speed (km/h)', padL, padT-2);
    cctx.fillText('time (last 20 s)', cw-130, ch-4);
    cctx.fillStyle='#ff9f43'; cctx.fillRect(padL+6, padT+6, 10,10); cctx.fillStyle='#c9d2e6'; cctx.fillText('v_other', padL+22, padT+15);
    cctx.fillStyle='#4da3ff'; cctx.fillRect(padL+90, padT+6, 10,10); cctx.fillStyle='#c9d2e6'; cctx.fillText('v_ego', padL+106, padT+15);
  }

  // Loop
  let running = false, lastT = 0, acc = 0;
  function loop(ts){
    if(!running){ lastT = ts; draw(); return requestAnimationFrame(loop); }
    const dtms = ts - lastT; lastT = ts; acc += dtms/1000;
    while(acc >= DT_SIM){ step(DT_SIM); acc -= DT_SIM; }
    draw(); updateReadout();
    requestAnimationFrame(loop);
  }

  function updateReadout(){
    const w = world; if(!w) return;
    tOut.textContent = w.t.toFixed(2);
    stateOut.textContent = w.state;
    vEgoOut.textContent = kmh(w.ego.v).toFixed(1);
    vOthOut.textContent = kmh(w.other.v).toFixed(1);
    clrOut.textContent = clearanceRearMinusFront().toFixed(2);
    if(w.state === 'laneChange'){
      const tau = clamp((w.t - w.lcStartT)/w.lcDur,0,1);
      lcProg.textContent = Math.round(tau*100) + '%';
    } else if(w.state === 'done') lcProg.textContent = '100%'; else lcProg.textContent = '0%';
  }

  // Controls wiring
  function linkRangeNumber(rangeEl, numEl, onChange){
    const sync = v=>{ rangeEl.value = v; numEl.value = v; if (typeof onChange === 'function' && world) onChange(+v); };
    rangeEl.addEventListener('input', ()=> sync(rangeEl.value));
    numEl.addEventListener('input', ()=> sync(numEl.value));
  }

  // React to control changes live
  // ⬇️ Scenario speed applies to: (1) target V0, (2) other car (always), (3) ego initial speed when t===0
  linkRangeNumber(speedKmh, speedKmhNum, v => {
    if (world) {
      world.V0 = v / 3.6;        // scenario target (m/s)
      world.other.v = world.V0;  // keep other car at scenario speed
      if (world.t === 0) {
        world.ego.v = world.V0;  // update ego only before sim starts
      }
      draw();
      updateReadout();
    }
  });

  linkRangeNumber(maxA, maxANum, v => { if(world){ world.maxA = Math.max(0.01, v); } });
  linkRangeNumber(bufSec, bufSecNum, v => { if(world){ world.bufferSec = Math.max(0, v); } });
  linkRangeNumber(lcDur, lcDurNum, v => { if(world){ world.lcDur = v; if(world.state==='laneChange'){ world.lcEndT = world.lcStartT + world.lcDur; } } });

  gapMode.addEventListener('change', ()=>{ if(world) world.mode = gapMode.value; });
  lenNum.addEventListener('change', reset);
  widNum.addEventListener('change', reset);
  laneWNum.addEventListener('change', reset);

  playBtn.addEventListener('click', ()=>{ running = !running; playBtn.textContent = running ? '❚❚ Pause' : '▶ Play'; });
  resetBtn.addEventListener('click', reset);

  // Init
  reset();
  // Ensure initial sync of paired inputs to world
  speedKmh.dispatchEvent(new Event('input'));
  maxA.dispatchEvent(new Event('input'));
  bufSec.dispatchEvent(new Event('input'));
  lcDur.dispatchEvent(new Event('input'));
  gapMode.dispatchEvent(new Event('change'));
  updateReadout();
  requestAnimationFrame(loop);

  // Keys
  window.addEventListener('keydown', (e)=>{
    if(e.code==='Space'){ e.preventDefault(); playBtn.click(); }
    else if(e.key==='r' || e.key==='R'){ resetBtn.click(); }
  });
})();
</script>
</body>
</html>
