<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Annotator</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Chart.js core + Luxon adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-image/0.4.0/leaflet-image.js"></script>

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; padding: 0; font-family: Arial, sans-serif; }
    #sidebar {
      position: fixed; top: 0; left: 0; height: 100%; width: 182px;
      transform: translateX(-152px); transition: transform .3s ease;
      background: #fff; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto; padding: 50px 10px 10px; z-index: 1000;
    }
    #sidebar.collapsed { transform: translateX(-152px); }
    #sidebar.expanded  { transform: translateX(0); }
    #toggleSidebar {
      position: fixed; top: 10px; left: 10px;
      background: #007bff; border: none; color: #fff;
      font-size: 1.5em; padding: 4px 8px; cursor: pointer;
      border-radius: 4px; z-index: 1100;
    }

    .spinner {
      border: 2px solid rgba(0,0,0,0.1);
      border-left-color: #333;
      border-radius: 50%; width: 16px; height: 16px;
      animation: spin .8s linear infinite; display: inline-block;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #totalDistance.updated { transition: background .5s; background: yellow; }

    .bigButton { display: block; width: 80%; min-width: 80px; padding: 12px; font-size: 14px; border-radius: 4px; cursor: pointer; margin: 8px auto; }
    .orangeButton { background-color: orange; color: white; }
    .blueButton   { background-color: blue;   color: white; }
    .greyButton   { background-color: grey;   color: white; }
    .greenButton  { background-color: green;  color: white; }
    .redButton    { background-color: red;    color: white; }

    #mainContent { height: 100vh; overflow-y: auto; margin-left: 202px; padding: 20px; box-sizing: border-box; }

    /* ── Manual Annotation Layout ── */
    #manualAnnotation {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    #manualAnnotation textarea {
      flex: 1;
      resize: vertical;
      font-size: 14px;
      padding: 8px;
    }
    #manualAnnotation button {
      display: inline-block;
      width: auto;
      padding: 6px 10px;
      font-size: 12px;
      margin: 0;
      white-space: nowrap;
    }

    table { width: 100%; margin: 10px 0; border-collapse: collapse; }
    td, th { text-align: center; padding: 10px; }
    #logTableContainer table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #logTableContainer table th,
    #logTableContainer table td {
      border: 1px solid #444;
      padding: 6px 8px;
      text-align: center;
    }
    #countTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #countTable th,
    #countTable td {
    border: 1px solid #444 !important;
    padding: 6px 8px;
    text-align: center;
    margin-bottom: 80px;
    }
    #mapContainer {
      margin-bottom: 80px;
    }
    #countContainer {
      margin-bottom: 80px;
    }
    #chartsContainer {
      margin-bottom: 80px;
    }
    #chartsContainer .chartBox + .chartBox {
      margin-top: 80px;
    }
    #streetTable {
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
   #streetTable th,
   #streetTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
    #weatherTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #weatherTable th,
   #weatherTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
   #phaseTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #phaseTable th,
   #phaseTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;

   #snapshotTableContainer table {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#snapshotTableContainer table th,
#snapshotTableContainer table td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}
   }

    .center-groups { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }

    .section { margin-bottom: 30px; }
    .page-break { page-break-after: always; }
    
@media print {
  /* reset page‐sizing so we don’t clip */
  html, body {
    height: auto !important;
    overflow: visible !important;
  }

  /* hide the sidebar and toggle button */
  #sidebar,
  #toggleSidebar {
    display: none !important;
  }

  /* hide everything except mainContent */
  body * {
    visibility: hidden !important;
  }
  #mainContent,
  #mainContent * {
    visibility: visible !important;
  }

  /* stretch mainContent to fill the page and show all of it */
  #mainContent {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    margin: 0 !important;
    width: 100% !important;
    height: auto !important;         /* ← override the 100vh */
    max-height: none !important;     /* ← remove any implicit max */
    overflow: visible !important;    /* ← show all the content */
  }
  }

  /* hide the tiny weather icon in sidebar */
  #weatherIcon {
    display: none !important;
  }

    .distance-label {
  pointer-events: none;
  font-weight: bold;
  background: rgba(255,255,255,0.8);
  padding: 2px 6px;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  white-space: nowrap;
}
    
  </style>
</head>
<body>
  <input 
    type="file" 
    id="cameraInput" 
    accept="image/*" 
    capture="environment" 
    style="display:none"
  />

  <video id="cameraVideo" autoplay playsinline style="display:none;"></video>
  <canvas id="cameraCanvas" style="display:none;"></canvas>

  <button id="toggleSidebar" aria-expanded="false">☰</button>
  <div id="sidebar" class="collapsed">
    <p id="dateTime"></p>
    <p id="dayPhase">Phase: N/A</p>
    <div class="weatherSection">
      <img id="weatherIcon" src="" alt="Weather">
      <p id="temperature">Temp: N/A</p>
    </div>
    <p id="streetCity">Street: N/A<br>City: N/A</p>
    <p id="location"></p>
    <p id="roadType">Road type: N/A</p>
    <p id="speed">Speed: N/A</p>
    <div class="distanceContainer">
      <p id="totalDistance">Distance: 0.0 km</p>
      <button class="bigButton orangeButton" onclick="resetDistance()">Reset distance</button>
    </div>
    <button class="bigButton greenButton" onclick="saveAndPrint()">Save report to PDF</button>
  </div>

  <div id="mainContent">
    <!-- ── Manual Annotation Section (moved & resized) ── -->
    <div id="manualAnnotation" class="section">
      <textarea id="textBox" rows="2" placeholder="Enter your annotation here…"></textarea>
      <button class="blueButton" onclick="logButton('Manual annotation', false)">
        Manual annotation
      </button>
    </div>

    <style>
      /* start hidden */
      #buttonGroups {
    display: none;
      }
  /* when checkbox is checked, show it */
      #showButtons:checked ~ #buttonGroups {
        display: flex;         /* or block, grid, whatever layout you need */
        align-items: flex-start;   /* if you want centering like your parent */
        gap: 6px;              /* if you want that spacing */
      }
    </style>

    <div style="margin-bottom:10px;
            display:flex;
            flex-wrap:wrap;
            align-items:center;
            gap:6px;">
      <input type="checkbox" id="showButtons" checked>
      <label for="showButtons">Show KPI Hot Keys</label>

      <div id="buttonGroups"
        class="center-groups"
        style="flex-basis:100%;
        margin-top:6px;">
        <div id="buttonGroups" class="center-groups" style="margin-top: 6px; margin-bottom: 30px;">
        </div>
      </div>
    </div>
    <div class="page-break"></div>

    <h3>Issue list</h3>
    <div id="logTableContainer" class="section"></div>
    <div class="page-break"></div>

     <div id="snapshotContainer" class="section">
       <h3>Issue Snapshots</h3>
       <div id="snapshotTableContainer"></div>
     </div>
    <div class="page-break"></div>

      <div id="photoSnapshotContainer" class="section">
        <h3>Photo Snapshots</h3>
        <div id="photoSnapshotTableContainer"></div>
      </div>
    <div class="page-break"></div>


    <div id="map2Container" class="section">
      <h3>Street View</h3>
      <div id="map2" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>
    
    <div id="mapContainer" class="section">
      <h3>Route view</h3>
      <div id="map" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>

    <div id="countContainer" class="section">
      <h3>KPI Calculation</h3>
      <table id="countTable">
        <tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>
        <tr><td colspan="3">&nbsp;</td></tr>
      </table>
    </div>
    <div class="page-break"></div>

    <div id="chartsContainer" class="section">
      <div class="chartBox">
        <h3>Distance vs Time</h3>
        <canvas id="distanceChart"></canvas>
      </div>
      <div class="chartBox">
        <h3>Speed vs Distance</h3>
        <canvas id="speedChart"></canvas>
      </div>
    </div>
    <div class="page-break"></div>

    <div id="streetsContainer" class="section">
      <h3>Road Types Mileage</h3>
      <table id="streetTable"><tr><th>Road type</th></tr></table>
    </div>

    <div id="weatherContainer" class="section">
      <h3>Weather Conditions Mileage</h3>
      <table id="weatherTable">
         <tr><th>Condition</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <div id="phaseContainer" class="section">
      <h3>Phase Mileage</h3>
      <table id="phaseTable">
         <tr><th>Phase</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <footer style="text-align:center; padding:10px; font-size:12px; color:#666;">
      © Lynoit Tech 2025
    </footer>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // DOM refs
    const toggleBtn = document.getElementById('toggleSidebar');
    const sidebar   = document.getElementById('sidebar');
    const locEl     = document.getElementById('location');
    const roadTypeEl= document.getElementById('roadType');
    const streetCityEl=document.getElementById('streetCity');
    const tempEl    = document.getElementById('temperature');
    const iconEl    = document.getElementById('weatherIcon');
    const distEl    = document.getElementById('totalDistance');
    const speedEl   = document.getElementById('speed');
    const countTbl  = document.getElementById('countTable');
    const streetTbl = document.getElementById('streetTable');
    const logContainer = document.getElementById('logTableContainer');
    const buttonGroups = document.getElementById('buttonGroups');
    const weatherDistances = {};
    const phaseDistances = {};
    
    // ── Whitelist of road types we care about ──
    const allowedRoadTypes = new Set([
      'motorway',
      'trunk',
      'primary',
      'secondary',
      'tertiary',
      'unclassified',
      'residential',
      'service',
    ]);

    let logTable=[], redCounts={}, lastPos=null, totalDist=0;
    let positions=[], timeData=[], distData=[], speedData=[];
    let map, trackLine, distanceChart, speedChart;
    let roadTypes=new Set(), lastChartTs=0, posCount=0, lastCity=null;
    let roadDistances = {};
    let currentDistMarker = null;
    let map2, circle2;

    toggleBtn.onclick = () => {
      const exp = sidebar.classList.toggle('expanded');
      sidebar.classList.toggle('collapsed', !exp);
      toggleBtn.setAttribute('aria-expanded', exp);
    };

    window.onload = () => {
      initMap(); initMap2(); initCharts(); updateDateTime(); setInterval(updateDateTime,1000);
      navigator.geolocation.watchPosition(showPosition,showError,{enableHighAccuracy:true,maximumAge:5000,timeout:10000});
      buildButtons();
    };

    function initMap(){
      map=L.map('map').setView([0,0],2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{attribution:'© OpenStreetMap contributors'}).addTo(map);
      trackLine=L.polyline([],{weight:4}).addTo(map);
    }

    function initMap2(){
  // no zoomControl or attribution to keep it clean
  map2 = L.map('map2', {
    zoomControl: false,
    attributionControl: false
  }).setView([0,0], 18);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '© OpenStreetMap contributors'
  }).addTo(map2);

  // a circle showing the 100 m radius
  circle2 = L.circle([0,0], {
    radius: 100,           // 100 meters
    color: 'blue',
    fillOpacity: 0.1
  }).addTo(map2);

  currentPosMarker2 = L.circleMarker([0,0], {
  radius: 8,             // bigger dot
  color: 'red',
  fillColor: 'red',
  fillOpacity: 1
}).addTo(map2);
      
}
    
    function initCharts(){
      distanceChart=new Chart(document.getElementById('distanceChart').getContext('2d'),{type:'line',data:{labels:timeData,datasets:[{label:'Distance (km)',data:distData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'time',time:{unit:'minute',tooltipFormat:'HH:mm:ss'}},y:{beginAtZero:true}}}});
      speedChart=new Chart(document.getElementById('speedChart').getContext('2d'),{type:'line',data:{labels:distData,datasets:[{label:'Speed (km/h)',data:speedData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'linear',title:{display:true,text:'Distance (km)'}},y:{beginAtZero:true,title:{display:true,text:'Speed (km/h)'}}}}});
    }

   function showPosition(pos) {
  const { latitude: lat, longitude: lon } = pos.coords;
  const ts = pos.timestamp;
  let segDist = 0; // in meters

  // 1) Calculate segment distance & apply noise threshold
  if (lastPos) {
    segDist = calculateDistance(lastPos.lat, lastPos.lon, lat, lon);
    if (segDist < 10) return; // ignore tiny jitters

    // accumulate total and per‐weather
    totalDist += segDist;
    const phaseText = document.getElementById('dayPhase').textContent.split(': ')[1] || 'Unknown';
    phaseDistances[phaseText] = (phaseDistances[phaseText] || 0) + segDist;
    const condition = iconEl.alt || 'Unknown';
    weatherDistances[condition] = (weatherDistances[condition] || 0) + segDist;

        const distKm = (totalDist / 1000).toFixed(2);
    const labelHtml = `<div class="distance-label">${distKm} km</div>`;

    if (!currentDistMarker) {
      currentDistMarker = L.marker([lat, lon], {
        icon: L.divIcon({
          className: '',        // styling lives in .distance-label
          html: labelHtml,
          iconSize: [0, 0],     // let the inner div size itself
          iconAnchor: [0, -10]  // float just above the point
        })
      }).addTo(map);
    } else {
      currentDistMarker.setLatLng([lat, lon]);
      currentDistMarker.setIcon(L.divIcon({
        className: '',
        html: labelHtml,
        iconSize: [0, 0],
        iconAnchor: [0, -10]
      }));
    }    
  }

  // 2) Update position state & map
  const prevPos = lastPos;
  lastPos = { lat, lon, ts };
  posCount++;
  trackLine.addLatLng([lat, lon]);
  if (positions.length === 0) {
    map.setView([lat, lon], 15);
  } else if (posCount % 20 === 0) {
    map.fitBounds(trackLine.getBounds().pad(0.2));
  }
  positions.push([lat, lon]);

  // 3) Update speed display
  if (prevPos) {
    const dt = (ts - prevPos.ts) / 1000; // seconds
    const speedKmh = dt > 0 ? (segDist / dt) * 3.6 : 0;
    speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;
  }

  // 4) Update distance display & charts
  distEl.textContent = `Distance: ${(totalDist / 1000).toFixed(1)} km`;
  distEl.classList.add('updated');
  setTimeout(() => distEl.classList.remove('updated'), 500);

  if (Date.now() - lastChartTs > 5000) {
    timeData.push(new Date(ts));
    distData.push((totalDist / 1000).toFixed(3));
    speedData.push(speedEl.textContent.split(' ')[1]);
    requestAnimationFrame(() => {
      distanceChart.update();
      speedChart.update();
      updateCountTable();
      updateWeatherTable();
    });
    lastChartTs = Date.now();
  }

  // 5) Update raw lat/lon display
  locEl.innerHTML = `Lat: ${lat}<br>Lon: ${lon}`;

  updateDayPhase(lat, lon);

  // 6) Reverse‐geocode + whitelist + accumulate per‐type distance
  fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`)
    .then(r => r.json())
    .then(data => {
      const rawRt = data.extratags?.highway || data.type || 'unknown';
      const displayRt = allowedRoadTypes.has(rawRt) ? rawRt : 'Other';

      // accumulate this segment to the proper road‐type bucket
      if (segDist > 0) {
        roadDistances[displayRt] = (roadDistances[displayRt] || 0) + segDist;
      }

      // update sidebar & sets
      roadTypeEl.textContent = `Road type: ${displayRt}`;
      if (allowedRoadTypes.has(rawRt)) roadTypes.add(rawRt);

      // street & city display
      const street = data.address.road
        || data.address.pedestrian
        || data.address.footway
        || 'Unknown street';
      const city = data.address.city
        || data.address.town
        || data.address.village
        || 'Unknown city';
      streetCityEl.innerHTML = `Street: ${street}<br>City: ${city}`;

      // fetch weather on city change
      if (city !== lastCity) {
        lastCity = city;
        getWeather(city);
      }

      // refresh all tables
      updateStreetTable();
      updateCountTable();
      updateWeatherTable();
      updatePhaseTable();
    })
    .catch(err => {
      streetCityEl.textContent = 'Error: ' + err.message;
      console.error('Reverse geocode error', err);
    });

    if (map2) {
      map2.setView([lat, lon], 20);  // zoom level 20 ≃ 100 m across
      currentPosMarker2.setLatLng([lat, lon]);
    }     
}
    
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6_371_000;          // earth’s radius in meters
      const toRad = Math.PI / 180;
      const φ1 = lat1 * toRad;
      const φ2 = lat2 * toRad;
      const dφ = (lat2 - lat1) * toRad;
      const dλ = (lon2 - lon1) * toRad;

      const a = Math.sin(dφ/2)**2
          + Math.cos(φ1) * Math.cos(φ2) * Math.sin(dλ/2)**2;

      // clamp (1 - a) to [0,1] to avoid small floating‑point overshoot
      const oneMinusA = Math.max(0, 1 - a);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(oneMinusA));
      return R * c;  // distance in meters
    }
    
function updateStreetTable() {
  // build header row
  let html = `
    <tr>
      <th>Road type</th>
      <th>Distance (km)</th>
    </tr>`;

  // one row per seen road type
  for (const rt of roadTypes) {
    const meters = roadDistances[rt] || 0;
    html += `
      <tr>
        <td>${rt}</td>
        <td>${(meters / 1000).toFixed(2)}</td>
      </tr>`;
  }

  // inject into the table
  streetTbl.innerHTML = html;
}
    function resetDistance(){totalDist=0;lastPos=null;positions=[];roadTypes.clear();distEl.textContent='Distance: 0.0 km';speedEl.textContent='Speed: N/A';roadTypeEl.textContent = 'Road type: N/A';timeData=[];distData=[];speedData=[];trackLine.setLatLngs([]);map.setView([0,0],2);updateStreetTable();updateCountTable();}
    function saveAndPrint(){const btn=event.currentTarget;btn.disabled=true;const orig=btn.textContent;btn.innerHTML='<span class="spinner"></span> Generating…';logButton('Save report to PDF',false);setTimeout(()=>{window.print();btn.disabled=false;btn.textContent=orig;},500);}
    function showError(e){locEl.textContent='Error: '+e.message;speedEl.textContent='Speed: N/A';}
    function getWeather(city){fetch(`https://api.weatherapi.com/v1/current.json?key=ad8caecea06c43d1912181938230407&q=${encodeURIComponent(city)}`)
        .then(r=>r.json()).then(d=>{const iconPath=d.current.condition.icon||'';const iconUrl=iconPath.startsWith('//')?'https:'+iconPath:iconPath;iconEl.src=iconUrl;iconEl.alt=d.current.condition.text||'weather';tempEl.textContent=`Temp: ${d.current.temp_c}°C`;}).catch(err=>{tempEl.textContent='Temp: N/A';console.error('Weather error',err);});}

    async function logButton(name, isRed) {
  // --- 1) Capture a single frame from the hidden video ---
  const video  = document.getElementById('cameraVideo');
  const canvas = document.getElementById('cameraCanvas');
  const ctx    = canvas.getContext('2d');
  // make canvas match video size
  canvas.width  = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
  const photoDataUrl = canvas.toDataURL('image/jpeg', 0.8);

  // --- 2) Gather your other metadata ---
  const dt        = new Date(),
        date      = dt.toLocaleDateString(),
        time      = dt.toLocaleTimeString(),
        fullPhase = document.getElementById('dayPhase').textContent,
        phase     = fullPhase.split(': ')[1] || fullPhase,
        [lat, lon]= locEl.innerHTML.split('<br>').map(l => l.split(': ')[1]),
        dist      = (totalDist / 1000).toFixed(1),
        spd       = speedEl.textContent.split(' ')[1],
        rt        = roadTypeEl.textContent.split(': ')[1],
        comment   = document.getElementById('textBox').value;

  // --- 3) Push into your logTable, adding photoDataUrl as the last column ---
  logTable.push([
    name, date, time, phase,
    tempEl.textContent, iconEl.alt,
    lat, lon, dist, spd, rt,
    comment,
    photoDataUrl   // ← automatic snapshot
  ]);

  // --- 4) Update all of your UI tables & map marker ---
  displayLogTable();
  displaySnapshotTable();
  displayPhotoTable();

  L.marker([+lat, +lon], {
    icon: L.divIcon({ html: `<strong>${name}</strong>` })
  }).addTo(map);

  if (isRed) {
    redCounts[name] = (redCounts[name] || 0) + 1;
    updateCountTable();
  }

  // --- 5) Clear the annotation box for the next entry ---
  document.getElementById('textBox').value = '';
}


function displayPhotoTable() {
  let html = `
    <table>
      <tr>
        <th>No.</th>
        <th>Issue</th>
        <th>Photo</th>
      </tr>`;

  logTable.forEach((row, i) => {
    const name      = row[0];
    const photoData = row[row.length - 1];
    html += `
      <tr>
        <td>${i+1}</td>
        <td>${name}</td>
        <td>
          <img 
            src="${photoData}" 
            style="width:300px; height:200px; object-fit:cover; border:1px solid #444;"
          />
        </td>
      </tr>`;
  });

  html += `</table>`;
  document.getElementById('photoSnapshotTableContainer').innerHTML = html;
}

    
function displayLogTable() {
  // 1) Build & inject main log table
  let html = `
    <table>
      <tr>
        <th>No.</th><th>Issue</th><th>Date</th><th>Time</th>
        <th>Phase</th><th>Temp</th><th>Weather</th>
        <th>Lat</th><th>Lon</th><th>Dist (km)</th>
        <th>Speed</th><th>Road</th><th>Comment</th>
      </tr>`;
  logTable.forEach((row, i) => {
    html += `<tr><td>${i+1}</td>` +
            row.map(v => `<td>${v}</td>`).join('') +
            `</tr>`;
  });
  html += `</table>`;
  logContainer.innerHTML = html;

  // 2) Build & inject snapshot-table with 'Issue' before 'Snapshot'
  let snapHtml = `
    <table id="snapshotTable"
           style="width:100%;border-collapse:collapse;
                  border:1px solid #444;margin-bottom:80px;">
      <tr>
        <th style="border:1px solid #444;padding:6px 8px;">No.</th>
        <th style="border:1px solid #444;padding:6px 8px;">Issue</th>
        <th style="border:1px solid #444;padding:6px 8px;">Snapshot</th>
      </tr>`;
  logTable.forEach((row, i) => {
    snapHtml += `
      <tr>
        <td style="border:1px solid #444;padding:6px 8px;">${i+1}</td>
        <td style="border:1px solid #444;padding:6px 8px;">${row[0]}</td>
        <td id="snapshot-${i}"
            style="border:1px solid #444;padding:6px 8px;">Loading…</td>
      </tr>`;
  });
  snapHtml += `</table>`;
  document.getElementById('snapshotTableContainer').innerHTML = snapHtml;

  // 3) Turn each "Loading…" cell into a mini Leaflet map
  logTable.forEach((row, i) => {
    const lat = parseFloat(row[6]), lon = parseFloat(row[7]);
    const cell = document.getElementById(`snapshot-${i}`);
    cell.innerHTML = '';

    // create div for mini-map
    const div = document.createElement('div');
    div.id = `snapmap-${i}`;
    div.style.width  = '300px';
    div.style.height = '200px';
    cell.appendChild(div);

    // init an off-DOM Leaflet map
    const snapMap = L.map(div.id, {
      zoomControl: false,
      attributionControl: false,
      dragging: false,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
      tap: false
    }).setView([lat, lon], 17);

    // add OSM tiles and red circle marker
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(snapMap);

    L.circleMarker([lat, lon], {
      radius: 6,
      color: 'red',
      fillColor: 'red',
      fillOpacity: 1
    }).addTo(snapMap);

    snapMap.invalidateSize();
  });
}


    function updateCountTable(){let html='<tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>';const km=totalDist/1000;for(let issue in redCounts){const c=redCounts[issue];const per=km>0?((c/km)*1000).toFixed(1):'—';html+=`<tr><td>${issue}</td><td>${c}</td><td>${per}</td></tr>`;}countTbl.innerHTML=html;}

    // Build buttons from CSV using fetch + PapaParse
    function buildButtons() {
      fetch('buttons.csv')
        .then(response => {
          if (!response.ok) throw new Error('Failed to load buttons.csv');
          return response.text();
        })
        .then(csv => {
          const { data, errors } = Papa.parse(csv, { header: true, skipEmptyLines: true });
          if (errors.length) console.error('CSV parse errors', errors);
          const groups = {};
          data.forEach(({ group, label, cssClass, logName, isRed }) => {
            if (!group || !label) return;
            if (!groups[group]) {
              const div = document.createElement('div');
              div.className = 'button-group';
              groups[group] = div;
              buttonGroups.appendChild(div);
            }
            const btn = document.createElement('button');
            btn.textContent = label;
            btn.classList.add('bigButton', cssClass);
            btn.onclick = () => logButton(logName, isRed === 'true');
            groups[group].appendChild(btn);
          });
        })
        .catch(err => console.error(err));
    }

        function updateDayPhase(lat, lon) {
    fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&formatted=0`)
    .then(r => r.json())
    .then(data => {
      const now   = new Date();
      const dawn  = new Date(data.results.civil_twilight_begin);
      const sunrise = new Date(data.results.sunrise);
      const sunset  = new Date(data.results.sunset);
      const dusk    = new Date(data.results.civil_twilight_end);

      let phase;
      if (now < dawn) {
        phase = 'Night';
      } else if (now < sunrise) {
        phase = 'Dawn';
      } else if (now < sunset) {
        phase = 'Daylight';
      } else if (now < dusk) {
        phase = 'Dusk';
      } else {
        phase = 'Night';
      }

      document.getElementById('dayPhase').textContent = `Phase: ${phase}`;
    })
    .catch(err => console.error('Sun API error', err));
}

    function updateWeatherTable() {
  let html = `
    <tr>
      <th>Condition</th>
      <th>Distance (km)</th>
    </tr>`;
  for (const cond in weatherDistances) {
    html += `
      <tr>
        <td>${cond}</td>
        <td>${(weatherDistances[cond] / 1000).toFixed(2)}</td>
      </tr>`;
  }
  document.getElementById('weatherTable').innerHTML = html;
}

    function updatePhaseTable() {
  let html = `
    <tr>
      <th>Phase</th>
      <th>Distance (km)</th>
    </tr>`;

  for (const phase in phaseDistances) {
    html += `
      <tr>
        <td>${phase}</td>
        <td>${(phaseDistances[phase] / 1000).toFixed(2)}</td>
      </tr>`;
  }

  document.getElementById('phaseTable').innerHTML = html;
}

    function updateDateTime() { document.getElementById('dateTime').textContent = new Date().toLocaleString();
    }

    function updateSnapshotTable() {
  const container = document.getElementById('snapshotTableContainer');
  if (!container) return;
  
  // start the table
  let html = `
    <table>
      <tr>
        <th>No.</th>
        <th>Snapshot</th>
        <th>Issue</th>
      </tr>`;

  // one row per log entry
  logTable.forEach((row, i) => {
    const [ name,, , , , , lat, lon ] = row;
    // build a URL for a small static map centered on [lat,lon]
    const mapUrl = 
      `https://staticmap.openstreetmap.de/staticmap.php`
      + `?center=${lat},${lon}`
      + `&zoom=17`
      + `&size=300x200`
      + `&markers=${lat},${lon},red-pushpin`;

    html += `
      <tr>
        <td>${i+1}</td>
        <td>
          <img 
            src="${mapUrl}" 
            alt="Map at ${lat},${lon}" 
            style="width:300px; height:200px; object-fit:cover; border:1px solid #ccc;"
          />
        </td>
        <td>${name}</td>
      </tr>`;
  });

  html += `</table>`;
  container.innerHTML = html;
}
    
  </script>
</body>
</html>
