<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, viewport-fit=cover"
  />
  <title>USB-C Webcam Viewer (Android)</title>
  <style>
    :root { --bg:#0b0d10; --fg:#e8eef6; --muted:#9fb0c3; --card:#141820; --accent:#4da3ff; }
    html,body { margin:0; padding:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { max-width: 820px; margin: 0 auto; padding: 16px; }
    h1 { font-size: 1.25rem; margin: 0 0 8px; }
    h2 { font-size: 1.05rem; margin: 0 0 8px; }
    .card { background:var(--card); border-radius: 16px; padding: 12px; box-shadow: 0 2px 10px rgba(0,0,0,.25); margin-bottom: 12px; }
    .row { display:grid; grid-template-columns: 1fr; gap: 8px; }
    @media (min-width: 560px) { .row.two { grid-template-columns: 1fr 1fr; } }
    label { font-size:.9rem; color:var(--muted); display:block; margin-bottom:4px; }
    select, input[type="text"], button { width:100%; font-size:1rem; padding:10px; border-radius:12px; border:1px solid #263141; background:#0f131a; color:var(--fg); }
    select:focus, input:focus, button:focus { outline: 2px solid var(--accent); outline-offset:2px; }
    button.primary { background: var(--accent); color:#041423; border: none; font-weight: 600; }
    button.ghost { background: #0f131a; border:1px solid #263141; }
    .controls { display:flex; gap:8px; flex-wrap:wrap; }
    .controls button { flex:1; min-width: 120px; }
    .preview-wrap { position: relative; border-radius: 16px; overflow: hidden; background:#000; }
    video, img.stream { width: 100%; height: auto; display:block; }
    .overlay { position: absolute; inset: 0; pointer-events: none; }
    .badge { position:absolute; left:10px; top:10px; padding:4px 8px; background:rgba(0,0,0,.6); border-radius:10px; font-size:.8rem; }
    .switch { display:flex; align-items:center; gap:8px; }
    .muted { color: var(--muted); font-size:.9rem; }
    canvas { display:none; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:.85rem; white-space:pre-wrap; padding:10px; background:#0f131a; border-radius:12px; border:1px solid #263141; max-height:160px; overflow:auto; }
    .hint { font-size:.9rem; color:var(--muted); }
    .pill { display:inline-block; padding:4px 10px; border-radius:999px; background:#0f131a; border:1px solid #263141; font-size:.8rem; margin-right:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>USB-C Webcam Viewer (Android)</h1>
    <div class="card">
      <div class="hint">
        <span class="pill">Step 1</span> Tap <b>Grant camera access</b> → then pick your camera (if Android exposes it).<br/>
        <span class="pill">USB cam not listed?</span> Use <b>Fallback Stream</b> below. On the same tablet, the USB Camera app usually serves MJPEG at <code>http://localhost:8081/video</code>.
      </div>
    </div>

    <div class="card">
      <h2>Browser Camera</h2>
      <div class="row two">
        <div>
          <label for="deviceSelect">Video device</label>
          <select id="deviceSelect" disabled>
            <option>— grant access first —</option>
          </select>
        </div>
        <div>
          <label for="resSelect">Resolution preset</label>
          <select id="resSelect">
            <option value="1280x720">1280×720 (HD)</option>
            <option value="1920x1080">1920×1080 (Full HD)</option>
            <option value="640x480">640×480 (VGA)</option>
            <option value="320x240">320×240 (QVGA)</option>
            <option value="max">Max available</option>
          </select>
        </div>
      </div>

      <div class="controls" style="margin-top:8px;">
        <button id="btnGrant" class="ghost">Grant camera access</button>
        <button id="btnRefresh" class="ghost">Refresh device list</button>
        <button id="btnStart" class="primary">Start</button>
        <button id="btnStop" class="ghost">Stop</button>
      </div>

      <div class="controls" style="margin-top:8px;">
        <label class="switch"><input id="mirrorToggle" type="checkbox" /> Mirror preview</label>
        <button id="btnSnapshot" class="ghost">Snapshot</button>
        <button id="btnFullscreen" class="ghost">Fullscreen</button>
      </div>

      <div class="preview-wrap" style="margin-top:10px;">
        <video id="video" playsinline muted autoplay></video>
        <div class="overlay">
          <div class="badge" id="badge">Idle</div>
        </div>
      </div>
    </div>

    <div class="card">
      <h2>Fallback Stream (MJPEG/Video with auto-reconnect)</h2>
      <div class="hint" style="margin-bottom:6px;">
        Use if your USB camera isn’t listed above. This tries <code>http://localhost:8081/video</code> → <code>http://127.0.0.1:8081/video</code> → your URL.
      </div>
      <div class="row two">
        <div>
          <label for="fallbackUrl">Stream URL (optional, e.g. http://192.168.0.37:8081/video)</label>
          <input id="fallbackUrl" type="text" placeholder="Leave empty to auto-try localhost, or paste MJPEG/HLS/MP4 URL" />
        </div>
        <div class="controls" style="align-items:end;">
          <button id="btnOpenFallback" class="primary">Open stream</button>
          <button id="btnStopFallback" class="ghost">Stop stream</button>
        </div>
      </div>
      <div class="preview-wrap" style="margin-top:10px;">
        <img id="mjpeg" class="stream" alt="" style="display:none;" />
        <video id="altVideo" playsinline controls style="display:none;"></video>
        <div class="overlay">
          <div class="badge" id="badge2">Fallback idle</div>
        </div>
      </div>
      <div class="hint" style="margin-top:6px;">
        MJPEG uses &lt;img&gt; for lowest latency. MP4/HLS uses &lt;video&gt;. “Stay awake” prevents screen dimming.
      </div>
    </div>

    <div class="card">
      <h2>Log</h2>
      <div id="log" class="log">Ready.</div>
    </div>

    <canvas id="snapshotCanvas"></canvas>
  </div>

  <script>
    const el = (id) => document.getElementById(id);
    const logBox = el('log');
    const addLog = (m) => {
      const t = new Date().toLocaleTimeString();
      logBox.textContent += `\n[${t}] ${m}`;
      logBox.scrollTop = logBox.scrollHeight;
    };

    const video = el('video');
    const badge = el('badge');
    const deviceSelect = el('deviceSelect');
    const resSelect = el('resSelect');
    const btnGrant = el('btnGrant');
    const btnRefresh = el('btnRefresh');
    const btnStart = el('btnStart');
    const btnStop = el('btnStop');
    const btnSnapshot = el('btnSnapshot');
    const btnFullscreen = el('btnFullscreen');
    const mirrorToggle = el('mirrorToggle');
    const canvas = el('snapshotCanvas');

    let currentStream = null;

    function setBadge(txt) { badge.textContent = txt; }

    async function stopCurrentStream() {
      if (currentStream) {
        currentStream.getTracks().forEach(tr => tr.stop());
        currentStream = null;
        setBadge('Stopped');
        addLog('Stopped current stream.');
      }
    }

    function resolutionToConstraints(val) {
      if (val === 'max') {
        return { width: { ideal: 4096 }, height: { ideal: 2160 } };
      }
      const [w,h] = val.split('x').map(Number);
      return { width: { ideal: w }, height: { ideal: h } };
    }

    async function ensurePermission() {
      try {
        addLog('Requesting initial camera permission…');
        const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
        tmp.getTracks().forEach(t => t.stop());
        deviceSelect.disabled = false;
        addLog('Permission granted.');
        return true;
      } catch (e) {
        addLog('Permission error: ' + e.message);
        alert('Please allow camera permission.');
        return false;
      }
    }

    async function refreshDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videos = devices.filter(d => d.kind === 'videoinput');
        deviceSelect.innerHTML = '';
        if (videos.length === 0) {
          const o = document.createElement('option');
          o.textContent = 'No video inputs found';
          deviceSelect.appendChild(o);
          deviceSelect.disabled = true;
          addLog('No video devices. If using USB camera, Android may not expose it to the browser.');
          return;
        }
        for (const d of videos) {
          const o = document.createElement('option');
          o.value = d.deviceId;
          o.textContent = d.label || `Camera ${deviceSelect.length+1}`;
          deviceSelect.appendChild(o);
        }
        deviceSelect.disabled = false;
        addLog(`Found ${videos.length} video device(s).`);
      } catch (e) {
        addLog('enumerateDevices error: ' + e.message);
      }
    }

    async function startSelected() {
      await stopCurrentStream();
      const deviceId = deviceSelect.value;
      const resVal = resSelect.value;
      const constraints = {
        audio: false,
        video: {
          ...resolutionToConstraints(resVal),
          deviceId: deviceId ? { exact: deviceId } : undefined
        }
      };
      try {
        addLog('Starting stream with constraints: ' + JSON.stringify(constraints.video));
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        currentStream = stream;
        video.srcObject = stream;
        setBadge('Streaming');
        addLog('Stream started.');
      } catch (e) {
        setBadge('Error');
        addLog('getUserMedia error: ' + e.message);
        alert('Could not start the selected camera.\n\nIf this is a USB camera that does not appear here, use the Fallback Stream below (localhost or /video on port 8081).');
      }
    }

    navigator.mediaDevices?.addEventListener?.('devicechange', async () => {
      addLog('devicechange event → refreshing device list…');
      await refreshDevices();
    });

    btnGrant.addEventListener('click', async () => {
      const ok = await ensurePermission();
      if (ok) await refreshDevices();
    });
    btnRefresh.addEventListener('click', async () => {
      if (deviceSelect.disabled) {
        const ok = await ensurePermission();
        if (!ok) return;
      }
      await refreshDevices();
    });
    btnStart.addEventListener('click', startSelected);
    btnStop.addEventListener('click', stopCurrentStream);

    mirrorToggle.addEventListener('change', () => {
      video.style.transform = mirrorToggle.checked ? 'scaleX(-1)' : 'none';
    });

    btnSnapshot.addEventListener('click', () => {
      if (!currentStream) return alert('No active stream.');
      const track = currentStream.getVideoTracks()[0];
      const settings = track.getSettings();
      const w = video.videoWidth || settings.width || 1280;
      const h = video.videoHeight || settings.height || 720;
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      if (mirrorToggle.checked) {
        ctx.translate(w, 0); ctx.scale(-1, 1);
      }
      ctx.drawImage(video, 0, 0, w, h);
      canvas.toBlob(b => {
        const url = URL.createObjectURL(b);
        const a = document.createElement('a');
        a.href = url;
        const ts = new Date().toISOString().replace(/[:.]/g,'-');
        a.download = `snapshot_${ts}.png`;
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 1000);
      }, 'image/png', 1.0);
      addLog(`Snapshot saved (${w}×${h}).`);
    });

    btnFullscreen.addEventListener('click', () => {
      const elem = video.parentElement;
      if (document.fullscreenElement) document.exitFullscreen();
      else elem.requestFullscreen?.();
    });

    // ===== Fallback Stream (MJPEG with auto-reconnect; tries localhost/127.0.0.1/custom) =====
    const fallbackUrl = el('fallbackUrl');
    const btnOpenFallback = el('btnOpenFallback');
    const btnStopFallback = el('btnStopFallback');
    const mjpegImg = el('mjpeg');
    const altVideo = el('altVideo'); // kept for MP4/HLS if you ever need it
    const badge2 = el('badge2');

    let mjpegState = {
      active: false,
      currentUrl: '',
      retryMs: 1000,
      retryTimer: null,
      wakeLock: null,
      stayAwake: false,
    };

    function setBadge2(txt) { badge2.textContent = txt; }
    function clearRetry() { if (mjpegState.retryTimer) { clearTimeout(mjpegState.retryTimer); mjpegState.retryTimer = null; } }

    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator && mjpegState.stayAwake && !mjpegState.wakeLock) {
          mjpegState.wakeLock = await navigator.wakeLock.request('screen');
          mjpegState.wakeLock.addEventListener('release', () => { mjpegState.wakeLock = null; });
        }
      } catch { /* ignore */ }
    }
    async function releaseWakeLock() { try { await mjpegState.wakeLock?.release(); } catch {} mjpegState.wakeLock = null; }

    function stopFallback() {
      clearRetry();
      if (mjpegState.active) {
        mjpegImg.src = '';
        mjpegImg.style.display = 'none';
      }
      altVideo.pause(); altVideo.removeAttribute('src'); altVideo.load(); altVideo.style.display = 'none';
      mjpegState.active = false;
      mjpegState.currentUrl = '';
      mjpegState.retryMs = 1000;
      setBadge2('Stopped');
      addLog('Fallback: stopped.');
      releaseWakeLock();
    }

    function trySetMjpeg(url) {
      // Avoid redundant restarts for same URL
      if (mjpegState.active && mjpegState.currentUrl === url && mjpegImg.complete) return;

      clearRetry();
      mjpegState.active = true;
      mjpegState.currentUrl = url;
      setBadge2('Connecting…');
      addLog('Fallback: opening MJPEG ' + url);

      // Some Android builds fire onload for every MJPEG frame; treat onload as "playing"
      mjpegImg.onload = () => {
        setBadge2('Playing');
        mjpegState.retryMs = 1000; // reset backoff
      };
      mjpegImg.onerror = () => {
        setBadge2(`Retrying in ${Math.round(mjpegState.retryMs/1000)}s…`);
        addLog('Fallback: MJPEG error, will retry.');
        clearRetry();
        mjpegState.retryTimer = setTimeout(() => {
          mjpegState.retryMs = Math.min(mjpegState.retryMs + 1000, 5000); // linear backoff to 5s
          mjpegImg.src = '';                // force reconnect
          mjpegImg.src = mjpegState.currentUrl;
        }, mjpegState.retryMs);
      };

      mjpegImg.style.display = 'block';
      altVideo.style.display = 'none';
      mjpegImg.src = url;
    }

    async function openFallbackSmart() {
      // Try in order: localhost → 127.0.0.1 → user-entered
      const user = (fallbackUrl.value || '').trim();
      const candidates = [
        'http://localhost:8081/video',
        'http://127.0.0.1:8081/video',
      ];
      if (user) candidates.push(user);

      // clean start without extra spam
      stopFallback();

      await requestWakeLock();
      setBadge2('Scanning…');

      let tried = 0;
      const tryNext = () => {
        if (tried >= candidates.length) {
          setBadge2('No stream reachable');
          addLog('Fallback: no candidate URL worked.');
          releaseWakeLock();
          return;
        }
        const url = candidates[tried++];
        addLog('Fallback: trying ' + url);

        // Quick probe with <img>; if we get any frame, adopt this URL
        let settled = false;
        const probeImg = new Image();
        const settle = (ok) => {
          if (settled) return;
          settled = true;
          probeImg.onload = null;
          probeImg.onerror = null;
          if (ok) {
            addLog('Fallback: selected ' + url);
            trySetMjpeg(url);
          } else {
            setTimeout(tryNext, 200);
          }
        };
        const timeout = setTimeout(() => settle(false), 1200);
        probeImg.onload = () => { clearTimeout(timeout); settle(true); };
        probeImg.onerror = () => { clearTimeout(timeout); settle(false); };

        const bust = url.includes('?') ? '&_=' : '?_=';
        probeImg.src = url + bust + Date.now();
      };

      tryNext();
    }

    btnOpenFallback.addEventListener('click', openFallbackSmart);
    btnStopFallback.addEventListener('click', stopFallback);

    // Add a “Stay awake” toggle next to the buttons
    (function addStayAwakeToggle() {
      const parent = btnOpenFallback.parentElement;
      const wrap = document.createElement('label');
      wrap.className = 'switch';
      wrap.style.marginLeft = '8px';
      wrap.innerHTML = `<input id="stayAwake" type="checkbox" /> Stay awake`;
      parent.appendChild(wrap);
      const stay = document.getElementById('stayAwake');
      stay.addEventListener('change', async () => {
        mjpegState.stayAwake = stay.checked;
        if (stay.checked) await requestWakeLock(); else await releaseWakeLock();
      });
    })();

    // Release wake lock on visibility change
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) releaseWakeLock(); else requestWakeLock();
    });

    // Initial note
    (function init() {
      addLog('Tip: On Android, browsers often cannot enumerate USB UVC cameras. Use the fallback stream (localhost:8081/video) from the USB Camera app.');
    })();
  </script>
</body>
</html>
