<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BTC & ETH Sentiment + Daily Price & Change</title>
<style>
  :root{--bg:#0f1220;--card:#171a2b;--ink:#e7e9ff;--muted:#9aa3b2;--accent:#6ea8ff;--good:#2ecc71;--bad:#ff5c5c;--border:#272a3d}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial;background:var(--bg);color:var(--ink)}
  header{padding:18px 16px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,#14172a,#0f1220)}
  h1{margin:0;font-size:20px}
  .muted{color:var(--muted)}
  main{max-width:1200px;margin:18px auto;padding:0 12px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:14px}
  .controls>*{background:var(--card);border:1px solid var(--border);color:var(--ink);border-radius:10px;padding:10px 12px}
  .controls input[type="text"]{min-width:340px}
  button{cursor:pointer}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px}
  .card h2{margin:4px 0 10px;font-size:16px;display:flex;gap:10px;align-items:baseline}
  .priceTag{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;font-variant-numeric:tabular-nums}
  th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left}
  th{color:var(--muted);font-weight:600}
  td.num{text-align:right}
  .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#1d2136;border:1px solid var(--border);color:var(--muted);font-size:12px;margin-right:6px}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .status{min-height:24px}
  .good{color:var(--good);font-weight:600}
  .bad{color:var(--bad);font-weight:600}
  .spinner{display:inline-block;width:16px;height:16px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;vertical-align:-3px}
  @keyframes spin{to{transform:rotate(360deg)}}
  .foot{margin-top:16px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>Bitcoin & Ethereum — Sentiment + Daily Price & Change (last N days)</h1>
  <div class="muted small">Reddit + RSS via your Cloudflare Worker. Prices via CoinGecko with Binance fallback. Auto-fallback to direct fetch if Worker blocks.</div>
</header>

<main>
  <div class="controls">
    <label>Worker URL:
      <input id="workerUrl" type="text" placeholder="https://your-name.workers.dev"/>
    </label>
    <button id="saveWorker">Save</button>
    <span class="muted small">Saved to localStorage</span>
  </div>

  <div class="controls">
    <label>Days:
      <input id="days" type="number" min="1" max="30" value="7" style="width:80px;margin-left:6px;background:transparent;border:none;outline:none;color:var(--ink);">
    </label>
    <label><input id="includeCryptoSub" type="checkbox" checked> Include r/CryptoCurrency</label>
    <label><input id="includeNews" type="checkbox" checked> Include News RSS</label>
    <label><input id="titlesOnly" type="checkbox"> Titles only (faster)</label>
    <button id="runBtn">Run scan</button>
    <span id="status" class="status"></span>
  </div>

  <div class="row" style="margin-bottom:8px;">
    <span class="tag">Reddit: r/Bitcoin, r/Ethereum <span id="srcExtra"></span></span>
    <span class="tag" id="newsTag">RSS: CoinDesk, CoinTelegraph, Bitcoin Magazine, Google News</span>
    <span class="tag">Naive sentiment w/ keyword filter</span>
    <span class="tag">Aggregation: per UTC date</span>
  </div>

  <div class="grid">
    <section class="card">
      <h2>Bitcoin <span id="btcPrice" class="priceTag"></span></h2>
      <table id="btcTable">
        <thead>
          <tr>
            <th>Date (UTC)</th>
            <th class="good">Positive</th>
            <th class="bad">Negative</th>
            <th>Price (USD)</th>
            <th>% Change vs prev day</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <section class="card">
      <h2>Ethereum <span id="ethPrice" class="priceTag"></span></h2>
      <table id="ethTable">
        <thead>
          <tr>
            <th>Date (UTC)</th>
            <th class="good">Positive</th>
            <th class="bad">Negative</th>
            <th>Price (USD)</th>
            <th>% Change vs prev day</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <div class="foot">
    Tip: If prices still don’t appear, verify your Worker allowlist includes <code>api.coingecko.com</code> and <code>api.binance.com</code>, or just leave the Worker box empty and it will fetch prices directly.
  </div>
</main>

<script>
/* ==================== Config ==================== */
const SUBS_CORE = ["Bitcoin","Ethereum"];
const SUB_CRYPTOCURRENCY = "CryptoCurrency";
const REDDIT_PAGE_LIMIT = 100;
const REDDIT_MAX_PAGES = 8;

const RSS_SOURCES = [
  "https://www.coindesk.com/arc/outboundfeeds/rss/",
  "https://cointelegraph.com/rss",
  "https://bitcoinmagazine.com/.rss",
  "https://news.google.com/rss/search?q=bitcoin",
  "https://news.google.com/rss/search?q=ethereum"
];

const KEYWORDS = {
  btc: /(bitcoin|btc|\$btc|\bXBT\b)/i,
  eth: /(ethereum|eth|\$eth)/i
};

const POSITIVE_WORDS = [
  "bull","bullish","buy","accumulate","moon","pump","surge","rally","breakout","support",
  "undervalued","strong","uptrend","green","optimistic","positive","booming","soaring","rocket","rebound"
];
const NEGATIVE_WORDS = [
  "bear","bearish","sell","dump","crash","plunge","collapse","resistance","overvalued","weak",
  "downtrend","red","fear","negative","panic","recession","fraud","scam","rug","ban"
];

const MAP_CG_TO_BINANCE = { bitcoin: "BTCUSDT", ethereum: "ETHUSDT" };

/* ==================== Helpers ==================== */
function getWorker(){ return (localStorage.getItem("workerEndpoint") || "").trim(); }
function setWorker(url){
  if(!/^https?:\/\//i.test(url)) throw new Error("Worker URL must start with http(s)://");
  localStorage.setItem("workerEndpoint", url.replace(/\/+$/,""));
}
function setStatus(msg, spinning=false){
  const el = document.getElementById('status');
  el.innerHTML = spinning ? `<span class="spinner"></span> ${msg}` : msg;
}
function utcDateStr(tsSeconds){
  const d = new Date(tsSeconds*1000);
  return d.toISOString().slice(0,10);
}
function row(html){ const tr=document.createElement('tr'); tr.innerHTML=html; return tr; }
const delay = (ms)=> new Promise(r=>setTimeout(r, ms));
function fmtUSD(n){
  if(n==null || !isFinite(n)) return "—";
  return `$${Number(n).toLocaleString(undefined,{maximumFractionDigits:2})}`;
}

/* ==================== Sentiment ==================== */
function sentimentScore(text){
  if(!text) return 0;
  const t = text.toLowerCase();
  let s = 0;
  for(const w of POSITIVE_WORDS){ if(t.includes(w)) s++; }
  for(const w of NEGATIVE_WORDS){ if(t.includes(w)) s--; }
  return s;
}

/* ==================== Fetch helpers (Worker → direct fallback) ==================== */
async function fetchJSONSmart(targetUrl){
  const worker = getWorker();
  const tryDirect = async ()=>{
    const r = await fetch(targetUrl, { headers:{ "Accept":"application/json" } });
    if(!r.ok) throw new Error(`Direct HTTP ${r.status} for ${targetUrl}`);
    return await r.json();
  };
  if(worker){
    try{
      const proxied = `${worker}/?url=${encodeURIComponent(targetUrl)}`;
      const r = await fetch(proxied, { headers:{ "Accept":"application/json" } });
      if(!r.ok) throw new Error(`Worker HTTP ${r.status} for ${targetUrl}`);
      return await r.json();
    }catch(e){
      console.warn("Worker JSON fetch failed, trying direct:", e);
      return await tryDirect();
    }
  }
  return await tryDirect();
}
async function fetchTextSmart(targetUrl){
  const worker = getWorker();
  const tryDirect = async ()=>{
    const r = await fetch(targetUrl);
    if(!r.ok) throw new Error(`Direct HTTP ${r.status} for ${targetUrl}`);
    return await r.text();
  };
  if(worker){
    try{
      const proxied = `${worker}/?url=${encodeURIComponent(targetUrl)}`;
      const r = await fetch(proxied);
      if(!r.ok) throw new Error(`Worker HTTP ${r.status} for ${targetUrl}`);
      return await r.text();
    }catch(e){
      console.warn("Worker TEXT fetch failed, trying direct:", e);
      return await tryDirect();
    }
  }
  return await tryDirect();
}

/* ==================== Reddit (/new.json) ==================== */
async function fetchSubNew(sub, after=null){
  const url = new URL(`https://www.reddit.com/r/${sub}/new.json`);
  url.searchParams.set('limit', REDDIT_PAGE_LIMIT);
  if(after) url.searchParams.set('after', after);
  return await fetchJSONSmart(url.toString());
}

async function fetchRedditAcross(sub, days, titlesOnly){
  const cutoff = Date.now()/1000 - days*86400;
  let after = null, all = [], pages = 0;
  while(pages < REDDIT_MAX_PAGES){
    const data = await fetchSubNew(sub, after);
    const children = data?.data?.children || [];
    if(children.length === 0) break;

    const posts = children.map(c => c.data).map(p => ({
      id: p.name,
      title: p.title || "",
      selftext: titlesOnly ? "" : (p.selftext || ""),
      created_utc: p.created_utc || 0
    }));

    all.push(...posts.filter(p => p.created_utc >= cutoff));
    after = data?.data?.after || null;
    pages++;

    const lastTs = posts[posts.length-1]?.created_utc || 0;
    if(!after || lastTs < cutoff) break;
    await delay(220);
  }
  return all;
}

/* ==================== RSS (no API key) ==================== */
function parseRssItems(xmlText){
  const doc = new DOMParser().parseFromString(xmlText, "text/xml");
  let items = Array.from(doc.querySelectorAll("item"));
  if(items.length === 0){ items = Array.from(doc.querySelectorAll("entry")); }
  return items.map(el => {
    const title = (el.querySelector("title")?.textContent || "").trim();
    const desc = (el.querySelector("description, summary, content")?.textContent || "").trim();
    const pub = (el.querySelector("pubDate, updated, published")?.textContent || "").trim();
    const ts = pub ? Math.floor(Date.parse(pub)/1000) : Math.floor(Date.now()/1000);
    return { title, desc, created_utc: isFinite(ts) ? ts : Math.floor(Date.now()/1000) };
  });
}

async function fetchAllRss(days){
  const cutoff = Date.now()/1000 - days*86400;
  const out = [];
  for(const url of RSS_SOURCES){
    try{
      const text = await fetchTextSmart(url);
      const items = parseRssItems(text);
      for(const it of items){
        if(it.created_utc >= cutoff){
          out.push({ title: it.title, selftext: it.desc, created_utc: it.created_utc });
        }
      }
      await delay(200);
    }catch(e){
      console.warn("RSS failed", url, e);
    }
  }
  return out;
}

/* ==================== Prices (CG → Binance; Worker → direct) ==================== */
async function fetchCurrentPrices(){
  window.__currentPrices = window.__currentPrices || {};
  // Try CoinGecko
  try{
    const url = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd";
    const data = await fetchJSONSmart(url);
    const btc = data?.bitcoin?.usd ?? null;
    const eth = data?.ethereum?.usd ?? null;
    if(btc!=null){ document.getElementById("btcPrice").textContent = fmtUSD(btc); window.__currentPrices.btc = Number(btc); }
    if(eth!=null){ document.getElementById("ethPrice").textContent = fmtUSD(eth); window.__currentPrices.eth = Number(eth); }
    if(btc!=null && eth!=null) return;
  }catch(e){
    console.warn("CoinGecko current price failed, will try Binance", e);
  }
  // Binance fallback
  try{
    const url = new URL("https://api.binance.com/api/v3/ticker/price");
    url.searchParams.set("symbols", JSON.stringify(["BTCUSDT","ETHUSDT"]));
    const data = await fetchJSONSmart(url.toString());
    const map = {};
    (Array.isArray(data)?data:[data]).forEach(d => map[d.symbol]=Number(d.price));
    if(map.BTCUSDT!=null){ document.getElementById("btcPrice").textContent = fmtUSD(map.BTCUSDT); window.__currentPrices.btc = map.BTCUSDT; }
    if(map.ETHUSDT!=null){ document.getElementById("ethPrice").textContent = fmtUSD(map.ETHUSDT); window.__currentPrices.eth = map.ETHUSDT; }
  }catch(e){
    console.warn("Binance current price failed", e);
  }
}

async function fetchHistoricPrices(symbol, days){
  // CoinGecko
  try{
    const url = `https://api.coingecko.com/api/v3/coins/${symbol}/market_chart?vs_currency=usd&days=${days+2}&interval=daily`;
    const data = await fetchJSONSmart(url);
    const out = {};
    for(const [ts, price] of (data?.prices || [])){
      const d = new Date(ts);
      const dateStr = d.toISOString().slice(0,10);
      out[dateStr] = Number(price);
    }
    if(Object.keys(out).length) return out;
  }catch(e){
    console.warn(`CoinGecko historic (${symbol}) failed, will try Binance`, e);
  }
  // Binance fallback (klines)
  try{
    const binanceSymbol = MAP_CG_TO_BINANCE[symbol];
    const url = new URL("https://api.binance.com/api/v3/klines");
    url.searchParams.set("symbol", binanceSymbol);
    url.searchParams.set("interval", "1d");
    url.searchParams.set("limit", String(days+2));
    const data = await fetchJSONSmart(url.toString());
    const out = {};
    for(const k of data){
      const openTime = k[0];
      const closePrice = Number(k[4]);
      const dateStr = new Date(openTime).toISOString().slice(0,10);
      out[dateStr] = closePrice;
    }
    return out;
  }catch(e){
    console.warn(`Binance historic (${symbol}) failed`, e);
    return {};
  }
}

/* Inject today's live quote if daily candle missing; find nearest previous priced date */
function injectTodayPrice(prices, symbolKey){
  const todayStr = new Date().toISOString().slice(0,10);
  const cur = window.__currentPrices?.[symbolKey];
  if (cur!=null && prices[todayStr]==null) prices[todayStr] = Number(cur);
  return prices;
}
function prevDateWithPrice(prices, dates, startIndex){
  for(let j=startIndex+1; j<dates.length; j++){
    const dj = dates[j];
    if(prices[dj] != null) return dj;
  }
  return null;
}

/* ==================== Aggregation & Table Fill ==================== */
function aggregateByDateForAsset(posts, which){
  const byDate = {};
  const kw = which==='btc' ? KEYWORDS.btc : KEYWORDS.eth;
  for(const p of posts){
    const text = `${p.title} ${p.selftext || ""}`.trim();
    if(!kw.test(text)) continue;
    const score = sentimentScore(text);
    const d = utcDateStr(p.created_utc);
    if(!byDate[d]) byDate[d] = {pos:0, neg:0};
    if(score > 0) byDate[d].pos++;
    else if(score < 0) byDate[d].neg++;
  }
  return byDate;
}

function fillTable(tbody, byDate, prices){
  tbody.innerHTML = "";
  const dates = Object.keys(byDate).sort().reverse(); // newest first
  for(let i=0; i<dates.length; i++){
    const d = dates[i];
    const {pos, neg} = byDate[d];

    const priceVal = prices ? prices[d] : null;
    const priceText = fmtUSD(priceVal);

    let changeText = "-";
    if (prices && priceVal != null) {
      const prevD = prevDateWithPrice(prices, dates, i);
      const prevVal = prevD ? prices[prevD] : null;
      if (prevVal != null && prevVal !== 0){
        const change = ((priceVal - prevVal) / prevVal) * 100;
        const color = change > 0 ? "var(--good)" : change < 0 ? "var(--bad)" : "var(--muted)";
        const sign  = change > 0 ? "+" : (change < 0 ? "" : "");
        changeText = `<span style="color:${color}">${sign}${change.toFixed(2)}%</span>`;
      }
    }

    tbody.appendChild(row(
      `<td>${d}</td>`+
      `<td class="num good">${pos||0}</td>`+
      `<td class="num bad">${neg||0}</td>`+
      `<td class="num">${priceText}</td>`+
      `<td class="num">${changeText}</td>`
    ));
  }
}

/* ==================== UI wiring ==================== */
function coverage(prices, dates){
  let hit=0; for(const d of dates){ if(prices[d]!=null) hit++; }
  return `${hit}/${dates.length}`;
}

async function run(){
  const days = Math.max(1, Math.min(30, Number(document.getElementById('days').value || 7)));
  const titlesOnly = document.getElementById('titlesOnly').checked;
  const includeCrypto = document.getElementById('includeCryptoSub').checked;
  const includeNews = document.getElementById('includeNews').checked;

  document.getElementById('srcExtra').textContent = includeCrypto ? ", r/CryptoCurrency" : "";
  document.getElementById('newsTag').style.display = includeNews ? "inline-block" : "none";
  setStatus(`Fetching prices & content for last ${days} day(s)…`, true);

  try{
    await fetchCurrentPrices();

    let posts = [];
    for(const s of SUBS_CORE){
      const got = await fetchRedditAcross(s, days, titlesOnly);
      posts.push(...got);
    }
    if(includeCrypto){
      const gotMix = await fetchRedditAcross(SUB_CRYPTOCURRENCY, days, titlesOnly);
      posts.push(...gotMix);
    }
    if(includeNews){
      const rssItems = await fetchAllRss(days);
      posts.push(...rssItems);
    }

    const btcByDate = aggregateByDateForAsset(posts, 'btc');
    const ethByDate = aggregateByDateForAsset(posts, 'eth');

    const btcPricesRaw = await fetchHistoricPrices("bitcoin", days);
    await delay(120);
    const ethPricesRaw = await fetchHistoricPrices("ethereum", days);

    const btcPrices = injectTodayPrice(btcPricesRaw, 'btc');
    const ethPrices = injectTodayPrice(ethPricesRaw, 'eth');

    fillTable(document.querySelector('#btcTable tbody'), btcByDate, btcPrices);
    fillTable(document.querySelector('#ethTable tbody'), ethByDate, ethPrices);

    const totalPulled = posts.length;
    const totalBtcPos = Object.values(btcByDate).reduce((a,x)=>a+(x.pos||0),0);
    const totalBtcNeg = Object.values(btcByDate).reduce((a,x)=>a+(x.neg||0),0);
    const totalEthPos = Object.values(ethByDate).reduce((a,x)=>a+(x.pos||0),0);
    const totalEthNeg = Object.values(ethByDate).reduce((a,x)=>a+(x.neg||0),0);

    const btcDates = Object.keys(btcByDate).sort().reverse();
    const ethDates = Object.keys(ethByDate).sort().reverse();
    setStatus(
      `Pulled ${totalPulled} items. `+
      `BTC +${totalBtcPos}/-${totalBtcNeg} (prices ${coverage(btcPrices, btcDates)}) • `+
      `ETH +${totalEthPos}/-${totalEthNeg} (prices ${coverage(ethPrices, ethDates)})`
    );
  }catch(err){
    console.error(err);
    setStatus(`Error: ${err.message}. If Worker blocks, clear the Worker URL (uses direct fetch for prices).`);
  }
}

document.getElementById('runBtn').addEventListener('click', run);

// Worker URL persistence
const workerInput = document.getElementById('workerUrl');
workerInput.value = getWorker();
document.getElementById('saveWorker').addEventListener('click', ()=>{
  try{
    setWorker(workerInput.value || "");
    setStatus("Worker URL saved.", false);
  }catch(e){
    setStatus(e.message, false);
  }
});

// autorun if Worker already saved
if(getWorker()){ run(); }
</script>
</body>
</html>
