<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>BTC & ETH Sentiment + Daily Price & Change</title>
<style>
  :root{--bg:#0f1220;--card:#171a2b;--ink:#e7e9ff;--muted:#9aa3b2;--accent:#6ea8ff;--good:#2ecc71;--bad:#ff5c5c;--border:#272a3d}
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial;background:var(--bg);color:var(--ink)}
  header{padding:18px 16px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,#14172a,#0f1220)}
  h1{margin:0;font-size:20px}
  .muted{color:var(--muted)}
  main{max-width:1200px;margin:18px auto;padding:0 12px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center;margin-bottom:14px}
  .controls>*{background:var(--card);border:1px solid var(--border);color:var(--ink);border-radius:10px;padding:10px 12px}
  .controls input[type="text"]{min-width:340px}
  button{cursor:pointer}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:14px}
  .card h2{margin:4px 0 10px;font-size:16px;display:flex;gap:10px;align-items:baseline}
  .priceTag{font-size:12px;color:var(--muted)}
  table{width:100%;border-collapse:collapse;font-variant-numeric:tabular-nums}
  th,td{border-bottom:1px solid var(--border);padding:8px 10px;text-align:left}
  th{color:var(--muted);font-weight:600}
  td.num{text-align:right}
  .tag{display:inline-block;padding:2px 8px;border-radius:999px;background:#1d2136;border:1px solid var(--border);color:var(--muted);font-size:12px;margin-right:6px}
  .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .status{min-height:24px}
  .good{color:var(--good);font-weight:600}
  .bad{color:var(--bad);font-weight:600}
  .spinner{display:inline-block;width:16px;height:16px;border:2px solid var(--border);border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;vertical-align:-3px}
  @keyframes spin{to{transform:rotate(360deg)}}
  .foot{margin-top:16px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>Bitcoin & Ethereum ‚Äî Sentiment + Daily Price & Change (last N days)</h1>
  <div class="muted small">Reddit + RSS via your Cloudflare Worker. Prices via CoinGecko with Binance fallback. Auto-fallback to direct fetch if Worker blocks.</div>
</header>

<main>
  <div class="controls">
    <label>Worker URL:
      <input id="workerUrl" type="text" placeholder="https://your-name.workers.dev"/>
    </label>
    <button id="saveWorker">Save</button>
    <span class="muted small">Saved to localStorage</span>
  </div>

  <div class="controls">
    <label>Days:
      <input id="days" type="number" min="1" max="30" value="7" style="width:80px;margin-left:6px;background:transparent;border:none;outline:none;color:var(--ink);">
    </label>
    <label><input id="includeCryptoSub" type="checkbox" checked> Include r/CryptoCurrency</label>
    <label><input id="includeNews" type="checkbox" checked> Include News RSS</label>
    <label><input id="titlesOnly" type="checkbox"> Titles only (faster)</label>
    <button id="runBtn">Run scan</button>
    <span id="status" class="status"></span>
  </div>

  <div class="row" style="margin-bottom:8px;">
    <span class="tag">Reddit: r/Bitcoin, r/Ethereum <span id="srcExtra"></span></span>
    <span class="tag" id="newsTag">RSS: CoinDesk, CoinTelegraph, Bitcoin Magazine, Google News</span>
    <span class="tag">Naive sentiment w/ keyword filter</span>
    <span class="tag">Aggregation: per UTC date</span>
  </div>

  <div class="grid">
    <section class="card">
      <h2>Bitcoin <span id="btcPrice" class="priceTag"></span></h2>
      <table id="btcTable">
        <thead>
          <tr>
            <th>Date (UTC)</th>
            <th class="good">Positive</th>
            <th class="bad">Negative</th>
            <th>Price (USD)</th>
            <th>% Change vs prev day</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <section class="card">
      <h2>Ethereum <span id="ethPrice" class="priceTag"></span></h2>
      <table id="ethTable">
        <thead>
          <tr>
            <th>Date (UTC)</th>
            <th class="good">Positive</th>
            <th class="bad">Negative</th>
            <th>Price (USD)</th>
            <th>% Change vs prev day</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>
  </div>

  <div class="foot">
    Tip: If prices still don‚Äôt appear, verify your Worker allowlist includes <code>api.coingecko.com</code> and <code>api.binance.com</code>, or just leave the Worker box empty and it will fetch prices directly.
  </div>
</main>

<script>
/* ==================== Config ==================== */
const SUBS_CORE = ["Bitcoin","Ethereum"];
const SUB_CRYPTOCURRENCY = "CryptoCurrency";
const REDDIT_PAGE_LIMIT = 100;
const REDDIT_MAX_PAGES = 8;

const RSS_SOURCES = [
  "https://www.coindesk.com/arc/outboundfeeds/rss/",
  "https://cointelegraph.com/rss",
  "https://bitcoinmagazine.com/.rss",
  "https://news.google.com/rss/search?q=bitcoin",
  "https://news.google.com/rss/search?q=ethereum"
];

const KEYWORDS = {
  btc: /(bitcoin|btc|\$btc|\bXBT\b)/i,
  eth: /(ethereum|eth|\$eth)/i
};

/***** Multilingual crypto sentiment lexicon + scorer *****/

/* 1) Term lists (single words and short phrases).
   NOTE: Keep items lowercase; phrases can include spaces. */

const LEX_POS = {
  // English
  en: [
    "bull","bullish","buy","accumulate","long","support","breakout","break out","bounce",
    "rally","moon","to the moon","mooning","pump","surge","spike","rip","squeeze",
    "green","uptrend","up trend","ath","all time high","rebound","recovery","strong",
    "undervalued","discount","cheap","oversold","momentum","rocket","lfg","hodl",
    "wagmi","diamond hands","flippening"
  ],
  // Swedish
  sv: [
    "tjur","bullish","k√∂p","k√∂pa","stark","upptrend","upp trend","gr√∂n","hausse",
    "raket","till m√•nen","√•terh√§mtning","ath","all time high","billig","√∂ver s√•ld","momentum","st√∂d"
  ],
  // Norwegian
  no: [
    "bullish","kj√∏p","kj√∏pe","sterk","opptrend","opp trend","gr√∏nn","rally","brudd opp",
    "st√∏tte","til m√•nen","ath","all time high","momentum"
  ],
  // Danish
  da: [
    "bullish","k√∏b","st√¶rk","optrend","op trend","gr√∏n","rally","brud op",
    "st√∏tte","til m√•nen","ath","all time high","momentum"
  ],
  // Finnish
  fi: [
    "h√§rk√§","nouseva","osta","ostaa","vahva","nousutrendi","vihre√§","ralli","l√§pimurto",
    "tuki","kuuhun","ath","kaikkien aikojen huippu","toipuminen","momentum"
  ],
  // German
  de: [
    "bulle","bullisch","kaufen","stark","aufw√§rtstrend","gr√ºn","rallye","ausbruch",
    "unterst√ºtzung","zum mond","ath","allzeithoch","erholung","impuls","g√ºnstig","unterbewertet"
  ],
  // French
  fr: [
    "taureau","haussier","achat","fort","tendance haussi√®re","vert","rallye","cassure",
    "support","vers la lune","ath","plus haut historique","rebond","reprise","optimiste","positif","momentum"
  ],
  // Spanish
  es: [
    "toro","alcista","comprar","fuerte","tendencia alcista","verde","rally","ruptura",
    "soporte","a la luna","ath","m√°ximo hist√≥rico","recuperaci√≥n","impulso","barato","infravalorado","hodl"
  ],
  // Portuguese
  pt: [
    "touro","altista","comprar","forte","tend√™ncia de alta","verde","rali","rompimento",
    "suporte","√† lua","ath","m√°xima hist√≥rica","recupera√ß√£o","otimista","positivo","barato","subvalorizado"
  ],
  // Italian
  it: [
    "toro","rialzista","comprare","forte","trend rialzista","verde","rally","breakout",
    "supporto","verso la luna","ath","massimo storico","ripresa","slancio","sottovalutato"
  ],
  // Dutch
  nl: [
    "stier","bullish","kopen","sterk","opwaartse trend","groen","rally","uitbraak",
    "steun","naar de maan","ath","all time high","herstel","momentum"
  ],
  // Turkish
  tr: [
    "boƒüa","boƒüa piyasasƒ±","al","alƒ±m","g√º√ßl√º","y√ºkseli≈ü","ye≈üil","ralli","kƒ±rƒ±lma",
    "destek","aya","ath","t√ºm zamanlarƒ±n en y√ºksek","toparlanma","momentum","ucuz","deƒüerinin altƒ±nda"
  ],
  // Russian
  ru: [
    "–±—ã–∫","–±—ã—á–∏–π","–ø–æ–∫—É–ø–∞—Ç—å","—Å–∏–ª—å–Ω—ã–π","–≤–æ—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥","–∑–µ–ª—ë–Ω—ã–π","—Ä–∞–ª–ª–∏","–ø—Ä–æ–±–æ–π",
    "–ø–æ–¥–¥–µ—Ä–∂–∫–∞","–Ω–∞ –ª—É–Ω—É","ath","–∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–π –º–∞–∫—Å–∏–º—É–º","–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ","–∏–º–ø—É–ª—å—Å","–Ω–µ–¥–æ–æ—Ü–µ–Ω—ë–Ω–Ω—ã–π","–¥—ë—à–µ–≤–æ","—Ö–æ–¥–ª"
  ],
  // Slang/emojis/symbols (language-agnostic)
  slang: [
    "wagmi","hodl","diamond hands","gm","gf",
    "üöÄ","üìà","üü¢","‚úÖ","üî•","üíéüôå","üíé","üôå","üêÇ","üòé","‚ú®","lfg"
  ]
};

const LEX_NEG = {
  en: [
    "bear","bearish","sell","dump","crash","plunge","collapse","capitulation","liquidation",
    "resistance","overvalued","weak","downtrend","down trend","red","fear","negative","panic",
    "fraud","scam","scammy","rug","rug pull","ponzi","exploit","hack","ban","crackdown",
    "rekt","ngmi","paper hands","selloff","sell-off"
  ],
  sv: [
    "bj√∂rn","bj√∂rnmarknad","s√§lj","s√§lja","dump","krasch","ras","kollaps","kapitulation",
    "likvidation","motst√•nd","√∂verv√§rderad","svag","nedtrend","r√∂d","r√§dsla","negativ","panik",
    "bedr√§geri","bluff","scam","rug pull","ponzi","intr√•ng","hack","f√∂rbud","nedslag","rekt","ngmi","papper h√§nder"
  ],
  no: [
    "bj√∏rn","bearish","selg","dump","krakk","fall","kollaps","kapitulasjon","likvidasjon",
    "motstand","overvurdert","svak","nedtrend","r√∏d","frykt","negativ","panikk",
    "svindel","scam","rug pull","ponzi","hack","forbud","nedslag","rekt","ngmi","paper hands"
  ],
  da: [
    "bj√∏rn","bearish","s√¶lg","dump","krak","fald","kollaps","kapitulation","likvidation",
    "modstand","overvurderet","svag","nedtrend","r√∏d","frygt","negativ","panik",
    "bedrageri","svindel","rug pull","ponzi","hack","forbud","nedslag","rekt","ngmi","paper hands"
  ],
  fi: [
    "karhu","laskutrendi","myy","dump","romahdus","lasku","kollapsi","kapitulaatio","likvidointi",
    "vastus","yliarvostettu","heikko","punainen","pelko","negatiivinen","paniikki",
    "petos","huijaus","rug pull","ponzi","hakkerointi","kielto","likvidaatio","rekt","ngmi","paperik√§det"
  ],
  de: [
    "b√§r","b√§risch","verkaufen","dumpen","crash","einbruch","kollaps","kapitulation","liquidation",
    "widerstand","√ºberbewertet","schwach","abw√§rtstrend","rot","angst","negativ","panik",
    "betrug","scam","rug pull","ponzi","exploit","hack","verbot","durchgreifen","rekt","ngmi","paper hands"
  ],
  fr: [
    "ours","baissier","vente","dump","krach","chute","effondrement","capitulation","liquidation",
    "r√©sistance","sur√©valu√©","faible","tendance baissi√®re","rouge","peur","n√©gatif","panique",
    "fraude","arnaque","rug pull","ponzi","exploit","piratage","interdiction","r√©pression","rekt","ngmi","mains de papier"
  ],
  es: [
    "oso","bajista","vender","dump","desplome","crash","colapso","capitulaci√≥n","liquidaci√≥n",
    "resistencia","sobrevalorado","d√©bil","tendencia bajista","rojo","miedo","negativo","p√°nico",
    "fraude","estafa","rug pull","ponzi","exploit","hackeo","prohibici√≥n","represi√≥n","rekt","ngmi","manos de papel"
  ],
  pt: [
    "urso","baixista","vender","dump","queda","crash","colapso","capitula√ß√£o","liquida√ß√£o",
    "resist√™ncia","sobrevalorizado","fraco","tend√™ncia de baixa","vermelho","medo","negativo","p√¢nico",
    "fraude","golpe","rug pull","ponzi","exploit","hack","proibi√ß√£o","repress√£o","rekt","ngmi","m√£os de papel"
  ],
  it: [
    "orso","ribassista","vendere","dump","crollo","caduta","collasso","capitolazione","liquidazione",
    "resistenza","sopravvalutato","debole","trend ribassista","rosso","paura","negativo","panico",
    "frode","truffa","rug pull","ponzi","exploit","hackeraggio","divieto","repressione","rekt","ngmi","mani di carta"
  ],
  nl: [
    "beer","bearish","verkopen","dump","crash","inzinking","instorting","capitulatie","liquidatie",
    "weerstand","overgewaardeerd","zwak","neerwaartse trend","rood","angst","negatief","paniek",
    "fraude","oplichterij","rug pull","ponzi","exploit","hack","verbod","repressie","rekt","ngmi","papieren handen"
  ],
  tr: [
    "ayƒ±","ayƒ± piyasasƒ±","sat","dump","√ß√∂k√º≈ü","d√º≈ü√º≈ü","√ß√∂kme","kapit√ºlasyon","likidasyon",
    "diren√ß","a≈üƒ±rƒ± deƒüerli","zayƒ±f","d√º≈ü√º≈ü trendi","kƒ±rmƒ±zƒ±","korku","negatif","panik",
    "dolandƒ±rƒ±cƒ±lƒ±k","sahtekarlƒ±k","rug pull","ponzi","exploit","hack","yasak","baskƒ±","rekt","ngmi","kaƒüƒ±t eller"
  ],
  ru: [
    "–º–µ–¥–≤–µ–¥—å","–º–µ–¥–≤–µ–∂–∏–π","–ø—Ä–æ–¥–∞–≤–∞—Ç—å","–¥–∞–º–ø","–∫—Ä–∞—Ö","–æ–±–≤–∞–ª","–∫–æ–ª–ª–∞–ø—Å","–∫–∞–ø–∏—Ç—É–ª—è—Ü–∏—è","–ª–∏–∫–≤–∏–¥–∞—Ü–∏—è",
    "—Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ","–ø–µ—Ä–µ–æ—Ü–µ–Ω—ë–Ω–Ω—ã–π","—Å–ª–∞–±—ã–π","–Ω–∏—Å—Ö–æ–¥—è—â–∏–π —Ç—Ä–µ–Ω–¥","–∫—Ä–∞—Å–Ω—ã–π","—Å—Ç—Ä–∞—Ö","–Ω–µ–≥–∞—Ç–∏–≤","–ø–∞–Ω–∏–∫–∞",
    "–º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–æ","—Å–∫–∞–º","rug pull","–ø–æ–Ω–∑–∏","—ç–∫—Å–ø–ª–æ–π—Ç","–≤–∑–ª–æ–º","–∑–∞–ø—Ä–µ—Ç","—Ä–µ–ø—Ä–µ—Å—Å–∏–∏","rekt","ngmi","–±—É–º–∞–∂–Ω—ã–µ —Ä—É–∫–∏"
  ],
  slang: [
    "fud","ngmi","rekt","paper hands","üßª","üìâ","üü•","üîª","‚ùå","üò±","üò≠","üíÄ","‚ö†Ô∏è","üêª"
  ]
};

/* 2) Negators (flip nearby sentiment) */
const NEGATORS = {
  en: ["not","no","never","without","isn't","aren't","wasn't","weren't","don't","doesn't","didn't","won't","can't","cannot"],
  sv: ["inte","ej","aldrig","utan","inget","ingen","inga","utan att"],
  no: ["ikke","aldri","uten","ingen","ingenting"],
  da: ["ikke","aldrig","uden","ingen","intet"],
  fi: ["ei","ilman","ikin√§","koskaan","mik√§√§n ei"],
  de: ["nicht","nie","ohne","kein","keine","keinen","keinem","keiner"],
  fr: ["ne","pas","jamais","sans","aucun","aucune"],
  es: ["no","nunca","jam√°s","sin","ning√∫n","ninguna"],
  pt: ["n√£o","nunca","sem","nenhum","nenhuma"],
  it: ["non","mai","senza","nessuno","nessuna"],
  nl: ["niet","nooit","zonder","geen","geenszins"],
  tr: ["deƒüil","asla","hi√ß","olmadan"],
  ru: ["–Ω–µ","–Ω–µ—Ç","–Ω–∏–∫–æ–≥–¥–∞","–±–µ–∑"]
};

/* 3) Normalization helpers */
function norm(s){
  if(!s) return "";
  return s.toLowerCase()
          .normalize("NFD").replace(/[\u0300-\u036f]/g,"") // strip accents
          .replace(/\s+/g," ").trim();
}
function tokenize(s){
  // keep $ and # tokens; split on non-letter/number/$_ and keep cyrillic letters
  return norm(s).split(/[^0-9a-z_$#\u0400-\u04FF]+/i).filter(Boolean);
}

/* 4) Build fast lookup sets */
const POS_SET = new Set(), POS_PHRASES = new Set();
const NEG_SET = new Set(), NEG_PHRASES = new Set();
(function build(){
  const add = (obj, SET, PHRASES)=>{
    Object.values(obj).flat().forEach(t=>{
      const x = norm(t);
      if(x.includes(" ")) PHRASES.add(x); else SET.add(x);
    });
  };
  add(LEX_POS, POS_SET, POS_PHRASES);
  add(LEX_NEG, NEG_SET, NEG_PHRASES);
})();

/* 5) Negation lookup (flatten) */
const NEGATOR_SET = new Set(Object.values(NEGATORS).flat().map(norm));

/* 6) Scorer: emoji/slang + phrases + single words + multi-lang negation */
function sentimentScore(text){
  if(!text) return 0;

  const original = text;
  const tNorm = norm(original);
  const toks = tokenize(original);

  let score = 0;

  // Emojis/phrases: scan by substring (phrases) and raw inc (emojis)
  POS_PHRASES.forEach(p => { if(tNorm.includes(p)) score += 1; });
  NEG_PHRASES.forEach(p => { if(tNorm.includes(p)) score -= 1; });

  // Single-word hits with a small back-window for negators (3 tokens)
  for(let i=0;i<toks.length;i++){
    const w = toks[i];
    let delta = 0;
    if (POS_SET.has(w)) delta = 1;
    else if (NEG_SET.has(w)) delta = -1;

    if (delta !== 0){
      // check preceding 3 tokens for a negator (any language)
      const wStart = Math.max(0, i-3);
      const prev = toks.slice(wStart, i);
      if (prev.some(p => NEGATOR_SET.has(p))) delta *= -1;

      // tiny emphasis if "very" (and equivalents)
      if (prev.includes("very") || prev.includes("v√§ldigt") || prev.includes("meget") ||
          prev.includes("sehr") || prev.includes("tr√®s") || prev.includes("muy") ||
          prev.includes("muito") || prev.includes("molto")) {
        delta *= 1.2;
      }
      score += delta;
    }
  }

  // treat tiny values as neutral to reduce noise
  return Math.abs(score) < 0.5 ? 0 : score;
}

const MAP_CG_TO_BINANCE = { bitcoin: "BTCUSDT", ethereum: "ETHUSDT" };

/* ==================== Helpers ==================== */
function getWorker(){ return (localStorage.getItem("workerEndpoint") || "").trim(); }
function setWorker(url){
  if(!/^https?:\/\//i.test(url)) throw new Error("Worker URL must start with http(s)://");
  localStorage.setItem("workerEndpoint", url.replace(/\/+$/,""));
}
function setStatus(msg, spinning=false){
  const el = document.getElementById('status');
  el.innerHTML = spinning ? `<span class="spinner"></span> ${msg}` : msg;
}
function utcDateStr(tsSeconds){
  const d = new Date(tsSeconds*1000);
  return d.toISOString().slice(0,10);
}
function row(html){ const tr=document.createElement('tr'); tr.innerHTML=html; return tr; }
const delay = (ms)=> new Promise(r=>setTimeout(r, ms));
function fmtUSD(n){
  if(n==null || !isFinite(n)) return "‚Äî";
  return `$${Number(n).toLocaleString(undefined,{maximumFractionDigits:2})}`;
}

/* ==================== Fetch helpers (Worker ‚Üí direct fallback) ==================== */
async function fetchJSONSmart(targetUrl){
  const worker = getWorker();
  const tryDirect = async ()=>{
    const r = await fetch(targetUrl, { headers:{ "Accept":"application/json" } });
    if(!r.ok) throw new Error(`Direct HTTP ${r.status} for ${targetUrl}`);
    return await r.json();
  };
  if(worker){
    try{
      const proxied = `${worker}/?url=${encodeURIComponent(targetUrl)}`;
      const r = await fetch(proxied, { headers:{ "Accept":"application/json" } });
      if(!r.ok) throw new Error(`Worker HTTP ${r.status} for ${targetUrl}`);
      return await r.json();
    }catch(e){
      console.warn("Worker JSON fetch failed, trying direct:", e);
      return await tryDirect();
    }
  }
  return await tryDirect();
}
async function fetchTextSmart(targetUrl){
  const worker = getWorker();
  const tryDirect = async ()=>{
    const r = await fetch(targetUrl);
    if(!r.ok) throw new Error(`Direct HTTP ${r.status} for ${targetUrl}`);
    return await r.text();
  };
  if(worker){
    try{
      const proxied = `${worker}/?url=${encodeURIComponent(targetUrl)}`;
      const r = await fetch(proxied);
      if(!r.ok) throw new Error(`Worker HTTP ${r.status} for ${targetUrl}`);
      return await r.text();
    }catch(e){
      console.warn("Worker TEXT fetch failed, trying direct:", e);
      return await tryDirect();
    }
  }
  return await tryDirect();
}

/* ==================== Reddit (/new.json) ==================== */
async function fetchSubNew(sub, after=null){
  const url = new URL(`https://www.reddit.com/r/${sub}/new.json`);
  url.searchParams.set('limit', REDDIT_PAGE_LIMIT);
  if(after) url.searchParams.set('after', after);
  return await fetchJSONSmart(url.toString());
}

async function fetchRedditAcross(sub, days, titlesOnly){
  const cutoff = Date.now()/1000 - days*86400;
  let after = null, all = [], pages = 0;
  while(pages < REDDIT_MAX_PAGES){
    const data = await fetchSubNew(sub, after);
    const children = data?.data?.children || [];
    if(children.length === 0) break;

    const posts = children.map(c => c.data).map(p => ({
      id: p.name,
      title: p.title || "",
      selftext: titlesOnly ? "" : (p.selftext || ""),
      created_utc: p.created_utc || 0
    }));

    all.push(...posts.filter(p => p.created_utc >= cutoff));
    after = data?.data?.after || null;
    pages++;

    const lastTs = posts[posts.length-1]?.created_utc || 0;
    if(!after || lastTs < cutoff) break;
    await delay(220);
  }
  return all;
}

/* ==================== RSS (no API key) ==================== */
function parseRssItems(xmlText){
  const doc = new DOMParser().parseFromString(xmlText, "text/xml");
  let items = Array.from(doc.querySelectorAll("item"));
  if(items.length === 0){ items = Array.from(doc.querySelectorAll("entry")); }
  return items.map(el => {
    const title = (el.querySelector("title")?.textContent || "").trim();
    const desc = (el.querySelector("description, summary, content")?.textContent || "").trim();
    const pub = (el.querySelector("pubDate, updated, published")?.textContent || "").trim();
    const ts = pub ? Math.floor(Date.parse(pub)/1000) : Math.floor(Date.now()/1000);
    return { title, desc, created_utc: isFinite(ts) ? ts : Math.floor(Date.now()/1000) };
  });
}

async function fetchAllRss(days){
  const cutoff = Date.now()/1000 - days*86400;
  const out = [];
  for(const url of RSS_SOURCES){
    try{
      const text = await fetchTextSmart(url);
      const items = parseRssItems(text);
      for(const it of items){
        if(it.created_utc >= cutoff){
          out.push({ title: it.title, selftext: it.desc, created_utc: it.created_utc });
        }
      }
      await delay(200);
    }catch(e){
      console.warn("RSS failed", url, e);
    }
  }
  return out;
}

/* ==================== Prices (CG ‚Üí Binance; Worker ‚Üí direct) ==================== */
async function fetchCurrentPrices(){
  window.__currentPrices = window.__currentPrices || {};
  // Try CoinGecko
  try{
    const url = "https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum&vs_currencies=usd";
    const data = await fetchJSONSmart(url);
    const btc = data?.bitcoin?.usd ?? null;
    const eth = data?.ethereum?.usd ?? null;
    if(btc!=null){ document.getElementById("btcPrice").textContent = fmtUSD(btc); window.__currentPrices.btc = Number(btc); }
    if(eth!=null){ document.getElementById("ethPrice").textContent = fmtUSD(eth); window.__currentPrices.eth = Number(eth); }
    if(btc!=null && eth!=null) return;
  }catch(e){
    console.warn("CoinGecko current price failed, will try Binance", e);
  }
  // Binance fallback
  try{
    const url = new URL("https://api.binance.com/api/v3/ticker/price");
    url.searchParams.set("symbols", JSON.stringify(["BTCUSDT","ETHUSDT"]));
    const data = await fetchJSONSmart(url.toString());
    const map = {};
    (Array.isArray(data)?data:[data]).forEach(d => map[d.symbol]=Number(d.price));
    if(map.BTCUSDT!=null){ document.getElementById("btcPrice").textContent = fmtUSD(map.BTCUSDT); window.__currentPrices.btc = map.BTCUSDT; }
    if(map.ETHUSDT!=null){ document.getElementById("ethPrice").textContent = fmtUSD(map.ETHUSDT); window.__currentPrices.eth = map.ETHUSDT; }
  }catch(e){
    console.warn("Binance current price failed", e);
  }
}

async function fetchHistoricPrices(symbol, days){
  // CoinGecko
  try{
    const url = `https://api.coingecko.com/api/v3/coins/${symbol}/market_chart?vs_currency=usd&days=${days+2}&interval=daily`;
    const data = await fetchJSONSmart(url);
    const out = {};
    for(const [ts, price] of (data?.prices || [])){
      const d = new Date(ts);
      const dateStr = d.toISOString().slice(0,10);
      out[dateStr] = Number(price);
    }
    if(Object.keys(out).length) return out;
  }catch(e){
    console.warn(`CoinGecko historic (${symbol}) failed, will try Binance`, e);
  }
  // Binance fallback (klines)
  try{
    const binanceSymbol = MAP_CG_TO_BINANCE[symbol];
    const url = new URL("https://api.binance.com/api/v3/klines");
    url.searchParams.set("symbol", binanceSymbol);
    url.searchParams.set("interval", "1d");
    url.searchParams.set("limit", String(days+2));
    const data = await fetchJSONSmart(url.toString());
    const out = {};
    for(const k of data){
      const openTime = k[0];
      const closePrice = Number(k[4]);
      const dateStr = new Date(openTime).toISOString().slice(0,10);
      out[dateStr] = closePrice;
    }
    return out;
  }catch(e){
    console.warn(`Binance historic (${symbol}) failed`, e);
    return {};
  }
}

/* Inject today's live quote if daily candle missing; find nearest previous priced date */
function injectTodayPrice(prices, symbolKey){
  const todayStr = new Date().toISOString().slice(0,10);
  const cur = window.__currentPrices?.[symbolKey];
  if (cur!=null && prices[todayStr]==null) prices[todayStr] = Number(cur);
  return prices;
}
function prevDateWithPrice(prices, dates, startIndex){
  for(let j=startIndex+1; j<dates.length; j++){
    const dj = dates[j];
    if(prices[dj] != null) return dj;
  }
  return null;
}

/* ==================== Aggregation & Table Fill ==================== */
function aggregateByDateForAsset(posts, which){
  const byDate = {};
  const kw = which==='btc' ? KEYWORDS.btc : KEYWORDS.eth;
  for(const p of posts){
    const text = `${p.title} ${p.selftext || ""}`.trim();
    if(!kw.test(text)) continue;
    const score = sentimentScore(text);
    const d = utcDateStr(p.created_utc);
    if(!byDate[d]) byDate[d] = {pos:0, neg:0};
    if(score > 0) byDate[d].pos++;
    else if(score < 0) byDate[d].neg++;
  }
  return byDate;
}

function fillTable(tbody, byDate, prices){
  tbody.innerHTML = "";
  const dates = Object.keys(byDate).sort().reverse(); // newest first
  for(let i=0; i<dates.length; i++){
    const d = dates[i];
    const {pos, neg} = byDate[d];

    const priceVal = prices ? prices[d] : null;
    const priceText = fmtUSD(priceVal);

    let changeText = "-";
    if (prices && priceVal != null) {
      const prevD = prevDateWithPrice(prices, dates, i);
      const prevVal = prevD ? prices[prevD] : null;
      if (prevVal != null && prevVal !== 0){
        const change = ((priceVal - prevVal) / prevVal) * 100;
        const color = change > 0 ? "var(--good)" : change < 0 ? "var(--bad)" : "var(--muted)";
        const sign  = change > 0 ? "+" : (change < 0 ? "" : "");
        changeText = `<span style="color:${color}">${sign}${change.toFixed(2)}%</span>`;
      }
    }

    tbody.appendChild(row(
      `<td>${d}</td>`+
      `<td class="num good">${pos||0}</td>`+
      `<td class="num bad">${neg||0}</td>`+
      `<td class="num">${priceText}</td>`+
      `<td class="num">${changeText}</td>`
    ));
  }
}

/* ==================== UI wiring ==================== */
function coverage(prices, dates){
  let hit=0; for(const d of dates){ if(prices[d]!=null) hit++; }
  return `${hit}/${dates.length}`;
}

async function run(){
  const days = Math.max(1, Math.min(30, Number(document.getElementById('days').value || 7)));
  const titlesOnly = document.getElementById('titlesOnly').checked;
  const includeCrypto = document.getElementById('includeCryptoSub').checked;
  const includeNews = document.getElementById('includeNews').checked;

  document.getElementById('srcExtra').textContent = includeCrypto ? ", r/CryptoCurrency" : "";
  document.getElementById('newsTag').style.display = includeNews ? "inline-block" : "none";
  setStatus(`Fetching prices & content for last ${days} day(s)‚Ä¶`, true);

  try{
    await fetchCurrentPrices();

    let posts = [];
    for(const s of SUBS_CORE){
      const got = await fetchRedditAcross(s, days, titlesOnly);
      posts.push(...got);
    }
    if(includeCrypto){
      const gotMix = await fetchRedditAcross(SUB_CRYPTOCURRENCY, days, titlesOnly);
      posts.push(...gotMix);
    }
    if(includeNews){
      const rssItems = await fetchAllRss(days);
      posts.push(...rssItems);
    }

    const btcByDate = aggregateByDateForAsset(posts, 'btc');
    const ethByDate = aggregateByDateForAsset(posts, 'eth');

    const btcPricesRaw = await fetchHistoricPrices("bitcoin", days);
    await delay(120);
    const ethPricesRaw = await fetchHistoricPrices("ethereum", days);

    const btcPrices = injectTodayPrice(btcPricesRaw, 'btc');
    const ethPrices = injectTodayPrice(ethPricesRaw, 'eth');

    fillTable(document.querySelector('#btcTable tbody'), btcByDate, btcPrices);
    fillTable(document.querySelector('#ethTable tbody'), ethByDate, ethPrices);

    const totalPulled = posts.length;
    const totalBtcPos = Object.values(btcByDate).reduce((a,x)=>a+(x.pos||0),0);
    const totalBtcNeg = Object.values(btcByDate).reduce((a,x)=>a+(x.neg||0),0);
    const totalEthPos = Object.values(ethByDate).reduce((a,x)=>a+(x.pos||0),0);
    const totalEthNeg = Object.values(ethByDate).reduce((a,x)=>a+(x.neg||0),0);

    const btcDates = Object.keys(btcByDate).sort().reverse();
    const ethDates = Object.keys(ethByDate).sort().reverse();
    setStatus(
      `Pulled ${totalPulled} items. `+
      `BTC +${totalBtcPos}/-${totalBtcNeg} (prices ${coverage(btcPrices, btcDates)}) ‚Ä¢ `+
      `ETH +${totalEthPos}/-${totalEthNeg} (prices ${coverage(ethPrices, ethDates)})`
    );
  }catch(err){
    console.error(err);
    setStatus(`Error: ${err.message}. If Worker blocks, clear the Worker URL (uses direct fetch for prices).`);
  }
}

document.getElementById('runBtn').addEventListener('click', run);

// Worker URL persistence
const workerInput = document.getElementById('workerUrl');
workerInput.value = getWorker();
document.getElementById('saveWorker').addEventListener('click', ()=>{
  try{
    setWorker(workerInput.value || "");
    setStatus("Worker URL saved.", false);
  }catch(e){
    setStatus(e.message, false);
  }
});

// autorun if Worker already saved
if(getWorker()){ run(); }
</script>
</body>
</html>
