<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ACC Curve Handling + Lane Centering Simulator</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" />
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<style>
  :root{--bg:#0f1115;--panel:#151924;--ink:#e8eef8;--muted:#9bb0c8;--accent:#78a6ff;}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.35 system-ui,Segoe UI,Roboto,Arial}
  h2,h3{margin:.4rem 0}
  .grid{display:grid;grid-template-columns: 320px 1fr 520px;gap:10px;min-height:100vh;padding:10px}
  .card{background:var(--panel);border:1px solid #1f2535;border-radius:14px;box-shadow:0 10px 24px rgba(0,0,0,.25);padding:14px}
  label{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:8px 0}
  input[type="number"], input[type="range"]{width:130px;background:#0c101a;color:var(--ink);border:1px solid #2a3550;border-radius:8px;padding:6px 8px}
  .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:10px}
  .btns{display:flex;gap:8px;margin-top:8px}
  button{background:#1d2a44;color:var(--ink);border:1px solid #2c3a5f;border-radius:10px;padding:8px 12px;cursor:pointer}
  button:hover{filter:brightness(1.1)}
  .small{color:var(--muted);font-size:12px}
  canvas{width:100%;height:260px;background:#0c101a;border:1px solid #1f2535;border-radius:12px}
  #bird{height:calc(100vh - 40px);background:#0c101a}
  .stack{display:flex;flex-direction:column;gap:10px}
  .cols{display:flex;flex-direction:column;gap:10px}
  .kv{display:flex;justify-content:space-between;color:var(--muted);font-size:13px;margin-top:6px}
  .inline{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .help{font-size:12px;color:#b6c6de}
</style>
</head>
<body>
<div class="grid">
  <!-- LEFT: Controls -->
  <div class="card cols">
    <h2>Inputs</h2>
    <div class="help">Curve uses EU-style transition (clothoid: linear curvature ramp). ACC adapts speed for comfort in the curve, then returns to the set speed.</div>

    <label>
      <span>Curve radius R (m)</span>
      <input id="inR" type="number" min="20" step="5" value="150" />
    </label>
    <label>
      <span>Curve angle (deg)</span>
      <input id="inTheta" type="number" min="10" max="180" step="5" value="60" />
    </label>
    <label>
      <span>Set speed (km/h)</span>
      <input id="inVset" type="number" min="10" max="200" step="1" value="90" />
    </label>
    <label>
      <span>Longitudinal accel. magnitude (m/s²)</span>
      <input id="inAlong" type="number" min="0.2" max="4" step="0.1" value="1.5" />
    </label>
    <label title="Where the deceleration begins before the curve entry">
      <span>Distance Start (m)</span>
      <input id="inDstart" type="number" min="0" step="5" value="120" />
    </label>
    <label title="Where acceleration to set speed begins before the curve exit">
      <span>Distance End (m)</span>
      <input id="inDend" type="number" min="0" step="5" value="80" />
    </label>
    <label title="Comfort lateral acceleration cap for the curve speed adaptation">
      <span>Comfort lateral a<sub>y</sub> (m/s²)</span>
      <input id="inAyMax" type="number" min="0.5" max="4" step="0.1" value="2.0" />
    </label>

    <div class="kv"><span>Computed curve speed (km/h):</span><span id="kvCurve">–</span></div>
    <div class="kv"><span>Transition length (m):</span><span id="kvTrans">–</span></div>

    <div class="btns">
      <button id="btnStart">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset">Reset</button>
    </div>

    <h3>Status</h3>
    <div class="inline small">
      <div>t = <span id="statT">0.00</span> s</div>
      <div>| v = <span id="statV">0.0</span> km/h</div>
      <div>| a<sub>y</sub> = <span id="statAy">0.00</span> m/s²</div>
    </div>
    <div class="small">Lane width 3.75 m, wheelbase 2.7 m. Lateral controller: Stanley.</div>
  </div>

  <!-- MIDDLE: Plots -->
  <div class="card stack">
    <h2>Plots (vs distance)</h2>
    <canvas id="chartRadius"></canvas>
    <canvas id="chartSpeed"></canvas>
    <canvas id="chartAy"></canvas>
  </div>

  <!-- RIGHT: Birdview -->
  <div class="card">
    <h2>Birdview</h2>
    <canvas id="bird"></canvas>
  </div>
</div>

<script>
/* =========================
   Utility & Parameters
========================= */
const cfg = {
  laneWidth: 3.75,
  wheelbase: 2.7,
  dt: 0.02,
  dsPath: 0.5, // meters for path discretization
  jerkComfort: 0.5, // m/s^3 used to compute transition length (EU design vibe)
  stanley_ke: 3.0,
  stanley_kv: 1.0,
  steerMax: 35 * Math.PI/180,
  accelTol: 0.1, // km/h tolerance before applying accel
};

const els = {
  inR:       document.getElementById('inR'),
  inTheta:   document.getElementById('inTheta'),
  inVset:    document.getElementById('inVset'),
  inAlong:   document.getElementById('inAlong'),
  inDstart:  document.getElementById('inDstart'),
  inDend:    document.getElementById('inDend'),
  inAyMax:   document.getElementById('inAyMax'),
  kvCurve:   document.getElementById('kvCurve'),
  kvTrans:   document.getElementById('kvTrans'),
  btnStart:  document.getElementById('btnStart'),
  btnPause:  document.getElementById('btnPause'),
  btnReset:  document.getElementById('btnReset'),
  statT:     document.getElementById('statT'),
  statV:     document.getElementById('statV'),
  statAy:    document.getElementById('statAy'),
  bird:      document.getElementById('bird'),
  chartRadius: document.getElementById('chartRadius'),
  chartSpeed:  document.getElementById('chartSpeed'),
  chartAy:     document.getElementById('chartAy'),
};

let charts = {};
let world = null;     // precomputed path and curvature
let sim = null;       // simulation state
let running = false;
let rafId = null;

/* =========================
   Path Generation (Clothoid)
========================= */
// Build a centerline path: straight-in, transition-in, constant arc, transition-out, straight-out.
function buildPath(params){
  const {R, thetaRad, vSet, dStart, dEnd} = params;

  // Transition length from jerk comfort: Ls = v^3 / (J * R)
  const Ls = Math.max(10, Math.pow(vSet,3) / (cfg.jerkComfort * R)); // keep sane min length
  const Larc = R * thetaRad;

  // Enough straight before/after to visualize
  const Lpre = dStart + 60;
  const Lpost = dEnd + 120;

  const segments = [
    {type:'straight', L: Lpre, k0:0, k1:0},
    {type:'spiral_in', L: Ls,  k0:0, k1:  1/R},
    {type:'arc',       L: Larc,k0:1/R,k1:  1/R},
    {type:'spiral_out',L: Ls,  k0:1/R,k1:  0  },
    {type:'straight',  L: Lpost,k0:0,k1:0},
  ];

  // Curvature function along s
  function kappaAt(seg, u){ // u in [0,1] within the segment
    if(seg.type==='straight') return 0;
    if(seg.type==='arc') return seg.k0;
    // linear ramp
    return seg.k0 + (seg.k1 - seg.k0)*u;
  }

  let x=[0], y=[0], psi=[0], s=[0], kap=[0];
  let sCursor=0;
  let entryS= Lpre;              // start of spiral_in
  let exitS = Lpre + Ls + Larc + Ls; // end of spiral_out
  const ds = cfg.dsPath;

  // Integrate heading and position with small steps
  for(const seg of segments){
    const steps = Math.max(1, Math.round(seg.L/ds));
    for(let i=1;i<=steps;i++){
      const u = i/steps;
      const k = kappaAt(seg, u);
      const dsi = seg.L/steps;
      const psiPrev = psi[psi.length-1];
      const psiNew  = psiPrev + k * dsi;
      const xNew = x[x.length-1] + Math.cos(psiPrev) * dsi;
      const yNew = y[y.length-1] + Math.sin(psiPrev) * dsi;
      x.push(xNew); y.push(yNew); psi.push(psiNew);
      sCursor += dsi;
      s.push(sCursor);
      kap.push(k);
    }
  }

  // Find indices at entry/exit of the curve domain (start of spiral_in, end of spiral_out)
  const idxEntry = findIndexAtS(s, entryS);
  const idxExit  = findIndexAtS(s, exitS);

  // Lane polylines: offset by ± laneWidth/2
  const w = cfg.laneWidth/2;
  const left = [], right = [];
  for(let i=0;i<x.length;i++){
    const nx = -Math.sin(psi[i]), ny = Math.cos(psi[i]);
    left.push({x:x[i] + nx*w,  y:y[i] + ny*w});
    right.push({x:x[i] - nx*w, y:y[i] - ny*w});
  }

  return {
    x,y,psi,s,kap,
    idxEntry, idxExit,
    left,right,
    Ls, Larc, entryS, exitS
  };
}
function findIndexAtS(sArr, sVal){
  let lo=0, hi=sArr.length-1;
  while(lo<hi){
    const mid=(lo+hi)>>1;
    if(sArr[mid] < sVal) lo=mid+1; else hi=mid;
  }
  return lo;
}

/* =========================
   Simulation
========================= */
function initSim(params){
  world = buildPath(params);
  const startX = world.x[2], startY = world.y[2], startPsi = world.psi[2];

  sim = {
    t:0,
    x: startX,
    y: startY,
    psi: startPsi,
    v: params.vSet,
    sIdxNear: 0,
    sNear: world.s[0],
    vSet: params.vSet,
    aMag: params.aMag,
    dStart: params.dStart,
    dEnd: params.dEnd,
    ayMax: params.ayMax,
    R: params.R,
    sEntry: world.s[world.idxEntry],
    sExit: world.s[world.idxExit],
    // logs (x-axis = distance along reference centerline)
    logS: [],
    logR: [],
    logV: [],
    logAy: [],
  };

  // Prime logs with the full radius profile for plotting
  for(let i=0;i<world.s.length;i++){
    const k = Math.abs(world.kap[i]);
    const Rloc = (k<1e-6) ? Infinity : 1/k;
    sim.logS.push(world.s[i]);
    sim.logR.push( isFinite(Rloc) ? Rloc : 2000 ); // cap for plotting
    sim.logV.push(null); // will fill incrementally
    sim.logAy.push(null);
  }

  // Charts
  setupCharts(sim.logS, sim.logR);
  updateInfo(params, world);
  drawBird(); // initial
}

function speedPolicy(sim){
  // Compute location along reference
  const i = nearestPathIndex(sim.x, sim.y, sim.sIdxNear);
  sim.sIdxNear = i;
  sim.sNear = world.s[i];
  const k = Math.abs(world.kap[i]);
  const Rloc = (k<1e-6)? Infinity : 1/k;
  const vAllow = Math.min(sim.vSet, Math.sqrt(sim.ayMax * (isFinite(Rloc)? Rloc: 1e9)));
  const kmh = (mps)=> mps*3.6;

  // Decide target regime by position relative to entry/exit and user distances
  const decelStartS = sim.sEntry - sim.dStart;
  const accelStartS = sim.sExit - sim.dEnd;

  let target = sim.vSet;
  if(sim.sNear >= decelStartS && sim.sNear < accelStartS){
    // Within curve adaptation window
    target = vAllow;
  }else if(sim.sNear >= accelStartS){
    target = sim.vSet;
  }else{
    target = sim.vSet;
  }

  // Simple bang-bang accel towards target
  const tol = cfg.accelTol/3.6; // convert to m/s
  let a=0;
  if(sim.v > target + tol) a = -sim.aMag;
  else if(sim.v < target - tol) a = +sim.aMag;
  else a = 0;
  return {aCmd: a, vAllow, Rloc};
}

function step(params){
  if(!sim || !world) return;
  const dt = cfg.dt;

  // Longitudinal ACC
  const pol = speedPolicy(sim);
  sim.v = Math.max(0, sim.v + pol.aCmd*dt);

  // Lateral (Stanley) – follow centerline
  const i = sim.sIdxNear;
  const xr = world.x[i], yr = world.y[i], psir = world.psi[i];
  // cross-track error (signed) relative to reference normal
  const nx = -Math.sin(psir), ny = Math.cos(psir);
  const ex = sim.x - xr, ey = sim.y - yr;
  const e_ct = nx*ex + ny*ey; // + left, - right
  let psi_err = wrapAngle(psir - sim.psi);

  const delta = clamp( psi_err + Math.atan2(cfg.stanley_ke * e_ct, cfg.stanley_kv + sim.v), -cfg.steerMax, cfg.steerMax );
  const psiDot = sim.v / cfg.wheelbase * Math.tan(delta);

  // Integrate vehicle state
  sim.psi = wrapAngle(sim.psi + psiDot*dt);
  sim.x   = sim.x + sim.v*Math.cos(sim.psi)*dt;
  sim.y   = sim.y + sim.v*Math.sin(sim.psi)*dt;
  sim.t  += dt;

  // Log plots vs distance along reference
  const k = Math.abs(world.kap[i]);
  const Rloc = (k<1e-6)? Infinity : 1/k;
  const ay = k * sim.v * sim.v;
  sim.logV[i] = sim.v*3.6;
  sim.logAy[i] = ay;

  // UI status
  els.statT.textContent = sim.t.toFixed(2);
  els.statV.textContent = (sim.v*3.6).toFixed(1);
  els.statAy.textContent = ay.toFixed(2);

  // Charts – update sparsely for performance
  if(i % 3 === 0) refreshChartsChunk(i);

  // Draw birdview
  drawBird();
}

function nearestPathIndex(x,y, hintIdx){
  // Local window search around hint to speed up
  const w = 200;
  const start = Math.max(0, hintIdx - 50);
  const end   = Math.min(world.x.length-1, hintIdx + w);
  let bestIdx = start, bestD2 = 1e18;
  for(let i=start;i<=end;i++){
    const dx = x - world.x[i], dy = y - world.y[i];
    const d2 = dx*dx + dy*dy;
    if(d2 < bestD2){ bestD2 = d2; bestIdx = i; }
  }
  return bestIdx;
}

function wrapAngle(a){
  while(a> Math.PI) a -= 2*Math.PI;
  while(a<=-Math.PI) a += 2*Math.PI;
  return a;
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

/* =========================
   Charts
========================= */
function setupCharts(sArr, RArr){
  const commonOpts = {
    type:'line',
    data:{ labels: sArr, datasets: [] },
    options:{
      responsive:true,
      animation:false,
      interaction:{mode:'nearest', intersect:false},
      scales:{
        x:{ title:{text:'Distance s (m)', display:true}, ticks:{maxTicksLimit:10}},
      },
      plugins:{
        legend:{labels:{color:'#e8eef8'}},
      }
    }
  };

  const rCfg = JSON.parse(JSON.stringify(commonOpts));
  rCfg.data.datasets = [
    {label:'Radius R(s) [m]', data: RArr, pointRadius:0, borderWidth:2}
  ];
  rCfg.options.scales.y = { title:{text:'Radius (m)', display:true}, suggestedMin:0, suggestedMax:Math.max(...RArr.filter(x=>isFinite(x)).slice(0,500))||500 };
  charts.radius = new Chart(els.chartRadius, rCfg);

  const vCfg = JSON.parse(JSON.stringify(commonOpts));
  vCfg.data.datasets = [
    {label:'Speed [km/h]', data: sArr.map(()=>null), pointRadius:0, borderWidth:2}
  ];
  vCfg.options.scales.y = { title:{text:'Speed (km/h)', display:true}, suggestedMin:0, suggestedMax:140 };
  charts.speed = new Chart(els.chartSpeed, vCfg);

  const ayCfg = JSON.parse(JSON.stringify(commonOpts));
  ayCfg.data.datasets = [
    {label:'Lateral accel a_y [m/s²]', data: sArr.map(()=>null), pointRadius:0, borderWidth:2}
  ];
  ayCfg.options.scales.y = { title:{text:'a_y (m/s²)', display:true}, suggestedMin:0, suggestedMax:3.5 };
  charts.ay = new Chart(els.chartAy, ayCfg);
}

function refreshChartsChunk(i){
  if(!charts.radius) return;
  charts.speed.data.datasets[0].data[i] = sim.logV[i];
  charts.ay.data.datasets[0].data[i] = sim.logAy[i];

  // Small, fast partial updates
  charts.speed.update('none');
  charts.ay.update('none');
}

/* =========================
   Birdview Rendering
========================= */
function drawBird(){
  const c = els.bird;
  const dpr = window.devicePixelRatio || 1;
  const w = c.clientWidth, h = c.clientHeight;
  if(c.width !== Math.round(w*dpr) || c.height !== Math.round(h*dpr)){
    c.width = Math.round(w*dpr);
    c.height = Math.round(h*dpr);
  }
  const ctx = c.getContext('2d');
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,w,h);

  // Fit entire path into view with margins
  const bb = bbox(world.x, world.y);
  const margin = 15;
  const sx = (w - 2*margin) / (bb.maxx - bb.minx);
  const sy = (h - 2*margin) / (bb.maxy - bb.miny);
  const scale = Math.min(sx, sy);
  const ox = margin - bb.minx*scale;
  const oy = margin - bb.miny*scale;

  // Helpers
  const toScreen = (X,Y)=>({X: X*scale+ox, Y: Y*scale+oy});

  // Draw lane polygons
  ctx.lineWidth = 2;
  ctx.strokeStyle = '#33415e';
  ctx.beginPath();
  for(let i=0;i<world.left.length;i++){
    const p = toScreen(world.left[i].x, world.left[i].y);
    if(i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
  }
  ctx.stroke();

  ctx.beginPath();
  for(let i=0;i<world.right.length;i++){
    const p = toScreen(world.right[i].x, world.right[i].y);
    if(i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
  }
  ctx.stroke();

  // Centerline
  ctx.strokeStyle='#3f5a8f';
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  for(let i=0;i<world.x.length;i++){
    const p = toScreen(world.x[i], world.y[i]);
    if(i===0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // Mark decel/accel windows
  const iDecelStart = findIndexAtS(world.s, sim.sEntry - sim.dStart);
  const iAccelStart = findIndexAtS(world.s, sim.sExit  - sim.dEnd);

  ctx.fillStyle = 'rgba(120,166,255,0.10)';
  fillSBand(ctx, world, toScreen, iDecelStart, world.idxEntry);
  ctx.fillStyle = 'rgba(120,255,180,0.10)';
  fillSBand(ctx, world, toScreen, iAccelStart, world.idxExit);

  // Draw Vehicle
  drawCar(ctx, toScreen, sim.x, sim.y, sim.psi, scale);
}

function bbox(xs, ys){
  let minx=Infinity,miny=Infinity,maxx=-Infinity,maxy=-Infinity;
  for(let i=0;i<xs.length;i++){
    if(xs[i]<minx)minx=xs[i];
    if(xs[i]>maxx)maxx=xs[i];
    if(ys[i]<miny)miny=ys[i];
    if(ys[i]>maxy)maxy=ys[i];
  }
  return {minx,miny,maxx,maxy};
}
function fillSBand(ctx, world, toScreen, i0, i1){
  if(i1 <= i0) return;
  ctx.beginPath();
  for(let i=i0;i<=i1;i++){
    const p = toScreen(world.left[i].x, world.left[i].y);
    if(i===i0) ctx.moveTo(p.X,p.Y); else ctx.lineTo(p.X,p.Y);
  }
  for(let i=i1;i>=i0;i--){
    const p = toScreen(world.right[i].x, world.right[i].y);
    ctx.lineTo(p.X,p.Y);
  }
  ctx.closePath();
  ctx.fill();
}
function drawCar(ctx, toScreen, x, y, psi, scale){
  // Vehicle body as rounded rectangle
  const L = 4.6, W = 1.9;
  const p = toScreen(x,y);
  ctx.save();
  ctx.translate(p.X,p.Y);
  ctx.rotate(psi);
  ctx.fillStyle = '#89a9ff';
  const w = W*scale, l = L*scale;
  roundRect(ctx, -l*0.4, -w/2, l*0.8, w, 8); // body
  ctx.fill();
  // Nose
  ctx.fillStyle = '#cde';
  roundRect(ctx, l*0.1, -w/2, l*0.3, w, 8);
  ctx.fill();
  // Heading arrow
  ctx.beginPath();
  ctx.moveTo(l*0.45, 0);
  ctx.lineTo(l*0.25, -w*0.18);
  ctx.lineTo(l*0.25,  w*0.18);
  ctx.closePath();
  ctx.fillStyle='#e6f2ff';
  ctx.fill();
  ctx.restore();
}
function roundRect(ctx, x, y, w, h, r){
  if (w<2*r) r=w/2; if (h<2*r) r=h/2;
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y,   x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x,   y+h, r);
  ctx.arcTo(x,   y+h, x,   y,   r);
  ctx.arcTo(x,   y,   x+w, y,   r);
  ctx.closePath();
}

/* =========================
   UI Wiring & Runtime
========================= */
function readParams(){
  const R = parseFloat(els.inR.value);
  const thetaDeg = parseFloat(els.inTheta.value);
  const thetaRad = thetaDeg * Math.PI/180;
  const vSet = parseFloat(els.inVset.value)/3.6;
  const aMag = parseFloat(els.inAlong.value);
  const dStart = parseFloat(els.inDstart.value);
  const dEnd = parseFloat(els.inDend.value);
  const ayMax = parseFloat(els.inAyMax.value);

  return {R, thetaRad, vSet, aMag, dStart, dEnd, ayMax};
}

function updateInfo(params, world){
  const vCurve = Math.sqrt(params.ayMax * params.R) * 3.6;
  els.kvCurve.textContent = isFinite(vCurve) ? vCurve.toFixed(1) : '∞';
  els.kvTrans.textContent = world.Ls.toFixed(1);
}

function resetAll(){
  const params = readParams();
  initSim(params);
  // Fill charts initial radius, clear others
  charts.speed.data.datasets[0].data = sim.logV.slice();
  charts.ay.data.datasets[0].data = sim.logAy.slice();
  charts.radius.update('none');
  charts.speed.update('none');
  charts.ay.update('none');
  running = false;
  cancelAnimationFrame(rafId);
}
function loop(){
  if(!running) return;
  step();
  rafId = requestAnimationFrame(loop);
}

els.btnStart.onclick = ()=>{ if(!sim) resetAll(); running=true; cancelAnimationFrame(rafId); loop(); };
els.btnPause.onclick = ()=>{ running=false; cancelAnimationFrame(rafId); };
els.btnReset.onclick = ()=> resetAll();

// Rebuild path immediately on any input change (and keep paused)
['inR','inTheta','inVset','inAlong','inDstart','inDend','inAyMax'].forEach(id=>{
  els[id].addEventListener('change', ()=>{ resetAll(); });
});

window.addEventListener('resize', ()=> drawBird());

// First load
resetAll();

</script>
</body>
</html>
