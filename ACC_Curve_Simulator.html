<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ACC Curve Speed Adaption — Simulator (Time-Capped Axes)</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root { --bg:#0f1116; --panel:#171a22; --muted:#9aa4b2; --accent:#3fb950; --grid:#222737; }
    html,body { height:100%; margin:0; background:var(--bg); color:#e6edf3; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    .wrap { display:grid; grid-template-columns: 320px 640px 640px; gap:12px; padding:12px; }
    .card { background:var(--panel); border-radius:12px; box-shadow:0 1px 0 rgba(0,0,0,.2), inset 0 0 0 1px #1f2433; }
    .card h2 { font-size:16px; margin:0; padding:12px 12px 8px; border-bottom:1px solid var(--grid); color:#c8d1dc; }
    .card .body { padding:12px; }
    .grid2 {
  display:grid;
  grid-template-columns: 1fr;
  gap:8px;
}
    label { font-size:12px; color:#cbd5e1; display:flex; align-items:center; justify-content:space-between; gap:8px; }
    input[type="number"] { width:110px; padding:6px 8px; border-radius:8px; border:1px solid #2a2f45; background:#0e1220; color:#e6edf3; }
    .btns { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    button { background:#242a3d; color:#e6edf3; border:1px solid #2a2f45; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:600; }
    button.primary{ background:linear-gradient(180deg,#2fb171,#167f4c); border-color:#1c5; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    canvas.chart { display:block; background:#0d1020; border-radius:10px; box-shadow:inset 0 0 0 1px #1f2433; }
    .row { display:flex; flex-direction:column; gap:12px; }
    .hint { color:var(--muted); font-size:12px; line-height:1.4; }
    .kv { display:grid; grid-template-columns: 1fr auto; gap:6px; margin-top:8px; font-size:12px; color:#c8d1dc; }
    .kv div { padding:4px 6px; background:#0e1220; border:1px solid #2a2f45; border-radius:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT: Controls -->
    <section class="card" id="controls">
      <h2>Input Parameters</h2>
      <div class="body">
        <div class="grid2">
          <label>Curve radius R (m)
            <input id="inpR" type="number" min="20" step="5" value="150" />
          </label>
          <label>Curve angle (deg)
            <input id="inpPhi" type="number" min="15" max="180" step="5" value="50" />
          </label>
          <label>Set speed (km/h)
            <input id="inpVset" type="number" min="10" max="180" step="1" value="90" />
          </label>
          <label>Comfort lateral acceleration<sub>max</sub> (m/s²)
            <input id="inpAlat" type="number" min="0.5" max="4" step="0.1" value="2.0" />
          </label>
          <label>Longitudinal |a| (m/s²)
            <input id="inpAlong" type="number" min="0.1" max="4" step="0.1" value="1.5" />
          </label>
          <label>Distance Start (m)
            <input id="inpDstart" type="number" min="0" step="5" value="150" />
          </label>
          <label>Distance End (m)
            <input id="inpDend" type="number" min="0" step="5" value="100" />
          </label>
          <label>Lane width (m)
            <input id="inpLaneW" type="number" min="2.5" max="4.0" step="0.1" value="3.5" />
          </label>
        </div>
        <div class="btns">
          <button class="primary" id="btnApply">Apply</button>
          <button id="btnStart">Start</button>
          <button id="btnPause" disabled>Pause</button>
          <button id="btnReset">Reset</button>
        </div>
        <div class="kv">
          <div>Transition length L<sub>s</sub> (m)</div><div id="kvLs">–</div>
          <div>Curve entry @ s (m)</div><div id="kvSstart">–</div>
          <div>Curve exit @ s (m)</div><div id="kvSend">–</div>
          <div>v<sub>curve</sub> (km/h) from a<sub>lat</sub></div><div id="kvVcurve">–</div>
          <div>Estimated sim time (s)</div><div id="kvT">–</div>
        </div>
        <p class="hint">
          ACC adapts speed so lateral acceleration ≲ a<sub>max</sub>. It starts decelerating <b>Distance Start</b> before the transition-in, and starts accelerating back towards set speed <b>Distance End</b> before the transition-out ends. Lane Centering keeps the car on the centerline.
        <div>EU Roundabout design table</div>
        <table>
        <tr>
            <th>Speed</th>
            <th>Radius</th>
        </tr>
        <tr>
            <td>20</td>
            <td>16</td>
        </tr>
        <tr>
            <td>30</td>
            <td>36</td>
        </tr>
        <tr>
            <td>40</td>
            <td>64</td>
        </tr>
        <tr>
            <td>50</td>
            <td>100</td>
        </tr>
        <tr>
            <td>60</td>
            <td>144</td>
        </tr>
    </table>
        <div> </div>
        <div>EU Road curve design table</div>
        <table>
        <tr>
            <th>Speed</th>
            <th>Radius (urban/rural)</th>
        </tr>
        <tr>
            <td>50</td>
            <td>180/127</td>
        </tr>
        <tr>
            <td>60</td>
            <td>255/180</td>
        </tr>
        <tr>
            <td>70</td>
            <td>360/255</td>
        </tr>
        <tr>
            <td>85</td>
            <td>510/360</td>
        </tr>
        <tr>
            <td>100</td>
            <td>720/510</td>
        </tr>
        <tr>
            <td>120</td>
            <td>1020/720</td>
        </tr>
    </table>
        </p>
      </div>
    </section>

    <!-- MIDDLE: Charts -->
    <section class="card">
      <h2>Time Plots (fixed size, with history)</h2>
      <div class="body row">
        <canvas id="chSpeed" class="chart" width="620" height="140"></canvas>
        <canvas id="chLatA" class="chart" width="620" height="140"></canvas>
        <canvas id="chRadius" class="chart" width="620" height="140"></canvas>
      </div>
    </section>

    <!-- RIGHT: Birdview -->
    <section class="card">
      <h2>Birdview</h2>
      <div class="body">
        <canvas id="bird" width="620" height="460" class="chart"></canvas>
      </div>
    </section>
  </div>

<script>
(() => {
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const kPH2MS = 1000/3600; const MS2kPH = 3.6;

  let cfg = { R:150, phiDeg:90, vSet:90*kPH2MS, aLatMax:2.0, aLongMag:1.5, dStart:150, dEnd:100, laneW:3.5 };
  let track = null;
  let sim = { t:0, dt:0.02, running:false, s:0, v:0, tArr:[], vArr:[], aLatArr:[], RArr:[] };

  const E = id => document.getElementById(id);
  const inpR=E('inpR'), inpPhi=E('inpPhi'), inpVset=E('inpVset'), inpAlat=E('inpAlat'), inpAlong=E('inpAlong'), inpDstart=E('inpDstart'), inpDend=E('inpDend'), inpLaneW=E('inpLaneW');
  const kvLs=E('kvLs'), kvSstart=E('kvSstart'), kvSend=E('kvSend'), kvVcurve=E('kvVcurve'), kvT=E('kvT');
  const btnApply=E('btnApply'), btnStart=E('btnStart'), btnPause=E('btnPause'), btnReset=E('btnReset');
  const cvBird=E('bird');

  // Charts with linear time axis
  const makeChart = (canvas, label, yLabel) => new Chart(canvas.getContext('2d'), {
    type: 'line',
    data: { datasets: [{ label, data: [], borderWidth: 2, pointRadius: 0 }] },
    options: {
      animation: false, responsive: false, parsing:false, normalized:true,
      plugins: { legend: { labels: { color:'#c8d1dc' } }, tooltip:{enabled:true} },
      scales: {
        x: { type:'linear', min:0, max:10, title:{ display:true, text:'time (s)', color:'#9aa4b2' }, grid:{ color:'#223' }, ticks:{ color:'#c8d1dc' } },
        y: { title:{ display:true, text:yLabel, color:'#9aa4b2' }, grid:{ color:'#223' }, ticks:{ color:'#c8d1dc' } }
      }
    }
  });

  const chSpeed = makeChart(E('chSpeed'), 'Speed (km/h)', 'km/h');
  const chLatA  = makeChart(E('chLatA'), 'Lateral acceleration (m/s²)', 'm/s²');
  const chRadius= new Chart(E('chRadius').getContext('2d'), {
    type:'line',
    data:{ datasets:[{ label:'Curve radius R (m)', data:[], borderWidth:2, pointRadius:0 }] },
    options:{ animation:false, responsive:false, parsing:false, normalized:true, spanGaps:true,
      plugins:{ legend:{ labels:{ color:'#c8d1dc' } } },
      scales:{ x:{ type:'linear', min:0, max:10, title:{ display:true, text:'time (s)', color:'#9aa4b2' }, grid:{ color:'#223' }, ticks:{ color:'#c8d1dc' } },
              y:{ title:{ display:true, text:'m', color:'#9aa4b2' }, grid:{ color:'#223' }, ticks:{ color:'#c8d1dc' } } }
    }
  });

  function buildTrack() {
    const R = cfg.R; const phi = cfg.phiDeg * Math.PI/180;
    const Ls = clamp(0.3*R, 60, 200); const A = Math.sqrt(Ls * R);
    const Lpre  = Math.max(cfg.dStart + 80, 120);
    const Lpost = Math.max(cfg.dEnd   + 80, 120);
    const Larc = R * phi;
    const totalLen = Lpre + Ls + Larc + Ls + Lpost;

    const sStart = Lpre; const sEnterCircle = sStart + Ls; const sExitCircle = sEnterCircle + Larc; const sEnd = sExitCircle + Ls;

    const ds = 1.0; const n = Math.ceil(totalLen/ds)+1;
    const s = new Float64Array(n), x=new Float64Array(n), y=new Float64Array(n), psi=new Float64Array(n), kappa=new Float64Array(n), Rarr=new Float64Array(n);

    let heading=0, X=0, Y=0;
    for (let i=0;i<n;i++) {
      const si=i*ds; s[i]=si;
      let k; if (si < sStart) k=0; else if (si < sEnterCircle) { const st=si-sStart; k = st / (A*A); }
      else if (si < sExitCircle) { k = 1/R; }
      else if (si < sEnd) { const st=si - sExitCircle; k = (Ls - st)/(A*A); }
      else k=0;
      kappa[i]=k; Rarr[i]=(k>1e-8)? 1/k : Infinity;
      if (i>0) { heading += kappa[i-1]*ds; X += Math.cos(heading)*ds; Y += Math.sin(heading)*ds; }
      psi[i]=heading; x[i]=X; y[i]=Y;
    }
    const minX=Math.min(...x), maxX=Math.max(...x), minY=Math.min(...y), maxY=Math.max(...y);
    return { s,x,y,psi,kappa,R:Rarr,sStart,sEnd,Ls,totalLen,bbox:{minX,maxX,minY,maxY} };
  }

  function drawBird() {
    const ctx = cvBird.getContext('2d'); ctx.clearRect(0,0,cvBird.width,cvBird.height);
    if (!track) return;
    const {minX,maxX,minY,maxY}=track.bbox; const margin=20; const scale=Math.min((cvBird.width-2*margin)/(maxX-minX+1e-6),(cvBird.height-2*margin)/(maxY-minY+1e-6));
    const laneW = cfg.laneW;
    const toPix=(wx,wy)=>{const px=margin+(wx-minX)*scale; const py=cvBird.height-(margin+(wy-minY)*scale); return [px,py];};

// Visual exaggeration factor (change 2.0 to taste or make it a UI input)
const LANE_EXAG = 5.0;

const drawEdge = (sign) => {
  const ctx2 = ctx;
  ctx2.lineWidth = 2;
  ctx2.strokeStyle = '#44506b';
  ctx2.beginPath();

  for (let i = 0; i < track.s.length; i += 2) {
    const nx = -Math.sin(track.psi[i]);
    const ny =  Math.cos(track.psi[i]);
    const laneVis = cfg.laneW * LANE_EXAG;   // exaggerate only in drawing
    const wx = track.x[i] + sign * (laneVis / 2) * nx;
    const wy = track.y[i] + sign * (laneVis / 2) * ny;
    const [px, py] = toPix(wx, wy);
    if (i === 0) ctx2.moveTo(px, py); else ctx2.lineTo(px, py);
  }
  ctx2.stroke();
};

// draw both edges
drawEdge(+1);
drawEdge(-1);


    ctx.setLineDash([10,8]); ctx.strokeStyle='#6b7280'; ctx.beginPath(); for(let i=0;i<track.s.length;i+=2){ const [px,py]=toPix(track.x[i],track.y[i]); if(i===0)ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.stroke(); ctx.setLineDash([]);

    const decelS=Math.max(0,track.sStart-cfg.dStart); const accelS=Math.max(0,track.sEnd-cfg.dEnd);
    const mark=(sVal,label,color)=>{ const idx=Math.min(track.s.length-1,Math.max(0,Math.round(sVal))); const [px,py]=toPix(track.x[idx],track.y[idx]); ctx.fillStyle=color; ctx.beginPath(); ctx.arc(px,py,5,0,Math.PI*2); ctx.fill(); ctx.font='12px ui-sans-serif'; ctx.fillStyle='#cbd5e1'; ctx.textAlign='left'; ctx.fillText(label, px+8, py-8); };
    mark(decelS,'Decel start','#22c55e');
    mark(accelS,'Accel start','#f59e0b');
    mark(track.sStart,'Curve start','#60a5fa'); // start of transition-in
    mark(track.sEnd,'Curve end','#ef4444');     // end of transition-out

// draw car centered in right lane
const carLen = 4.6, carW = 1.9;
const sIdx = Math.min(track.s.length-1, Math.max(0, Math.round(sim.s)));
const heading = track.psi[sIdx];
const nx = -Math.sin(heading), ny = Math.cos(heading);

// use the same exaggerated width you used for drawing
const laneVis   = cfg.laneW * LANE_EXAG;

// RIGHT-HALF center of a single lane = quarter-lane shift to the right
const cx = track.x[sIdx] - (laneVis / 4) * nx;  // use + if it flips to the other side
const cy = track.y[sIdx] - (laneVis / 4) * ny;

    const [cpx,cpy]=toPix(cx,cy);
    ctx.save(); ctx.translate(cpx,cpy); ctx.rotate(-heading); ctx.fillStyle='#111827aa'; ctx.fillRect(-carLen*scale/2+2, -carW*scale/2+2, carLen*scale, carW*scale); ctx.fillStyle='#38bdf8'; ctx.fillRect(-carLen*scale/2, -carW*scale/2, carLen*scale, carW*scale); ctx.fillStyle='#0ea5e9'; ctx.fillRect(carLen*scale/2 - 6, -3, 6, 6); ctx.restore();
  }

  function stepSim() {
    if (!sim.running || !track) return;
    const i = Math.min(track.s.length-1, Math.max(0, Math.round(sim.s)));
    const Rhere = track.R[i];
    const vLimitInst = (Rhere===Infinity) ? Infinity : Math.sqrt(cfg.aLatMax * Rhere);
    const vSet = cfg.vSet; const vCurveDesign = Math.sqrt(cfg.aLatMax * cfg.R);
    const decelStartS = Math.max(0, track.sStart - cfg.dStart);
    const accelStartS = Math.max(0, track.sEnd   - cfg.dEnd);

    let vDes; if (sim.s < decelStartS) vDes = vSet; else if (sim.s < accelStartS) vDes = Math.min(vSet, vCurveDesign); else vDes = vSet;
    const vTarget = Math.min(vDes, vLimitInst);

    const tol=0.1; let aCmd=0; if (sim.v > vTarget + tol) aCmd = -cfg.aLongMag; else if (sim.v < vTarget - tol) aCmd = +cfg.aLongMag; else aCmd = 0;

    sim.v = Math.max(0, sim.v + aCmd * sim.dt);
    sim.s = Math.min(track.totalLen, sim.s + sim.v * sim.dt);
    sim.t += sim.dt;

    const aLat = (Rhere===Infinity) ? 0 : (sim.v*sim.v / Rhere);
    sim.tArr.push(sim.t); sim.vArr.push(sim.v * MS2kPH); sim.aLatArr.push(aLat); sim.RArr.push((Rhere===Infinity)? null : Rhere);

    appendChartPoints();
    drawBird();
    if (sim.s >= track.totalLen) { sim.running=false; btnStart.disabled=false; btnPause.disabled=true; }
  }

  function appendChartPoints() {
    const t = sim.tArr[sim.tArr.length-1]; const v = sim.vArr[sim.vArr.length-1]; const a = sim.aLatArr[sim.aLatArr.length-1]; const r = sim.RArr[sim.RArr.length-1];
    chSpeed.data.datasets[0].data.push({x:t,y:v}); chLatA.data.datasets[0].data.push({x:t,y:a}); chRadius.data.datasets[0].data.push({x:t,y:r});
    const Nmax=6000; [chSpeed, chLatA, chRadius].forEach(ch=>{ const ds=ch.data.datasets[0].data; if(ds.length>Nmax) ds.splice(0, ds.length-Nmax); ch.update('none'); });
  }

  function resetCharts() { [chSpeed, chLatA, chRadius].forEach(ch=>{ ch.data.datasets.forEach(ds=>ds.data.length=0); ch.update('none'); }); }

  // Estimate total simulation time using coarse forward integration
  function estimateTotalTime() {
    if (!track) return 10;
    let t=0, v=cfg.vSet, s=0; const dt=0.02; const vSet=cfg.vSet; const vCurveDesign=Math.sqrt(cfg.aLatMax * cfg.R);
    const decelStartS=Math.max(0,track.sStart-cfg.dStart); const accelStartS=Math.max(0,track.sEnd-cfg.dEnd);
    let guard=0; const guardMax=1e6;
    while (s < track.totalLen && guard++ < guardMax) {
      const i = Math.min(track.s.length-1, Math.max(0, Math.round(s)));
      const Rhere=track.R[i]; const vLimitInst=(Rhere===Infinity)? Infinity : Math.sqrt(cfg.aLatMax * Rhere);
      let vDes; if (s < decelStartS) vDes=vSet; else if (s < accelStartS) vDes=Math.min(vSet,vCurveDesign); else vDes=vSet;
      const vTarget=Math.min(vDes, vLimitInst);
      const tol=0.1; let aCmd=0; if (v > vTarget + tol) aCmd=-cfg.aLongMag; else if (v < vTarget - tol) aCmd=+cfg.aLongMag; else aCmd=0;
      v=Math.max(0, v + aCmd*dt); s+=v*dt; t+=dt; if (t>1e4) break;
    }
    return t;
  }

  function applyFromUI() {
    cfg.R = Number(inpR.value); cfg.phiDeg = Number(inpPhi.value); cfg.vSet = Number(inpVset.value)*kPH2MS; cfg.aLatMax = Number(inpAlat.value); cfg.aLongMag = Number(inpAlong.value); cfg.dStart = Number(inpDstart.value); cfg.dEnd = Number(inpDend.value); cfg.laneW = Number(inpLaneW.value);
    track = buildTrack();
    sim.s=0; sim.v=cfg.vSet; sim.t=0; sim.tArr.length=0; sim.vArr.length=0; sim.aLatArr.length=0; sim.RArr.length=0;

    const T = estimateTotalTime();
    kvT.textContent = Math.ceil(T).toString();
    [chSpeed, chLatA, chRadius].forEach(ch=>{ ch.options.scales.x.min=0; ch.options.scales.x.max=Math.max(5, Math.ceil(T)); ch.update('none'); });

    resetCharts(); drawBird();
    kvLs.textContent = track.Ls.toFixed(1); kvSstart.textContent = track.sStart.toFixed(1); kvSend.textContent = track.sEnd.toFixed(1);
    const vCurve = Math.sqrt(cfg.aLatMax * cfg.R) * MS2kPH; kvVcurve.textContent = vCurve.toFixed(1);
  }

  btnApply.onclick = applyFromUI; btnStart.onclick = ()=>{ sim.running=true; btnStart.disabled=true; btnPause.disabled=false; }; btnPause.onclick = ()=>{ sim.running=false; btnStart.disabled=false; btnPause.disabled=true; }; btnReset.onclick = ()=>{ sim.running=false; btnStart.disabled=false; btnPause.disabled=true; applyFromUI(); };

  function loop(){ stepSim(); requestAnimationFrame(loop); }
  applyFromUI(); loop();
})();
</script>
</body>
</html>
