<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ACC Curve Adaptation + LCS — Simulator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root{
      --bg:#0e1116; --panel:#151a21; --ink:#e9eef7; --muted:#95a3b4; --accent:#66d9ef;
      --good:#4ade80; --warn:#f59e0b; --bad:#ef4444;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    h1{font-size:18px;margin:0 0 12px}
    h2{font-size:14px;margin:16px 0 8px;color:var(--muted);font-weight:600}
    .wrap{display:grid;grid-template-columns:360px 1fr 520px;gap:12px;height:100%;padding:12px}
    .card{background:var(--panel);border:1px solid #212734;border-radius:16px;box-shadow:0 4px 12px rgba(0,0,0,.25);display:flex;flex-direction:column}
    .card header{padding:12px 14px;border-bottom:1px solid #212734}
    .card .body{padding:12px 14px;overflow:auto}
    label{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:8px 0;font-size:13px}
    input[type=number], input[type=range]{width:140px}
    input[type=range]{accent-color:var(--accent)}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button{background:#1f2632;border:1px solid #2a3240;color:var(--ink);padding:8px 12px;border-radius:10px;cursor:pointer}
    button.primary{background:#1f3550;border-color:#25405f}
    button:disabled{opacity:.5;cursor:not-allowed}
    .pill{display:inline-block;background:#1b2230;border:1px solid #2a3240;padding:6px 8px;border-radius:999px;font-size:12px;margin:2px 4px 0 0}
    .kv{display:grid;grid-template-columns:auto 1fr;gap:6px 10px;font-size:12px;color:var(--muted)}
    canvas{max-width:100%}
    #charts{display:grid;grid-template-rows:1fr 1fr 1fr;gap:10px;height:calc(100% - 52px);padding:10px}
    #bird{width:100%;height:100%;position:relative}
    #roadCanvas{width:100%;height:100%;display:block}
    details{border:1px dashed #2a3240;border-radius:12px;padding:6px 8px;margin-top:6px}
    details>summary{cursor:pointer;color:var(--muted)}
    .legend{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <!-- Column 1: Controls -->
    <section class="card" id="controls">
      <header>
        <h1>ACC Curve Adaptation + Lane Centering</h1>
      </header>
      <div class="body">
        <h2>Inputs</h2>
        <label>
          <span>Curve radius R (m)</span>
          <input id="inR" type="number" min="30" max="3000" step="10" value="200">
        </label>
        <label>
          <span>Set speed (km/h)</span>
          <input id="inVset" type="number" min="10" max="200" step="1" value="100">
        </label>
        <label>
          <span>Longitudinal accel limit |a<sub>x</sub>| (m/s²)</span>
          <input id="inAx" type="number" min="0.1" max="3.5" step="0.1" value="1.0">
        </label>
        <label>
          <span>Distance Start (m)</span>
          <input id="inDstart" type="number" min="10" max="1500" step="10" value="200">
        </label>
        <label>
          <span>Distance End (m)</span>
          <input id="inDend" type="number" min="10" max="1500" step="10" value="200">
        </label>

        <details>
          <summary>Advanced</summary>
          <label>
            <span>Comfort lateral a<sub>y,max</sub> (m/s²)</span>
            <input id="inAyMax" type="number" min="0.5" max="4" step="0.1" value="1.8">
          </label>
          <label>
            <span>Max lateral jerk j<sub>max</sub> (m/s³)</span>
            <input id="inJmax" type="number" min="0.1" max="2.0" step="0.1" value="0.5">
          </label>
          <label>
            <span>Circular arc length L<sub>c</sub> (m)</span>
            <input id="inLc" type="number" min="20" max="1000" step="10" value="150">
          </label>
          <label>
            <span>Lane width (m)</span>
            <input id="inLaneW" type="number" min="2.8" max="4.2" step="0.05" value="3.75">
          </label>
          <label>
            <span>Vehicle L×W (m×m)</span>
            <input id="inVehL" type="number" min="3.0" max="6.0" step="0.1" value="4.6">
            <input id="inVehW" type="number" min="1.5" max="2.5" step="0.05" value="1.9">
          </label>
        </details>

        <h2>Controls</h2>
        <div class="row">
          <button id="btnStart" class="primary">Start</button>
          <button id="btnPause" disabled>Pause</button>
          <button id="btnReset" disabled>Reset</button>
        </div>

        <h2>Computed</h2>
        <div class="kv" id="computedKV"></div>
        <div class="legend">Notes:
          <div class="pill">Transition = clothoid (Euler spiral)</div>
          <div class="pill">j limited</div>
          <div class="pill">ACC ramps by |a<sub>x</sub>|</div>
        </div>
      </div>
    </section>

    <!-- Column 2: Charts -->
    <section class="card">
      <header>
        <h1>Curvature → Radius, Speed & Lateral a<sub>y</sub> vs time</h1>
      </header>
      <div id="charts" class="body">
        <canvas id="chartR"></canvas>
        <canvas id="chartV"></canvas>
        <canvas id="chartAy"></canvas>
      </div>
    </section>

    <!-- Column 3: Birdview -->
    <section class="card">
      <header>
        <h1>Birdview</h1>
      </header>
      <div id="bird" class="body">
        <canvas id="roadCanvas"></canvas>
      </div>
    </section>
  </div>

<script>
(() => {
  // ------- State & helpers -------
  const $ = sel => document.querySelector(sel);
  const inR = $('#inR'), inVset = $('#inVset'), inAx = $('#inAx'), inDstart = $('#inDstart'), inDend = $('#inDend');
  const inAyMax = $('#inAyMax'), inJmax = $('#inJmax'), inLc = $('#inLc'), inLaneW = $('#inLaneW'), inVehL = $('#inVehL'), inVehW = $('#inVehW');
  const kv = $('#computedKV');
  const btnStart = $('#btnStart'), btnPause = $('#btnPause'), btnReset = $('#btnReset');

  const roadCanvas = document.getElementById('roadCanvas');
  const rctx = roadCanvas.getContext('2d');
  const DPR = Math.max(1, window.devicePixelRatio || 1);

  // Charts
  const chartR = new Chart(document.getElementById('chartR'), {
    type: 'line', data: { labels: [], datasets: [{ label: 'Curve radius R (m)', data: [], borderWidth: 2 }] },
    options: baseChartOptions('Radius (m) — gaps mean straight (R = ∞)')
  });
  const chartV = new Chart(document.getElementById('chartV'), {
    type: 'line', data: { labels: [], datasets: [
      { label: 'Speed (km/h)', data: [], borderWidth: 2 },
      { label: 'Ref speed (km/h)', data: [], borderDash: [6,4], borderWidth: 2 }
    ]}, options: baseChartOptions('Speed'))
  });
  const chartAy = new Chart(document.getElementById('chartAy'), {
    type: 'line', data: { labels: [], datasets: [
      { label: 'Lateral a_y (m/s²)', data: [], borderWidth: 2 },
      { label: 'Comfort limit (m/s²)', data: [], borderDash:[4,4], borderWidth: 2 }
    ]}, options: baseChartOptions('Lateral acceleration'))
  });

  function baseChartOptions(yTitle){
    return {
      responsive:true, maintainAspectRatio:false, animation:false,
      scales: {
        x: { title:{display:true, text:'Time (s)'}, ticks:{color:'#c8d2e0'} },
        y: { title:{display:true, text:yTitle}, ticks:{color:'#c8d2e0'}, grid:{color:'rgba(200,200,200,0.08)'} }
      },
      plugins: { legend:{labels:{color:'#e9eef7'}}, tooltip:{mode:'index', intersect:false} },
      elements: { point:{ radius:0 } }
    }
  }

  // Simulation model containers
  let sim = null; // holds current simulation state
  let raf = null; // animation frame handle

  // ------- Geometry: clothoid road with circular arc -------
  function buildRoad(params){
    const { R0, v_set, j_max, Lc, Dstart, Dend } = params;
    // Use design speed ~ min(v_set, v_arc) to size the clothoid
    const a_y_max = params.a_y_max;
    const v_arc = Math.min(v_set, Math.sqrt(a_y_max * R0));
    const v_design = v_arc; // during the curve
    const A2 = Math.pow(v_design,3)/j_max; // A^2
    const Ls = A2 / R0; // transition length from k=0 to k=1/R0

    const s_PC = 0; // start of transition-in
    const s_POC = Ls; // start of circular arc (Point of Curvature reached)
    const s_endCirc = Ls + Lc;
    const s_PT = Ls + Lc + Ls; // end of transition-out

    const Lpre = Math.max(Dstart + 50, 50);
    const Lpost = Math.max(Dend + 80, 80);
    const s_start = -Lpre;
    const s_end = s_PT + Lpost;

    const ds = 0.5; // spatial step (m)
    const N = Math.ceil((s_end - s_start)/ds) + 1;
    const s = new Array(N), k = new Array(N), psi = new Array(N), x = new Array(N), y = new Array(N), R = new Array(N);

    let heading = 0, X = 0, Y = 0;
    for(let i=0;i<N;i++){
      const si = s_start + i*ds;
      s[i] = si;
      let ki = 0;
      if(si < s_PC){
        ki = 0;
      } else if (si < s_POC){
        ki = (si - s_PC)/A2; // linear increase
      } else if (si < s_endCirc){
        ki = 1/R0; // constant curvature
      } else if (si < s_PT){
        ki = (s_PT - si)/A2; // linear decrease
      } else {
        ki = 0;
      }
      k[i] = ki;
      // integrate heading and position using simple forward Euler
      heading += ki * ds;
      heading = normalizeAngle(heading);
      X += Math.cos(heading) * ds;
      Y += Math.sin(heading) * ds;
      psi[i] = heading; x[i] = X; y[i] = Y;
      R[i] = (Math.abs(ki) > 1e-9) ? 1/ki : NaN; // radius; NaN shows as gap
    }

    // Lane boundaries (offset by +/- laneW/2)
    const laneW = params.laneW;
    const left = [], right = [];
    for(let i=0;i<N;i++){
      const nx = -Math.sin(psi[i]);
      const ny =  Math.cos(psi[i]);
      left.push({x: x[i] + nx*(laneW/2), y: y[i] + ny*(laneW/2)});
      right.push({x: x[i] - nx*(laneW/2), y: y[i] - ny*(laneW/2)});
    }

    return {s, k, psi, x, y, R, Ls, A2, v_arc, s_PC, s_POC, s_endCirc, s_PT, s_start, s_end, left, right};
  }

  function normalizeAngle(a){
    while(a> Math.PI) a-=2*Math.PI;
    while(a<-Math.PI) a+=2*Math.PI;
    return a;
  }

  // ------- Speed profile (reference) along s -------
  function buildSpeedRef(road, params){
    const { s, k } = road;
    const { v_set, a_y_max, Dstart, Dend } = params;
    const s_PT = road.s_PT;
    const v_arc = road.v_arc;

    const vref = new Array(s.length);
    for(let i=0;i<s.length;i++){
      const si = s[i];
      let v = v_set;
      if(si >= -Dstart && si < 0){
        const u = (si + Dstart)/Dstart; // 0→1
        v = v_set + (v_arc - v_set) * u; // linear ramp to v_arc at s=0
      } else if (si >= 0 && si < (s_PT - Dend)){
        v = v_arc;
      } else if (si >= (s_PT - Dend) && si < s_PT){
        const u = (si - (s_PT - Dend))/Dend; // 0→1
        v = v_arc + (v_set - v_arc) * u; // ramp back up
      } else if (si >= s_PT){
        v = v_set;
      }
      vref[i] = v;
    }
    return vref;
  }

  // ------- Simulation loop -------
  function startSimulation(){
    // Read inputs
    const R0 = +inR.value;
    const v_set = (+inVset.value) / 3.6; // m/s
    const a_x_lim = +inAx.value; // magnitude for both accel/decel
    const Dstart = +inDstart.value;
    const Dend   = +inDend.value;
    const a_y_max = +inAyMax.value;
    const j_max = +inJmax.value;
    const Lc = +inLc.value;
    const laneW = +inLaneW.value;
    const vehL = +inVehL.value, vehW = +inVehW.value;

    const params = { R0, v_set, a_x_lim, Dstart, Dend, a_y_max, j_max, Lc, laneW, vehL, vehW };

    const road = buildRoad(params);
    const vref = buildSpeedRef(road, params);

    // Display computed values
    const theta_deg = ( (road.s_endCirc - road.s_POC) / R0 ) * 180/Math.PI; // central angle
    kv.innerHTML = `
      <span>v<sub>arc</sub></span><span>${(road.v_arc*3.6).toFixed(1)} km/h</span>
      <span>Transition L<sub>s</sub></span><span>${road.Ls.toFixed(1)} m</span>
      <span>Spiral A</span><span>${Math.sqrt(road.A2).toFixed(2)}</span>
      <span>Arc central angle</span><span>${theta_deg.toFixed(1)}°</span>
      <span>Path length</span><span>${(road.s_end - road.s_start).toFixed(1)} m</span>
    `;

    // Reset charts
    [chartR, chartV, chartAy].forEach(ch => { ch.data.labels = []; ch.data.datasets.forEach(ds=>ds.data=[]); ch.update(); });

    // Prepare birdview canvas sizing
    resizeRoadCanvas();
    const view = computeView(road);

    // Initial state
    const idxStart = 0; // corresponds to s_start
    let i = idxStart; // spatial index
    let sNow = road.s[i];
    let x = road.x[i], y = road.y[i], psi = road.psi[i];
    let v = params.v_set; // start at set speed
    let t = 0;
    const dt = 0.02; // 50 Hz sim

    // Precompute ay comfort line for chart
    const ayLimLine = [];

    sim = { params, road, vref, i, sNow, x, y, psi, v, t, dt, view, ayLimLine, running:true };

    btnStart.disabled = true; btnPause.disabled = false; btnReset.disabled = false;

    // Begin anim
    cancelAnimationFrame(raf);
    loop();
  }

  function loop(){
    if(!sim || !sim.running){ raf = requestAnimationFrame(loop); return; }
    // step physics multiple substeps per frame for smoother motion if frame is slow
    const steps = 1; // could use time-based; fixed is fine here
    for(let n=0;n<steps;n++) stepOnce();

    // draw & update charts sparsely to save cycles
    drawBird();
    if((sim.t*50|0) % 2 === 0){ // ~25 Hz points
      pushChartPoints();
    }

    // stop condition
    if(sim.i >= sim.road.s.length-2){ sim.running=false; }

    raf = requestAnimationFrame(loop);
  }

  function stepOnce(){
    const { road, params, dt } = sim;
    // Current spatial index maps to nearest s
    const i = sim.i;
    const s = road.s[i];
    const k = road.k[i];

    // Reference speed at this index
    const vref = sim.vref[i];

    // Longitudinal control with accel limit
    const dv = vref - sim.v;
    let a = 0;
    if(Math.abs(dv) > 0.02){
      a = Math.sign(dv) * params.a_x_lim;
    }

    // Integrate speed
    let vNext = Math.max(0, sim.v + a*dt);

    // Spatial advance by average speed in this step
    const vMid = (sim.v + vNext)/2;
    const ds = vMid * dt;

    // Advance index by ds
    // Convert ds to index steps (precomputed grid spacing is ~0.5 m)
    const grid_ds = 0.5;
    let di = Math.max(1, Math.round(ds / grid_ds));

    // Guard end
    if(sim.i + di >= road.s.length) di = road.s.length - sim.i - 1;

    sim.i += di;
    sim.v = vNext;
    sim.sNow = road.s[sim.i];
    sim.x = road.x[sim.i];
    sim.y = road.y[sim.i];
    sim.psi = road.psi[sim.i];
    sim.t += dt;
  }

  // ------- Charts update -------
  function pushChartPoints(){
    const { road, i, v, t, params } = sim;
    const k = road.k[i];
    const R = (Math.abs(k) > 1e-9) ? 1/k : null;
    const ay = v*v * k; // since k >= 0, signless ay

    chartR.data.labels.push(t.toFixed(2));
    chartR.data.datasets[0].data.push(R);
    chartR.update('none');

    chartV.data.labels.push(t.toFixed(2));
    chartV.data.datasets[0].data.push(v*3.6);
    const vref_kmh = sim.vref[i]*3.6; chartV.data.datasets[1].data.push(vref_kmh);
    chartV.update('none');

    chartAy.data.labels.push(t.toFixed(2));
    chartAy.data.datasets[0].data.push(ay);
    chartAy.data.datasets[1].data.push(params.a_y_max);
    chartAy.update('none');
  }

  // ------- Birdview drawing -------
  let viewCache = null;
  function computeView(road){
    // Bounds from lane edges
    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(let p of road.left){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
    for(let p of road.right){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y); }
    const pad = 8; // meters
    minX-=pad; minY-=pad; maxX+=pad; maxY+=pad;
    return {minX,minY,maxX,maxY};
  }

  function resizeRoadCanvas(){
    const rect = roadCanvas.getBoundingClientRect();
    roadCanvas.width = Math.max(300, rect.width * DPR);
    roadCanvas.height = Math.max(300, rect.height * DPR);
    rctx.setTransform(DPR,0,0,DPR,0,0); // draw in CSS pixels
  }
  window.addEventListener('resize', resizeRoadCanvas);

  function worldToScreen(x,y, view){
    const w = roadCanvas.width / DPR, h = roadCanvas.height / DPR;
    const spanX = view.maxX - view.minX;
    const spanY = view.maxY - view.minY;
    const sx = w / spanX; const sy = h / spanY;
    const s = Math.min(sx, sy);
    const ox = (w - s*spanX)/2 - s*view.minX;
    const oy = (h - s*spanY)/2 + s*view.maxY; // invert Y for screen
    const X = ox + s*x;
    const Y = oy - s*y;
    return {X,Y, s};
  }

  function drawBird(){
    const { road, params, i } = sim;
    const view = sim.view;

    // Clear
    rctx.clearRect(0,0,roadCanvas.width/DPR, roadCanvas.height/DPR);

    // Draw lane polygons
    rctx.lineWidth = 2; rctx.lineJoin = 'round';

    // Centerline
    rctx.beginPath();
    for(let n=0;n<road.x.length;n+=2){
      const P = worldToScreen(road.x[n], road.y[n], view);
      if(n===0) rctx.moveTo(P.X,P.Y); else rctx.lineTo(P.X,P.Y);
    }
    rctx.strokeStyle = '#374151'; rctx.stroke();

    // Left/right edges
    rctx.beginPath();
    for(let n=0;n<road.left.length;n+=2){ const p = road.left[n]; const P = worldToScreen(p.x,p.y,view); if(n===0) rctx.moveTo(P.X,P.Y); else rctx.lineTo(P.X,P.Y); }
    rctx.strokeStyle = '#64748b'; rctx.stroke();
    rctx.beginPath();
    for(let n=0;n<road.right.length;n+=2){ const p = road.right[n]; const P = worldToScreen(p.x,p.y,view); if(n===0) rctx.moveTo(P.X,P.Y); else rctx.lineTo(P.X,P.Y); }
    rctx.strokeStyle = '#64748b'; rctx.stroke();

    // Markers: PC, POC, endCirc, PT and Dstart/Dend points along centerline
    const mark = (sVal, color, label) => {
      // find nearest index by s value
      const idx = Math.max(0, Math.min(road.s.length-1, Math.round((sVal - road.s[0]) / 0.5)));
      const P = worldToScreen(road.x[idx], road.y[idx], view);
      rctx.fillStyle = color; rctx.beginPath(); rctx.arc(P.X,P.Y,4,0,Math.PI*2); rctx.fill();
      rctx.fillStyle = '#cbd5e1'; rctx.font = '12px Inter'; rctx.fillText(label, P.X+6, P.Y-6);
    };

    mark(road.s_PC, '#60a5fa', 'PC');
    mark(road.s_POC, '#34d399', 'POC');
    mark(road.s_endCirc, '#34d399', 'End circ');
    mark(road.s_PT, '#60a5fa', 'PT');
    mark(-params.Dstart, '#fbbf24', 'Start decel');
    mark(road.s_PT - params.Dend, '#fbbf24', 'Start accel');

    // Draw vehicle as rectangle oriented at psi at current index
    const x = road.x[i], y = road.y[i], psi = road.psi[i];
    const vehL = params.vehL, vehW = params.vehW;
    const P = worldToScreen(x, y, view);
    const s = P.s;
    rctx.save();
    rctx.translate(P.X, P.Y);
    rctx.rotate(-psi); // minus because screen Y is inverted
    rctx.fillStyle = '#22d3ee';
    rctx.strokeStyle = '#0ea5b7';
    rctx.lineWidth = 2;
    rctx.beginPath();
    rctx.rect(-vehL*s/2, -vehW*s/2, vehL*s, vehW*s);
    rctx.fill(); rctx.stroke();
    rctx.restore();
  }

  // ------- Buttons -------
  btnStart.addEventListener('click', startSimulation);
  btnPause.addEventListener('click', () => {
    if(!sim) return;
    sim.running = !sim.running;
    btnPause.textContent = sim.running ? 'Pause' : 'Resume';
  });
  btnReset.addEventListener('click', () => {
    if(sim){ cancelAnimationFrame(raf); }
    sim = null; btnStart.disabled = false; btnPause.disabled = true; btnReset.disabled = true; btnPause.textContent = 'Pause';
    [chartR, chartV, chartAy].forEach(ch => { ch.data.labels = []; ch.data.datasets.forEach(ds=>ds.data=[]); ch.update(); });
    rctx.clearRect(0,0,roadCanvas.width,roadCanvas.height);
  });

  // ------- Kick -------
  resizeRoadCanvas();
})();
</script>
</body>
</html>
