<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ACC Curve Adaption & LKS — Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
  <style>
    :root { --bg:#0f1116; --panel:#171a22; --muted:#9aa4b2; --accent:#3fb950; --grid:#222737; }
    html,body { height:100%; margin:0; background:var(--bg); color:#e6edf3; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    .wrap { display:grid; grid-template-columns: 320px 640px 640px; gap:12px; padding:12px; }
    .card { background:var(--panel); border-radius:12px; box-shadow:0 1px 0 rgba(0,0,0,.2), inset 0 0 0 1px #1f2433; }
    .card h2 { font-size:16px; margin:0; padding:12px 12px 8px; border-bottom:1px solid var(--grid); color:#c8d1dc; }
    .card .body { padding:12px; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label { font-size:12px; color:#cbd5e1; display:flex; align-items:center; justify-content:space-between; gap:8px; }
    input[type="number"] { width:110px; padding:6px 8px; border-radius:8px; border:1px solid #2a2f45; background:#0e1220; color:#e6edf3; }
    .btns { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
    button { background:#242a3d; color:#e6edf3; border:1px solid #2a2f45; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:600; }
    button.primary{ background:linear-gradient(180deg,#2fb171,#167f4c); border-color:#1c5; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    canvas.chart { display:block; background:#0d1020; border-radius:10px; box-shadow:inset 0 0 0 1px #1f2433; }
    .row { display:flex; flex-direction:column; gap:12px; }
    .hint { color:var(--muted); font-size:12px; line-height:1.4; }
    .kv { display:grid; grid-template-columns: 1fr auto; gap:6px; margin-top:8px; font-size:12px; color:#c8d1dc; }
    .kv div { padding:4px 6px; background:#0e1220; border:1px solid #2a2f45; border-radius:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- LEFT: Controls -->
    <section class="card" id="controls">
      <h2>Parameters</h2>
      <div class="body">
        <div class="grid2">
          <label>Curve radius R (m)
            <input id="inpR" type="number" min="20" step="5" value="150" />
          </label>
          <label>Curve angle (deg)
            <input id="inpPhi" type="number" min="15" max="180" step="5" value="90" />
          </label>
          <label>Set speed (km/h)
            <input id="inpVset" type="number" min="10" max="180" step="1" value="90" />
          </label>
          <label>Comfort lat. a<sub>max</sub> (m/s²)
            <input id="inpAlat" type="number" min="0.5" max="4" step="0.1" value="2.0" />
          </label>
          <label>Longitudinal |a| (m/s²)
            <input id="inpAlong" type="number" min="0.1" max="4" step="0.1" value="1.5" />
          </label>
          <label>Distance Start (m)
            <input id="inpDstart" type="number" min="0" step="5" value="150" />
          </label>
          <label>Distance End (m)
            <input id="inpDend" type="number" min="0" step="5" value="100" />
          </label>
          <label>Lane width (m)
            <input id="inpLaneW" type="number" min="2.5" max="4.0" step="0.1" value="3.5" />
          </label>
        </div>
        <div class="btns">
          <button class="primary" id="btnApply">Apply</button>
          <button id="btnStart">Start</button>
          <button id="btnPause" disabled>Pause</button>
          <button id="btnReset">Reset</button>
        </div>
        <div class="kv">
          <div>Transition length L<sub>s</sub> (m)</div><div id="kvLs">–</div>
          <div>Curve entry @ s (m)</div><div id="kvSstart">–</div>
          <div>Curve exit @ s (m)</div><div id="kvSend">–</div>
          <div>v<sub>curve</sub> (km/h) from a<sub>lat</sub></div><div id="kvVcurve">–</div>
        </div>
        <p class="hint">
          ACC adapts speed so lateral acceleration ≲ a<sub>max</sub>. It starts decelerating <b>Distance Start</b> before the transition-in, and starts accelerating back towards set speed <b>Distance End</b> before the transition-out ends. Lane Centering keeps the car on the centerline.
        </p>
      </div>
    </section>

    <!-- MIDDLE: Charts -->
    <section class="card">
      <h2>Time Plots (fixed size, with history)</h2>
      <div class="body row">
        <canvas id="chSpeed" class="chart" width="620" height="140"></canvas>
        <canvas id="chLatA" class="chart" width="620" height="140"></canvas>
        <canvas id="chRadius" class="chart" width="620" height="140"></canvas>
      </div>
    </section>

    <!-- RIGHT: Birdview -->
    <section class="card">
      <h2>Birdview (curve + LKS)</h2>
      <div class="body">
        <canvas id="bird" width="620" height="460" class="chart"></canvas>
      </div>
    </section>
  </div>

<script>
(() => {
  // ------------------------
  // Helpers
  // ------------------------
  const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
  const kPH2MS = 1000/3600;
  const MS2kPH = 3.6;

  // ------------------------
  // State
  // ------------------------
  let cfg = {
    R: 150, // m
    phiDeg: 90, // deg total central angle of the curve
    vSet: 90 * kPH2MS, // m/s
    aLatMax: 2.0, // m/s^2 comfort
    aLongMag: 1.5, // m/s^2 absolute accel / decel
    dStart: 150, // m before curve start (transition-in begins)
    dEnd: 100, // m before curve end (transition-out ends)
    laneW: 3.5 // m
  };

  // Track precomputed geometry arrays
  let track = null; // {s:[], x:[], y:[], psi:[], kappa:[], R:[], sStart, sEnd, Ls, totalLen, bbox}

  // Simulation runtime
  let sim = {
    t: 0, dt: 0.02, running: false, s: 0, v: 0,
    tArr: [], vArr: [], aLatArr: [], RArr: []
  };

  // ------------------------
  // UI Elements
  // ------------------------
  const E = id => document.getElementById(id);
  const inpR=E('inpR'), inpPhi=E('inpPhi'), inpVset=E('inpVset'), inpAlat=E('inpAlat'), inpAlong=E('inpAlong'), inpDstart=E('inpDstart'), inpDend=E('inpDend'), inpLaneW=E('inpLaneW');
  const kvLs=E('kvLs'), kvSstart=E('kvSstart'), kvSend=E('kvSend'), kvVcurve=E('kvVcurve');
  const btnApply=E('btnApply'), btnStart=E('btnStart'), btnPause=E('btnPause'), btnReset=E('btnReset');
  const cvBird=E('bird');

  // ------------------------
  // Charts (fixed size via canvas attributes, no CSS scaling => crisp text)
  // ------------------------
  const makeChart = (canvas, label, yLabel) => new Chart(canvas.getContext('2d'), {
    type: 'line',
    data: { labels: [], datasets: [{ label, data: [], borderWidth: 2, pointRadius: 0 }] },
    options: {
      animation: false,
      responsive: false,
      plugins: {
        legend: { labels: { color:'#c8d1dc' } },
        tooltip: { enabled:true }
      },
      scales: {
        x: { title: { display: true, text: 'time (s)', color:'#9aa4b2' }, grid: { color:'#223' }, ticks:{ color:'#c8d1dc' } },
        y: { title: { display: true, text: yLabel, color:'#9aa4b2' }, grid: { color:'#223' }, ticks:{ color:'#c8d1dc' } }
      }
    }
  });

  const chSpeed = makeChart(E('chSpeed'), 'Speed (km/h)', 'km/h');
  const chLatA  = makeChart(E('chLatA'), 'Lateral acceleration (m/s²)', 'm/s²');
  const chRadius= new Chart(E('chRadius').getContext('2d'), {
    type: 'line',
    data: { labels: [], datasets: [
      { label:'Curve radius R (m)', data: [], borderWidth:2, pointRadius:0 },
    ]},
    options: {
      animation:false, responsive:false,
      plugins:{ legend:{ labels:{ color:'#c8d1dc' }}},
      spanGaps:true,
      scales:{ x:{ title:{ display:true, text:'time (s)', color:'#9aa4b2' }, grid:{ color:'#223' }, ticks:{ color:'#c8d1dc' } },
               y:{ title:{ display:true, text:'m', color:'#9aa4b2' }, grid:{ color:'#223' }, ticks:{ color:'#c8d1dc' } } }
    }
  });

  // ------------------------
  // Track generation with EU-style transition (Euler spiral / clothoid)
  // ------------------------
  function buildTrack() {
    const R = cfg.R; // design radius in constant-radius portion
    const phi = cfg.phiDeg * Math.PI/180; // total circular arc angle

    // Choose transition length Ls ~ 0.3 R, clamped to [60, 200] m (typical practical range)
    const Ls = clamp(0.3*R, 60, 200);
    const A = Math.sqrt(Ls * R); // clothoid parameter (kappa = s/A^2)

    // Pre/post straights to comfortably accommodate dStart/dEnd
    const Lpre  = Math.max(cfg.dStart + 80, 120);
    const Lpost = Math.max(cfg.dEnd   + 80, 120);

    const Larc = R * phi; // constant radius section length
    const totalLen = Lpre + Ls + Larc + Ls + Lpost;

    const sStart = Lpre;            // start of transition-in
    const sEnterCircle = sStart + Ls;
    const sExitCircle  = sEnterCircle + Larc;
    const sEnd   = sExitCircle + Ls; // end of transition-out

    const ds = 1.0; // spatial step (m)
    const n  = Math.ceil(totalLen/ds)+1;
    const s = new Float64Array(n);
    const x = new Float64Array(n);
    const y = new Float64Array(n);
    const psi = new Float64Array(n);
    const kappa = new Float64Array(n);
    const Rarr = new Float64Array(n);

    let heading = 0, X=0, Y=0;

    for (let i=0;i<n;i++) {
      const si = i*ds;
      s[i] = si;
      // curvature along s
      let k;
      if (si < sStart) { k = 0; }
      else if (si < sEnterCircle) { // transition-in
        const st = si - sStart; // 0..Ls
        k = st / (A*A);
      }
      else if (si < sExitCircle) { // constant radius
        k = 1/R;
      }
      else if (si < sEnd) { // transition-out
        const st = si - sExitCircle; // 0..Ls
        k = (Ls - st) / (A*A);
      }
      else { // after
        k = 0;
      }
      kappa[i] = k;
      Rarr[i] = (k>1e-8) ? 1/k : Infinity;

      // integrate heading & position (explicit Euler is fine at 1 m steps)
      if (i>0) {
        heading += kappa[i-1]*ds; // dpsi = k*ds
        X += Math.cos(heading)*ds;
        Y += Math.sin(heading)*ds;
      }
      psi[i] = heading;
      x[i]=X; y[i]=Y;
    }

    // normalize/translate so that straight-in runs along +X, already true; ensure min at (0,0)
    const minX = Math.min(...x), maxX = Math.max(...x), minY = Math.min(...y), maxY = Math.max(...y);

    return { s,x,y,psi,kappa,R:Rarr, sStart, sEnd, Ls, totalLen,
             bbox:{ minX, maxX, minY, maxY } };
  }

  // ------------------------
  // Birdview drawing
  // ------------------------
  function drawBird() {
    const ctx = cvBird.getContext('2d');
    ctx.clearRect(0,0,cvBird.width,cvBird.height);
    if (!track) return;

    const {minX,maxX,minY,maxY} = track.bbox;
    const margin = 20; // px
    const scale = Math.min((cvBird.width-2*margin)/(maxX-minX+1e-6), (cvBird.height-2*margin)/(maxY-minY+1e-6));

    function worldToPix(wx, wy) {
      const px = margin + (wx - minX)*scale;
      const py = cvBird.height - (margin + (wy - minY)*scale); // flip Y
      return [px, py];
    }

    const laneW = cfg.laneW;

    // draw lane edges
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#44506b';
    ctx.beginPath();
    for (let i=0;i<track.s.length;i+=2) {
      const nx = -Math.sin(track.psi[i]);
      const ny =  Math.cos(track.psi[i]);
      const wx = track.x[i] + (laneW/2)*nx;
      const wy = track.y[i] + (laneW/2)*ny;
      const [px,py] = worldToPix(wx,wy);
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();

    ctx.beginPath();
    for (let i=0;i<track.s.length;i+=2) {
      const nx = -Math.sin(track.psi[i]);
      const ny =  Math.cos(track.psi[i]);
      const wx = track.x[i] - (laneW/2)*nx;
      const wy = track.y[i] - (laneW/2)*ny;
      const [px,py] = worldToPix(wx,wy);
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();

    // dashed centerline
    ctx.setLineDash([10,8]);
    ctx.strokeStyle = '#6b7280';
    ctx.beginPath();
    for (let i=0;i<track.s.length;i+=2) {
      const [px,py] = worldToPix(track.x[i], track.y[i]);
      if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // draw decel/accel markers
    const decelS = Math.max(0, track.sStart - cfg.dStart);
    const accelS = Math.max(0, track.sEnd   - cfg.dEnd);
    ctx.fillStyle = '#22c55e';
    drawMarkerAtS(decelS, 'Decel start');
    ctx.fillStyle = '#f59e0b';
    drawMarkerAtS(accelS, 'Accel start');

    function drawMarkerAtS(sVal, label) {
      const idx = Math.min(track.s.length-1, Math.max(0, Math.round(sVal)));
      const [px,py] = worldToPix(track.x[idx], track.y[idx]);
      ctx.beginPath(); ctx.arc(px,py,5,0,Math.PI*2); ctx.fill();
      ctx.font = '12px ui-sans-serif'; ctx.fillStyle='#cbd5e1'; ctx.textAlign='left';
      ctx.fillText(label, px+8, py-8);
    }

    // draw car centered on lane (LKS)
    const carLen = 4.6, carW = 1.9;
    const sIdx = Math.min(track.s.length-1, Math.max(0, Math.round(sim.s)));
    const cx = track.x[sIdx], cy = track.y[sIdx], heading = track.psi[sIdx];

    // outer shadow
    const [cpx,cpy] = worldToPix(cx,cy);
    ctx.save();
    ctx.translate(cpx,cpy);
    ctx.rotate(-heading); // because canvas Y flipped earlier
    ctx.fillStyle = '#111827aa';
    ctx.fillRect(-carLen*scale/2+2, -carW*scale/2+2, carLen*scale, carW*scale);
    // body
    ctx.fillStyle = '#38bdf8';
    ctx.fillRect(-carLen*scale/2, -carW*scale/2, carLen*scale, carW*scale);
    // nose marker
    ctx.fillStyle = '#0ea5e9';
    ctx.fillRect(carLen*scale/2 - 6, -3, 6, 6);
    ctx.restore();
  }

  // ------------------------
  // Simulation logic (ACC with curve-speed adaption)
  // ------------------------
  function stepSim() {
    if (!sim.running || !track) return;

    const i = Math.min(track.s.length-1, Math.max(0, Math.round(sim.s)));
    const Rhere = track.R[i];
    const vLimitInst = (Rhere===Infinity) ? Infinity : Math.sqrt(cfg.aLatMax * Rhere);

    const vSet = cfg.vSet;
    const vCurveDesign = Math.sqrt(cfg.aLatMax * cfg.R); // based on design R

    const decelStartS = Math.max(0, track.sStart - cfg.dStart);
    const accelStartS = Math.max(0, track.sEnd   - cfg.dEnd);

    // Desired speed profile gate
    let vDes;
    if (sim.s < decelStartS) vDes = vSet;
    else if (sim.s < accelStartS) vDes = Math.min(vSet, vCurveDesign);
    else vDes = vSet;

    // Always respect instantaneous lateral comfort
    const vTarget = Math.min(vDes, vLimitInst);

    // Simple bang-bang towards vTarget with |a| limit
    const tol = 0.1; // m/s
    let aCmd = 0;
    if (sim.v > vTarget + tol) aCmd = -cfg.aLongMag;
    else if (sim.v < vTarget - tol) aCmd = +cfg.aLongMag;
    else aCmd = 0;

    // Integrate
    sim.v = Math.max(0, sim.v + aCmd * sim.dt);
    sim.s = Math.min(track.totalLen, sim.s + sim.v * sim.dt);
    sim.t += sim.dt;

    // Logs for charts
    const aLat = (Rhere===Infinity) ? 0 : (sim.v*sim.v / Rhere);
    sim.tArr.push(sim.t);
    sim.vArr.push(sim.v * MS2kPH);
    sim.aLatArr.push(aLat);
    sim.RArr.push((Rhere===Infinity) ? null : Rhere);

    // Update visuals
    appendChartPoints();
    drawBird();

    // stop at end
    if (sim.s >= track.totalLen) { sim.running=false; btnStart.disabled=false; btnPause.disabled=true; }
  }

  // ------------------------
  // Charts update (incremental)
  // ------------------------
  function appendChartPoints() {
    const t = sim.tArr[sim.tArr.length-1];
    chSpeed.data.labels.push(t.toFixed(1));
    chLatA.data.labels.push(t.toFixed(1));
    chRadius.data.labels.push(t.toFixed(1));

    chSpeed.data.datasets[0].data.push(sim.vArr[sim.vArr.length-1]);
    chLatA.data.datasets[0].data.push(sim.aLatArr[sim.aLatArr.length-1]);
    chRadius.data.datasets[0].data.push(sim.RArr[sim.RArr.length-1]);

    // keep last N points to bound memory
    const Nmax = 6000; // ~2 minutes at 50 Hz labels (we add each step)
    [chSpeed, chLatA, chRadius].forEach(ch => {
      if (ch.data.labels.length > Nmax) {
        ch.data.labels.shift();
        ch.data.datasets[0].data.shift();
      }
      ch.update('none');
    });
  }

  function resetCharts() {
    [chSpeed, chLatA, chRadius].forEach(ch => {
      ch.data.labels.length = 0;
      ch.data.datasets.forEach(ds=>ds.data.length=0);
      ch.update('none');
    });
  }

  // ------------------------
  // Control handlers
  // ------------------------
  function applyFromUI() {
    cfg.R = Number(inpR.value);
    cfg.phiDeg = Number(inpPhi.value);
    cfg.vSet = Number(inpVset.value) * kPH2MS;
    cfg.aLatMax = Number(inpAlat.value);
    cfg.aLongMag = Number(inpAlong.value);
    cfg.dStart = Number(inpDstart.value);
    cfg.dEnd = Number(inpDend.value);
    cfg.laneW = Number(inpLaneW.value);

    track = buildTrack();
    sim.s = 0; sim.v = cfg.vSet; sim.t = 0;
    sim.tArr.length=0; sim.vArr.length=0; sim.aLatArr.length=0; sim.RArr.length=0;
    resetCharts();
    drawBird();

    // Stats
    kvLs.textContent = track.Ls.toFixed(1);
    kvSstart.textContent = track.sStart.toFixed(1);
    kvSend.textContent = track.sEnd.toFixed(1);
    const vCurve = Math.sqrt(cfg.aLatMax * cfg.R) * MS2kPH;
    kvVcurve.textContent = vCurve.toFixed(1);
  }

  btnApply.onclick = applyFromUI;
  btnStart.onclick = () => { sim.running = true; btnStart.disabled=true; btnPause.disabled=false; };
  btnPause.onclick = () => { sim.running = false; btnStart.disabled=false; btnPause.disabled=true; };
  btnReset.onclick = () => { sim.running=false; btnStart.disabled=false; btnPause.disabled=true; applyFromUI(); };

  // ------------------------
  // Main loop
  // ------------------------
  function loop() {
    stepSim();
    requestAnimationFrame(loop);
  }

  // Init
  applyFromUI();
  loop();
})();
</script>
</body>
</html>
