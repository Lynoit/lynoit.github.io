<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACC Curve Handling Simulator (EU Clothoid)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net"/>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<style>
  :root{
    --bg:#0e1116; --card:#151a21; --muted:#8ea0b7; --text:#e7eef7; --accent:#4da3ff;
    --ok:#53d769; --warn:#ffd60a; --bad:#ff453a;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:Inter,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{display:grid;grid-template-columns:320px 1fr 520px;gap:12px;height:100%;padding:12px;box-sizing:border-box}
  .card{background:var(--card);border-radius:14px;box-shadow:0 8px 20px #00000040;padding:14px;display:flex;flex-direction:column;gap:12px}
  h2{margin:0 0 4px 0;font-size:16px;color:var(--muted);font-weight:600;letter-spacing:.3px}
  label{font-size:13px;color:var(--muted);display:flex;justify-content:space-between;gap:8px;align-items:center}
  input[type="number"], input[type="range"]{
    width:100%;accent-color:var(--accent);
  }
  .row{display:grid;grid-template-columns:1fr 90px;gap:8px;align-items:center}
  .buttons{display:flex;gap:8px}
  button{
    background:#1b2330;border:1px solid #223048;color:var(--text);padding:10px 12px;border-radius:10px;
    cursor:pointer;font-weight:600
  }
  button.primary{background:var(--accent);color:#021827;border:none}
  button:disabled{opacity:.6;cursor:not-allowed}
  .pill{display:inline-flex;gap:8px;align-items:center;background:#0f1520;border:1px solid #223048;color:var(--muted);padding:6px 10px;border-radius:999px;font-size:12px}
  canvas{background:#0a0e14;border-radius:10px}
  .plots{display:flex;flex-direction:column;gap:10px;height:100%}
  .plots .card{height:33%}
  .plotwrap{flex:1;min-height:0}
  .readout{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:6px;font-size:12px}
  .readout div{background:#0f1520;border:1px solid #223048;border-radius:10px;padding:8px}
  .rightcol{position:relative}
  #view{flex:1;height:100%;width:100%;border-radius:12px}
  .small{font-size:12px;color:var(--muted)}
  details{border:1px solid #223048;border-radius:10px;padding:8px}
  details>summary{cursor:pointer;color:var(--muted);font-weight:600;margin:4px 0}
  .legend{display:flex;gap:8px;flex-wrap:wrap}
  .legend .pill span{font-variant-numeric:tabular-nums}
</style>
</head>
<body>
<div class="wrap">
  <!-- Column 1: Controls -->
  <div class="card">
    <h2>Inputs</h2>

    <div class="row">
      <label>Curve radius R (m)<span id="valR"></span></label>
      <input id="R" type="range" min="50" max="1000" step="10" value="200" oninput="syncLbls()">
    </div>
    <div class="row">
      <label>Set speed (km/h)<span id="valV"></span></label>
      <input id="Vset" type="range" min="30" max="140" step="1" value="100" oninput="syncLbls()">
    </div>
    <div class="row">
      <label>Longitudinal accel magnitude (m/s²)<span id="valAx"></span></label>
      <input id="Ax" type="range" min="0.2" max="3.0" step="0.1" value="1.5" oninput="syncLbls()">
    </div>
    <div class="row">
      <label>Distance Start (m)<span id="valDs"></span></label>
      <input id="Dstart" type="range" min="50" max="800" step="10" value="250" oninput="syncLbls()">
    </div>
    <div class="row">
      <label>Distance End (m)<span id="valDe"></span></label>
      <input id="Dend" type="range" min="30" max="600" step="10" value="150" oninput="syncLbls()">
    </div>

    <details>
      <summary>Advanced (comfort &amp; geometry)</summary>
      <div class="row">
        <label>Comfort lateral-acc limit (m/s²)<span id="valAy"></span></label>
        <input id="AyMax" type="range" min="0.5" max="3.5" step="0.1" value="2.0" oninput="syncLbls()">
      </div>
      <div class="row">
        <label>Transition jerk limit (m/s³)<span id="valJ"></span></label>
        <input id="Jerk" type="range" min="0.2" max="1.2" step="0.05" value="0.5" oninput="syncLbls()">
      </div>
      <div class="row">
        <label>Constant-arc length (m)<span id="valLc"></span></label>
        <input id="Lconst" type="range" min="60" max="400" step="10" value="120" oninput="syncLbls()">
      </div>
    </details>

    <div class="buttons">
      <button class="primary" id="btnStart">Start</button>
      <button id="btnPause">Pause</button>
      <button id="btnReset">Reset</button>
    </div>

    <div class="legend">
      <div class="pill"><b>ACC</b> Curve Speed Adapt</div>
      <div class="pill"><b>LCC</b> Lane Centering</div>
      <div class="pill">Transition: EU Clothoid</div>
    </div>

    <h2>Live Readout</h2>
    <div class="readout">
      <div>t = <span id="rd_t">0.00</span> s</div>
      <div>v = <span id="rd_v">0.0</span> km/h</div>
      <div>ay = <span id="rd_ay">0.00</span> m/s²</div>
      <div>R(local) = <span id="rd_r">∞</span> m</div>
      <div>s = <span id="rd_s">0.0</span> m</div>
      <div>state = <span id="rd_state">coast</span></div>
    </div>
    <div class="small">
      <p><b>How it works:</b> Curvature ramps linearly (clothoid) until 1/R, then constant-radius arc, then ramps down. ACC decelerates from <i>Distance Start</i> to meet the comfort speed
      \(v_{curve}=\min(v_{set},\sqrt{a_{y,max}\,R})\), then accelerates from <i>Distance End</i> toward the end of the curve. LCC keeps the car centered with a small steering lag.</p>
    </div>
  </div>

  <!-- Column 2: Plots -->
  <div class="plots">
    <div class="card plotwrap">
      <h2>Curve Radius vs Time</h2>
      <canvas id="plotR"></canvas>
    </div>
    <div class="card plotwrap">
      <h2>Speed vs Time</h2>
      <canvas id="plotV"></canvas>
    </div>
    <div class="card plotwrap">
      <h2>Lateral Acceleration vs Time</h2>
      <canvas id="plotAy"></canvas>
    </div>
  </div>

  <!-- Column 3: Birdview -->
  <div class="card rightcol">
    <h2>Birdview</h2>
    <canvas id="view"></canvas>
    <div class="small">Centerline with lane edges; car shows slight steering lag from the lane-centering controller.</div>
  </div>
</div>

<script>
/* ========= Utilities ========= */
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const kmh2ms = v => v/3.6;
const ms2kmh = v => v*3.6;
function fmt(x, d=2){ return (x===Infinity?'∞':x.toFixed(d)); }

/* ========= DOM refs & labels ========= */
const ui = {
  R:       document.getElementById('R'),
  Vset:    document.getElementById('Vset'),
  Ax:      document.getElementById('Ax'),
  Dstart:  document.getElementById('Dstart'),
  Dend:    document.getElementById('Dend'),
  AyMax:   document.getElementById('AyMax'),
  Jerk:    document.getElementById('Jerk'),
  Lconst:  document.getElementById('Lconst'),
  btnStart:document.getElementById('btnStart'),
  btnPause:document.getElementById('btnPause'),
  btnReset:document.getElementById('btnReset'),
};
function syncLbls(){
  document.getElementById('valR').textContent  = ui.R.value+' m';
  document.getElementById('valV').textContent  = ui.Vset.value+' km/h';
  document.getElementById('valAx').textContent = ui.Ax.value+' m/s²';
  document.getElementById('valDs').textContent = ui.Dstart.value+' m';
  document.getElementById('valDe').textContent = ui.Dend.value+' m';
  document.getElementById('valAy').textContent = ui.AyMax.value+' m/s²';
  document.getElementById('valJ').textContent  = ui.Jerk.value+' m/s³';
  document.getElementById('valLc').textContent = ui.Lconst.value+' m';
}
syncLbls();

/* ========= Curve geometry (EU-style) =========
   Transition uses clothoid: curvature k(s)=s/A^2 (linear in distance).
   Choose A via jerk limit: j = v^3/A^2  =>  A = v^(3/2)/sqrt(j)
   Transition length L_t satisfies k_max=1/R = L_t/A^2  =>  L_t = A^2/R = v^3/(j*R)
*/
function buildCurve({R, vEntry, jLat, Lconst}){
  const kMax = 1/Math.max(R,1e-6);
  // Compute transition length based on entry speed & jerk limit; clamp to reasonable band
  let Lt = (Math.pow(vEntry,3) / (jLat * R));
  Lt = clamp(Lt, 30, 400); // keep nice visuals
  const Lc = Lconst;       // constant arc length (user control)
  const Ltot = 2*Lt + Lc;

  function kOfS(s){
    if (s < 0) return 0;
    if (s < Lt) return kMax * (s / Lt);
    if (s < Lt + Lc) return kMax;
    if (s < Ltot) return kMax * (1 - (s - (Lt+Lc))/Lt);
    return 0;
  }
  function ROfS(s){
    const k = kOfS(s);
    if (k <= 1e-9) return Infinity;
    return 1/k;
  }

  // Precompute a drawable centerline with pre/post straights
  const pre =  Math.max(60, +ui.Dstart.value + 50); // show some straight before
  const post = Math.max(60, +ui.Dend.value + 50);   // and after
  const s0 = -pre, s1 = Ltot + post;
  const ds = 1; // 1 m grid
  const N = Math.floor((s1 - s0)/ds)+1;

  let x=0, y=0, psi=0; // start along +x
  const path = [];
  for (let i=0;i<N;i++){
    const s = s0 + i*ds;
    const k = kOfS(s);
    psi += k * ds;
    x += Math.cos(psi) * ds;
    y += Math.sin(psi) * ds;
    path.push({s, x, y, psi, k});
  }
  return {kOfS, ROfS, path, s0, s1, Lt, Lc, Ltot, kMax};
}

/* ========= Simulation state ========= */
let sim=null, charts=null, view=null, rafId=null, lastT=0;

function reset(){
  cancelAnimationFrame(rafId); rafId=null;
  // Parameters
  const R = +ui.R.value;
  const vSet = kmh2ms(+ui.Vset.value);
  const axMag = +ui.Ax.value; // magnitude, applied ±
  const AyMax = +ui.AyMax.value; // comfort cap
  const jLat = +ui.Jerk.value;
  const Lconst = +ui.Lconst.value;

  // Build curve geometry using entry speed as current set speed
  const geom = buildCurve({R, vEntry:vSet, jLat, Lconst});

  // Car initial condition: start before Distance Start so decel can begin in time
  const sInit = geom.s0;
  const Dstart = +ui.Dstart.value;
  const Dend   = +ui.Dend.value;
  const sCurveStart = 0;                    // start of transition-in
  const sCurveEnd   = geom.Ltot;            // end of transition-out
  const sAccelStart = sCurveEnd - Dend;     // when to start re-accelerating

  const vCurve = Math.min(vSet, Math.sqrt(AyMax * R)); // comfort-limited curve speed on constant arc
  const tol = 1e-3;

  sim = {
    running:false,
    t:0, dt:0.016, // ~60Hz
    s:sInit, v:vSet, ax:0, ay:0, psi:0, state:'coast',
    vSet, vCurve, axMag, AyMax, Dstart, Dend,
    sCurveStart, sCurveEnd, sAccelStart,
    sDecelStart: sCurveStart - Dstart,
    geom,
    steerPsi:0, steerLag:0.35, // LCC: small steering lag for visual realism
    hist: {t:[], v:[], ay:[], R:[]}
  };

  // Charts
  setupCharts();

  // Viewport prep
  setupView(geom.path);

  // Reset readouts
  updateReadout();

  // Draw static geometry once
  drawView(true);
}

function setupCharts(){
  const common = {
    type:'line',
    options:{
      responsive:true,
      maintainAspectRatio:false,
      animation:false,
      plugins:{legend:{display:false}},
      scales:{
        x:{title:{display:true,text:'Time (s)',color:'#c7d2e2'}, grid:{color:'#223048'}, ticks:{color:'#c7d2e2'}},
        y:{grid:{color:'#223048'}, ticks:{color:'#c7d2e2'}}
      },
      elements:{point:{radius:0}, line:{tension:0.15}}
    },
    data:{labels:[], datasets:[{data:[], borderWidth:2}]}
  };
  const ctxR = document.getElementById('plotR').getContext('2d');
  const ctxV = document.getElementById('plotV').getContext('2d');
  const ctxA = document.getElementById('plotAy').getContext('2d');

  charts?.R?.destroy(); charts?.V?.destroy(); charts?.A?.destroy();
  charts = {
    R: new Chart(ctxR, JSON.parse(JSON.stringify(common))),
    V: new Chart(ctxV, JSON.parse(JSON.stringify(common))),
    A: new Chart(ctxA, JSON.parse(JSON.stringify(common)))
  };
  charts.R.data.datasets[0].label='Radius (m)';
  charts.R.options.scales.y.title={display:true,text:'Radius (m)',color:'#c7d2e2'};
  charts.V.data.datasets[0].label='Speed (km/h)';
  charts.V.options.scales.y.title={display:true,text:'Speed (km/h)',color:'#c7d2e2'};
  charts.A.data.datasets[0].label='Lateral a (m/s²)';
  charts.A.options.scales.y.title={display:true,text:'Lateral acceleration (m/s²)',color:'#c7d2e2'};
  charts.R.update(); charts.V.update(); charts.A.update();
}

function setupView(path){
  const canvas = document.getElementById('view');
  // Fill available card height
  const parent = canvas.parentElement;
  const rect = parent.getBoundingClientRect();
  canvas.width  = rect.width - 28; // padding allowance
  canvas.height = Math.max(260, rect.height - 90);
  view = {canvas, ctx:canvas.getContext('2d')};

  // Compute bounding box of path with lane width margins
  const wLane=3.75, margin=15;
  let minX=Infinity, minY=Infinity, maxX=-Infinity, maxY=-Infinity;
  for(const p of path){ minX=Math.min(minX,p.x); minY=Math.min(minY,p.y); maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);}
  minX -= (wLane+margin); maxX += (wLane+margin);
  minY -= (wLane+margin); maxY += (wLane+margin);
  const w=canvas.width, h=canvas.height;
  const scale = 0.95*Math.min(w/(maxX-minX), h/(maxY-minY));
  const cx = (minX+maxX)/2, cy=(minY+maxY)/2;
  view.toScreen = (pt)=>{
    // y flipped for screen coords
    return {x: w/2 + (pt.x - cx)*scale, y: h/2 - (pt.y - cy)*scale};
  };
  view.scale = scale; view.wLane=wLane;
}

/* ========= Main loop ========= */
function start(){
  if(!sim) reset();
  sim.running=true;
  ui.btnStart.disabled=true; ui.btnPause.disabled=false;
  lastT = performance.now();
  loop();
}
function pause(){
  sim.running=false;
  ui.btnStart.disabled=false; ui.btnPause.disabled=true;
}
function loop(now){
  if(!sim?.running) return;
  rafId = requestAnimationFrame(loop);
  const tnow = performance.now();
  let dt = (tnow - lastT)/1000; lastT = tnow;
  dt = clamp(dt, 0.005, 0.04); // keep stable
  step(dt);
  if (sim.s > sim.geom.s1 - 5 || sim.v<=0.01){ pause(); } // stop near end
}

function step(dt){
  const g = sim.geom;
  sim.dt = dt;
  sim.t += dt;

  // Curvature & local radius at current s
  const k = g.kOfS(sim.s);
  const Rloc = (k<=1e-9)?Infinity:(1/k);

  // Update LCC steering lag (visual only)
  const psiPath = interpPsiAtS(sim.s, g.path);
  sim.steerPsi += (psiPath - sim.steerPsi) * (dt / sim.steerLag);

  // ACC longitudinal control
  const atDecel = (sim.s >= sim.sDecelStart) && (sim.v > sim.vCurve + 0.01);
  const atAccel = (sim.s >= sim.sAccelStart) && (sim.v < sim.vSet - 0.01);
  if (atDecel){
    sim.ax = -sim.axMag;
    sim.state = 'decel';
  } else if (atAccel){
    sim.ax = +sim.axMag;
    sim.state = 'accel';
  } else {
    sim.ax = 0;
    sim.state = 'coast';
  }
  // Kinematics
  const vPrev = sim.v;
  sim.v = Math.max(0, sim.v + sim.ax*dt);
  // integrate distance by trapezoid
  sim.s += 0.5*(vPrev + sim.v)*dt;

  // Lateral acceleration from curvature
  sim.ay = sim.v*sim.v * k;

  // Logs (thin out a bit)
  if ((sim.hist.t.length===0) || (sim.t - sim.hist.t.at(-1) > 0.05)){
    const Rdisp = Math.min(Rloc, 5000); // clamp for plot
    sim.hist.t.push(sim.t);
    sim.hist.v.push(ms2kmh(sim.v));
    sim.hist.ay.push(sim.ay);
    sim.hist.R.push(Rdisp);
    updateCharts();
  }
  updateReadout(Rloc);
  drawView();
}

function updateReadout(Rloc=Infinity){
  document.getElementById('rd_t').textContent  = fmt(sim.t,2);
  document.getElementById('rd_v').textContent  = fmt(ms2kmh(sim.v),1);
  document.getElementById('rd_ay').textContent = fmt(sim.ay,2);
  document.getElementById('rd_r').textContent  = (Rloc===Infinity?'∞':fmt(Rloc,0));
  document.getElementById('rd_s').textContent  = fmt(sim.s,1);
  document.getElementById('rd_state').textContent = sim.state;
}

function updateCharts(){
  const {t,v,ay,R} = sim.hist;
  charts.R.data.labels = t;
  charts.V.data.labels = t;
  charts.A.data.labels = t;
  charts.R.data.datasets[0].data = R;
  charts.V.data.datasets[0].data = v;
  charts.A.data.datasets[0].data = ay;
  charts.R.update('none'); charts.V.update('none'); charts.A.update('none');
}

/* ========= Birdview drawing ========= */
function drawView(staticOnly=false){
  const ctx = view.ctx, canvas=view.canvas;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const {path, s0, s1} = sim.geom;
  // Draw lane center + edges
  const laneW = view.wLane;
  drawPolyline(path, '#2a3950', 3); // centerline
  drawLaneEdges(path, laneW/2, '#223048', 2);

  // Draw decel/accel markers
  drawSMarker(sim.sDecelStart, '#ffd60a'); // start slowing
  drawSMarker(sim.sAccelStart, '#53d769'); // start accel

  // Car
  const car = pointAtS(sim.s, path);
  const scr = view.toScreen(car);
  const len=4.3, wid=1.9;
  ctx.save();
  ctx.translate(scr.x, scr.y);
  ctx.rotate(- (sim.steerPsi)); // flip because screen y is inverted in toScreen
  ctx.fillStyle = '#4da3ff';
  ctx.strokeStyle = '#0a0e14';
  ctx.lineWidth = 2;
  roundRect(ctx, -len*view.scale/2, -wid*view.scale/2, len*view.scale, wid*view.scale, 6);
  ctx.fill(); ctx.stroke();
  // heading arrow
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(len*view.scale*0.6,0);
  ctx.strokeStyle='#c7d2e2aa'; ctx.lineWidth=3; ctx.stroke();
  ctx.restore();

  if(staticOnly) return;

  // Ghost path ahead (speed color)
  // Optionally, color by comfort ratio; simple indicator (not legend)
}

function drawPolyline(path, stroke='#2a3950', width=2){
  const {ctx} = view;
  ctx.save(); ctx.beginPath();
  for (let i=0;i<path.length;i++){
    const p = view.toScreen(path[i]);
    if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
  }
  ctx.strokeStyle=stroke; ctx.lineWidth=width; ctx.stroke(); ctx.restore();
}
function drawLaneEdges(path, offset, stroke='#223048', width=1.5){
  const {ctx} = view;
  ctx.save();
  ctx.beginPath();
  for (let side of [+1,-1]){
    ctx.beginPath();
    for (let i=0;i<path.length;i++){
      const P = path[i];
      const nx = -Math.sin(P.psi)*side, ny = Math.cos(P.psi)*side;
      const off = {x:P.x + nx*offset, y:P.y + ny*offset};
      const s = view.toScreen(off);
      if(i===0) ctx.moveTo(s.x,s.y); else ctx.lineTo(s.x,s.y);
    }
    ctx.strokeStyle=stroke; ctx.lineWidth=width; ctx.stroke();
  }
  ctx.restore();
}
function drawSMarker(sMark, color){
  const {ctx} = view;
  // Find nearest point along path by s
  const P = pointAtS(sMark, sim.geom.path);
  const Q = view.toScreen(P);
  ctx.save();
  ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=2;
  ctx.beginPath(); ctx.arc(Q.x,Q.y,6,0,Math.PI*2); ctx.fill();
  ctx.restore();
}
function pointAtS(targetS, path){
  // Path is uniform ds=1 starting at s0; interpolate
  if (targetS <= path[0].s) return path[0];
  if (targetS >= path[path.length-1].s) return path[path.length-1];
  const idx = Math.floor((targetS - path[0].s));
  const i = clamp(idx,0,path.length-2);
  const a = path[i], b = path[i+1];
  const u = clamp((targetS - a.s)/(b.s-a.s),0,1);
  return {x:a.x + (b.x-a.x)*u, y:a.y + (b.y-a.y)*u, psi:a.psi + (b.psi-a.psi)*u};
}
function interpPsiAtS(targetS, path){ return pointAtS(targetS, path).psi; }
function roundRect(ctx, x, y, w, h, r){
  r=Math.min(r,Math.abs(w)/2,Math.abs(h)/2);
  ctx.beginPath();
  ctx.moveTo(x+r,y);
  ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r);
  ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r);
  ctx.closePath();
}

/* ========= Wire up ========= */
ui.btnStart.addEventListener('click', start);
ui.btnPause.addEventListener('click', pause);
ui.btnReset.addEventListener('click', ()=>{ reset(); ui.btnStart.disabled=false; ui.btnPause.disabled=true; });

window.addEventListener('resize', ()=>{ if(sim){ setupView(sim.geom.path); drawView(true);} });

reset(); // initial build
</script>
</body>
</html>
