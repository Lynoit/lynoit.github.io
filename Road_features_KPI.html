<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Road Features Map (Excel Positions)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; display: flex; flex-direction: column; }
    #controls { padding: 10px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    #map { position: relative; width: 100%; height: 60%; }
    #results, #seqResults { height: 20%; overflow: auto; margin-top: 5px; background: #fff; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border: 1px solid #ccc; padding: 4px; text-align: left; }
    .feature-label { background: white; border: 1px solid #333; border-radius: 4px; padding: 2px 4px; }
    .leaflet-tooltip.feature-label:after { background: white; }
    #searchOverlay {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 1.5em; z-index: 1000; pointer-events: none;
    }
    footer { text-align: center; padding: 10px; font-size: 0.8em; background: #fff; margin-top: auto; }
  </style>
</head>
<body>
  <div id="controls">
    <strong>Upload Positions (Excel):</strong>
    <input type="file" id="xlsInput" accept=".xlsx,.xls" />
    <button id="loadExcelBtn">Load Positions</button>
    <button id="searchBtn">Sequential Search</button>
    <button id="exportBtn" style="margin-left:10px;">Export to Excel</button>
    <label style="margin-left:10px;">
      Radius (m): <input type="number" id="range" value="5" min="1" step="1" style="width:80px;" />
    </label>
    <div style="margin-top:4px; font-size:0.8em;">Double-click map to toggle manual point.</div>
  </div>

  <div id="map">
    <div id="searchOverlay" style="display:none;">Searching for road featuresâ€¦</div>
  </div>

  <div id="results">
    <h4>Features by Type</h4>
    <table id="typeTable">
      <thead>
        <tr><th>Feature</th><th>Lat</th><th>Lon</th></tr>
      </thead>
      <tbody id="resultsBody"></tbody>
    </table>
  </div>

  <div id="seqResults">
    <h4>Features by Route Coordinate</h4>
    <table id="seqTable">
      <thead>
        <tr><th>#</th><th>Lat</th><th>Lon</th><th>Features</th></tr>
      </thead>
      <tbody id="seqBody"></tbody>
    </table>
  </div>

  <footer>&copy; Lynoit 2025</footer>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <script>
    const RANGE = () => parseInt(document.getElementById('range').value, 10) || 5;
    const showOverlay = () => (document.getElementById('searchOverlay').style.display = 'flex');
    const hideOverlay = () => (document.getElementById('searchOverlay').style.display = 'none');

    // Map
    const map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OSM' }).addTo(map);

    // Route storage and layer
    let routeLines = []; // array of arrays of [lng, lat]
    let routeLayer = null; // Leaflet polyline
    let currentGeoJSON = null; // FeatureCollection of route for bbox etc.

    // Manual point (toggle on double-click)
    let manualMarker = null;
    map.on('dblclick', (e) => {
      if (manualMarker) {
        map.removeLayer(manualMarker);
        manualMarker = null;
      } else {
        manualMarker = L.marker(e.latlng, { draggable: true }).addTo(map).bindTooltip('Manual point', {permanent:true, offset:[0,-24]});
      }
    });

    // Feature definitions
    const featureSettings = [
      { label: 'Bridge', selectors: [ ['bridge','yes'], ['man_made','bridge'] ] },
      { label: 'Tunnel', selectors: [ ['tunnel','yes'] ] },
      { label: 'Toll Station', selectors: [ ['amenity','toll_booth'] ] },
      { label: 'Roundabout', selectors: [ ['junction','roundabout'] ] },
      { label: 'Stop Sign', selectors: [ ['highway','stop'] ] },
      { label: 'Traffic Light', selectors: [ ['highway','traffic_signals'] ] },
      { label: 'Intersection', selectors: [ ['junction','yes'] ] }, // optional, may be noisy
      { label: 'Speed Bump', selectors: [ ['traffic_calming','speed_bump'] ] },
      ...['10','20','30','40','50','60','70','80','90','100','110','120','130','140','none']
        .map(v => ({ label: (v==='none'?'Unlimited':`${v} kph`), selectors: [ ['maxspeed', v] ] }))
    ];

    // Per-label layers + dedupe memory
    const featureLayers = {};
    const seenByLabel = {};
    featureSettings.forEach(({ label }) => {
      featureLayers[label] = L.layerGroup().addTo(map);
      seenByLabel[label] = [];
    });

    function nearExisting(label, lat, lon, meters = Math.max(3, RANGE()*0.75)) {
      const p = turf.point([lon, lat]);
      for (const [lt, ln] of seenByLabel[label]) {
        const d = turf.distance(p, turf.point([ln, lt]), { units: 'meters' });
        if (d <= meters) return true;
      }
      return false;
    }
    function recordSeen(label, lat, lon) { seenByLabel[label].push([lat, lon]); }

    function addMarker(label, coord) {
      L.circleMarker(coord, { radius: 6, color: 'blue', fillColor: 'blue', fillOpacity: 1, weight: 1, interactive: false })
        .addTo(featureLayers[label])
        .bindTooltip(label, { permanent: true, direction: 'right', offset: [10, 0], className: 'feature-label' });
    }

    function clearAll() {
      Object.values(featureLayers).forEach(layer => layer.clearLayers());
      Object.keys(seenByLabel).forEach(k => (seenByLabel[k] = []));
      document.getElementById('resultsBody').innerHTML = '';
      document.getElementById('seqBody').innerHTML = '';
    }

    function drawRouteFromCoords(coords) {
      // coords: [[lng,lat], ...]
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      routeLayer = L.polyline(coords.map(([lng,lat]) => [lat,lng]), { color: 'blue', weight: 4 }).addTo(map);
      map.fitBounds(routeLayer.getBounds(), { padding: [20,20] });
      routeLines = [coords.slice()]; // one continuous line from Excel order
      currentGeoJSON = {
        type: 'FeatureCollection',
        features: [{ type:'Feature', geometry: { type:'LineString', coordinates: coords }, properties:{} }]
      };
    }

    // Load Excel -> route
    document.getElementById('loadExcelBtn').addEventListener('click', async () => {
      const file = document.getElementById('xlsInput').files[0];
      if (!file) { alert('Select an Excel file first'); return; }
      try {
        const buf = await file.arrayBuffer();
        const wb = XLSX.read(buf, { type:'array' });
        const ws = wb.Sheets['Positions'];
        if (!ws) throw new Error('Sheet "Positions" not found.');

        const ref = ws['!ref'];
        if (!ref) throw new Error('Sheet has no data.');

        const range = XLSX.utils.decode_range(ref);
        const coords = [];
        for (let r = 3; r <= range.e.r; r++) { // row 4 => index 3
          const latCell = ws['B' + (r + 1)];
          const lonCell = ws['C' + (r + 1)];
          if (!latCell && !lonCell) continue;
          const lat = Number(latCell?.v);
          const lon = Number(lonCell?.v);
          if (Number.isFinite(lat) && Number.isFinite(lon)) {
            coords.push([lon, lat]); // GeoJSON order [lng,lat]
          }
        }

        if (coords.length < 2) throw new Error('Need at least two valid rows of Lat/Lon from row 4.');

        // (Optional) remove exact duplicates next to each other
        const filtered = [];
        for (let i=0;i<coords.length;i++){
          if (i===0 || coords[i][0]!==coords[i-1][0] || coords[i][1]!==coords[i-1][1]) filtered.push(coords[i]);
        }

        drawRouteFromCoords(filtered);
        clearAll();
        alert(`Loaded ${filtered.length} positions from "${file.name}".`);
      } catch (err) {
        alert('Failed to load Excel: ' + (err.message || err));
      }
    });

    // Overpass helper with mirrors + backoff
    const OVERPASS_MIRRORS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.ru/api/interpreter'
    ];
    async function fetchOverpass(query, attempt = 0) {
      const mirror = OVERPASS_MIRRORS[attempt % OVERPASS_MIRRORS.length];
      const body = 'data=' + encodeURIComponent(query);
      try {
        const res = await fetch(mirror, {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body
        });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        return await res.json();
      } catch (e) {
        if (attempt < 4) {
          await new Promise(r => setTimeout(r, 600 * (attempt + 1)));
          return fetchOverpass(query, attempt + 1);
        }
        throw e;
      }
    }

    function getRouteBbox() {
      if (!currentGeoJSON) return null;
      return turf.bbox(currentGeoJSON); // [minX,minY,maxX,maxY] => [W,S,E,N]
    }

    function buildQueryForSelectors(selectors, bboxStr) {
      const parts = [];
      for (const [k, v] of selectors) {
        parts.push(`node["${k}"="${v}"](${bboxStr});way["${k}"="${v}"](${bboxStr});`);
      }
      return `[out:json][timeout:25];(${parts.join('')});out center;`;
    }

    // Search features and populate tables
    document.getElementById('searchBtn').addEventListener('click', async () => {
      clearAll(); showOverlay();
      try {
        if (!routeLines.length) { hideOverlay(); alert('Load positions (Excel) first'); return; }
        const bbox = getRouteBbox();
        if (!bbox) throw new Error('No route geometry available.');
        const bboxStr = `${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]}`; // S,W,N,E

        const lines = routeLines;
        const allFound = [];

        for (const { label, selectors } of featureSettings) {
          try {
            const q = buildQueryForSelectors(selectors, bboxStr);
            const data = await fetchOverpass(q);

            (data.elements || []).forEach(el => {
              const lat = el.lat != null ? el.lat : el.center?.lat;
              const lon = el.lon != null ? el.lon : el.center?.lon;
              if (lat == null || lon == null) return;

              if (nearExisting(label, lat, lon)) return;

              const pt = turf.point([lon, lat]);
              const onAny = lines.some(coords => {
                const d = turf.pointToLineDistance(pt, turf.lineString(coords), { units: 'meters' });
                return d <= RANGE();
              });
              if (!onAny) return;

              recordSeen(label, lat, lon);
              document.getElementById('resultsBody').insertAdjacentHTML(
                'beforeend',
                `<tr><td>${label}</td><td>${lat.toFixed(6)}</td><td>${lon.toFixed(6)}</td></tr>`
              );
              addMarker(label, [lat, lon]);
              allFound.push({ el, label, lat, lon });
            });
          } catch (e) {
            console.warn(`Query failed for ${label}:`, e);
          }
        }

        // Sequential table across the Excel route coordinates
        const seqRows = [];
        lines.forEach(coords => {
          coords.forEach((c, i) => {
            const [lng, lat] = c;
            const labels = allFound
              .filter(({ lat: la, lon: lo }) =>
                turf.distance(turf.point([lo, la]), turf.point([lng, lat]), { units: 'meters' }) <= RANGE()
              )
              .map(x => x.label);
            if (labels.length) {
              seqRows.push({ idx: i + 1, lat, lng, labels: [...new Set(labels)].join(', ') });
            }
          });
        });

        // Manual point inclusion
        if (manualMarker) {
          const m = manualMarker.getLatLng();
          const labels = allFound
            .filter(({ lat: la, lon: lo }) =>
              turf.distance(turf.point([lo, la]), turf.point([m.lng, m.lat]), { units: 'meters' }) <= RANGE()
            )
            .map(x => x.label);
          if (labels.length) {
            seqRows.push({ idx: 'M', lat: m.lat, lng: m.lng, labels: [...new Set(labels)].join(', ') });
          }
        }

        // Render sequential rows
        const seqBody = document.getElementById('seqBody');
        seqRows.forEach(r => {
          seqBody.insertAdjacentHTML(
            'beforeend',
            `<tr><td>${r.idx}</td><td>${r.lat.toFixed(6)}</td><td>${r.lng.toFixed(6)}</td><td>${r.labels}</td></tr>`
          );
        });

      } catch (err) {
        alert(err.message || err);
      } finally {
        hideOverlay();
      }
    });

    // Export tables to Excel
    document.getElementById('exportBtn').addEventListener('click', () => {
      const wb = XLSX.utils.book_new();
      const ws1 = XLSX.utils.table_to_sheet(document.getElementById('typeTable'));
      XLSX.utils.book_append_sheet(wb, ws1, 'By Type');
      const ws2 = XLSX.utils.table_to_sheet(document.getElementById('seqTable'));
      XLSX.utils.book_append_sheet(wb, ws2, 'By Route Seq');
      XLSX.writeFile(wb, 'road_features.xlsx');
    });
  </script>
</body>
</html>
