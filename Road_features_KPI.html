<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Road Features Map (Excel Positions + Logbook)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    body { display: flex; flex-direction: column; }
    #controls { padding: 10px; background: #fff; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    #map { position: relative; width: 100%; flex: 1; }
    /* Blue (geo-reversed) tooltips */
    .leaflet-tooltip.feature-label {
      background: blue;
      color: #fff;
      border: 1px solid #002b99;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
    }
    .leaflet-tooltip.feature-label.leaflet-tooltip-right:before { border-right-color: blue; }
    /* Orange (logbook) tooltips */
    .leaflet-tooltip.logbook-label {
      background: orange;
      color: #000;
      border: 1px solid #b36b00;
      border-radius: 4px;
      padding: 2px 6px;
      font-size: 12px;
    }
    .leaflet-tooltip.logbook-label.leaflet-tooltip-top:before { border-top-color: orange; }

    #searchOverlay {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.5);
      display: flex; align-items: center; justify-content: center;
      color: white; font-size: 1.5em; z-index: 1000; pointer-events: none;
    }
    footer { text-align: center; padding: 10px; font-size: 0.8em; background: #fff; }

    /* Legend */
    .map-legend {
      background: rgba(255,255,255,0.9);
      padding: 6px 8px;
      border-radius: 6px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.3);
      font: 12px/1.2 Arial, sans-serif;
    }
    .map-legend .legend-row { display: flex; align-items: center; gap: 6px; margin: 2px 0; }
    .map-legend .legend-dot {
      width: 12px; height: 12px; border-radius: 50%;
      display: inline-block; border: 1px solid rgba(0,0,0,0.4);
    }
    .map-legend .legend-dot.orange { background: orange; }
    .map-legend .legend-dot.blue   { background: blue; border-color: #002b99; }
  </style>
</head>
<body>
  <div id="controls">
    <strong>Upload test drive logbook:</strong>
    <input type="file" id="xlsInput" accept=".xlsx,.xls" />
    <button id="loadExcelBtn">Load Positions</button>
    <button id="searchBtn">Find Road Features</button>
    <button id="exportBtn" style="margin-left:10px;">Export to excel</button>
    <label style="margin-left:10px;">
      Radius (m): <input type="number" id="range" value="5" min="1" step="1" style="width:80px;" />
    </label>
  </div>

  <div id="map">
    <div id="searchOverlay" style="display:none;">Searching for road featuresâ€¦</div>
  </div>

  <footer>&copy; Zeekr Tech EU 2025</footer>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

  <script>
    const RANGE = () => parseInt(document.getElementById('range').value, 10) || 5;
    const showOverlay = () => (document.getElementById('searchOverlay').style.display = 'flex');
    const hideOverlay = () => (document.getElementById('searchOverlay').style.display = 'none');

    // Map
    const map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OSM' }).addTo(map);

    // Legend
    const legend = L.control({ position: 'bottomleft' });
    legend.onAdd = function () {
      const div = L.DomUtil.create('div', 'map-legend');
      div.innerHTML = `
        <div class="legend-row"><span class="legend-dot orange"></span> Manual annotation</div>
        <div class="legend-row"><span class="legend-dot blue"></span> Reverse-geocoded road feature</div>
      `;
      L.DomEvent.disableClickPropagation(div);
      return div;
    };
    legend.addTo(map);

    // Route storage and layer
    let routeLines = [];            // array of arrays of [lng, lat]
    let routeLayer = null;          // Leaflet polyline
    let currentGeoJSON = null;      // FeatureCollection for bbox etc.

    // Logbook layer (featureGroup so getBounds() works)
    const logbookLayer = L.featureGroup().addTo(map);

    // Combined blue markers for features (single marker per coordinate)
    const featuresCombinedLayer = L.layerGroup().addTo(map);
    const featureNodeIndex = new Map(); // key => { marker, labels:Set<string> }
    const featureKey = (lat, lon) => `${lat.toFixed(6)},${lon.toFixed(6)}`; // group by exact coord (~0.1m)

    // Manual point (toggle on double-click)
    let manualMarker = null;
    map.on('dblclick', (e) => {
      if (manualMarker) {
        map.removeLayer(manualMarker);
        manualMarker = null;
      } else {
        manualMarker = L.marker(e.latlng, { draggable: true }).addTo(map)
          .bindTooltip('Manual point', {permanent:true, offset:[0,-24]});
      }
    });

    // Feature definitions
    const featureSettings = [
      { label: 'Bridge', selectors: [ ['bridge','yes'], ['man_made','bridge'] ] },
      { label: 'Tunnel', selectors: [ ['tunnel','yes'] ] },
      { label: 'Toll Station', selectors: [ ['amenity','toll_booth'] ] },
      { label: 'Roundabout', selectors: [ ['junction','roundabout'] ] },
      { label: 'Stop Sign', selectors: [ ['highway','stop'] ] },
      { label: 'Traffic Light', selectors: [ ['highway','traffic_signals'] ] },
      { label: 'Intersection', selectors: [ ['junction','yes'] ] }, // optional, may be noisy
      { label: 'Speed Bump', selectors: [ ['traffic_calming','speed_bump'] ] },
      ...['10','20','30','40','50','60','70','80','90','100','110','120','130','140','none']
        .map(v => ({ label: (v==='none'?'Unlimited':`${v} kph`), selectors: [ ['maxspeed', v] ] }))
    ];

    // Dedupe memory by label
    const seenByLabel = {};
    featureSettings.forEach(({ label }) => { seenByLabel[label] = []; });

    function nearExisting(label, lat, lon, meters = Math.max(3, RANGE()*0.75)) {
      const p = turf.point([lon, lat]);
      for (const [lt, ln] of seenByLabel[label]) {
        const d = turf.distance(p, turf.point([ln, lt]), { units: 'meters' });
        if (d <= meters) return true;
      }
      return false;
    }
    function recordSeen(label, lat, lon) { seenByLabel[label].push([lat, lon]); }

    // Single blue marker per coordinate; append labels with commas
    function addOrUpdateFeatureMarker(label, lat, lon) {
      const key = featureKey(lat, lon);
      let entry = featureNodeIndex.get(key);
      if (!entry) {
        const marker = L.circleMarker([lat, lon], {
          radius: 6, color: 'blue', fillColor: 'blue', fillOpacity: 1, weight: 1, interactive: false
        }).addTo(featuresCombinedLayer);
        entry = { marker, labels: new Set() };
        featureNodeIndex.set(key, entry);
      }
      entry.labels.add(label);
      const text = Array.from(entry.labels).join(', ');
      if (entry.marker.getTooltip()) {
        entry.marker.setTooltipContent(text);
      } else {
        entry.marker.bindTooltip(text, { permanent: true, direction: 'right', offset: [10, 0], className: 'feature-label' });
      }
    }

    function clearAll() {
      Object.keys(seenByLabel).forEach(k => (seenByLabel[k] = []));
      logbookLayer.clearLayers();
      featuresCombinedLayer.clearLayers();
      featureNodeIndex.clear();
    }
    function clearSearchOnly() {
      Object.keys(seenByLabel).forEach(k => (seenByLabel[k] = []));
      featuresCombinedLayer.clearLayers();
      featureNodeIndex.clear();
      // keep logbookLayer
    }

    function drawRouteFromCoords(coords) {
      if (routeLayer) { map.removeLayer(routeLayer); routeLayer = null; }
      routeLayer = L.polyline(coords.map(([lng,lat]) => [lat,lng]), { color: 'blue', weight: 4 }).addTo(map);
      routeLines = [coords.slice()]; // one continuous line from Excel order
      currentGeoJSON = {
        type: 'FeatureCollection',
        features: [{ type:'Feature', geometry: { type:'LineString', coordinates: coords }, properties:{} }]
      };
    }

    // Parse "Logbook" coords (label from C, coord from M, row >=5)
    function parseCoordCell(val) {
      if (val == null) return null;
      if (typeof val === 'number') return null;
      const s = String(val);
      const nums = s.match(/-?\d+(?:\.\d+)?/g);
      if (!nums || nums.length < 2) return null;
      const n1 = Number(nums[0]), n2 = Number(nums[1]);
      const latlon = Math.abs(n1) <= 90 && Math.abs(n2) <= 180;
      const lonlat = Math.abs(n1) <= 180 && Math.abs(n2) <= 90;
      if (latlon && !lonlat) return [n2, n1];
      if (!latlon && lonlat) return [n1, n2];
      if (latlon && lonlat) return [n2, n1];
      return null;
    }

    function addLogbookPoint(lat, lon, label) {
      const marker = L.circleMarker([lat, lon], {
        radius: 5, color: 'black', weight: 1, fillColor: 'orange', fillOpacity: 0.95
      }).addTo(logbookLayer);
      marker.bindTooltip(label || '(no label)', {
        permanent: true, direction: 'top', offset: [0, -6], className: 'logbook-label'
      });
    }

    // Load Excel -> route + logbook points
    document.getElementById('loadExcelBtn').addEventListener('click', async () => {
      const file = document.getElementById('xlsInput').files[0];
      if (!file) { alert('Select an Excel file first'); return; }
      try {
        clearAll();
        const buf = await file.arrayBuffer();
        const wb = XLSX.read(buf, { type:'array' });

        // Positions sheet (route)
        const wsPos = wb.Sheets['Positions'];
        if (!wsPos) throw new Error('Sheet "Positions" not found.');
        const refPos = wsPos['!ref'];
        if (!refPos) throw new Error('Sheet "Positions" has no data.');
        const rangePos = XLSX.utils.decode_range(refPos);

        const coords = [];
        for (let r = 3; r <= rangePos.e.r; r++) { // row 4 => index 3
          const latCell = wsPos['B' + (r + 1)];
          const lonCell = wsPos['C' + (r + 1)];
          if (!latCell && !lonCell) continue;
          const lat = Number(latCell?.v);
          const lon = Number(lonCell?.v);
          if (Number.isFinite(lat) && Number.isFinite(lon)) coords.push([lon, lat]);
        }
        if (coords.length < 2) throw new Error('Need at least two valid rows of Lat/Lon in "Positions" (from row 4).');

        // remove exact consecutive duplicates
        const filtered = [];
        for (let i=0;i<coords.length;i++){
          if (i===0 || coords[i][0]!==coords[i-1][0] || coords[i][1]!==coords[i-1][1]) filtered.push(coords[i]);
        }
        drawRouteFromCoords(filtered);

        // Logbook sheet (optional)
        const wsLog = wb.Sheets['Logbook'];
        let logCount = 0;
        if (wsLog) {
          const refLog = wsLog['!ref'];
          if (refLog) {
            const rangeLog = XLSX.utils.decode_range(refLog);
            for (let r = 4; r <= rangeLog.e.r; r++) { // row 5 => index 4
              const labelCell = wsLog['C' + (r + 1)];
              const coordCell = wsLog['M' + (r + 1)];
              const label = (labelCell && String(labelCell.v).trim()) || '';
              const parsed = parseCoordCell(coordCell ? coordCell.v : null);
              if (parsed) {
                const [lng, lat] = parsed;
                if (Number.isFinite(lat) && Number.isFinite(lng)) {
                  addLogbookPoint(lat, lng, label);
                  logCount++;
                }
              }
            }
          }
        }

        // Fit bounds to include both route and logbook
        let bounds = routeLayer.getBounds();
        if (logbookLayer.getLayers().length) bounds.extend(logbookLayer.getBounds());
        map.fitBounds(bounds, { padding: [20,20] });

        alert(`Loaded ${filtered.length} route positions and ${logCount} logbook point(s) from "${file.name}".`);
      } catch (err) {
        alert('Failed to load Excel: ' + (err.message || err));
      }
    });

    // Overpass helper with mirrors + backoff
    const OVERPASS_MIRRORS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://overpass.openstreetmap.ru/api/interpreter'
    ];
    async function fetchOverpass(query, attempt = 0) {
      const mirror = OVERPASS_MIRRORS[attempt % OVERPASS_MIRRORS.length];
      const body = 'data=' + encodeURIComponent(query);
      try {
        const res = await fetch(mirror, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body });
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        return await res.json();
      } catch (e) {
        if (attempt < 4) {
          await new Promise(r => setTimeout(r, 600 * (attempt + 1)));
          return fetchOverpass(query, attempt + 1);
        }
        throw e;
      }
    }

    function getRouteBbox() {
      if (!currentGeoJSON) return null;
      // [minX,minY,maxX,maxY] => [W,S,E,N]
      return turf.bbox(currentGeoJSON);
    }

    function buildQueryForSelectors(selectors, bboxStr) {
      const parts = [];
      for (const [k, v] of selectors) {
        parts.push(`node["${k}"="${v}"](${bboxStr});way["${k}"="${v}"](${bboxStr});`);
      }
      return `[out:json][timeout:25];(${parts.join('')});out center;`;
    }

    // Search features and plot (no tables)
    document.getElementById('searchBtn').addEventListener('click', async () => {
      clearSearchOnly(); showOverlay();
      try {
        if (!routeLines.length) { hideOverlay(); alert('Load positions (Excel) first'); return; }
        const bbox = getRouteBbox();
        if (!bbox) throw new Error('No route geometry available.');
        const bboxStr = `${bbox[1]},${bbox[0]},${bbox[3]},${bbox[2]}`; // S,W,N,E
        const lines = routeLines;

        for (const { label, selectors } of featureSettings) {
          try {
            const q = buildQueryForSelectors(selectors, bboxStr);
            const data = await fetchOverpass(q);

            (data.elements || []).forEach(el => {
              const lat = el.lat != null ? el.lat : el.center?.lat;
              const lon = el.lon != null ? el.lon : el.center?.lon;
              if (lat == null || lon == null) return;

              if (nearExisting(label, lat, lon)) return;

              const pt = turf.point([lon, lat]);
              const onAny = lines.some(coords => {
                const d = turf.pointToLineDistance(pt, turf.lineString(coords), { units: 'meters' });
                return d <= RANGE();
              });
              if (!onAny) return;

              recordSeen(label, lat, lon);
              addOrUpdateFeatureMarker(label, lat, lon);
            });
          } catch (e) {
            console.warn(`Query failed for ${label}:`, e);
          }
        }
      } catch (err) {
        alert(err.message || err);
      } finally {
        hideOverlay();
      }
    });

    // Export: one row per route coordinate, columns A-D as requested
    document.getElementById('exportBtn').addEventListener('click', () => {
      if (!routeLines.length) { alert('Load positions (Excel) first'); return; }

      // Gather orange (logbook) and blue (features) markers from the map
      const logPts = logbookLayer.getLayers().map(m => ({
        lat: m.getLatLng().lat,
        lng: m.getLatLng().lng,
        label: (m.getTooltip() && m.getTooltip().getContent()) ? String(m.getTooltip().getContent()).trim() : ''
      }));

      const featPts = featuresCombinedLayer.getLayers().map(m => ({
        lat: m.getLatLng().lat,
        lng: m.getLatLng().lng,
        labels: ((m.getTooltip() && m.getTooltip().getContent()) ? String(m.getTooltip().getContent()) : '')
                  .split(',').map(s => s.trim()).filter(Boolean)
      }));

      const rangeMeters = RANGE();
      const rows = [['Latitude', 'Longitude', 'Manual annotations', 'Reverse-geocoded features']];

      routeLines.forEach(coords => {
        coords.forEach(([lng, lat]) => {
          const pt = turf.point([lng, lat]);

          const orangeLabels = [];
          for (const p of logPts) {
            const d = turf.distance(pt, turf.point([p.lng, p.lat]), { units: 'meters' });
            if (d <= rangeMeters && p.label) orangeLabels.push(p.label);
          }

          const blueLabels = [];
          for (const p of featPts) {
            const d = turf.distance(pt, turf.point([p.lng, p.lat]), { units: 'meters' });
            if (d <= rangeMeters) blueLabels.push(...p.labels);
          }

          const colC = [...new Set(orangeLabels)].join(', ');
          const colD = [...new Set(blueLabels)].join(', ');
          rows.push([lat, lng, colC, colD]);
        });
      });

      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(rows);
      XLSX.utils.book_append_sheet(wb, ws, 'All Coordinates');
      XLSX.writeFile(wb, 'coordinates_with_labels.xlsx');
    });
  </script>
</body>
</html>
