<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACC Cut-In Simulator</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
<style>
  :root{ --bg:#0f1220; --panel:#161a2b; --ink:#e8ecff; --muted:#a9b0d5; --grid-gap:14px; }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,Segoe UI,Roboto,Inter,Arial;}
  .wrap{display:grid; grid-template-columns: 360px 660px 520px; gap:var(--grid-gap); padding:var(--grid-gap);}
  .card{background:var(--panel); border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35); padding:14px 16px;}
  h2{margin:0 0 10px 0; font-weight:600; letter-spacing:.2px}
  .row{display:grid; grid-template-columns: 1fr 110px; gap:10px; align-items:center; margin:8px 0}
  /* ↓ smaller input font size */
  input[type="number"]{
    width:100%; box-sizing:border-box; background:#0f1325; color:var(--ink);
    border:1px solid #242948; border-radius:10px; padding:8px 10px; font-size:13px;
  }
  .mini{font-size:12px; color:var(--muted)}
  .btnbar{display:flex; gap:8px; margin:12px 0}
  button{background:#1e2442; color:var(--ink); border:1px solid #2a315b; border-radius:12px; padding:8px 12px; cursor:pointer}
  button:hover{filter:brightness(1.1)} button:disabled{opacity:.5; cursor:not-allowed}
  table{width:100%; border-collapse:collapse; font-size:14px}
  th,td{border-bottom:1px solid #242948; padding:6px 8px; text-align:left}
  th{color:var(--muted); font-weight:600}
  #charts{display:grid; gap:10px}
  canvas{background:#0b0f1f; border:1px solid #242948; border-radius:12px}
  .hint{color:var(--muted); font-size:12px; margin-top:8px}
  .twocol{display:grid; grid-template-columns: 1fr 90px; gap:10px; align-items:center}
  .checkboxes{display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin:4px 0 8px}
  label.cb{display:flex; gap:6px; align-items:center; background:#101531; border:1px solid #242948; padding:6px 10px; border-radius:10px; cursor:pointer}
  .readout{display:grid; grid-template-columns: 1fr 1fr; gap:6px; font-size:13px; margin-top:8px}
  .readout div{background:#101531; border:1px solid #242948; border-radius:8px; padding:6px 8px}
  .tag{font-size:11px; color:var(--muted)}
  .unit{color:var(--muted); font-size:12px}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  /* Left-column input labels */
.row > div:first-child {
  font-size: 12px;   /* ← set your size here */
  line-height: 1.25;
}
</style>
</head>
<body>
<div class="wrap">
  <!-- LEFT: Controls + Milestones -->
  <section class="card">
    <h2>Inputs &amp; Controls</h2>

    <div class="row"><div>Cut-in object speed <span class="unit">(km/h)</span></div>
      <input id="in_vCutKph" type="number" min="0" max="200" step="1" value="80">
    </div>
    <div class="row"><div>Cut-in initial gap <span class="unit">(m, front-to-front)</span></div>
      <input id="in_gap" type="number" min="-20" max="200" step="1" value="50">
    </div>
    <div class="row"><div>Cut-in lateral peak speed <span class="unit">(m/s)</span></div>
      <input id="in_vLat" type="number" min="0.1" max="5" step="0.1" value="1">
    </div>
    <div class="row"><div><b>Cut-in start time</b> <span class="unit">(s)</span></div>
      <input id="in_tCut" type="number" min="0" max="15" step="0.1" value="3">
    </div>
    <div class="row"><div>ACC set speed <span class="unit">(km/h)</span></div>
      <input id="in_vSetKph" type="number" min="0" max="200" step="1" value="90">
    </div>
    <div class="row"><div>ACC time gap <span class="unit">(s)</span></div>
      <input id="in_headway" type="number" min="0.8" max="3" step="0.1" value="2">
    </div>
    <div class="row"><div>ACC max decel limit <span class="unit">(m/s²)</span></div>
      <input id="in_maxDecel" type="number" min="0.5" max="10" step="0.1" value="3.0">
    </div>

    <div style="margin-top:8px">
      <div class="mini">Detection method(s)</div>
      <div class="checkboxes">
        <label class="cb"><input id="cb_m1" type="checkbox" checked> Method 1: % inside lane</label>
        <label class="cb"><input id="cb_m2" type="checkbox"> Method 2: sustained lateral motion</label>
      </div>
      <div class="twocol">
        <div><span class="mini">M1 threshold (%)</span></div>
        <input id="in_m1pct" type="number" min="0" max="100" step="1" value="50">
      </div>
      <div class="twocol">
        <div><span class="mini">M2 window (ms)</span></div>
        <input id="in_m2ms" type="number" min="100" max="2000" step="50" value="500">
      </div>
      <div class="hint">If both are checked, detection fires when either method triggers.</div>
    </div>

    <div class="btnbar">
      <button id="btnStart">Start</button>
      <button id="btnPause" disabled>Pause</button>
      <button id="btnReset">Reset</button>
    </div>

    <div class="readout" id="readout">
      <div><b class="tag">Sim time</b><div class="mono" id="ro_t">0.0 s</div></div>
      <div><b class="tag">Gap</b><div class="mono" id="ro_gap">—</div></div>
      <div><b class="tag">Desired gap</b><div class="mono" id="ro_gdes">—</div></div>
      <div><b class="tag">v ego</b><div class="mono" id="ro_vego">—</div></div>
      <div><b class="tag">v cut-in</b><div class="mono" id="ro_vcut">—</div></div>
      <div><b class="tag">a ego</b><div class="mono" id="ro_aego">—</div></div>
    </div>

    <h2 style="margin-top:16px">Milestones</h2>
    <table id="milestones">
      <thead><tr><th style="width:110px">Time (s)</th><th>Event</th></tr></thead>
      <tbody></tbody>
    </table>
  </section>

  <!-- MIDDLE: Charts -->
  <section class="card">
    <h2>Plots</h2>
    <div id="charts">
      <canvas id="chartGap"   width="640" height="160"></canvas>
      <canvas id="chartSpeed" width="640" height="220"></canvas>
      <canvas id="chartAccel" width="640" height="180"></canvas>
    </div>
    <div class="hint">Time axis in seconds; gap is front-to-front distance. Dashed lines show the minimum encountered so far.</div>
  </section>

  <!-- RIGHT: Birdview -->
  <section class="card">
    <h2>Birdview</h2>
    <canvas id="bird" width="500" height="480"></canvas>
    <div class="hint">Straight road with two lanes. Cut-in comes from the left lane into ego lane; lane centering keeps the ego at lane center.</div>
  </section>
</div>

<script>
(() => {
  // ---------- Constants & helpers ----------
  const laneW = 3.5;
  const carLen = 4.5, carWid = 1.8;
  const dt = 0.02;                 // 20 ms
  const maxAccel = 1.5;            // m/s² (positive accel limit)
  const kCruise = 0.6;             // cruise gain to set speed
  const kGap = 0.25, kRel = 0.8;   // ACC gains
  const vyMinForM2 = 0.05;         // m/s threshold for method 2
  const clamp = (x,min,max)=>Math.max(min,Math.min(max,x));
  const kph2mps = v=>v/3.6;

  // Birdview
  const VIEW_ZOOM = 1.2;
  const EDGE_W_VIS = 0.22;
  const MARK_W_VIS = 0.18;
  const POST_RUN_SEC = 5.0;

  // "Near-enough" gap acceptance
  const REACH_FRAC = 0.10;
  const REACH_AB  = 5.0;
  const REACH_DELAY = 0.3;

  // ---------- DOM ----------
  const el = id => document.getElementById(id);
  const in_vCutKph = el('in_vCutKph');
  const in_gap     = el('in_gap');
  const in_vLat    = el('in_vLat');
  const in_tCut    = el('in_tCut');
  const in_vSetKph = el('in_vSetKph');
  const in_headway = el('in_headway');
  const in_maxDecel = el('in_maxDecel');
  const cb_m1 = el('cb_m1'), cb_m2 = el('cb_m2');
  const in_m1pct = el('in_m1pct'), in_m2ms = el('in_m2ms');
  const btnStart = el('btnStart'), btnPause = el('btnPause'), btnReset = el('btnReset');
  const ro_t = el('ro_t'), ro_gap = el('ro_gap'), ro_gdes = el('ro_gdes'), ro_vego = el('ro_vego'),
        ro_vcut = el('ro_vcut'), ro_aego = el('ro_aego');
  const msTableBody = document.querySelector('#milestones tbody');
  const bird = el('bird'), ctx = bird.getContext('2d');

  // ---------- Milestones ----------

  function eventPriority(label){
  if (label.startsWith('Simulation start')) return 0;
  if (label.startsWith('Start of lateral movement')) return 1;
  if (label.startsWith('Detection of the cut-in object')) return 2;
  if (label.startsWith('Start of deceleration')) return 3;
  if (label.startsWith('Scenario failed')) return 4;                 // ← NEW
  if (label.startsWith('ACC reaches desired time gap')) return 5;
  if (label.startsWith('Simulation stop')) return 6;
  return 99;
  }
  
  function addMilestone(time, label){
    const tDisp = Math.round(time * 100) / 100;
    const tr = document.createElement('tr');
    tr.innerHTML = `<td class="mono">${tDisp.toFixed(2)}</td><td>${label}</td>`;
    const newPri = eventPriority(label);
    const rows = [...msTableBody.querySelectorAll('tr')];
    let inserted = false;
    for (let i = 0; i < rows.length; i++){
      const tRow = parseFloat(rows[i].children[0].textContent);
      const labelRow = rows[i].children[1].textContent;
      const priRow = eventPriority(labelRow);
      if (tDisp < tRow || (tDisp === tRow && newPri < priRow)){
        msTableBody.insertBefore(tr, rows[i]); inserted = true; break;
      }
    }
    if (!inserted) msTableBody.appendChild(tr);
  }
  function resetMilestones(){ msTableBody.innerHTML = ''; }

  // ---------- Simulation state ----------
  let sim = null, timer = null, charts = null, chartsInit = false;

  function initSim() {
    const vSet = kph2mps(+in_vSetKph.value);
    const vCut = kph2mps(+in_vCutKph.value);
    const gap0 = +in_gap.value;

    let tStart = parseFloat(in_tCut.value); if (!isFinite(tStart) || tStart < 0) tStart = 3;
    const vLatTarget = Math.max(0.1, +in_vLat.value);
    let tCut = 0.5 * laneW * Math.PI / vLatTarget; tCut = clamp(tCut, 0.5, 12);

    const headway = +in_headway.value;
    const maxDecel = Math.max(0.1, +in_maxDecel.value || 3.0);

    sim = {
      t: 0, running: false,
      detected: false, detectTime: null,
      decelStarted: false, decelTime: null,
      gapReached: false, gapReachedTime: null,
      postRunActive: false, postRunTimer: 0,
      reachDelayTimer: 0, usedM1: false, usedM2: false,
      latStarted: false,
      xE: 0, vE: vSet, aE: 0,
      xC: gap0, vC: vCut, yC: laneW,
      m2Timer: 0,
      logT: [], logVego: [], logVcut: [], logAego: [], logGap: [],
      minGap: gap0, minVego: vSet, minAccel: 0,
      scenarioFailed: false,
      scenarioFailTime: null,
      vSet, vCut, headway, tStart, tCut, maxDecel
    };

    resetMilestones();
    addMilestone(0, 'Simulation start');

    sim.logT.push(sim.t);
    sim.logVego.push(sim.vE);
    sim.logVcut.push(sim.vC);
    sim.logAego.push(sim.aE);
    sim.logGap.push(sim.xC - sim.xE);
  }

  // ---------- Detection ----------
  function percentInsideEgoLane(yCenter){
    const L = carWid;
    const y0 = yCenter - L/2, y1 = yCenter + L/2;
    const a = Math.max(y0, -laneW/2);
    const b = Math.min(y1,  laneW/2);
    const overlap = Math.max(0, b - a);
    return (overlap / L) * 100.0;
  }
  function updateDetection(sim){
    if (sim.detected) return;
    let fired = false;
    if (cb_m1.checked){
      const pct = percentInsideEgoLane(sim.yC);
      const thr = +in_m1pct.value;
      if (pct >= thr){ sim.detected = true; sim.detectTime = sim.t; sim.usedM1 = true; fired = true; }
    }
    if (!fired && cb_m2.checked){
      const vy = vyCut(sim.t);
      const windowSec = (+in_m2ms.value) / 1000.0;
      sim.m2Timer = (vy < -vyMinForM2) ? sim.m2Timer + dt : 0;
      if (sim.m2Timer >= windowSec){ sim.detected = true; sim.detectTime = sim.t; sim.usedM2 = true; fired = true; }
    }
    if (fired){
      sim.reachDelayTimer = 0;
      addMilestone(sim.detectTime, `Detection of the cut-in object ${sim.usedM1 && sim.usedM2 ? '(M1+M2)' : (sim.usedM1? '(M1)':'(M2)')}`);
    }
  }

  // ---------- Lateral profile ----------
  function yCut(t){
    if (t < sim.tStart) return laneW;
    const s = (t - sim.tStart) / sim.tCut;
    if (s >= 1) return 0;
    const u = 0.5*(1 - Math.cos(Math.PI*s));
    return laneW * (1 - u);
  }
  function vyCut(t){
    if (t <= sim.tStart || t >= sim.tStart + sim.tCut) return 0;
    const s = (t - sim.tStart) / sim.tCut;
    return - laneW * 0.5 * Math.sin(Math.PI*s) * (Math.PI / sim.tCut);
  }

  // ---------- Chart plugin: label on min-line ----------
  // ---------- Chart plugin: label on min-line (robust to value/text being fn or number) ----------
const minLineLabelPlugin = {
  id: 'minLineLabelPlugin',
  afterDatasetsDraw(chart) {
    const opts = chart.options?.plugins?.minLineLabel;
    if (!opts || !opts.items || !chart.data.labels?.length) return;

    const { ctx, chartArea, scales } = chart;
    if (!chartArea || !scales?.x || !scales?.y) return;

    const getVal  = v => (typeof v === 'function' ? v() : v);
    const getText = t => (typeof t === 'function' ? t() : (t ?? ''));

    const x = chartArea.right - 6; // right-edge padding
    ctx.save();
    ctx.textBaseline = 'middle';
    ctx.textAlign = 'right';
    ctx.font = '12px system-ui, Segoe UI';

    for (const item of opts.items) {
      const val = getVal(item.value);
      if (!isFinite(val)) continue;

      const y = scales.y.getPixelForValue(val);
      const text = getText(item.text);
      const padX = 6, padY = 3;
      const metrics = ctx.measureText(text);
      const w = metrics.width + padX*2, h = 18;
      const rx = x - w, ry = y - h/2;

      // background capsule
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      roundRect(ctx, rx, ry, w, h, 8);
      ctx.fill();

      // border in the series color
      ctx.strokeStyle = item.color || '#fff';
      ctx.lineWidth = 1;
      roundRect(ctx, rx, ry, w, h, 8);
      ctx.stroke();

      // text
      ctx.fillStyle = item.color || '#fff';
      ctx.fillText(text, x - padX, y + 0.5);
    }

    ctx.restore();

    function roundRect(ctx,x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y,   x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x,   y+h, r);
      ctx.arcTo(x,   y+h, x,   y,   r);
      ctx.arcTo(x,   y,   x+w, y,   r);
      ctx.closePath();
    }
  }
};
Chart.register(minLineLabelPlugin);

  // ---------- Charts ----------
  function initCharts(){
    if (chartsInit) return;
    const axis = {
      ticks:  { color:'#e8ecff' },
      grid:   { color:'rgba(168,176,213,0.15)' },
      border: { color:'rgba(168,176,213,0.25)' }
    };

    const gp = new Chart(document.getElementById('chartGap').getContext('2d'), {
      type:'line',
      data:{
        labels:[],
        datasets:[
          { // gap
            data:[], label:'Gap (m)',
            borderColor:'#cfa8ff', backgroundColor:'rgba(207,168,255,0.10)',
            borderWidth:2, pointRadius:2, pointHoverRadius:3, tension:0.18, spanGaps:true, showLine:true
          },
          { // min gap line
            data:[],
            borderColor:'#ff8ad4', backgroundColor:'rgba(255,138,212,0.06)',
            borderDash:[5,5], borderWidth:2, pointRadius:0, tension:0, spanGaps:true, showLine:true
          }
        ]
      },
      options:{
        animation:false, responsive:false, maintainAspectRatio:false,
        scales:{ x:axis, y:axis },
        plugins:{
          legend:{ display:false }, tooltip:{ mode:'index', intersect:false },
          minLineLabel:{
            items:[
              { value: ()=> sim ? sim.minGap : NaN,
                text:  ()=> sim ? `min ${sim.minGap.toFixed(1)} m` : '',
                color: '#ff8ad4' }
            ]
          }
        }
      }
    });

    const sp = new Chart(document.getElementById('chartSpeed').getContext('2d'), {
      type:'line',
      data:{
        labels:[],
        datasets:[
          { // ego speed
            data:[], label:'Ego speed (km/h)',
            borderColor:'#7CFFB2', backgroundColor:'rgba(124,255,178,0.10)',
            borderWidth:2, pointRadius:2, pointHoverRadius:3, tension:0.18, spanGaps:true, showLine:true
          },
          { // cut-in speed
            data:[], label:'Cut-in speed (km/h)',
            borderColor:'#7cc4ff', backgroundColor:'rgba(124,196,255,0.10)',
            borderWidth:2, borderDash:[6,4], pointRadius:2, pointHoverRadius:3, tension:0.18, spanGaps:true, showLine:true
          },
          { // min ego speed line
            data:[],
            borderColor:'#ffd0a6', backgroundColor:'rgba(255,208,166,0.06)',
            borderDash:[5,5], borderWidth:2, pointRadius:0, tension:0, spanGaps:true, showLine:true
          }
        ]
      },
      options:{
        animation:false, responsive:false, maintainAspectRatio:false,
        scales:{ x:axis, y:axis },
        plugins:{
          legend:{ display:false }, tooltip:{ mode:'index', intersect:false },
          minLineLabel:{
            items:[
              { value: ()=> sim ? (sim.minVego*3.6) : NaN,
                text:  ()=> sim ? `min ${(sim.minVego*3.6).toFixed(1)} km/h` : '',
                color: '#ffd0a6' }
            ]
          }
        }
      }
    });

    const ac = new Chart(document.getElementById('chartAccel').getContext('2d'), {
      type:'line',
      data:{
        labels:[],
        datasets:[
          { // ego accel
            data:[], label:'Ego accel (m/s²)',
            borderColor:'#ffd36b', backgroundColor:'rgba(255,211,107,0.10)',
            borderWidth:2, pointRadius:2, pointHoverRadius:3, tension:0.18, spanGaps:true, showLine:true
          },
          { // min accel line
            data:[],
            borderColor:'#a3ff9e', backgroundColor:'rgba(163,255,158,0.06)',
            borderDash:[5,5], borderWidth:2, pointRadius:0, tension:0, spanGaps:true, showLine:true
          }
        ]
      },
      options:{
        animation:false, responsive:false, maintainAspectRatio:false,
        scales:{ x:axis, y:axis },
        plugins:{
          legend:{ display:false }, tooltip:{ mode:'index', intersect:false },
          minLineLabel:{
            items:[
              { value: ()=> sim ? sim.minAccel : NaN,
                text:  ()=> sim ? `min ${sim.minAccel.toFixed(2)} m/s²` : '',
                color: '#a3ff9e' }
            ]
          }
        }
      }
    });

    charts = { gp, sp, ac };
    chartsInit = true;
  }

  function updateCharts(){
    if (!chartsInit || !sim) return;
    const labels = sim.logT.map(t=>t.toFixed(2));
    charts.gp.data.labels = labels;
    charts.sp.data.labels = labels;
    charts.ac.data.labels = labels;

    charts.gp.data.datasets[0].data = sim.logGap;
    charts.sp.data.datasets[0].data = sim.logVego.map(v=>v*3.6);
    charts.sp.data.datasets[1].data = sim.logVcut.map(v=>v*3.6);
    charts.ac.data.datasets[0].data = sim.logAego;

    // constant min lines
    charts.gp.data.datasets[1].data = Array(labels.length).fill(sim.minGap);
    charts.sp.data.datasets[2].data = Array(labels.length).fill(sim.minVego * 3.6);
    charts.ac.data.datasets[1].data = Array(labels.length).fill(sim.minAccel);

    charts.gp.update('none'); charts.sp.update('none'); charts.ac.update('none');
  }

  // ---------- Birdview ----------
  function drawBird(){
    const s = sim;
    const W = bird.width, H = bird.height;
    ctx.clearRect(0,0,W,H);

    // Base world window
    let xMin = s.xE - 15, xMax = s.xE + 70;
    let yMin = -laneW/2 - 1.0;
    let yMax =  3*laneW/2 + 1.0;

    // Zoom
    const xC = (xMin + xMax)/2, yC = (yMin + yMax)/2;
    const halfX = (xMax - xMin)/(2*VIEW_ZOOM);
    const halfY = (yMax - yMin)/(2*VIEW_ZOOM);
    xMin = xC - halfX; xMax = xC + halfX;
    yMin = yC - halfY; yMax = yC + halfY;

    // Uniform scale
    const sPx = Math.min((W-30)/(xMax-xMin), (H-30)/(yMax-yMin));
    const viewWpx = (xMax-xMin)*sPx, viewHpx = (yMax-yMin)*sPx;
    const xPad = (W - viewWpx)/2, yPad = (H - viewHpx)/2;

    const toPix = (x,y)=>[(x - xMin) * sPx + xPad, (yMax - y) * sPx + yPad];

    function fillWorldRect(x0,y0,w,h,color){
      const [px0,pyTop] = toPix(x0, y0 + h);
      const pxw = w * sPx, pyh = h * sPx;
      ctx.fillStyle = color;
      ctx.fillRect(px0, pyTop, pxw, -pyh);
    }

    // Road background
    fillWorldRect(xMin, yMin, (xMax-xMin), (yMax-yMin), '#0b0f1f');

    // Lane markings
    const edgeWidth = EDGE_W_VIS, markWidth = MARK_W_VIS;
    const dashLen = 3.0, gapLen = 9.0;

    fillWorldRect(xMin, -laneW/2 - edgeWidth/2, (xMax-xMin), edgeWidth, '#e8ecff');
    fillWorldRect(xMin,  3*laneW/2 - edgeWidth/2, (xMax-xMin), edgeWidth, '#e8ecff');

    (function drawDashedDivider(){
      const y = laneW/2, period = dashLen + gapLen;
      let x = Math.floor(xMin / period) * period;
      while (x < xMax){
        const segStart = Math.max(x, xMin);
        const segEnd   = Math.min(x + dashLen, xMax);
        if (segEnd > segStart){
          fillWorldRect(segStart, y - markWidth/2, (segEnd - segStart), markWidth, '#e8ecff');
        }
        x += period;
      }
    })();

    // Trajectory hint
    ctx.strokeStyle = '#7cc4ff'; ctx.globalAlpha = 0.35; ctx.lineWidth = 2;
    ctx.beginPath();
    for (let u=0; u<=1; u+=0.02){
      const t = s.tStart + u*s.tCut;
      const xc = s.xC - (s.t - t) * s.vC;
      const yc = yCut(t);
      const [px,py] = toPix(xc,yc);
      if (u===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
    }
    ctx.stroke(); ctx.globalAlpha = 1;

    // Cars
    function drawCarBox(x, y, bodyColor, outlineColor){
      const [px,py] = toPix(x,y);
      const wPx = carLen * sPx, hPx = carWid * sPx;

      ctx.save(); ctx.translate(px,py);
      ctx.fillStyle = bodyColor; ctx.strokeStyle = outlineColor || 'rgba(0,0,0,0.55)';
      const r = Math.min(wPx,hPx) * 0.12;
      roundRect(-wPx*0.5, -hPx*0.5, wPx, hPx, r); ctx.fill(); ctx.lineWidth = 1.25; ctx.stroke();

      ctx.fillStyle = 'rgba(180,200,255,0.25)'; // windshield
      const wsL = wPx*0.18;
      ctx.fillRect(wPx*0.5 - wsL, -hPx*0.33, wsL*0.9, hPx*0.66);

      ctx.fillStyle = '#1b1f2f'; // wheels
      const tireLen = 0.80 * sPx, tireWid = 0.28 * sPx, axleX = wPx*0.28, yOff = hPx*0.5 - tireWid*0.7;
      ctx.fillRect(+axleX - tireLen*0.5, -yOff - tireWid*0.5, tireLen, tireWid);
      ctx.fillRect(+axleX - tireLen*0.5, +yOff - tireWid*0.5, tireLen, tireWid);
      ctx.fillRect(-axleX - tireLen*0.5, -yOff - tireWid*0.5, tireLen, tireWid);
      ctx.fillRect(-axleX - tireLen*0.5, +yOff - tireWid*0.5, tireLen, tireWid);

      ctx.fillStyle = 'rgba(255,255,255,0.6)'; // front marker
      ctx.fillRect(wPx*0.5 - 2, -hPx*0.1, 2, hPx*0.2);
      ctx.restore();

      function roundRect(x,y,w,h,rad){
        ctx.beginPath();
        ctx.moveTo(x+rad,y);
        ctx.arcTo(x+w,y,x+w,y+h,rad);
        ctx.arcTo(x+w,y+h,x,y+h,rad);
        ctx.arcTo(x,y+h,x,y,rad);
        ctx.arcTo(x,y,x+w,y,rad);
        ctx.closePath();
      }
    }

    drawCarBox(s.xE, 0, '#7CFFB2', 'rgba(0,0,0,0.55)');
    drawCarBox(s.xC, s.yC, s.detected ? '#ffd36b' : '#a5c6ff', '#26304f');
  }

  // ---------- Simulation ----------
  function step(){
    const s = sim;
    s.t += dt;

    if (!s.latStarted && s.t >= s.tStart) {
      s.latStarted = true;
      addMilestone(s.t, 'Start of lateral movement of the cut-in object');
    }

    // Cut-in kinematics
    s.yC = yCut(s.t);
    s.xC += s.vC * dt;

    // Detection
    updateDetection(s);

    // Gaps
    const gap = s.xC - s.xE;
    const gDes = Math.max(0, s.headway * s.vE);

    // Ego longitudinal control
    let aCmd;
    if (!s.detected){
      aCmd = clamp(kCruise * (s.vSet - s.vE), -s.maxDecel, maxAccel);
    } else {
      const eGap = gap - gDes;
      const eVel = s.vC - s.vE;
      aCmd = kGap * eGap + kRel * eVel;
      aCmd = clamp(aCmd, -s.maxDecel, maxAccel);
      if (!s.decelStarted && aCmd < -0.01){
        s.decelStarted = true; s.decelTime = s.t;
        addMilestone(s.decelTime, 'Start of deceleration');
      }
    }

    // Integrate ego
    s.aE = aCmd;
    s.vE = Math.max(0, s.vE + s.aE * dt);
    s.xE += s.vE * dt;

// --- Scenario failure: collision-like gap (front-to-front <= car length) ---
const gapNow = s.xC - s.xE;
if (!s.scenarioFailed && gapNow <= carLen) {
  s.scenarioFailed = true;
  s.scenarioFailTime = s.t;
  addMilestone(s.scenarioFailTime, 'Scenario failed');
  // ensure we stop 5 s after this happens
  sim.postRunActive = true;
  sim.postRunTimer = 0;
}

    // Running minima
    s.minGap   = Math.min(s.minGap, gap);
    s.minVego  = Math.min(s.minVego, s.vE);
    s.minAccel = Math.min(s.minAccel, s.aE);

    // Near-enough desired time gap milestone (+post-run)
    if (s.detected && !s.gapReached){
      s.reachDelayTimer += dt;
      if (s.reachDelayTimer >= REACH_DELAY){
        const gDesNow = Math.max(0, s.headway * s.vE);
        const err = Math.abs((s.xC - s.xE) - gDesNow);
        const band = Math.max(REACH_AB, REACH_FRAC * gDesNow);
        if (err <= band){
          s.gapReached = true; s.gapReachedTime = s.t;
          addMilestone(s.gapReachedTime, 'ACC reaches desired time gap');
          s.postRunActive = true; s.postRunTimer = 0;
        }
      }
    }
    if (s.postRunActive){
      s.postRunTimer += dt;
      if (s.postRunTimer >= POST_RUN_SEC){
        addMilestone(s.t, 'Simulation end');
        stopSim();
      }
    }

    // Logs
    s.logT.push(s.t);
    s.logVego.push(s.vE);
    s.logVcut.push(s.vC);
    s.logAego.push(s.aE);
    s.logGap.push(s.xC - s.xE);

    // Readout
    ro_t.textContent = `${s.t.toFixed(1)} s`;
    ro_gap.textContent = `${gap.toFixed(1)} m`;
    ro_gdes.textContent = `${gDes.toFixed(1)} m`;
    ro_vego.textContent = `${(s.vE*3.6).toFixed(1)} km/h`;
    ro_vcut.textContent = `${(s.vC*3.6).toFixed(1)} km/h`;
    ro_aego.textContent = `${s.aE.toFixed(2)} m/s²`;

    updateCharts();
    drawBird();
  }

  function start(){
    if (!chartsInit) initCharts();
    if (!sim) initSim();
    if (sim.running) return;
    sim.running = true;
    btnStart.disabled = true;
    btnPause.disabled = false;
    updateCharts();
    timer = setInterval(step, dt*1000);
  }

  function stopSim(){
    if (!sim || !sim.running) return;
    clearInterval(timer); timer = null;
    sim.running = false;
    btnStart.disabled = false;
    btnPause.disabled = true;
    updateCharts();
  }

  function pause(){
    if (!sim || !sim.running) return;
    clearInterval(timer); timer = null;
    sim.running = false;
    btnStart.disabled = false;
    btnPause.disabled = true;
  }

  function reset(){
    if (timer){ clearInterval(timer); timer = null; }
    sim = null;
    btnStart.disabled = false;
    btnPause.disabled = true;
    if (!chartsInit) initCharts();
    charts.gp.data.labels = []; charts.gp.data.datasets[0].data=[]; charts.gp.data.datasets[1].data=[];
    charts.sp.data.labels = []; charts.sp.data.datasets[0].data=[]; charts.sp.data.datasets[1].data=[]; charts.sp.data.datasets[2].data=[];
    charts.ac.data.labels = []; charts.ac.data.datasets[0].data=[]; charts.ac.data.datasets[1].data=[];
    charts.gp.update('none'); charts.sp.update('none'); charts.ac.update('none');
    const c = document.getElementById('bird').getContext('2d');
    c.clearRect(0,0,document.getElementById('bird').width, document.getElementById('bird').height);
    ro_t.textContent='0.0 s'; ro_gap.textContent='—'; ro_gdes.textContent='—';
    ro_vego.textContent='—'; ro_vcut.textContent='—'; ro_aego.textContent='—';
    resetMilestones();
  }

  btnStart.addEventListener('click', start);
  btnPause.addEventListener('click', pause);
  btnReset.addEventListener('click', reset);

  // Prepare charts up front
  initCharts();
})();
</script>
</body>
</html>
