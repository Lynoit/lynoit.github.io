<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Reverse Geocode Road Features Live Plots</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 2em; }
    #info { margin-bottom: 1em; font-size: 1em; }
    #currentFeature {
      display: flex;
      align-items: center;
      margin-bottom: 1em;
      font-size: 1.2em;
    }
    #currentFeature .icon {
      font-size: 1.5em;
      margin-right: 0.5em;
    }
    #map { height: 300px; width: 100%; margin-bottom: 2em; border: 1px solid #ccc; }
    .chart-container { width: 100%; max-width: 600px; margin-bottom: 2em; }
  </style>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Live Road Feature Tracking</h1>
  <div id="info">Locating‚Ä¶</div>

  <!-- Current feature display -->
  <div id="currentFeature">
    <span class="icon">‚ùì</span>
    <span class="label">Unknown</span>
  </div>

  <div id="map"></div>

  <div id="charts">
    <div class="chart-container"><canvas id="speedChart"></canvas></div>
    <div class="chart-container"><canvas id="roundaboutChart"></canvas></div>
    <div class="chart-container"><canvas id="stopSignChart"></canvas></div>
    <div class="chart-container"><canvas id="trafficLightChart"></canvas></div>
    <div class="chart-container"><canvas id="bridgeChart"></canvas></div>
    <div class="chart-container"><canvas id="tunnelChart"></canvas></div>
    <div class="chart-container"><canvas id="roadTypeChart"></canvas></div>
    <div class="chart-container"><canvas id="cityChart"></canvas></div>
    <div class="chart-container"><canvas id="countryChart"></canvas></div>
    <div class="chart-container"><canvas id="tollChart"></canvas></div>
    <div class="chart-container"><canvas id="laneChart"></canvas></div>
    <div class="chart-container"><canvas id="surfaceChart"></canvas></div>
  </div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // Data arrays
    let lastPos = null;
    let totalDistance = 0;
    const distances     = [];
    const speeds        = [];
    const roundabouts   = [];
    const stopSigns     = [];
    const trafficLights = [];
    const bridges       = [];
    const tunnels       = [];
    const roadTypes     = [];
    const cities        = [];
    const countries     = [];
    const tolls         = [];
    const lanes         = [];
    const surfaces      = [];

    // Icon mapping for roadType = data.type
    const featureIcons = {
      motorway:       'üõ£Ô∏è',
      motorway_link:  'üõ£Ô∏è',
      trunk:          'üõ§Ô∏è',
      trunk_link:     'üõ§Ô∏è',
      primary:        'üöß',
      primary_link:   'üöß',
      secondary:      'üõ£Ô∏è',
      secondary_link: 'üõ£Ô∏è',
      tertiary:       'üöó',
      tertiary_link:  'üöó',
      residential:    'üè†',
      service:        '‚öôÔ∏è',
      cycleway:       'üö≤',
      footway:        'üö∂',
      unknown:        '‚ùì'
    };

    // Grab display elements
    const featureIconEl  = document.querySelector('#currentFeature .icon');
    const featureLabelEl = document.querySelector('#currentFeature .label');
    const info           = document.getElementById('info');
    const mapElem        = document.getElementById('map');

    // Setup map
    const map     = L.map(mapElem).setView([0,0],2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{
      attribution:'&copy; OSM contributors'
    }).addTo(map);
    const marker    = L.marker([0,0]).addTo(map);
    const routeLine = L.polyline([], { color:'blue', weight:3 }).addTo(map);

    // Haversine distance
    function haversine([lat1,lon1],[lat2,lon2]) {
      const R=6371000, toRad=x=>x*Math.PI/180;
      const dLat=toRad(lat2-lat1), dLon=toRad(lon2-lon1);
      const a=Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }

    // Chart factory
    const makeChart=(ctx,label,yLabel,yType='linear')=>new Chart(ctx,{
      type:'scatter',
      data:{datasets:[{label,data:[]}]},
      options:{
        scales:{
          x:{title:{display:true,text:'Distance (m)'}},
          y:{
            type:yType,
            title:{display:true,text:yLabel}
          }
        }
      }
    });

    // Init charts
    const speedChart        = makeChart(document.getElementById('speedChart'),      'Legal Speed',     'Speed (km/h)');
    const roundaboutChart   = makeChart(document.getElementById('roundaboutChart'),'Roundabout',      'Presence (1/0)');
    const stopSignChart     = makeChart(document.getElementById('stopSignChart'),  'Stop Sign',       'Presence (1/0)');
    const trafficLightChart = makeChart(document.getElementById('trafficLightChart'),'Traffic Light',   'Presence (1/0)');
    const bridgeChart       = makeChart(document.getElementById('bridgeChart'),    'Bridge',          'Presence (1/0)');
    const tunnelChart       = makeChart(document.getElementById('tunnelChart'),    'Tunnel',          'Presence (1/0)');
    const roadTypeChart     = makeChart(document.getElementById('roadTypeChart'),  'Road Type',       'Category','category');
    const cityChart         = makeChart(document.getElementById('cityChart'),      'City',            'Category','category');
    const countryChart      = makeChart(document.getElementById('countryChart'),   'Country',         'Category','category');
    const tollChart         = makeChart(document.getElementById('tollChart'),      'Toll Station',    'Presence (1/0)');
    const laneChart         = makeChart(document.getElementById('laneChart'),      'Number of Lanes', 'Lanes');
    const surfaceChart      = makeChart(document.getElementById('surfaceChart'),   'Surface',         'Category','category');

    // Update all
    function updateCharts() {
      const upd=(c,arr)=>{
        c.data.datasets[0].data = distances.map((d,i)=>({x:d,y:arr[i]}));
        if(c.options.scales.y.type==='category'){
          c.options.scales.y.labels = [...new Set(arr)];
        }
        c.update();
      };
      upd(speedChart,        speeds);
      upd(roundaboutChart,   roundabouts);
      upd(stopSignChart,     stopSigns);
      upd(trafficLightChart, trafficLights);
      upd(bridgeChart,       bridges);
      upd(tunnelChart,       tunnels);
      upd(roadTypeChart,     roadTypes);
      upd(cityChart,         cities);
      upd(countryChart,      countries);
      upd(tollChart,         tolls);
      upd(laneChart,         lanes);
      upd(surfaceChart,      surfaces);
    }

    // Reverse‚Äêgeocode + display
    let lastReverse=0, minInterval=1000;
    function reverseGeocode(lat,lon){
      const now=Date.now();
      if(now-lastReverse<minInterval) return;
      lastReverse=now;

      fetch(
        `https://nominatim.openstreetmap.org/reverse`
        + `?lat=${lat}&lon=${lon}`
        + `&format=jsonv2&extratags=1&zoom=16`
      )
      .then(r=>r.json())
      .then(data=>{
        const tags = data.extratags||{};
        const addr = data.address   || {};

        // Use data.type for road category
        const rt = (data.category==='highway' ? data.type : 'unknown') || 'unknown';

        // Extract features
        const features = {
          roadType:     rt,
          legalSpeed:   tags.maxspeed   || 'N/A',
          roundabout:   tags.junction   === 'roundabout',
          stopSign:     tags.highway    === 'stop',
          trafficLight: tags.highway    === 'traffic_signals',
          bridge:       tags.bridge     === 'yes',
          tunnel:       tags.tunnel     === 'yes',
          city:         addr.city||addr.town||addr.village||'Unknown',
          country:      addr.country    || 'Unknown'
        };
        const hasToll  = tags.toll   === 'yes';
        const numLanes = parseInt(tags.lanes,10)||NaN;
        const surfType = tags.surface      || 'Unknown';

        // Update current‚Äêfeature UI
        const icon = featureIcons[rt]||featureIcons.unknown;
        featureIconEl.textContent  = icon;
        featureLabelEl.textContent = rt.charAt(0).toUpperCase()+rt.slice(1);

        // Push into arrays
        distances.push(totalDistance);
        speeds.push(parseFloat(tags.maxspeed)||NaN);
        roundabouts.push(+features.roundabout);
        stopSigns.push(+features.stopSign);
        trafficLights.push(+features.trafficLight);
        bridges.push(+features.bridge);
        tunnels.push(+features.tunnel);
        roadTypes.push(features.roadType);
        cities.push(features.city);
        countries.push(features.country);
        tolls.push(+hasToll);
        lanes.push(numLanes);
        surfaces.push(surfType);

        // Update info & charts
        info.innerHTML = `<strong>Distance:</strong> ${totalDistance.toFixed(1)} m`;
        updateCharts();

        // Popup marker
        const popup = {
          ...features,
          tollStation: hasToll,
          lanes:       numLanes,
          surface:     surfType
        };
        const popupHtml = Object.entries(popup)
                            .map(([k,v])=>`<strong>${k}:</strong> ${v}`)
                            .join('<br>');
        L.marker([lat,lon]).bindPopup(popupHtml).addTo(map);
      })
      .catch(console.error);
    }

    // Watch position
    function updatePosition(pos){
      const [lat,lon] = [pos.coords.latitude, pos.coords.longitude];
      if(lastPos) totalDistance += haversine(lastPos,[lat,lon]);
      lastPos = [lat,lon];
      map.setView([lat,lon],16);
      marker.setLatLng([lat,lon]);
      routeLine.addLatLng([lat,lon]);
      reverseGeocode(lat,lon);
    }
    function handleError(e){
      info.textContent = `Geolocation error: ${e.message}`;
    }
    if(navigator.geolocation){
      navigator.geolocation.watchPosition(
        updatePosition, handleError,
        { enableHighAccuracy:true, maximumAge:0, timeout:5000 }
      );
    } else {
      info.textContent = 'Geolocation not supported.';
    }
  </script>
</body>
</html>
