<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Annotator Reports Viewer</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #fff; color: #000; }
#sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 320px; background: #f5f5f5; overflow-y: auto; border-right: 1px solid #ddd; }
#content { margin-left: 320px; padding: 20px; }

/* Sidebar accordion affordance */
.day-header{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  padding:10px 12px 10px 32px;           /* space for chevron */
  font-weight:600; background:#f8f9fb;   /* subtle card look */
  position:relative; cursor:pointer;
  border-bottom:1px solid #ddd;
}
.day-header:hover{ background:#eef2f9; }
.day-header:focus-visible{
  outline:2px solid var(--accent, #1f3de3);
  outline-offset:2px; border-radius:6px;
}
/* Chevron */
.day-header::before{
  content:'‚ñ∂'; position:absolute; left:12px; top:50%;
  transform:translateY(-50%); font-size:12px; color:#555;
  transition: transform .2s ease;
}
.day-header[aria-expanded="true"]::before{
  transform:translateY(-50%) rotate(90deg);
}
/* Count pill on the right */
.day-count{
  background:#e9eefc; color:#1f3de3; font-weight:700; font-size:11px;
  padding:2px 6px; border-radius:999px; border:1px solid #cbd5ff;
}

/* Append small "tests" text inside the badge */
.day-count::after{
  content: " tests";
  font-size: 10px;
  font-weight: 600;
  opacity: .8;
  margin-left: 4px;
}
    .session-list { display: none; list-style: none; margin: 0; padding: 0; }
    .session-item { padding: 8px 32px; cursor: pointer; border-bottom: 1px solid #eee; }
    .session-item:hover { background: #f0f0f0; }
    .session-item .meta { font-size: 12px; color: #666; margin-top: 2px; }

    h1 { margin: 0 0 12px 0; }
    h2 { margin-top: 1.5em; border-bottom: 1px solid #ddd; padding-bottom: 4px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 2em; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #f5f5f5 !important; }
    .error { color: #d00; padding: 16px; }

    .issue-badge { display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: red; color: white; border-radius: 12px; font-size: 12px; font-weight: bold; pointer-events: none; }
    #issue-map { width: 100%; height: 400px; margin: 20px 0; border: 1px solid #aaa; }

    .download-button { display: inline-block; margin-right: 12px; margin-bottom: 16px; padding: 8px 12px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; font-size: 14px; }
    .download-button:hover { background: #0056b3; }

    /* Overview (four charts side by side) */
    .overview {
      max-width: none;
      width: 100%;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 20px;
      align-items: start;
    }
    .heatmap-months { font-size: 12px; fill: #333; }
    .heatmap-dow { font-size: 12px; fill: #666; }
    .legend{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:12px;
  color:#666;
  margin-top:10px;
  justify-content:flex-end; 
}
    .legend .box { width: 12px; height: 12px; border: 1px solid #ccd3d9; }

    /* Latest routes grid */
    .routes-wrap { margin-top: 18px; }
    .route-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px,1fr)); gap: 14px; max-width: none; width: 100%; }
    .route-card { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
    .route-title { font-size: 13px; color: #333; margin-bottom: 8px; }
    /* keep the old style for non-enhanced anchors only */
    .route-title a:not(.route-link) { color: inherit; text-decoration: none; }
    .route-title a:not(.route-link):hover { text-decoration: underline; }
    .route-meta { font-size: 12px; color: #666; margin-top: 6px; }
    .route-map { width: 100%; height: clamp(180px, 20vw, 320px); border: 1px solid #aaa; border-radius: 6px; }

    /* Make "Test activity overview" same size as "Latest routes" */
    #title-overview { font-size: 1.5em; }

    /* Remove the line under "Latest routes" only */
    .routes-wrap > h2{ border-bottom: none !important; padding-bottom: 0; }
    /* Remove the line under "Mileage per country" */
    .eu-mileage-wrap > h2 { border-bottom: none !important; padding-bottom: 0; }

    /* --- Link-stylish treatment for Latest routes title links --- */
    :root{ --accent:#1f3de3; }
    .route-link{
      display:inline-flex; align-items:center; gap:8px;
      color:var(--accent); font-weight:700; text-decoration:none;
    }
    .route-link .u{
      background-image: linear-gradient(currentColor,currentColor);
      background-repeat: no-repeat;
      background-size: 100% 2px;
      background-position: 0 100%;
      text-underline-offset: 4px;
      padding-bottom: 2px;
    }
    .route-link::after{
      content:"‚Ä∫"; font-size:1.05em; opacity:.6;
      transform: translateX(0);
      transition: transform .18s ease, opacity .18s ease;
    }
    .route-link:hover, .route-link:focus{ color:#1430c9; }
    .route-link:hover::after, .route-link:focus::after{ transform: translateX(3px); opacity:1; }
    .route-link:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:4px; }
    .route-link{ color:#000 !important; text-decoration:none !important; }
    .route-link .u{ background-image:none !important; padding-bottom:0; }
    .route-link:hover, .route-link:focus{ color:#000; text-decoration:none; }
    .route-title a.route-link:hover{ text-decoration:none; }

    .route-overlay .route-link{ color:#000; text-shadow:none; }
    .route-overlay .route-link .u{ background-image:none; }

    .route-link:focus-visible{ outline:2px solid #000; outline-offset:2px; border-radius:4px; }
    .route-title a.route-link:hover{ text-decoration:none; }

    /* ===== Typing indicator for titles ===== */
    .title-thinking { display:inline-flex; align-items:center; gap:6px; }
    .title-thinking .dots { display:inline-flex; gap:4px; }
    .title-thinking .dot {
      width:6px; height:6px; border-radius:50%;
      background:#888; opacity:.25;
      animation:titleBlink 1.2s infinite both;
    }
    .title-thinking .dot:nth-child(2){ animation-delay:.2s; }
    .title-thinking .dot:nth-child(3){ animation-delay:.4s; }
    @keyframes titleBlink {
      0%, 80%, 100% { opacity:.25; }
      40% { opacity:1; }
    }

    /* ===== Make chart SVGs scale to container width ===== */
    #heatmap-host svg,
    #country-host svg,
    #temp-host svg,
    #weather-host svg {
      width: 100%;
      height: auto;
      display: block;
    }

 /* KPI badge (uses same s1..s10 colors as score boxes) */
.kpi-badge{
  display:inline-flex; align-items:center; justify-content:center;
  padding:1px 6px;              /* was 2px 8px */
  margin-left:6px;              /* was 8px */
  border-radius:999px;
  font-size:10px;               /* was 11px */
  line-height:1;                /* tighter box */
  font-weight:700;
  border:1px solid rgba(0,0,0,.15);
  vertical-align:middle;        /* nicer alignment next to text */
}

    /* === Active badge for live sessions === */
.active-badge{
  display:inline-flex; align-items:center; justify-content:center;
  padding:2px 8px; margin-left:8px;
  background:#e01616; color:#fff; font-weight:700; font-size:11px;
  border-radius:999px; border:1px solid rgba(0,0,0,.15);
  animation: activeBlink 2s steps(2, end) infinite; /* 0.5 Hz (on/off every 1s) */
}
@keyframes activeBlink{
  0%{ opacity:1; }
  50%{ opacity:0; }
  100%{ opacity:1; }
}
/* Row for session title + badge */
.session-title-row{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
}

    /* ===== EU Mileage Map styles (NEW) ===== */
    .eu-mileage-map{
      width: 100%;
      height: clamp(300px, 40vw, 560px);
      border: 1px solid #aaa;
      border-radius: 6px;
      margin-top: 8px;
    }
    /* white, bold numbers over red dots */
    .leaflet-tooltip.eu-mileage-label{
      background: transparent;
      border: none;
      box-shadow: none;
      color: #fff;
      font-weight: 800;
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
      pointer-events: none;
    }

    /* Hide 1px seams between Leaflet raster tiles (Chrome/DPR ‚â† 1) */
.eu-mileage-map .leaflet-tile {
  width: 257px !important;   /* default tile is 256px ‚Üí overlap by 1px */
  height: 257px !important;
}

    /* === KPI scoring legend (below KPI table) === */
.score-legend{display:flex;align-items:stretch;border:1px solid #ccc;border-radius:6px;overflow:hidden;margin:10px 0 22px}
.score-box{flex:1;min-width:0;text-align:center;color:#fff;line-height:1.1;padding:6px 6px}
.score-box strong{display:block;font-size:14px}
.score-box small{display:block;font-size:11px;opacity:.95}
.score-th{display:block;font-size:10px;background:#f5f5f5;color:#000;border-top:1px solid #ddd;padding:3px 0}

/* colors 1..10 (red ‚Üí green) */
.s1{background:#c30000}.s2{background:#d62828}.s3{background:#e05d00}.s4{background:#ef8e00}.s5{background:#f4b400}
.s6{background:#ffe24a;color:#111}.s7{background:#b8df4a}.s8{background:#33a653}.s9{background:#0f9d8c}.s10{background:#216e39}

.kpi-avg{margin:8px 0 16px;font-size:13px;color:#222}
.kpi-avg .v{font-weight:700}

    /* highlight the selected score box + small caption */
.score-box.sel{ outline:3px solid rgba(0,0,0,.7); box-shadow: inset 0 0 0 2px rgba(255,255,255,.4); }
.score-legend-caption{ margin:6px 0 16px; font-size:12px; color:#333; }
/* Only the selected score box has black text + black frame */
.score-legend .score-box:not(.sel){ color:#fff; }                /* all others: white text */
.score-legend .score-box.sel{ color:#000 !important; }           /* selected: black text */
.score-legend .score-box.sel{ outline:3px solid #000; box-shadow: inset 0 0 0 2px rgba(255,255,255,.4); }   
/* Let outer frame be visible */
.score-legend{ overflow: visible !important; }

/* Make non-selected boxes use white text (overrides .s6 default) */
.score-legend .score-box:not(.sel){ color:#fff !important; }

/* Selected box: black text + thick black frame (tune --sel-frame) */
:root{ --sel-frame: 2px; } /* <- adjust thickness here */
.score-legend .score-box.sel{
  color:#000 !important;
  position: relative;
  z-index: 1;
  /* inner frame is always visible; outer frame gives extra thickness if not clipped */
  box-shadow:
    inset 0 0 0 var(--sel-frame) #000,
    0 0 0 calc(var(--sel-frame) - 1px) #000;
}
    .kpi-avg{
  text-align:right;
  margin: 4px 0 10px;   /* tighter gap below the table */
  font-size:13px; color:#222;
}

  </style>
</head>
<body>
  <div id="sidebar">
    <h2 style="padding:16px; margin:0; border-bottom:1px solid #ddd;">Test sessions</h2>
  </div>

  <div id="content">
    <!-- Pre-render headings in "Loading" state to avoid flicker -->
    <h1 id="title-overview" data-title="Test activity overview" data-loading="1">
      <span>Loading</span>
      <span class="title-thinking">
        <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
      </span>
    </h1>
    <div id="overview" class="overview">
      <div><div id="heatmap-host"></div></div>
      <div><div id="country-host"></div></div>
      <div><div id="temp-host"></div></div>
      <div><div id="weather-host"></div></div>

      <!-- NEW: EU Mileage map block (spans full width, before latest routes) -->
      <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
        <h2 id="title-eu-mileage" data-title="Mileage per country" data-loading="1" style="margin-top:16px;">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h2>
        <div id="eu-mileage-map" class="eu-mileage-map"></div>
      </div>

      <div class="routes-wrap" style="grid-column: 1 / -1;">
        <h2 id="title-latest-routes" data-title="Latest routes" data-loading="1" style="margin-top:16px;">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h2>
        <div id="routes-grid" class="route-grid"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>

  <script>
    // ---------- CONFIG ----------
    const ACCOUNT   = 'annotationcsv';
    const CONTAINER = 'csv';
    const SAS_TOKEN = 'sv=2024-11-04&ss=bfqt&srt=co&sp=rwdlacupiytfx&se=2025-12-30T14:44:25Z&st=2025-05-30T05:44:25Z&spr=https&sig=QriUtSG3IFzzE3cz7vpcXpE7Ed6QDwSYSZ6YvT2kM%2B0%3D';
    const BASE_URL  = `https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}`;
    const MIN_KM_FOR_OVERVIEW = 1;
    const ACTIVE_WINDOW_MS = 10 * 60 * 1000; // 10 minutes

    // ---------- CACHES / HELPERS ----------
    const summaryCache = new Map(); // filename -> { mileageKm, issueCount, meanTempC, weatherAgg, loaded:true }
    const blobMeta = new Map();     // filename -> lastModifiedMs (strict sort)
    const countryCache = new Map(); // filename -> array of countries

    // Parse each workbook at most once per session
const workbookCache = new Map(); // filename -> Promise<{ wb, buf }>
function loadWorkbook(filename) {
  if (workbookCache.has(filename)) return workbookCache.get(filename);
  const p = (async () => {
    const res = await fetch(`${BASE_URL}/${filename}?${SAS_TOKEN}`, { cache: 'default' });
    const buf = await res.arrayBuffer();
    const wb  = XLSX.read(new Uint8Array(buf), { type:'array' });
    return { wb, buf };
  })();
  workbookCache.set(filename, p);
  return p;
}

    function cssSafeId(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g,'_'); }
    function toDateOnly(d){ const t = new Date(d); t.setHours(0,0,0,0); return t; }

    // Append a timestamp so each request URL is unique ‚Üí bypasses caches.
function nc(url){
  return url + (url.includes('?') ? '&' : '?') + 'ts=' + Date.now();
}

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    /* Title loading indicator helper (uses data-title, default "Loading") */
    function setTitleLoading(el, on, labelText = 'Loading') {
      if (!el) return;
      if (on) {
        if (el.dataset.loading === '1') return; // already loading
        el.dataset.loading = '1';
        el.dataset.originalText = el.dataset.title || el.textContent;
        el.innerHTML = `
          <span>${labelText}</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>`;
      } else {
        if (el.dataset.loading !== '1') return;
        const txt = el.dataset.title || el.dataset.originalText || el.textContent;
        el.textContent = txt;
        delete el.dataset.loading;
        delete el.dataset.originalText;
      }
    }

    function computeMileageAndPathFromSampling(sheet) {
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (rows.length < 3) return { km: null, path: [] };

      const headers = rows[0].map(h => String(h ?? '').toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return { km: null, path: [] };

      let km = 0, prev = null;
      const path = [];
      for (let i = 1; i < rows.length; i++) {
        const lat = parseFloat(rows[i][latIdx]);
        const lon = parseFloat(rows[i][lonIdx]);
        if (isNaN(lat) || isNaN(lon)) continue;
        path.push([lat, lon]);
        if (prev) km += haversine(prev[0], prev[1], lat, lon) / 1000;
        prev = [lat, lon];
      }
      return { km: Math.round(km), path };
    }

    // --- Mean Temp + Mode Weather from the "Issue/Issues" sheet ---
    function computeTempWeatherFromIssuesSheet(sheet){
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
      if (rows.length < 2) return { meanTempC: null, weatherAgg: null };

      const headers = rows[0].map(h => String(h ?? '').trim().toLowerCase());
      const tempIdx = headers.findIndex(h => /\btemp\b/.test(h) || /temperature/.test(h));
      const wxIdx   = headers.findIndex(h => /weather/.test(h) || /condition/.test(h));

      const temps = [];
      const wxCounts = new Map();

      const normWx = (s)=>{
        if (s == null) return null;
        const v = String(s).trim().toLowerCase();
        if (!v) return null;
        if (/thunder|storm/.test(v)) return 'Storm';
        if (/snow|blizzard|sleet/.test(v)) return 'Snow';
        if (/rain|drizzle|shower/.test(v)) return 'Rain';
        if (/fog|mist|haze/.test(v)) return 'Fog';
        if (/cloud|overcast/.test(v)) return 'Cloudy';
        if (/clear|sun/.test(v)) return 'Clear';
        if (/wind/.test(v)) return 'Wind';
        return v.charAt(0).toUpperCase() + v.slice(1);
      };

      const parseTempFromValue = (val) => {
        if (val == null) return null;
        const s = String(val).trim();
        if (!s) return null;
        let m = s.match(/(-?\d+(?:[.,]\d+)?)\s*¬∞?\s*c\b/i);
        if (!m) m = s.match(/temp(?:erature)?[^0-9\-]*(-?\d+(?:[.,]\d+)?)/i);
        if (!m) return null;
        const num = parseFloat(m[1].replace(',', '.'));
        return Number.isFinite(num) ? num : null;
      };

      for (let r = 1; r < rows.length; r++){
        const row = rows[r];
        if (tempIdx >= 0){
          const t = parseTempFromValue(row[tempIdx]);
          if (t != null) temps.push(t);
        } else {
          for (let c = 0; c < row.length; c++){
            const t = parseTempFromValue(row[c]);
            if (t != null){ temps.push(t); break; }
          }
        }

        if (wxIdx >= 0){
          const w = normWx(row[wxIdx]);
          if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
        } else {
          for (let c = 0; c < row.length; c++){
            const cell = row[c];
            if (cell == null) continue;
            const m = String(cell).match(/weather\s*:\s*([a-z][a-z\s\-]+)/i);
            if (m){
              const w = normWx(m[1]);
              if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
              break;
            }
          }
        }
      }

      const meanTempC = temps.length
        ? Math.round((temps.reduce((a,b)=>a+b,0) / temps.length) * 10) / 10
        : null;

      let weatherAgg = null;
      if (wxCounts.size){
        weatherAgg = Array.from(wxCounts.entries()).sort((a,b)=> b[1] - a[1])[0][0];
      }

      return { meanTempC, weatherAgg };
    }

    function computeTempWeatherFromIssues(wb){
      const issueSheets = wb.SheetNames.filter(n => /issue/i.test(n));
      for (const name of issueSheets){
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      for (const name of wb.SheetNames){
        if (name.toLowerCase() === 'sampling') continue;
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      return { meanTempC: null, weatherAgg: null };
    }

    function countIssuesFromWorkbook(wb) {
      const norm = s => String(s||'').toLowerCase().replace(/\s+/g,'');
      for (const name of wb.SheetNames) {
        if (name.toLowerCase() === 'sampling') continue;
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[name], { header: 1 });
        if (rows.length < 2) continue;
        const hdrs = rows[0].map(norm);
        const latIdx = hdrs.findIndex(h => h.includes('lat'));
        const lonIdx = hdrs.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
        if (latIdx < 0 || lonIdx < 0) continue;
        let count = 0;
        for (let i = 1; i < rows.length; i++) {
          const lat = parseFloat(rows[i][latIdx]);
          const lon = parseFloat(rows[i][lonIdx]);
          if (!isNaN(lat) && !isNaN(lon)) count++;
        }
        if (count > 0) return count;
      }
      return 0;
    }
    
    // Reads "Statistics" sheet ‚Üí row/col labeled "Total test distance" (e.g. "518.6 km")
function extractTotalDistanceKmFromStatistics(wb){
  const sheetName = wb.SheetNames.find(n => /statistics/i.test(n));
  if (!sheetName) return null;

  const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1, blankrows: false });
  if (!rows || !rows.length) return null;

  const norm = v => String(v ?? '').trim();
  const isLabel = v => /total\s*test\s*distance/i.test(String(v ?? ''));

  const parseKm = v => {
    if (v == null) return null;
    const s = norm(v);
    if (!s) return null;
    // match "518.6 km" or "518,6 km" or plain number
    let m = s.match(/(-?\d+(?:[.,]\d+)?)\s*km\b/i);
    if (!m) m = s.match(/-?\d+(?:[.,]\d+)?/);
    if (!m) return null;
    const val = parseFloat(m[0].replace(',', '.'));
    return Number.isFinite(val) ? Math.round(val) : null; // keep km as integer like before
  };

  // Try common key‚Üívalue patterns
  for (let r = 0; r < rows.length; r++){
    const row = rows[r];
    for (let c = 0; c < row.length; c++){
      if (isLabel(row[c])){
        // prefer right cell, else cell below
        const right = (c + 1 < row.length) ? row[c+1] : null;
        const down  = (rows[r+1]?.[c]);
        const fromRight = parseKm(right);
        if (fromRight != null) return fromRight;
        const fromDown  = parseKm(down);
        if (fromDown  != null) return fromDown;
      }
    }
  }

  // Fallback: scan entire sheet for a lone "518.6 km"
  for (let r = 0; r < rows.length; r++){
    for (let c = 0; c < rows[r].length; c++){
      const km = parseKm(rows[r][c]);
      if (km != null) return km;
    }
  }
  return null;
}

// Extract [lat, lon] points from the first non-Sampling sheet that has lat/lon
function extractIssueCoordsFast(wb){
  const out = [];
  const isOK = (lat, lon) =>
    Number.isFinite(lat) && Number.isFinite(lon) &&
    lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;

  for (const name of wb.SheetNames){
    if (name.toLowerCase() === 'sampling') continue;

    const rows = XLSX.utils.sheet_to_json(wb.Sheets[name], { header: 1, blankrows: false });
    if (rows.length < 2) continue;

    const hdrs = rows[0].map(h => String(h ?? '').toLowerCase());
    const latIdx = hdrs.findIndex(h => h.includes('lat'));
    const lonIdx = hdrs.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
    if (latIdx < 0 || lonIdx < 0) continue;

    for (let r = 1; r < rows.length; r++){
      const lat = parseFloat(rows[r][latIdx]);
      const lon = parseFloat(rows[r][lonIdx]);
      if (isOK(lat, lon)) out.push([lat, lon]);
    }
    break; // first sheet with coords is enough
  }
  return out;
}
    
// Uses loadWorkbook(filename) ‚Üí Promise<{ wb, buf }>
async function fetchSessionSummary(filename) {
  if (summaryCache.has(filename)) return summaryCache.get(filename);

  const { wb } = await loadWorkbook(filename);

  // 1) Mileage (Statistics preferred, Sampling fallback)
  let mileageKm = extractTotalDistanceKmFromStatistics(wb);
  if (mileageKm == null) {
    const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
    if (samplingName) {
      const { km } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
      mileageKm = km;
    }
  }

  // 2) Temp/Weather + issue count
  const { meanTempC, weatherAgg } = computeTempWeatherFromIssues(wb);
  const issueCount = countIssuesFromWorkbook(wb);

  // 3) Test details
  let testObject = null, testPurpose = null;
  try {
    const details = extractTestDetails(wb);
    testObject  = details['test object'] || details['object'] || details['vehicle'] || null;
    testPurpose = details['purpose'] || details['test purpose'] || null;
  } catch {}

  // 4) KPI score (sum column / total KPIs ‚Üí 1 decimal ‚Üí scoreFromRate)
  let kpiScore = null, kpiAvgPer1k = null;
  try {
    const totalKpis = await getTotalKpis();
    if (typeof totalKpis === 'number' && totalKpis > 0) {
      const kpiSheetName = wb.SheetNames.find(n => /kpi/i.test(n));
      if (kpiSheetName && typeof extractAvgEventsPer1kFromSheet === 'function') {
        // NOTE: your extractAvgEventsPer1kFromSheet returns the SUM (by design)
        const sum = extractAvgEventsPer1kFromSheet(wb.Sheets[kpiSheetName]);
        if (sum != null) {
          const avg = sum / totalKpis;
          kpiAvgPer1k = Math.round(avg * 10) / 10;   // 1 decimal
          kpiScore    = scoreFromRate(kpiAvgPer1k);  // 1..10
        }
      }
    }
  } catch {}

  const summary = {
    mileageKm, issueCount, meanTempC, weatherAgg,
    testObject, testPurpose,
    kpiScore, kpiAvgPer1k,
    loaded: true
  };

  summaryCache.set(filename, summary);
  return summary;
}

    // Read "Test details" sheet (col1=label, col2=value) ‚Üí map
function extractTestDetails(wb){
  const details = {};
  const sheetName = wb.SheetNames.find(n => /test\s*details/i.test(n));
  if (!sheetName) return details;

  const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1, blankrows: false });
  for (let r = 0; r < rows.length; r++) {
    const row = rows[r];
    if (!row || row.length < 2) continue;
    const keyRaw = row[0];
    const valRaw = row[1];
    if (keyRaw == null || valRaw == null) continue;
    const key = String(keyRaw).trim().toLowerCase();
    const val = String(valRaw).trim();
    if (!key || !val) continue;
    details[key] = val;
  }
  return details;
}

    // --- Countries parser (from "Country" sheet or fallback Test details) ---
// Uses loadWorkbook(filename) ‚Üí Promise<{ wb, buf }>
function fetchCountriesForFile(filename){
  if (countryCache.has(filename)) {
    const cached = countryCache.get(filename);
    return Promise.resolve(Array.isArray(cached) ? cached : (cached ? [cached] : []));
  }

  return loadWorkbook(filename)
    .then(({ wb }) => {
      const out = new Set();

      // Prefer a sheet that looks like "Country"
      const countrySheetName = wb.SheetNames.find(n => /country/i.test(n));
      if (countrySheetName) {
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[countrySheetName], { header: 1, blankrows: false });
        if (rows.length) {
          const headers = rows[0].map(v => String(v ?? '').trim().toLowerCase());
          const colIdx = headers.findIndex(h => h.includes('country'));
          if (colIdx >= 0) {
            for (let r = 1; r < rows.length; r++) {
              const v = rows[r][colIdx];
              if (v != null && String(v).trim()) out.add(String(v).trim());
            }
          } else {
            // Fallback: try simple key/value style or single-column lists
            for (let r = 0; r < rows.length; r++) {
              const a = rows[r][0], b = rows[r][1];
              const aStr = String(a ?? '').trim().toLowerCase();
              if (aStr.includes('country') && b != null && String(b).trim()) out.add(String(b).trim());
              if (!aStr && rows[r].length === 1) {
                const val = rows[r][0];
                if (val != null && String(val).trim()) out.add(String(val).trim());
              }
            }
          }
        }
      }

      // If still empty, fall back to "Test details"
      if (out.size === 0) {
        const details = extractTestDetails(wb);
        const maybe = details['country'] || details['test country'] || details['location country'] || null;
        if (maybe && String(maybe).trim()) out.add(String(maybe).trim());
      }

      // Normalize to English when possible (e.g., "Sverige" -> "Sweden"),
      // but keep original label if we don't have a mapping.
      const normalized = Array.from(out)
        .map(s => String(s).trim())
        .filter(Boolean)
        .map(s => (typeof canonicalEU === 'function' ? (canonicalEU(s) || s) : s));

      countryCache.set(filename, normalized);
      return normalized;
    })
    .catch(() => {
      countryCache.set(filename, []);
      return [];
    });
}

// ---------- Europe country canonical names & centroids (EXPANDED) ----------
const EU_CENTROIDS = {
  // EU (unchanged)
  'Austria':[47.6,14.3],'Belgium':[50.6,4.7],'Bulgaria':[42.8,25.3],'Croatia':[45.1,15.4],
  'Cyprus':[35.1,33.4],'Czechia':[49.8,15.5],'Denmark':[56.0,10.0],'Estonia':[58.7,25.0],
  'Finland':[64.5,26.0],'France':[46.2,2.2],'Germany':[51.2,10.4],'Greece':[39.1,22.9],
  'Hungary':[47.2,19.5],'Ireland':[53.2,-8.0],'Italy':[42.8,12.5],'Latvia':[56.9,24.6],
  'Lithuania':[55.3,23.9],'Luxembourg':[49.8,6.1],'Malta':[35.9,14.4],'Netherlands':[52.2,5.3],
  'Poland':[52.0,19.1],'Portugal':[39.6,-8.0],'Romania':[45.9,24.9],'Slovakia':[48.7,19.5],
  'Slovenia':[46.1,14.8],'Spain':[40.3,-3.7],'Sweden':[62.0,15.0],

  // Non-EU Europe (added)
  'Albania':[41.2,20.2],
  'Andorra':[42.5,1.6],
  'Armenia':[40.3,44.9],
  'Azerbaijan':[40.1,47.8],
  'Belarus':[53.7,27.9],
  'Bosnia and Herzegovina':[44.2,17.7],
  'Iceland':[64.9,-18.6],
  'Kosovo':[42.6,20.9],
  'Liechtenstein':[47.1,9.6],
  'Moldova':[47.0,28.7],
  'Monaco':[43.73,7.42],
  'Montenegro':[42.8,19.2],
  'North Macedonia':[41.6,21.7],
  'Norway':[64.5,11.0],
  'Russia':[55.7,37.6],          // Moscow as European centroid
  'San Marino':[43.94,12.46],
  'Serbia':[44.0,20.8],
  'Switzerland':[46.8,8.2],
  'Turkey':[39.0,35.0],          // overall centroid; still fine for a single marker
  'Ukraine':[49.0,32.0],
  'United Kingdom':[54.2,-2.0],
  'Vatican City':[41.90,12.45],
  'Georgia':[42.3,43.4]
};
const EU_CANON_LOWER = {};
Object.keys(EU_CENTROIDS).forEach(k => EU_CANON_LOWER[k.toLowerCase()] = k);

// Common aliases / language variants ‚Üí canonical keys above
const COUNTRY_ALIASES = {
  'czech republic':'czechia',
  'the netherlands':'netherlands',
  'sverige': 'sweden',
  'kina': 'china',

  'rom√¢nia':'romania','republic of moldova':'moldova',
  'deutschland':'germany','√∂sterreich':'austria','oesterreich':'austria',
  'espa√±a':'spain','espana':'spain','italia':'italy',
  'magyarorsz√°g':'hungary','polska':'poland','suomi':'finland',
  'ell√°da':'greece','ellada':'greece',

  'bosnia-herzegovina':'bosnia and herzegovina','bosnia':'bosnia and herzegovina',
  'macedonia':'north macedonia','fyrom':'north macedonia',

  'uk':'united kingdom','u.k.':'united kingdom','gb':'united kingdom',
  'great britain':'united kingdom','england':'united kingdom',
  'scotland':'united kingdom','wales':'united kingdom','northern ireland':'united kingdom',

  'russian federation':'russia',
  't√ºrkiye':'turkey','turkiye':'turkey',

  'cote d‚Äôivoire':'c√¥te d‚Äôivoire' // (example of normalization pattern; harmless if unused)
};

function canonicalEU(raw){
  if (!raw) return null;
  let s = String(raw).trim();

  // Drop bracket comments like "Serbia (RS)"
  s = s.replace(/\(.*?\)/g,'').trim();

  let k = s.toLowerCase();
  if (COUNTRY_ALIASES[k]) k = COUNTRY_ALIASES[k];

  // Exact match
  if (EU_CANON_LOWER[k]) return EU_CANON_LOWER[k];

  // Try simple title case fallback (e.g., "serbia" ‚Üí "Serbia")
  const tc = k.replace(/\b\w/g, c => c.toUpperCase());
  return EU_CENTROIDS[tc] ? tc : null;
}

    // ---------- APP STATE ----------
    let issueCoords = [];
    let samplingCoords = [];
    let mapRef = null;
    let samplingLayerGroup = null;
    let allFiles = []; // used to re-render overview

    document.addEventListener('DOMContentLoaded', listBlobs);

    // Helper to render the default overview page
    function renderOverview(){
      const content = document.getElementById('content');
      content.innerHTML = `
        <h1 id="title-overview" data-title="Test activity overview" data-loading="1">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h1>
        <div id="overview" class="overview">
          <div><div id="heatmap-host"></div></div>
          <div><div id="country-host"></div></div>
          <div><div id="temp-host"></div></div>
          <div><div id="weather-host"></div></div>

          <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
            <h2 id="title-eu-mileage" data-title="Mileage per country" data-loading="1" style="margin-top:16px;">
              <span>Loading</span>
              <span class="title-thinking">
                <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
              </span>
            </h2>
            <div id="eu-mileage-map" class="eu-mileage-map"></div>
          </div>

          <div class="routes-wrap" style="grid-column: 1 / -1;">
            <h2 id="title-latest-routes" data-title="Latest routes" data-loading="1" style="margin-top:16px;">
              <span>Loading</span>
              <span class="title-thinking">
                <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
              </span>
            </h2>
            <div id="routes-grid" class="route-grid"></div>
          </div>
        </div>
      `;
      if (allFiles.length){
        const h1 = document.getElementById('title-overview');
        const h2 = document.getElementById('title-latest-routes');
        const hEU = document.getElementById('title-eu-mileage');
        setTitleLoading(h1, true, 'Loading');
        setTitleLoading(h2, true, 'Loading');
        setTitleLoading(hEU, true, 'Loading');

        buildOverviewHeatmap(allFiles).finally(() => setTitleLoading(h1, false));
        buildCountryMonthChart(allFiles);
        buildTempMonthChart(allFiles);
        buildWeatherMonthChart(allFiles);
        buildEUMileageMap(allFiles).finally(() => setTitleLoading(hEU, false));
        buildLatestRoutePreviews(allFiles).finally(() => setTitleLoading(h2, false));
      }
    }

    function listBlobs() {
      fetch(nc(`${BASE_URL}?restype=container&comp=list&${SAS_TOKEN}`), { cache:'default' })
        .then(r => r.text())
        .then(xml => {
          const doc = new DOMParser().parseFromString(xml, 'application/xml');

          // Read blobs with their Last-Modified timestamps
          const blobs = Array.from(doc.getElementsByTagName('Blob')).map(b => {
            const name = b.getElementsByTagName('Name')[0]?.textContent || '';
            const lmEl = b.getElementsByTagName('Last-Modified')[0] ||
                         b.getElementsByTagName('Properties')[0]?.getElementsByTagName('Last-Modified')[0];
            const lm   = lmEl?.textContent || '';
            return { name, lastModifiedMs: Date.parse(lm) || 0 };
          });

          const xlsx = blobs.filter(b => b.name.toLowerCase().endsWith('.xlsx'));
          if (xlsx.length === 0) { showError('No .xlsx files found.'); return; }

          // Cache for strict chronological sorting
          blobMeta.clear();
          xlsx.forEach(b => blobMeta.set(b.name, b.lastModifiedMs));

          const xlsxNames = xlsx.map(b => b.name);
          allFiles = xlsxNames; // remember for overview re-render

          buildSidebar(xlsxNames);

          const h1 = document.getElementById('title-overview');
          const h2 = document.getElementById('title-latest-routes');
          const hEU = document.getElementById('title-eu-mileage');
          setTitleLoading(h1, true, 'Loading');
          setTitleLoading(h2, true, 'Loading');
          setTitleLoading(hEU, true, 'Loading');

          buildOverviewHeatmap(xlsxNames).finally(() => setTitleLoading(h1, false));
          buildCountryMonthChart(xlsxNames);
          buildTempMonthChart(xlsxNames);
          buildWeatherMonthChart(xlsxNames);
          buildEUMileageMap(xlsxNames).finally(() => setTitleLoading(hEU, false));
          buildLatestRoutePreviews(xlsxNames).finally(() => setTitleLoading(h2, false));
        })
        .catch(err => showError('Failed to list blobs: ' + err));
    }

    // ---------- SIDEBAR ----------
  function buildSidebar(files) {
  const sb = document.getElementById('sidebar');
  sb.innerHTML = '';
  const header = document.createElement('h2');
  header.textContent = 'Test sessions';
  header.style.padding = '16px';
  header.style.margin = '0';
  header.style.borderBottom = '1px solid #ddd';
  header.style.cursor = 'pointer';
  header.title = 'Back to overview';
  header.addEventListener('click', (e) => { e.preventDefault(); renderOverview(); });
  sb.appendChild(header);

  const groups = files.reduce((acc, f) => {
    const m = f.match(/(\d{4}-\d{2}-\d{2})/);
    if (!m) return acc;
    (acc[m[1]] ||= []).push(f);
    return acc;
  }, {});

  Object.keys(groups).sort().reverse().forEach(day => {
    const hdr = document.createElement('div');
    hdr.className = 'day-header';
    hdr.setAttribute('role','button');
    hdr.setAttribute('aria-expanded','false');
    hdr.tabIndex = 0;
    hdr.title = 'Show sessions';

    const label = document.createElement('span');
    label.textContent = day;
    hdr.appendChild(label);

    const count = document.createElement('span');
    count.className = 'day-count';
    count.textContent = String(groups[day].length);
    hdr.appendChild(count);

    const lst = document.createElement('ul');
    lst.className = 'session-list';
    lst.style.display = 'none';

    groups[day].sort().forEach(f => {
      const namePretty = f.replace(`${day}_`, '').replace('.xlsx','');
      const li = document.createElement('li');
      li.className = 'session-item';
      li.onclick = () => loadFile(f);

      const row = document.createElement('div');
      row.className = 'session-title-row';

      const title = document.createElement('div');
      title.textContent = namePretty;

      // KPI badge (hidden until we calculate)
      const kpiBadge = document.createElement('span');
      kpiBadge.className = 'kpi-badge';
      kpiBadge.id = `kpi_${cssSafeId(f)}`;
      kpiBadge.style.display = 'none'; // will show when we have a score

      // Active badge (kept as-is)
      const lm = blobMeta.get(f) || 0;
      const isActive = (Date.now() - lm) <= ACTIVE_WINDOW_MS;
      const activeBadge = document.createElement('span');
      activeBadge.className = 'active-badge';
      activeBadge.textContent = 'Active';
      activeBadge.dataset.lm = String(lm);
      if (!isActive) activeBadge.style.display = 'none';

      row.appendChild(title);
      row.appendChild(kpiBadge);   // ‚Üê KPI badge first
      row.appendChild(activeBadge);

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.id = `meta_${cssSafeId(f)}`;
      meta.textContent = 'Loading‚Ä¶';

      li.appendChild(row);
      li.appendChild(meta);
      lst.appendChild(li);
    });

    let loadedThisGroup = false;
    const toggle = () => {
      const expand = lst.style.display !== 'block';
      lst.style.display = expand ? 'block' : 'none';
      hdr.setAttribute('aria-expanded', expand ? 'true' : 'false');
      hdr.title = expand ? 'Hide sessions' : 'Show sessions';
      if (expand && !loadedThisGroup) {
        loadedThisGroup = true;
        groups[day].forEach(f => {
          fetchSessionSummary(f).then(({ mileageKm, issueCount, testObject, testPurpose, kpiScore }) => {
            // Fill meta line
            const el = document.getElementById(`meta_${cssSafeId(f)}`);
            if (el) {
              const parts = [];
              if (testPurpose) parts.push(String(testPurpose));
              if (testObject)  parts.push(String(testObject));
              const left = parts.length ? parts.join('  ‚Ä¢  ') + '  ‚Ä¢  ' : '';
              const mileageText = (mileageKm ?? '‚Äì') + (mileageKm != null ? 'km' : '');
              el.textContent = `${left}Mileage: ${mileageText}  No of issues: ${issueCount}`;
            }

            // Fill KPI badge if we have a score
            const kb = document.getElementById(`kpi_${cssSafeId(f)}`);
            if (kb) {
              if (typeof kpiScore === 'number' && kpiScore >= 1 && kpiScore <= 10) {
                kb.textContent = `KPI ${kpiScore}`;
                kb.className = `kpi-badge s${kpiScore}`;   // color from .s1..s10
                kb.style.display = 'inline-flex';
              } else {
                kb.style.display = 'none';
              }
            }
          });
        });
      }
    };

    hdr.addEventListener('click', toggle);
    hdr.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
    });

    sb.appendChild(hdr);
    sb.appendChild(lst);
  });

  ensureActiveBadgeUpdater();
}

    let _activeBadgeTimer = null;
function ensureActiveBadgeUpdater(){
  if (_activeBadgeTimer) return;
  const tick = () => {
    const now = Date.now();
    document.querySelectorAll('.active-badge[data-lm]').forEach(el => {
      const lm = Number(el.dataset.lm || 0);
      const show = (now - lm) <= ACTIVE_WINDOW_MS;
      el.style.display = show ? 'inline-flex' : 'none';
    });
  };
  tick(); // initial
  _activeBadgeTimer = setInterval(tick, 30000); // every 30s
}

    // ---------- OVERVIEW HEATMAP (Test activity) ----------
    function buildOverviewHeatmap(files){
      const byDay = new Map(); // 'YYYY-MM-DD' -> totalIssues (only sessions ‚â•1 km and issues > 0)
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(withDates.map(x => fetchSessionSummary(x.filename).then(s => ({...x, ...s})))).then(rows => {
        rows.forEach(r => {
          if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return;
          const prev = byDay.get(r.dayStr) || 0;
          byDay.set(r.dayStr, prev + (r.issueCount || 0));
        });

        const days = Array.from(byDay.keys()).sort();
        const host = document.getElementById('heatmap-host');
        if (days.length === 0){
          host.innerHTML = '<div style="color:#666;">No eligible sessions (‚â• 1 km and &gt; 0 issues) to show yet.</div>';
          return;
        }

        const minDate = toDateOnly(days[0]);
        const maxDate = toDateOnly(days[days.length-1]);

        const start = new Date(minDate);
        const day = start.getDay(); // 0 Sun ‚Ä¶ 6 Sat
        const offsetToMonday = (day === 0 ? 6 : day - 1);
        start.setDate(start.getDate() - offsetToMonday);
        start.setHours(0,0,0,0);

        const end = new Date(maxDate);
        const endDay = end.getDay();
        const addToSunday = (7 - endDay) % 7;
        end.setDate(end.getDate() + addToSunday);
        end.setHours(0,0,0,0);

        const dense = [];
        let cur = new Date(start);
        while (cur <= end) {
          const ymd = cur.toISOString().slice(0,10);
          dense.push({ date: new Date(cur), count: byDay.get(ymd) || 0 });
          cur.setDate(cur.getDate() + 1);
        }

        renderHeatmap(dense);
      });
    }

    function renderHeatmap(denseDays){
      const host = document.getElementById('heatmap-host');
      host.innerHTML = '';

      const cell = 12, gap = 3, rows = 7;
      const weeks = Math.ceil(denseDays.length / 7);
      const width  = weeks * (cell + gap) + 40;
      const height = rows  * (cell + gap) + 20;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const level = v => (v === 0) ? 0 : (v < 5 ? 1 : (v < 10 ? 2 : (v < 20 ? 3 : 4)));

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      const months = document.createElementNS(NS, 'g'); months.setAttribute('class','heatmap-months');
      let lastMonth = -1;
      for (let w = 0; w < weeks; w++) {
        const idx = w * 7;
        if (idx >= denseDays.length) break;
        const d = denseDays[idx].date;
        const m = d.getMonth();
        if (m !== lastMonth) {
          lastMonth = m;
          const t = document.createElementNS(NS,'text');
          t.textContent = d.toLocaleString(undefined,{month:'short'});
          t.setAttribute('x', 40 + w*(cell+gap));
          t.setAttribute('y', 10);
          months.appendChild(t);
        }
      }
      svg.appendChild(months);

      const dow = document.createElementNS(NS,'g'); dow.setAttribute('class','heatmap-dow');
      [['Mon',0],['Wed',2],['Fri',4]].forEach(([name,row])=>{
        const t=document.createElementNS(NS,'text');
        t.textContent=name; t.setAttribute('x',0); t.setAttribute('y',24+row*(cell+gap));
        dow.appendChild(t);
      });
      svg.appendChild(dow);

      const cellsG = document.createElementNS(NS,'g');
      for (let i = 0; i < denseDays.length; i++) {
        const d = denseDays[i];
        const w = Math.floor(i / 7);
        const r = i % 7;
        const rect = document.createElementNS(NS,'rect');
        rect.setAttribute('x', 40 + w*(cell+gap));
        rect.setAttribute('y', 16 + r*(cell+gap));
        rect.setAttribute('width', cell);
        rect.setAttribute('height', cell);
        rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
        rect.setAttribute('fill', colors[level(d.count)]);
        rect.setAttribute('stroke', '#ccd3d9');
        rect.setAttribute('stroke-width', '1');
        cellsG.appendChild(rect);
      }
      svg.appendChild(cellsG);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Less
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Countries √ó Month (4 bins/month) ----------
    function buildCountryMonthChart(files){
  const withDates = files
    .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.f, dayStr: x.m[1] }));

  const cleanTitleCase = (s) => {
    const t = String(s || '').trim()
      .replace(/\(.*?\)/g, '')        // drop bracket comments e.g. "Sweden (SE)"
      .replace(/\s+/g, ' ');
    return t.replace(/\b\w/g, c => c.toUpperCase());
  };

  return Promise.all(
    withDates.map(x =>
      fetchSessionSummary(x.filename)
        .then(s => ({...x, ...s}))
        .then(r => {
          if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return null;
          return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
        })
    )
  ).then(rows => {
    const valid = rows.filter(Boolean).filter(r => Array.isArray(r.countries) && r.countries.length > 0);
    const host = document.getElementById('country-host');
    if (!host) return;

    if (!valid.length){
      host.innerHTML = '<div style="color:#666;">No country data found in the ‚ÄúCountry‚Äù table.</div>';
      return;
    }

    const counts = new Map(); // `${ym}|${wb}|${country}` -> n
    const monthsSet = new Set();
    const countriesSet = new Set();

    valid.forEach(r => {
      const ym  = r.dayStr.slice(0,7);
      const day = parseInt(r.dayStr.slice(8,10), 10);
      const wb  = Math.min(4, Math.max(1, Math.ceil(day/7))); // 1..4
      monthsSet.add(ym);

      // üîπ Normalize each country:
      const normed = r.countries
        .map(c => canonicalEU(c) || cleanTitleCase(c)) // EU ‚Üí English; others ‚Üí cleaned title case
        .filter(Boolean);

      const uniq = Array.from(new Set(normed));
      uniq.forEach(country => {
        countriesSet.add(country);
        const key = `${ym}|${wb}|${country}`;
        counts.set(key, (counts.get(key)||0) + 1);
      });
    });

    const months = Array.from(monthsSet).sort();
    const countries = Array.from(countriesSet).sort((a,b) => {
      const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
      const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
      if (totalB !== totalA) return totalB - totalA;
      return a.localeCompare(b);
    });

    renderCountryMonthHeatmap({ months, countries, counts });
  });
}

    function renderCountryMonthHeatmap({months, countries, counts}){
      const host = document.getElementById('country-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 110;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + countries.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => countries.flatMap(c => [1,2,3,4].map(w => counts.get(`${m}|${w}|${c}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Country labels (rows)
      const gCountries = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = countries[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gCountries.appendChild(t);
      }
      svg.appendChild(gCountries);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const country = countries[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${country}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Temperature √ó Month (4 bins/month) ----------
    function buildTempMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(
        withDates.map(x =>
          fetchSessionSummary(x.filename)
            .then(s => ({...x, ...s}))
        )
      ).then(rows => {
        const valid = rows.filter(r =>
          r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
          r.issueCount > 0 && r.meanTempC != null && !isNaN(r.meanTempC)
        );

        const host = document.getElementById('temp-host');
        if (!host) return;
        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No temperature data found in Issue/Issues table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${tempInt}` -> n
        const monthsSet = new Set();
        const tempsSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
          monthsSet.add(ym);

          const tempInt = Math.round(r.meanTempC);
          tempsSet.add(tempInt);
          const key = `${ym}|${wb}|${tempInt}`;
          counts.set(key, (counts.get(key)||0) + 1);
        });

        const months = Array.from(monthsSet).sort();
        const temps  = Array.from(tempsSet).sort((a,b)=>b-a); // highest first (y-axis reversed)
        renderTempMonthHeatmap({ months, temps, counts });
      });
    }

    function renderTempMonthHeatmap({months, temps, counts}){
      const host = document.getElementById('temp-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 54;  // numbers
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + temps.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => temps.flatMap(t => [1,2,3,4].map(w => counts.get(`${m}|${w}|${t}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Temperature labels (rows)
      const gTemps = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = `${temps[r]}¬∞`;
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gTemps.appendChild(t);
      }
      svg.appendChild(gTemps);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const tempVal = temps[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${tempVal}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Weather √ó Month (4 bins/month) ----------
    function buildWeatherMonthChart(files){
  const withDates = files
    .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.f, dayStr: x.m[1] }));

  // Treat these as placeholders ‚Üí ignore in chart
  const isPlaceholderWx = (w) => {
    if (!w) return true;
    const s = String(w).trim();
    return s === '' || /^weather$/i.test(s) || /^conditions?$/i.test(s) || /^n\/?a$/i.test(s) || /^unknown$/i.test(s);
  };

  return Promise.all(
    withDates.map(x =>
      fetchSessionSummary(x.filename)
        .then(s => ({...x, ...s}))
    )
  ).then(rows => {
    const valid = rows.filter(r =>
      r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
      r.issueCount > 0 && r.weatherAgg
    );

    const host = document.getElementById('weather-host');
    if (!host) return;

    const counts = new Map(); // `${ym}|${wb}|${wx}` -> n
    const monthsSet = new Set();
    const wxSet = new Set();

    valid.forEach(r => {
      const wx = String(r.weatherAgg).trim();
      if (isPlaceholderWx(wx)) return; // üîπ skip "Weather" etc.

      const ym  = r.dayStr.slice(0,7);
      const day = parseInt(r.dayStr.slice(8,10), 10);
      const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
      monthsSet.add(ym);
      wxSet.add(wx);

      const key = `${ym}|${wb}|${wx}`;
      counts.set(key, (counts.get(key)||0) + 1);
    });

    const months = Array.from(monthsSet).sort();
    const wxs = Array.from(wxSet).sort((a,b) => {
      const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
      const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
      if (totalB !== totalA) return totalB - totalA;
      return a.localeCompare(b);
    });

    if (!wxs.length){
      host.innerHTML = '<div style="color:#666;">No weather data found (placeholders ignored).</div>';
      return;
    }

    renderWeatherMonthHeatmap({ months, wxs, counts });
  });
}

    function renderWeatherMonthHeatmap({months, wxs, counts}){
      const host = document.getElementById('weather-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 90;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + wxs.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => wxs.flatMap(w => [1,2,3,4].map(bin => counts.get(`${m}|${bin}|${w}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Weather labels (rows)
      const gWx = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = wxs[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gWx.appendChild(t);
      }
      svg.appendChild(gWx);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const wx = wxs[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${wx}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- EU Mileage Map (NEW) ----------
function buildEUMileageMap(files){
  const withDates = files
    .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.f, dayStr: x.m[1] }));

  return Promise.all(withDates.map(x =>
    fetchSessionSummary(x.filename)
      .then(s => ({...x, ...s}))
      .then(r => {
        if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return null;
        return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
      })
  )).then(async rows => {
    const valid = rows.filter(Boolean);
    const agg = new Map();           // country -> total mileage (km)
    const issuePoints = [];          // all issue coordinates across valid sessions

    // Gather mileage + issue coordinates
    for (const r of valid){
      const euCountries = Array.isArray(r.countries)
        ? r.countries.map(canonicalEU).filter(Boolean)
        : [];
      if (euCountries.length){
        const share = r.mileageKm / euCountries.length;
        euCountries.forEach(cty => agg.set(cty, (agg.get(cty)||0) + share));
      }

      // Pull issue points from the workbook (fast scan)
      try{
        const { wb } = await loadWorkbook(r.filename);
        const pts = extractIssueCoordsFast(wb);
        if (pts && pts.length) issuePoints.push(...pts);
      }catch(e){ /* ignore */ }
    }

    renderEUMileageMap(agg, issuePoints);
  });
}

function renderEUMileageMap(agg, issuePoints = []){
  const hostId = 'eu-mileage-map';
  const container = document.getElementById(hostId);
  if (!container) return;

  container.innerHTML = '';
  const h = Math.round(container.getBoundingClientRect().height);
  container.style.height = h + 'px';

  const entries = Array.from(agg.entries()).filter(([,km]) => km > 0);
  if (!entries.length && (!issuePoints || !issuePoints.length)){
    container.outerHTML = `<div id="${hostId}" class="eu-mileage-map" style="display:flex;align-items:center;justify-content:center;color:#666;">No EU mileage data available yet.</div>`;
    return;
  }

  const map = L.map(container, { attributionControl:true, zoomControl:true });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  // --- Black trace layer (tiny dots) ---
  if (issuePoints && issuePoints.length){
    // keep performance sane on huge datasets
    const MAX_POINTS = 25000;
    const stride = Math.max(1, Math.ceil(issuePoints.length / MAX_POINTS));
    const dots = [];
    for (let i = 0; i < issuePoints.length; i += stride){
      const p = issuePoints[i];
      if (!p || p.length !== 2) continue;
      dots.push(L.circleMarker(p, {
        radius: 1.5,
        color: '#000',
        weight: 0,
        fillColor: '#000',
        fillOpacity: 0.45
      }));
    }
    L.layerGroup(dots).addTo(map);
  }

  // --- Country bubbles (same as before) ---
  const latlngs = [];
  const maxKm = entries.length ? Math.max(...entries.map(([,km]) => km)) : 0;
  const minR = 6, maxR = 30;

  entries.forEach(([country, km]) => {
    const [lat, lon] = EU_CENTROIDS[country] || [null, null];
    if (lat == null || lon == null) return;
    latlngs.push([lat, lon]);

    const r = (function(){
      if (maxKm <= 0) return minR;
      const f = Math.sqrt(km / maxKm);
      return Math.round(minR + f * (maxR - minR));
    })();

    const marker = L.circleMarker([lat,lon], {
      radius: r,
      color: '#900',
      weight: 1,
      fillColor: '#d00',
      fillOpacity: 0.7
    }).addTo(map);

    marker.bindTooltip(`${Math.round(km)} km`, {
      permanent: true,
      direction: 'center',
      className: 'eu-mileage-label'
    });
  });

  const allBounds = latlngs.slice();
  if (issuePoints && issuePoints.length){
    // help fit view even if no country bubbles
    const MAX_BOUNDS_SAMPLES = 2000;
    const jump = Math.max(1, Math.ceil(issuePoints.length / MAX_BOUNDS_SAMPLES));
    for (let i = 0; i < issuePoints.length; i += jump){
      allBounds.push(issuePoints[i]);
    }
  }

  if (allBounds.length){
    map.fitBounds(allBounds, { padding:[20,20] });
  }else{
    map.setView([54,15], 4);
  }

  map.whenReady(() => map.invalidateSize());
  setTimeout(() => map.invalidateSize(), 100);
}

    // ---------- LATEST ROUTE PREVIEWS (latest 10, ‚â•1 km, issues > 0) ----------
function buildLatestRoutePreviews(files){
  const withDates = files
    .map(f => ({ filename: f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.filename, dayStr: x.m[1] }));

  return Promise.all(
    withDates.map(x => fetchSessionSummary(x.filename).then(s => ({ ...x, ...s })))
  ).then(rows => {
    // Filter and sort strictly by date + last-modified
    const take = rows
      .filter(r => r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW && r.issueCount > 0)
      .sort((a, b) => {
        const d = b.dayStr.localeCompare(a.dayStr);                 // YYYY-MM-DD DESC
        if (d) return d;
        const lmDiff = (blobMeta.get(b.filename) || 0) - (blobMeta.get(a.filename) || 0); // Last-Modified DESC
        if (lmDiff) return lmDiff;
        return b.filename.localeCompare(a.filename);                // tie-break
      })
      .slice(0, 10);

    const grid = document.getElementById('routes-grid');
    if (!grid) return;
    grid.innerHTML = '';
    if (!take.length) return;

    // 1) Place all cards (with summary data, no workbook parsing yet)
    const slots = take.map(item => {
      const card = document.createElement('div');
      card.className = 'route-card';

      const niceName = item.filename.replace(`${item.dayStr}_`, '').replace('.xlsx','');

      const title = document.createElement('div');
      title.className = 'route-title';
      const link = document.createElement('a');
      link.className = 'route-link';
      link.href = '#';
      link.innerHTML = `<span class="u">${item.dayStr} ‚Äî ${niceName}</span>`;
      link.addEventListener('click', (e)=>{ e.preventDefault(); loadFile(item.filename); });
      title.appendChild(link);
      card.appendChild(title);

      const mapDiv = document.createElement('div');
      mapDiv.className = 'route-map';
      mapDiv.id = `route_${cssSafeId(item.filename)}`;
      card.appendChild(mapDiv);

      const meta = document.createElement('div');
      meta.className = 'route-meta';

      // Build left-side details from summary (no extra XLSX parsing)
      const leftParts = [];
      if (item.testObject)  leftParts.push(`Test object: ${item.testObject}`);
      if (item.testPurpose) leftParts.push(`Purpose: ${item.testPurpose}`);
      const leftText = leftParts.length ? leftParts.join('  ‚Ä¢  ') + '  ‚Ä¢  ' : '';

      const kmText = (item.mileageKm ?? '‚Äì');
      meta.textContent = `${leftText}Mileage: ${kmText} km  ‚Ä¢  Issues: ${item.issueCount}`;
      card.appendChild(meta);

      grid.appendChild(card);
      return { item, mapDiv, meta };
    });

    // 2) For each card, draw the mini route map using the cached workbook
    slots.forEach(({ item, mapDiv }) => {
      loadWorkbook(item.filename)
        .then(({ wb }) => {
          const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
          if (!samplingName) return;

          const { path } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
          if (!path || path.length < 2) return;

          const mini = L.map(mapDiv, { attributionControl:false, zoomControl:false });
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mini);
          const line = L.polyline(path, { color:'blue', weight:3, opacity:0.8 }).addTo(mini);
          mini.fitBounds(line.getBounds(), { padding:[8,8] });
          mini.whenReady(() => mini.invalidateSize());
        })
        .catch(() => { /* ignore individual failures for a single card */ });
    });
  });
}

    function scoringLegendHtml(){
  return `
  <div class="score-legend" aria-label="Scoring legend (1 worst, 10 best)">
    <div class="score-box s1"><strong>1</strong><small>Worst</small><span class="score-th">‚â• 100</span></div>
    <div class="score-box s2"><strong>2</strong><small>Too bad</small><span class="score-th">‚â• 60</span></div>
    <div class="score-box s3"><strong>3</strong><small>Bad</small><span class="score-th">‚â• 40</span></div>
    <div class="score-box s4"><strong>4</strong><small>Not good</small><span class="score-th">‚â• 30</span></div>
    <div class="score-box s5"><strong>5</strong><small>Unacceptable</small><span class="score-th">‚â• 20</span></div>
    <div class="score-box s6"><strong>6</strong><small>Marginal</small><span class="score-th">‚â• 15</span></div>
    <div class="score-box s7"><strong>7</strong><small>Acceptable</small><span class="score-th">‚â• 10</span></div>
    <div class="score-box s8"><strong>8</strong><small>Good</small><span class="score-th">‚â• 5</span></div>
    <div class="score-box s9"><strong>9</strong><small>Impressive</small><span class="score-th">‚â• 1</span></div>
    <div class="score-box s10"><strong>10</strong><small>Exceptional</small><span class="score-th">&lt; 1 (incl. 0)</span></div>
  </div>`;
}

    function extractAvgEventsPer1kFromSheet(sheet){
  const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
  if (!rows.length) return null;

  // Match headers like "Events per 1000 km", "Events/1000 km", spacing variants
  const isTargetHeader = (h) => /events?\s*(?:per|\/)\s*1000\s*km/i.test(String(h || ''));

  const hdr = rows[0];
  const colIdx = hdr.findIndex(isTargetHeader);
  if (colIdx < 0) return null;

  const toNum = (v) => {
    if (v == null) return null;
    const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  };

  const vals = [];
  for (let r = 1; r < rows.length; r++){
    const n = toNum(rows[r][colIdx]);
    if (n != null) vals.push(n);
  }
  if (!vals.length) return null;

  //const sum = vals.reduce((a,b)=>a+b,0);
  //return sum / vals.length; // exact mean (no rounding here)
  const sum = vals.reduce((a,b)=>a+b,0);
  return sum;                   // SUM
      
}

    // Map rate (events per 1000 km) -> score 1..10
function scoreFromRate(rate){
  if (rate == null || !isFinite(rate)) return null;
  if (rate >= 100) return 1;
  if (rate >= 60)  return 2;
  if (rate >= 40)  return 3;
  if (rate >= 30)  return 4;
  if (rate >= 20)  return 5;
  if (rate >= 15)  return 6;
  if (rate >= 10)  return 7;
  if (rate >= 5)   return 8;
  if (rate >= 1)   return 9;   // 1..‚àû handled above; 1‚Äì<5 -> 9
  return 10;                   // <1 (incl. 0)
}

const SCORE_LABEL = {
  1:'Worst',2:'Too bad',3:'Bad',4:'Not good',5:'Unacceptable',
  6:'Marginal',7:'Acceptable',8:'Good',9:'Impressive',10:'Exceptional'
};

// Legend with optional selected score (highlights the box)
function renderScoringLegend(selectedScore){
  const rows = [
    {n:1, cls:'s1',  lbl:'Worst',        thr:'‚â• 100'},
    {n:2, cls:'s2',  lbl:'Too bad',      thr:'‚â• 60'},
    {n:3, cls:'s3',  lbl:'Bad',          thr:'‚â• 40'},
    {n:4, cls:'s4',  lbl:'Not good',     thr:'‚â• 30'},
    {n:5, cls:'s5',  lbl:'Unacceptable', thr:'‚â• 20'},
    {n:6, cls:'s6',  lbl:'Marginal',     thr:'‚â• 15'},
    {n:7, cls:'s7',  lbl:'Acceptable',   thr:'‚â• 10'},
    {n:8, cls:'s8',  lbl:'Good',         thr:'‚â• 5'},
    {n:9, cls:'s9',  lbl:'Impressive',   thr:'‚â• 1'},
    {n:10,cls:'s10', lbl:'Exceptional',  thr:'< 1 (incl. 0)'},
  ];
  const boxes = rows.map(r =>
    `<div class="score-box ${r.cls}${selectedScore===r.n?' sel':''}">
       <strong>${r.n}</strong><small>${r.lbl}</small><span class="score-th">${r.thr}</span>
     </div>`
  ).join('');
  return `<div class="score-legend">${boxes}</div>`;
}

// Count total KPIs from KPI_buttons.csv (cached after first load)
function getTotalKpis(){
  if (typeof window.__TOTAL_KPIS__ === 'number') {
    return Promise.resolve(window.__TOTAL_KPIS__);
  }

  const relUrl   = 'KPI_buttons.csv';
  const azureUrl = `${BASE_URL}/KPI_buttons.csv?${SAS_TOKEN}`;

  const fetchAndCount = (url) =>
    fetch(nc(url), { cache: 'default' })   // cacheable, it's the same for all sessions
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.text();
      })
      .then(txt => {
        const lines = txt.split(/\r?\n/);
        const count = lines.reduce((n, line) => n + (line.indexOf('redButton') !== -1 ? 1 : 0), 0);
        window.__TOTAL_KPIS__ = count;
        return count;
      });

  return fetchAndCount(relUrl)
    .catch(() => fetchAndCount(azureUrl))
    .catch(() => null);
}

// ---------- SESSION VIEWER ----------
function loadFile(filename) {
  const content = document.getElementById('content');
  content.innerHTML = '';
  issueCoords = [];
  samplingCoords = [];
  mapRef = null;

  // Fallbacks if globals aren't defined
  const _scoreFromRate = (typeof scoreFromRate === 'function') ? scoreFromRate : function(rate){
    if (rate == null || !isFinite(rate)) return null;
    if (rate >= 100) return 1;
    if (rate >= 50)  return 2;
    if (rate >= 20)  return 3;
    if (rate >= 10)  return 4;
    if (rate >= 5)   return 5;
    if (rate >= 2)   return 6;
    if (rate >= 1.5) return 7;
    if (rate >= 0.5) return 8;
    if (rate >= 0)   return 9;
    return 10;
  };
  const _SCORE_LABEL = (typeof SCORE_LABEL === 'object' && SCORE_LABEL) ? SCORE_LABEL : {
    1:'Worst',2:'Too bad',3:'Bad',4:'Not good',5:'Unacceptable',
    6:'Marginal',7:'Acceptable',8:'Good',9:'Impressive',10:'Exceptional'
  };
  const _renderScoringLegend = (typeof renderScoringLegend === 'function')
    ? renderScoringLegend
    : function(selectedScore){
        const rows = [
          {n:1,  cls:'s1',  lbl:'Worst',        thr:'‚â• 100'},
          {n:2,  cls:'s2',  lbl:'Too bad',      thr:'‚â• 60'},
          {n:3,  cls:'s3',  lbl:'Bad',          thr:'‚â• 40'},
          {n:4,  cls:'s4',  lbl:'Not good',     thr:'‚â• 30'},
          {n:5,  cls:'s5',  lbl:'Unacceptable', thr:'‚â• 20'},
          {n:6,  cls:'s6',  lbl:'Marginal',     thr:'‚â• 15'},
          {n:7,  cls:'s7',  lbl:'Acceptable',   thr:'‚â• 10'},
          {n:8,  cls:'s8',  lbl:'Good',         thr:'‚â• 5'},
          {n:9,  cls:'s9',  lbl:'Impressive',   thr:'‚â• 1'},
          {n:10, cls:'s10', lbl:'Exceptional',  thr:'< 1 (incl. 0)'},
        ];
        return '<div class="score-legend">' + rows.map(function(r){
          return '<div class="score-box ' + r.cls + (selectedScore===r.n?' sel':'') + '">' +
                   '<strong>' + r.n + '</strong><small>' + r.lbl + '</small><span class="score-th">' + r.thr + '</span>' +
                 '</div>';
        }).join('') + '</div>';
      };

  // Local helper: SUM of "Events per 1000 km" column from a KPI sheet
  function extractSumEventsPer1kFromSheet(sheet){
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
    if (!rows.length) return null;
    const isTargetHeader = h => /events?\s*(?:per|\/)\s*1000\s*km/i.test(String(h || ''));
    const hdr = rows[0];
    const colIdx = hdr.findIndex(isTargetHeader);
    if (colIdx < 0) return null;

    const toNum = v => {
      if (v == null) return null;
      const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
      const n = parseFloat(s);
      return Number.isFinite(n) ? n : null;
    };

    let sum = 0, have = false;
    for (let r = 1; r < rows.length; r++){
      const n = toNum(rows[r][colIdx]);
      if (n != null){ sum += n; have = true; }
    }
    return have ? sum : null;
  }

  const issueTableInfo = {
    sheetName: null,
    headerNames: { col1: '', col2: '', col3: '' },
    issueInfo: {}
  };

  // Download links
  const xlsxLink = document.createElement('a');
  xlsxLink.href = `${BASE_URL}/${filename}?${SAS_TOKEN}`;
  xlsxLink.textContent = 'Download XLSX';
  xlsxLink.className = 'download-button';
  xlsxLink.setAttribute('download', filename);
  content.appendChild(xlsxLink);

  const pdfFilename = filename.replace(/\.xlsx$/i, '.pdf');
  const pdfLink = document.createElement('a');
  pdfLink.href = `${BASE_URL}/${pdfFilename}?${SAS_TOKEN}`;
  pdfLink.textContent = 'Download PDF';
  pdfLink.className = 'download-button';
  pdfLink.setAttribute('download', pdfFilename);
  content.appendChild(pdfLink);

  // === Use cached workbook ===
  loadWorkbook(filename)
    .then(({ wb /*, buf*/ }) => {
      const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
      if (samplingName) parseSamplingSheet(wb.Sheets[samplingName]);

      let nonSamplingCount = 0;
      let mapInserted = false;

      // Pre-fetch total KPIs once
      const totalKpisPromise = getTotalKpis();

      wb.SheetNames.forEach(sheet => {
        if (sheet.toLowerCase() === 'sampling') return;

        const html = XLSX.utils.sheet_to_html(wb.Sheets[sheet], { id: sheet });
        content.insertAdjacentHTML('beforeend', `<h2>${sheet}</h2>${html}`);

        // First sheet with lat/lon ‚Üí collect issues + headers
        if (!issueTableInfo.sheetName) {
          const tbl = document.getElementById(sheet);
          const rows = Array.from(tbl.querySelectorAll('tr'));
          if (rows.length > 1) {
            const hdrs = Array.from(rows[0].querySelectorAll('th,td')).map(c => c.textContent.trim().toLowerCase());
            const latIdx = hdrs.findIndex(h => h.includes('lat'));
            const lonIdx = hdrs.findIndex(h => h.includes('lon'));
            if (latIdx >= 0 && lonIdx >= 0) {
              issueTableInfo.sheetName = sheet;
              const rawHdrs = Array.from(rows[0].querySelectorAll('th,td'));
              issueTableInfo.headerNames.col1 = (rawHdrs[0]?.textContent || '').trim();
              issueTableInfo.headerNames.col2 = (rawHdrs[1]?.textContent || '').trim();
              issueTableInfo.headerNames.col3 = (rawHdrs[12]?.textContent || '').trim();

              rows.slice(1).forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const issueNo = (cells[0]?.textContent || '').trim();
                const col1 = issueNo;
                const col2 = (cells[1]?.textContent || '').trim();
                const col3 = (cells[12]?.textContent || '').trim();
                const lat = parseFloat((cells[latIdx]?.textContent || '').trim());
                const lon = parseFloat((cells[lonIdx]?.textContent || '').trim());
                if (!isNaN(lat) && !isNaN(lon)) {
                  issueCoords.push({ issueNo, lat, lon });
                }
                if (issueNo) {
                  issueTableInfo.issueInfo[issueNo] = { issueNo, col1, col2, col3, lat, lon };
                }
              });
            }
          }
        }

        // KPI sheet ‚Üí compute average from SUM / total KPIs (1 decimal) + legend
        if (/kpi/i.test(sheet)) {
          const kpiTable = document.getElementById(sheet);
          if (kpiTable) {
            kpiTable.style.marginBottom = '6px'; // tighter gap

            totalKpisPromise.then(totalKpis => {
              const inserts = [];
              const sum = extractSumEventsPer1kFromSheet(wb.Sheets[sheet]);
              if (sum != null && typeof totalKpis === 'number' && totalKpis > 0) {
                const avg = sum / totalKpis;
                const avg1 = Math.round(avg * 10) / 10; // numeric 1-dec
                inserts.push(
                  `<div class="kpi-avg">Average <em>events per 1000 km</em>: <span class="v">${avg1.toFixed(1)}</span></div>`
                );
                const score = _scoreFromRate(avg1);
                inserts.push(_renderScoringLegend(score));
                inserts.push(
  `<div class="score-legend-caption">Score: <strong>${score}</strong> ‚Äî ${_SCORE_LABEL[score]} (sum √∑ total KPIs = ${(+sum).toLocaleString(undefined,{maximumFractionDigits:1})} √∑ ${totalKpis})</div>`
);

              } else {
                inserts.push(_renderScoringLegend(null));
                inserts.push('<div class="score-legend-caption">Total KPIs unavailable ‚Äî cannot compute average.</div>');
              }
              if (inserts.length) kpiTable.insertAdjacentHTML('afterend', inserts.join(''));
            });
          }
        }

        nonSamplingCount++;
        if (nonSamplingCount === 2 && !mapInserted) {
          const mapDiv = document.createElement('div');
          mapDiv.id = 'issue-map';
          mapDiv.style.width = '100%';
          mapDiv.style.height = '400px';
          mapDiv.style.margin = '20px 0';
          mapDiv.style.border = '1px solid #aaa';
          content.appendChild(mapDiv);
          mapInserted = true;
        }
      });
    })
    .then(() => {
      if (!document.getElementById('issue-map')) {
        const mapDiv = document.createElement('div');
        mapDiv.id = 'issue-map';
        mapDiv.style.width = '100%';
        mapDiv.style.height = '400px';
        mapDiv.style.margin = '20px 0';
        mapDiv.style.border = '1px solid #aaa';
        document.getElementById('content').appendChild(mapDiv);
      }
      if (issueCoords.length || samplingCoords.length) {
        initMap();
      } else {
        const ph = document.getElementById('issue-map');
        const err = document.createElement('div');
        err.className = 'error';
        err.innerHTML = `Need at least 1 issue or sampling point to plot a map (found ${issueCoords.length} issues, ${samplingCoords.length} sampling points).`;
        ph.replaceWith(err);
      }
    })
    .then(() => {
      // Issue snapshots LAST (below everything)
      const zipFilename = filename.replace(/\.xlsx$/i, '.zip');
      return fetch(`${BASE_URL}/${zipFilename}?${SAS_TOKEN}`, { cache:'default' })
        .then(resp => {
          if (!resp.ok) throw new Error('ZIP not found');
          return resp.arrayBuffer();
        })
        .then(buf => JSZip.loadAsync(buf))
        .then(zip => {
          const title = document.createElement('h2');
          title.textContent = 'Issue snapshots';

          const table = document.createElement('table');
          table.id = 'issue-snapshots';
          table.style.width = 'auto';
          table.style.marginBottom = '2em';
          table.style.borderCollapse = 'collapse';

          const hdrRow = document.createElement('tr');
          ['col1','col2','col3','Location','Snapshot'].forEach(txt => {
            const th = document.createElement('th');
            th.textContent = (txt.startsWith('col') ? ( {col1:'',col2:'',col3:''}[txt] = 1, issueTableInfo.headerNames[txt] ) : txt) || txt;
            th.style.backgroundColor = '#f5f5f5';
            th.style.padding = '8px';
            th.style.border = '1px solid #ccc';
            hdrRow.appendChild(th);
          });
          table.appendChild(hdrRow);

          zip.forEach((path, entry) => {
            if (entry.dir || !/\.(jpe?g|png|gif)$/i.test(path)) return;
            const issueNo = path.replace(/\.[^/.]+$/, '');
            const info = issueTableInfo.issueInfo[issueNo];
            if (!info) return;

            const row = document.createElement('tr');
            [info.col1, info.col2, info.col3].forEach(val => {
              const td = document.createElement('td');
              td.textContent = val;
              td.style.padding = '8px';
              td.style.border = '1px solid #ccc';
              row.appendChild(td);
            });

            const tdMap = document.createElement('td');
            tdMap.style.padding = '8px';
            tdMap.style.border = '1px solid #ccc';
            const miniDiv = document.createElement('div');
            miniDiv.id = `snapshot-map-${cssSafeId(issueNo)}`;
            miniDiv.style.width = '150px';
            miniDiv.style.height = '150px';
            tdMap.appendChild(miniDiv);
            row.appendChild(tdMap);

            const tdImg = document.createElement('td');
            tdImg.style.padding = '8px';
            tdImg.style.border = '1px solid #ccc';

            entry.async('blob').then(rawBlob => {
              let mime = 'application/octet-stream';
              if (/\.(jpe?g)$/i.test(path)) mime = 'image/jpeg';
              else if (/\.png$/i.test(path)) mime = 'image/png';
              else if (/\.gif$/i.test(path)) mime = 'image/gif';
              const blob = new Blob([rawBlob], { type: mime });
              const url  = URL.createObjectURL(blob);

              const link = document.createElement('a');
              link.href = url; link.target = '_blank'; link.rel = 'noopener noreferrer';

              const img = document.createElement('img');
              img.src = url; img.style.maxWidth = '200px'; img.style.maxHeight = '200px'; img.style.cursor = 'pointer';
              link.appendChild(img);
              tdImg.appendChild(link);

              const miniMap = L.map(miniDiv, { attributionControl:false, zoomControl:false }).setView([info.lat, info.lon], 17);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(miniMap);
              const badgeIcon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
              L.marker([info.lat, info.lon], { icon: badgeIcon }).addTo(miniMap);
              const circle = L.circle([info.lat, info.lon], { radius: 100 }).addTo(miniMap);
              miniMap.fitBounds(circle.getBounds(), { padding:[4,4] });
              miniMap.invalidateSize();
            });

            row.appendChild(tdImg);
            table.appendChild(row);
          });

          content.appendChild(title);
          content.appendChild(table);
        })
        .catch(() => { /* optional ZIP; ignore */ });
    })
    .catch(err => {
      console.error(err);
      document.getElementById('content').innerHTML += `<div class="error">Failed to load ${filename}: ${err}</div>`;
    });
}

    function parseSamplingSheet(sheet) {
      const raw = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (raw.length < 2) return;
      const headers = raw[0].map(h => String(h).trim().toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return;
      for (let i = 1; i < raw.length; i++) {
        const row = raw[i];
        const lat = parseFloat(row[latIdx]);
        const lon = parseFloat(row[lonIdx]);
        if (!isNaN(lat) && !isNaN(lon)) samplingCoords.push({ lat, lon });
      }
    }

    function initMap() {
      mapRef = L.map('issue-map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(mapRef);

      const allPoints = [
        ...issueCoords.map(c => [c.lat, c.lon]),
        ...samplingCoords.map(c => [c.lat, c.lon]),
      ];
      if (allPoints.length > 0) mapRef.fitBounds(allPoints);

      issueCoords.forEach(c => {
        const icon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${c.issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
        L.marker([c.lat, c.lon], { icon }).addTo(mapRef);
      });

      samplingLayerGroup = L.layerGroup(
        samplingCoords.map(c => L.circleMarker([c.lat, c.lon], { radius: 3, color: 'blue', fillOpacity: 0.6, weight: 1 }))
      ).addTo(mapRef);

      mapRef.whenReady(() => mapRef.invalidateSize());
    }

    function showError(message) {
      document.getElementById('sidebar').innerHTML = `<div class="error">${message}</div>`;
    }
  </script>
</body>
</html>








