<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Annotator Reports Viewer</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #fff; color: #000; }
    #sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 240px; background: #f5f5f5; overflow-y: auto; border-right: 1px solid #ddd; }
    #content { margin-left: 240px; padding: 20px; }
    .day-header { padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #ddd; }
    .day-header:hover { background: #e0e0e0; }
    .session-list { display: none; list-style: none; margin: 0; padding: 0; }
    .session-item { padding: 8px 32px; cursor: pointer; border-bottom: 1px solid #eee; }
    .session-item:hover { background: #f0f0f0; }
    .session-item .meta { font-size: 12px; color: #666; margin-top: 2px; }

    h1 { margin: 0 0 12px 0; }
    h2 { margin-top: 1.5em; border-bottom: 1px solid #ddd; padding-bottom: 4px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 2em; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #f5f5f5 !important; }
    .error { color: #d00; padding: 16px; }

    .issue-badge { display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: red; color: white; border-radius: 12px; font-size: 12px; font-weight: bold; pointer-events: none; }
    #issue-map { width: 100%; height: 400px; margin: 20px 0; border: 1px solid #aaa; }

    .download-button { display: inline-block; margin-right: 12px; margin-bottom: 16px; padding: 8px 12px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; font-size: 14px; }
    .download-button:hover { background: #0056b3; }

    /* Overview (contribution heatmap) */
    .overview { max-width: 980px; }
    .heatmap-months { font-size: 12px; fill: #333; }
    .heatmap-dow { font-size: 12px; fill: #666; }
    .legend { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #666; margin-top: 10px; }
    .legend .box { width: 12px; height: 12px; border: 1px solid #ccd3d9; }

    /* Latest routes grid */
    .routes-wrap { margin-top: 18px; }
    .route-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px,1fr)); gap: 14px; max-width: 980px; }
    .route-card { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
    .route-title { font-size: 13px; color: #333; margin-bottom: 8px; }
    .route-meta { font-size: 12px; color: #666; margin-top: 6px; }
    .route-map { width: 100%; height: 180px; border: 1px solid #aaa; border-radius: 6px; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2 style="padding:16px; margin:0; border-bottom:1px solid #ddd;">Test sessions</h2>
  </div>

  <div id="content">
    <h1>Test activity overview</h1>
    <div id="overview" class="overview">
      <div style="color:#666; margin:6px 0 14px 0;">Aggregated issue counts per day (sessions &lt; 1 km ignored).</div>
      <div id="heatmap-host"></div>

      <div class="routes-wrap">
        <h2 style="margin-top:16px;">Latest routes (â‰¥ 1 km)</h2>
        <div id="routes-grid" class="route-grid"></div>
      </div>
    </div>
  </div>

  <footer style="text-align:center; padding:10px; font-size:12px; color:#666;">Ver 1.3</footer>

  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>

  <script>
    // ---------- CONFIG ----------
    const ACCOUNT   = 'annotationcsv';
    const CONTAINER = 'csv';
    const SAS_TOKEN = 'sv=2024-11-04&ss=bfqt&srt=co&sp=rwdlacupiytfx&se=2025-12-30T14:44:25Z&st=2025-05-30T05:44:25Z&spr=https&sig=QriUtSG3IFzzE3cz7vpcXpE7Ed6QDwSYSZ6YvT2kM%2B0%3D';
    const BASE_URL  = `https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}`;
    const MIN_KM_FOR_OVERVIEW = 1; // <-- changed to 1 km

    // ---------- CACHES / HELPERS ----------
    const summaryCache = new Map(); // filename -> { mileageKm, issueCount, loaded:true }

    function cssSafeId(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g,'_'); }
    function toDateOnly(d){ const t = new Date(d); t.setHours(0,0,0,0); return t; }

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*sin2(dLon/2);
      return 2 * R * Math.asin(Math.sqrt(a));
      function sin2(x){ x = Math.sin(x); return x*x; }
    }

    function computeMileageAndPathFromSampling(sheet) {
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (rows.length < 3) return { km: null, path: [] };

      const headers = rows[0].map(h => String(h ?? '').toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return { km: null, path: [] };

      let km = 0, prev = null;
      const path = [];
      for (let i = 1; i < rows.length; i++) {
        const lat = parseFloat(rows[i][latIdx]);
        const lon = parseFloat(rows[i][lonIdx]);
        if (isNaN(lat) || isNaN(lon)) continue;
        path.push([lat, lon]);
        if (prev) km += haversine(prev[0], prev[1], lat, lon) / 1000;
        prev = [lat, lon];
      }
      return { km: Math.round(km), path };
    }

    function countIssuesFromWorkbook(wb) {
      const norm = s => String(s||'').toLowerCase().replace(/\s+/g,'');
      for (const name of wb.SheetNames) {
        if (name.toLowerCase() === 'sampling') continue;
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[name], { header: 1 });
        if (rows.length < 2) continue;
        const hdrs = rows[0].map(norm);
        const latIdx = hdrs.findIndex(h => h.includes('lat'));
        const lonIdx = hdrs.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
        if (latIdx < 0 || lonIdx < 0) continue;
        let count = 0;
        for (let i = 1; i < rows.length; i++) {
          const lat = parseFloat(rows[i][latIdx]);
          const lon = parseFloat(rows[i][lonIdx]);
          if (!isNaN(lat) && !isNaN(lon)) count++;
        }
        if (count > 0) return count;
      }
      return 0;
    }

    function fetchSessionSummary(filename) {
      if (summaryCache.has(filename)) return Promise.resolve(summaryCache.get(filename));
      return fetch(`${BASE_URL}/${filename}?${SAS_TOKEN}`)
        .then(res => {
          if (!res.ok) throw new Error(`Fetch XLSX failed ${res.status}`);
          return res.arrayBuffer();
        })
        .then(buf => {
          const wb = XLSX.read(new Uint8Array(buf), { type:'array' });
          const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
          let mileageKm = null;
          if (samplingName) {
            const { km } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
            mileageKm = km;
          }
          const issueCount = countIssuesFromWorkbook(wb);
          const summary = { mileageKm, issueCount, loaded:true };
          summaryCache.set(filename, summary);
          return summary;
        })
        .catch(() => {
          const summary = { mileageKm: null, issueCount: 0, loaded:true };
          summaryCache.set(filename, summary);
          return summary;
        });
    }

    // ---------- APP STATE ----------
    let issueCoords = [];
    let samplingCoords = [];
    let mapRef = null;
    let samplingLayerGroup = null;

    document.addEventListener('DOMContentLoaded', listBlobs);

    function listBlobs() {
      fetch(`${BASE_URL}?restype=container&comp=list&${SAS_TOKEN}`)
        .then(r => r.text())
        .then(xml => {
          const doc   = new DOMParser().parseFromString(xml, 'application/xml');
          const names = Array.from(doc.getElementsByTagName('Name')).map(n => n.textContent);
          const xlsx  = names.filter(n => n.toLowerCase().endsWith('.xlsx'));
          if (xlsx.length === 0) { showError('No .xlsx files found.'); return; }

          buildSidebar(xlsx);
          buildOverviewHeatmap(xlsx);
          buildLatestRoutePreviews(xlsx); // <-- NEW
        })
        .catch(err => showError('Failed to list blobs: ' + err));
    }

    // ---------- SIDEBAR (with small meta) ----------
    function buildSidebar(files) {
      const sb = document.getElementById('sidebar');
      sb.innerHTML = '';
      const header = document.createElement('h2');
      header.textContent = 'Test sessions';
      header.style.padding = '16px';
      header.style.margin = '0';
      header.style.borderBottom = '1px solid #ddd';
      sb.appendChild(header);

      const groups = files.reduce((acc, f) => {
        const m = f.match(/(\d{4}-\d{2}-\d{2})/);
        if (!m) return acc;
        (acc[m[1]] ||= []).push(f);
        return acc;
      }, {});

      Object.keys(groups).sort().reverse().forEach(day => {
        const hdr = document.createElement('div');
        hdr.className = 'day-header';
        hdr.textContent = day;

        const lst = document.createElement('ul');
        lst.className = 'session-list';

        groups[day].sort().forEach(f => {
          const namePretty = f.replace(`${day}_`, '').replace('.xlsx','');
          const li = document.createElement('li');
          li.className = 'session-item';
          li.onclick = () => loadFile(f);

          const title = document.createElement('div');
          title.textContent = namePretty;

          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.id = `meta_${cssSafeId(f)}`;
          meta.textContent = 'Loadingâ€¦';

          li.appendChild(title);
          li.appendChild(meta);
          lst.appendChild(li);
        });

        let loadedThisGroup = false;
        hdr.onclick = () => {
          const expand = lst.style.display !== 'block';
          lst.style.display = expand ? 'block' : 'none';
          if (expand && !loadedThisGroup) {
            loadedThisGroup = true;
            groups[day].forEach(f => {
              fetchSessionSummary(f).then(({ mileageKm, issueCount }) => {
                const el = document.getElementById(`meta_${cssSafeId(f)}`);
                if (!el) return;
                const mileageText = (mileageKm ?? 'â€“') + (mileageKm != null ? 'km' : '');
                el.textContent = `Mileage: ${mileageText}  No of issues: ${issueCount}`;
              });
            });
          }
        };

        sb.appendChild(hdr);
        sb.appendChild(lst);
      });
    }

    // ---------- OVERVIEW HEATMAP ----------
    function buildOverviewHeatmap(files){
      const byDay = new Map(); // 'YYYY-MM-DD' -> totalIssues (only sessions >= 1km)
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      Promise.all(withDates.map(x => fetchSessionSummary(x.filename).then(s => ({...x, ...s}))))
        .then(rows => {
          rows.forEach(r => {
            if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW) return;
            const prev = byDay.get(r.dayStr) || 0;
            byDay.set(r.dayStr, prev + (r.issueCount || 0));
          });

          const days = Array.from(byDay.keys()).sort();
          if (days.length === 0){
            document.getElementById('heatmap-host').innerHTML =
              '<div style="color:#666;">No eligible sessions (â‰¥ 1 km) to show yet.</div>';
            return;
          }
          const minDate = toDateOnly(days[0]);
          const maxDate = toDateOnly(days[days.length-1]);

          const start = new Date(minDate);
          const day = start.getDay(); // 0 Sun â€¦ 6 Sat
          const offsetToMonday = (day === 0 ? 6 : day - 1);
          start.setDate(start.getDate() - offsetToMonday);
          start.setHours(0,0,0,0);

          const end = new Date(maxDate);
          const endDay = end.getDay();
          const addToSunday = (7 - endDay) % 7;
          end.setDate(end.getDate() + addToSunday);
          end.setHours(0,0,0,0);

          const dense = [];
          let cur = new Date(start);
          while (cur <= end) {
            const ymd = cur.toISOString().slice(0,10);
            dense.push({ date: new Date(cur), count: byDay.get(ymd) || 0 });
            cur.setDate(cur.getDate() + 1);
          }

          renderHeatmap(dense);
        });
    }

    function renderHeatmap(denseDays){
      const host = document.getElementById('heatmap-host');
      host.innerHTML = '';

      const cell = 12, gap = 3, rows = 7;
      const weeks = Math.ceil(denseDays.length / 7);
      const width  = weeks * (cell + gap) + 40;
      const height = rows  * (cell + gap) + 20;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const level = v => (v === 0) ? 0 : (v < 5 ? 1 : (v < 10 ? 2 : (v < 20 ? 3 : 4)));

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);

      const months = document.createElementNS(NS, 'g'); months.setAttribute('class','heatmap-months');
      let lastMonth = -1;
      for (let w = 0; w < weeks; w++) {
        const idx = w * 7;
        if (idx >= denseDays.length) break;
        const d = denseDays[idx].date;
        const m = d.getMonth();
        if (m !== lastMonth) {
          lastMonth = m;
          const t = document.createElementNS(NS,'text');
          t.textContent = d.toLocaleString(undefined,{month:'short'});
          t.setAttribute('x', 40 + w*(cell+gap));
          t.setAttribute('y', 10);
          months.appendChild(t);
        }
      }
      svg.appendChild(months);

      const dow = document.createElementNS(NS,'g'); dow.setAttribute('class','heatmap-dow');
      [['Mon',0],['Wed',2],['Fri',4]].forEach(([name,row])=>{
        const t=document.createElementNS(NS,'text');
        t.textContent=name; t.setAttribute('x',0); t.setAttribute('y',24+row*(cell+gap));
        dow.appendChild(t);
      });
      svg.appendChild(dow);

      const cellsG = document.createElementNS(NS,'g');
      for (let i = 0; i < denseDays.length; i++) {
        const d = denseDays[i];
        const w = Math.floor(i / 7);
        const r = i % 7;
        const rect = document.createElementNS(NS,'rect');
        rect.setAttribute('x', 40 + w*(cell+gap));
        rect.setAttribute('y', 16 + r*(cell+gap));
        rect.setAttribute('width', cell);
        rect.setAttribute('height', cell);
        rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
        rect.setAttribute('fill', colors[level(d.count)]);
        rect.setAttribute('stroke', '#ccd3d9');
        rect.setAttribute('stroke-width', '1');
        cellsG.appendChild(rect);
      }
      svg.appendChild(cellsG);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Less
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- LATEST ROUTE PREVIEWS (top 5 â‰¥ 1 km) ----------
    function buildLatestRoutePreviews(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      Promise.all(withDates.map(x => fetchSessionSummary(x.filename).then(s => ({...x, ...s}))))
        .then(rows => {
          // Filter â‰¥ 1 km, sort by date desc, take 5 newest
          const take = rows
            .filter(r => r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW)
            .sort((a,b) => b.dayStr.localeCompare(a.dayStr))
            .slice(0,5);

          if (take.length === 0) return;

          const grid = document.getElementById('routes-grid');
          grid.innerHTML = '';

          // For each, fetch workbook again to extract the full path
          take.forEach(item => {
            fetch(`${BASE_URL}/${item.filename}?${SAS_TOKEN}`)
              .then(res => res.arrayBuffer())
              .then(buf => {
                const wb = XLSX.read(new Uint8Array(buf), { type:'array' });
                const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
                if (!samplingName) return;

                const { km, path } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
                if (!path || path.length < 2) return;

                const card = document.createElement('div');
                card.className = 'route-card';

                const niceName = item.filename.replace(`${item.dayStr}_`, '').replace('.xlsx','');
                const title = document.createElement('div');
                title.className = 'route-title';
                title.textContent = `${item.dayStr} â€” ${niceName}`;
                card.appendChild(title);

                const mapDiv = document.createElement('div');
                mapDiv.className = 'route-map';
                mapDiv.id = `route_${cssSafeId(item.filename)}`;
                card.appendChild(mapDiv);

                const meta = document.createElement('div');
                meta.className = 'route-meta';
                meta.textContent = `Mileage: ${km ?? 'â€“'} km  â€¢  Issues: ${item.issueCount}`;
                card.appendChild(meta);

                grid.appendChild(card);

                // Mini map with polyline
                const mini = L.map(mapDiv, { attributionControl:false, zoomControl:false });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mini);

                const line = L.polyline(path, { color:'blue', weight:3, opacity:0.8 }).addTo(mini);
                mini.fitBounds(line.getBounds(), { padding:[8,8] });
                mini.whenReady(()=>mini.invalidateSize());
              })
              .catch(()=>{ /* ignore individual failures */ });
          });
        });
    }

    // ---------- SESSION VIEWER (unchanged core except CSS fix) ----------
    function loadFile(filename) {
      const content = document.getElementById('content');
      content.innerHTML = '';
      issueCoords = [];
      samplingCoords = [];
      mapRef = null;

      const issueTableInfo = {
        sheetName: null,
        headerNames: { col1: '', col2: '', col3: '' },
        issueInfo: {}
      };

      const xlsxLink = document.createElement('a');
      xlsxLink.href = `${BASE_URL}/${filename}?${SAS_TOKEN}`;
      xlsxLink.textContent = 'Download XLSX';
      xlsxLink.className = 'download-button';
      xlsxLink.setAttribute('download', filename);
      content.appendChild(xlsxLink);

      const pdfFilename = filename.replace(/\.xlsx$/i, '.pdf');
      const pdfLink = document.createElement('a');
      pdfLink.href = `${BASE_URL}/${pdfFilename}?${SAS_TOKEN}`;
      pdfLink.textContent = 'Download PDF';
      pdfLink.className = 'download-button';
      pdfLink.setAttribute('download', pdfFilename);
      content.appendChild(pdfLink);

      fetch(`${BASE_URL}/${filename}?${SAS_TOKEN}`)
        .then(res => res.arrayBuffer())
        .then(buffer => {
          const wb = XLSX.read(new Uint8Array(buffer), { type: 'array' });

          const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
          if (samplingName) parseSamplingSheet(wb.Sheets[samplingName]);

          let nonSamplingCount = 0;
          let mapInserted = false;

          wb.SheetNames.forEach(sheet => {
            if (sheet.toLowerCase() === 'sampling') return;

            const html = XLSX.utils.sheet_to_html(wb.Sheets[sheet], { id: sheet });
            content.insertAdjacentHTML('beforeend', `<h2>${sheet}</h2>${html}`);

            if (!issueTableInfo.sheetName) {
              const tbl = document.getElementById(sheet);
              const rows = Array.from(tbl.querySelectorAll('tr'));
              if (rows.length > 1) {
                const hdrs = Array.from(rows[0].querySelectorAll('th,td')).map(c => c.textContent.trim().toLowerCase());
                const latIdx = hdrs.findIndex(h => h.includes('lat'));
                const lonIdx = hdrs.findIndex(h => h.includes('lon'));
                if (latIdx >= 0 && lonIdx >= 0) {
                  issueTableInfo.sheetName = sheet;
                  const rawHdrs = Array.from(rows[0].querySelectorAll('th,td'));
                  issueTableInfo.headerNames.col1 = rawHdrs[0].textContent.trim();
                  issueTableInfo.headerNames.col2 = rawHdrs[1].textContent.trim();
                  issueTableInfo.headerNames.col3 = rawHdrs[12]?.textContent.trim() || '';

                  rows.slice(1).forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const issueNo = cells[0].textContent.trim();
                    const col1 = issueNo;
                    const col2 = cells[1].textContent.trim();
                    const col3 = cells[12]?.textContent.trim() || '';
                    const lat = parseFloat(cells[latIdx].textContent.trim());
                    const lon = parseFloat(cells[lonIdx].textContent.trim());
                    if (!isNaN(lat) && !isNaN(lon)) {
                      issueCoords.push({ issueNo, lat, lon });
                    }
                    issueTableInfo.issueInfo[issueNo] = { issueNo, col1, col2, col3, lat, lon };
                  });
                }
              }
            }

            nonSamplingCount++;
            if (nonSamplingCount === 2 && !mapInserted) {
              const mapDiv = document.createElement('div');
              mapDiv.id = 'issue-map';
              mapDiv.style.width = '100%';
              mapDiv.style.height = '400px';
              mapDiv.style.margin = '20px 0';
              mapDiv.style.border = '1px solid #aaa';
              content.appendChild(mapDiv);
              mapInserted = true;
            }
          });
        })
        .then(() => {
          if (!document.getElementById('issue-map')) {
            const mapDiv = document.createElement('div');
            mapDiv.id = 'issue-map';
            mapDiv.style.width = '100%';
            mapDiv.style.height = '400px';
            mapDiv.style.margin = '20px 0';
            mapDiv.style.border = '1px solid #aaa';
            document.getElementById('content').appendChild(mapDiv);
          }
          if (issueCoords.length || samplingCoords.length) {
            initMap();
          } else {
            const ph = document.getElementById('issue-map');
            const err = document.createElement('div');
            err.className = 'error';
            err.innerHTML = `Need at least 1 issue or sampling point to plot a map (found ${issueCoords.length} issues, ${samplingCoords.length} sampling points).`;
            ph.replaceWith(err);
          }
        })
        .then(() => {
          const zipFilename = filename.replace(/\.xlsx$/i, '.zip');
          return fetch(`${BASE_URL}/${zipFilename}?${SAS_TOKEN}`)
            .then(resp => {
              if (!resp.ok) return Promise.reject('ZIP not found');
              return resp.arrayBuffer();
            })
            .then(buf => JSZip.loadAsync(buf))
            .then(zip => {
              const content = document.getElementById('content');
              const mapDiv = document.getElementById('issue-map');
              const title = document.createElement('h2');
              title.textContent = 'Issue snapshots';

              const table = document.createElement('table');
              table.id = 'issue-snapshots';
              table.style.width = 'auto';
              table.style.marginBottom = '2em';
              table.style.borderCollapse = 'collapse';

              const hdrRow = document.createElement('tr');
              ['col1','col2','col3','Location','Snapshot'].forEach(txt => {
                const th = document.createElement('th');
                th.textContent = (txt.startsWith('col') ? ( {col1:'',col2:'',col3:''}[txt] = 1, issueTableInfo.headerNames[txt] ) : txt) || txt;
                th.style.backgroundColor = '#f5f5f5';
                th.style.padding = '8px';
                th.style.border = '1px solid #ccc';
                hdrRow.appendChild(th);
              });
              table.appendChild(hdrRow);

              zip.forEach((path, entry) => {
                if (entry.dir || !/\.(jpe?g|png|gif)$/i.test(path)) return;
                const issueNo = path.replace(/\.[^/.]+$/, '');
                const info = issueTableInfo.issueInfo[issueNo];
                if (!info) return;

                const row = document.createElement('tr');
                [info.col1, info.col2, info.col3].forEach(val => {
                  const td = document.createElement('td');
                  td.textContent = val;
                  td.style.padding = '8px';
                  td.style.border = '1px solid #ccc';
                  row.appendChild(td);
                });

                const tdMap = document.createElement('td');
                tdMap.style.padding = '8px';
                tdMap.style.border = '1px solid #ccc';
                const miniDiv = document.createElement('div');
                miniDiv.id = `snapshot-map-${cssSafeId(issueNo)}`;
                miniDiv.style.width = '150px';
                miniDiv.style.height = '150px';
                tdMap.appendChild(miniDiv);
                row.appendChild(tdMap);

                const tdImg = document.createElement('td');
                tdImg.style.padding = '8px';
                tdImg.style.border = '1px solid #ccc';

                entry.async('blob').then(rawBlob => {
                  let mime = 'application/octet-stream';
                  if (/\.(jpe?g)$/i.test(path)) mime = 'image/jpeg';
                  else if (/\.png$/i.test(path)) mime = 'image/png';
                  else if (/\.gif$/i.test(path)) mime = 'image/gif';
                  const blob = new Blob([rawBlob], { type: mime });
                  const url  = URL.createObjectURL(blob);

                  const link = document.createElement('a');
                  link.href = url; link.target = '_blank'; link.rel = 'noopener noreferrer';

                  const img = document.createElement('img');
                  img.src = url; img.style.maxWidth = '200px'; img.style.maxHeight = '200px'; img.style.cursor = 'pointer';
                  link.appendChild(img);
                  tdImg.appendChild(link);

                  const miniMap = L.map(miniDiv, { attributionControl:false, zoomControl:false }).setView([info.lat, info.lon], 17);
                  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(miniMap);
                  const badgeIcon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
                  L.marker([info.lat, info.lon], { icon: badgeIcon }).addTo(miniMap);
                  const circle = L.circle([info.lat, info.lon], { radius: 100 }).addTo(miniMap);
                  miniMap.fitBounds(circle.getBounds(), { padding:[4,4] });
                  miniMap.invalidateSize();
                });

                row.appendChild(tdImg);
                table.appendChild(row);
              });

              if (mapDiv) {
                mapDiv.insertAdjacentElement('afterend', title);
                title.insertAdjacentElement('afterend', table);
              } else {
                content.appendChild(title);
                content.appendChild(table);
              }
            });
        })
        .catch(err => {
          console.error(err);
          document.getElementById('content').innerHTML += `<div class="error">Failed to load ${filename}: ${err}</div>`;
        });
    }

    function parseSamplingSheet(sheet) {
      const raw = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (raw.length < 2) return;
      const headers = raw[0].map(h => String(h).trim().toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return;
      for (let i = 1; i < raw.length; i++) {
        const row = raw[i];
        const lat = parseFloat(row[latIdx]);
        const lon = parseFloat(row[lonIdx]);
        if (!isNaN(lat) && !isNaN(lon)) samplingCoords.push({ lat, lon });
      }
    }

    function initMap() {
      mapRef = L.map('issue-map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(mapRef);

      const allPoints = [
        ...issueCoords.map(c => [c.lat, c.lon]),
        ...samplingCoords.map(c => [c.lat, c.lon]),
      ];
      if (allPoints.length > 0) mapRef.fitBounds(allPoints);

      issueCoords.forEach(c => {
        const icon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${c.issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
        L.marker([c.lat, c.lon], { icon }).addTo(mapRef);
      });

      samplingLayerGroup = L.layerGroup(
        samplingCoords.map(c => L.circleMarker([c.lat, c.lon], { radius: 3, color: 'blue', fillOpacity: 0.6, weight: 1 }))
      ).addTo(mapRef);

      mapRef.whenReady(() => mapRef.invalidateSize());
    }

    function showError(message) {
      document.getElementById('sidebar').innerHTML = `<div class="error">${message}</div>`;
    }
  </script>
</body>
</html>
