<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Annotator Reports Viewer</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #fff; color: #000; }
    #sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 240px; background: #f5f5f5; overflow-y: auto; border-right: 1px solid #ddd; }
    #content { margin-left: 240px; padding: 20px; }
    .day-header { padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #ddd; }
    .day-header:hover { background: #e0e0e0; }
    .session-list { display: none; list-style: none; margin: 0; padding: 0; }
    .session-item { padding: 8px 32px; cursor: pointer; border-bottom: 1px solid #eee; }
    .session-item:hover { background: #f0f0f0; }
    .session-item .meta { font-size: 12px; color: #666; margin-top: 2px; }

    h1 { margin: 0 0 12px 0; }
    h2 { margin-top: 1.5em; border-bottom: 1px solid #ddd; padding-bottom: 4px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 2em; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #f5f5f5 !important; }
    .error { color: #d00; padding: 16px; }

    .issue-badge { display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: red; color: white; border-radius: 12px; font-size: 12px; font-weight: bold; pointer-events: none; }
    #issue-map { width: 100%; height: 400px; margin: 20px 0; border: 1px solid #aaa; }

    .download-button { display: inline-block; margin-right: 12px; margin-bottom: 16px; padding: 8px 12px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; font-size: 14px; }
    .download-button:hover { background: #0056b3; }

    /* Overview (four charts side by side) */
    .overview {
      max-width: none;
      width: 100%;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 20px;
      align-items: start;
    }
    .heatmap-months { font-size: 12px; fill: #333; }
    .heatmap-dow { font-size: 12px; fill: #666; }
    .legend{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:12px;
  color:#666;
  margin-top:10px;
  justify-content:flex-end; 
}
    .legend .box { width: 12px; height: 12px; border: 1px solid #ccd3d9; }

    /* Latest routes grid */
    .routes-wrap { margin-top: 18px; }
    .route-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px,1fr)); gap: 14px; max-width: none; width: 100%; }
    .route-card { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
    .route-title { font-size: 13px; color: #333; margin-bottom: 8px; }
    /* keep the old style for non-enhanced anchors only */
    .route-title a:not(.route-link) { color: inherit; text-decoration: none; }
    .route-title a:not(.route-link):hover { text-decoration: underline; }
    .route-meta { font-size: 12px; color: #666; margin-top: 6px; }
    .route-map { width: 100%; height: clamp(180px, 20vw, 320px); border: 1px solid #aaa; border-radius: 6px; }

    /* Make "Test activity overview" same size as "Latest routes" */
    #title-overview { font-size: 1.5em; }

    /* Remove the line under "Latest routes" only */
    .routes-wrap > h2{ border-bottom: none !important; padding-bottom: 0; }
    /* Remove the line under "Mileage per country" */
    .eu-mileage-wrap > h2 { border-bottom: none !important; padding-bottom: 0; }

    /* --- Link-stylish treatment for Latest routes title links --- */
    :root{ --accent:#1f3de3; }
    .route-link{
      display:inline-flex; align-items:center; gap:8px;
      color:var(--accent); font-weight:700; text-decoration:none;
    }
    .route-link .u{
      background-image: linear-gradient(currentColor,currentColor);
      background-repeat: no-repeat;
      background-size: 100% 2px;
      background-position: 0 100%;
      text-underline-offset: 4px;
      padding-bottom: 2px;
    }
    .route-link::after{
      content:"›"; font-size:1.05em; opacity:.6;
      transform: translateX(0);
      transition: transform .18s ease, opacity .18s ease;
    }
    .route-link:hover, .route-link:focus{ color:#1430c9; }
    .route-link:hover::after, .route-link:focus::after{ transform: translateX(3px); opacity:1; }
    .route-link:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:4px; }
    .route-link{ color:#000 !important; text-decoration:none !important; }
    .route-link .u{ background-image:none !important; padding-bottom:0; }
    .route-link:hover, .route-link:focus{ color:#000; text-decoration:none; }
    .route-title a.route-link:hover{ text-decoration:none; }

    .route-overlay .route-link{ color:#000; text-shadow:none; }
    .route-overlay .route-link .u{ background-image:none; }

    .route-link:focus-visible{ outline:2px solid #000; outline-offset:2px; border-radius:4px; }
    .route-title a.route-link:hover{ text-decoration:none; }

    /* ===== Typing indicator for titles ===== */
    .title-thinking { display:inline-flex; align-items:center; gap:6px; }
    .title-thinking .dots { display:inline-flex; gap:4px; }
    .title-thinking .dot {
      width:6px; height:6px; border-radius:50%;
      background:#888; opacity:.25;
      animation:titleBlink 1.2s infinite both;
    }
    .title-thinking .dot:nth-child(2){ animation-delay:.2s; }
    .title-thinking .dot:nth-child(3){ animation-delay:.4s; }
    @keyframes titleBlink {
      0%, 80%, 100% { opacity:.25; }
      40% { opacity:1; }
    }

    /* ===== Make chart SVGs scale to container width ===== */
    #heatmap-host svg,
    #country-host svg,
    #temp-host svg,
    #weather-host svg {
      width: 100%;
      height: auto;
      display: block;
    }

    /* ===== EU Mileage Map styles (NEW) ===== */
    .eu-mileage-map{
      width: 100%;
      height: clamp(300px, 40vw, 560px);
      border: 1px solid #aaa;
      border-radius: 6px;
      margin-top: 8px;
    }
    /* white, bold numbers over red dots */
    .leaflet-tooltip.eu-mileage-label{
      background: transparent;
      border: none;
      box-shadow: none;
      color: #fff;
      font-weight: 800;
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="sidebar">
    <h2 style="padding:16px; margin:0; border-bottom:1px solid #ddd;">Test sessions</h2>
  </div>

  <div id="content">
    <!-- Pre-render headings in "Loading" state to avoid flicker -->
    <h1 id="title-overview" data-title="Test activity overview" data-loading="1">
      <span>Loading</span>
      <span class="title-thinking">
        <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
      </span>
    </h1>
    <div id="overview" class="overview">
      <div><div id="heatmap-host"></div></div>
      <div><div id="country-host"></div></div>
      <div><div id="temp-host"></div></div>
      <div><div id="weather-host"></div></div>

      <!-- NEW: EU Mileage map block (spans full width, before latest routes) -->
      <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
        <h2 id="title-eu-mileage" data-title="Mileage per country" data-loading="1" style="margin-top:16px;">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h2>
        <div id="eu-mileage-map" class="eu-mileage-map"></div>
      </div>

      <div class="routes-wrap" style="grid-column: 1 / -1;">
        <h2 id="title-latest-routes" data-title="Latest routes" data-loading="1" style="margin-top:16px;">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h2>
        <div id="routes-grid" class="route-grid"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>

  <script>
    // ---------- CONFIG ----------
    const ACCOUNT   = 'annotationcsv';
    const CONTAINER = 'csv';
    const SAS_TOKEN = 'sv=2024-11-04&ss=bfqt&srt=co&sp=rwdlacupiytfx&se=2025-12-30T14:44:25Z&st=2025-05-30T05:44:25Z&spr=https&sig=QriUtSG3IFzzE3cz7vpcXpE7Ed6QDwSYSZ6YvT2kM%2B0%3D';
    const BASE_URL  = `https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}`;
    const MIN_KM_FOR_OVERVIEW = 1;

    // ---------- CACHES / HELPERS ----------
    const summaryCache = new Map(); // filename -> { mileageKm, issueCount, meanTempC, weatherAgg, loaded:true }
    const blobMeta = new Map();     // filename -> lastModifiedMs (strict sort)
    const countryCache = new Map(); // filename -> array of countries

    function cssSafeId(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g,'_'); }
    function toDateOnly(d){ const t = new Date(d); t.setHours(0,0,0,0); return t; }

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    /* Title loading indicator helper (uses data-title, default "Loading") */
    function setTitleLoading(el, on, labelText = 'Loading') {
      if (!el) return;
      if (on) {
        if (el.dataset.loading === '1') return; // already loading
        el.dataset.loading = '1';
        el.dataset.originalText = el.dataset.title || el.textContent;
        el.innerHTML = `
          <span>${labelText}</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>`;
      } else {
        if (el.dataset.loading !== '1') return;
        const txt = el.dataset.title || el.dataset.originalText || el.textContent;
        el.textContent = txt;
        delete el.dataset.loading;
        delete el.dataset.originalText;
      }
    }

    function computeMileageAndPathFromSampling(sheet) {
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (rows.length < 3) return { km: null, path: [] };

      const headers = rows[0].map(h => String(h ?? '').toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return { km: null, path: [] };

      let km = 0, prev = null;
      const path = [];
      for (let i = 1; i < rows.length; i++) {
        const lat = parseFloat(rows[i][latIdx]);
        const lon = parseFloat(rows[i][lonIdx]);
        if (isNaN(lat) || isNaN(lon)) continue;
        path.push([lat, lon]);
        if (prev) km += haversine(prev[0], prev[1], lat, lon) / 1000;
        prev = [lat, lon];
      }
      return { km: Math.round(km), path };
    }

    // --- Mean Temp + Mode Weather from the "Issue/Issues" sheet ---
    function computeTempWeatherFromIssuesSheet(sheet){
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
      if (rows.length < 2) return { meanTempC: null, weatherAgg: null };

      const headers = rows[0].map(h => String(h ?? '').trim().toLowerCase());
      const tempIdx = headers.findIndex(h => /\btemp\b/.test(h) || /temperature/.test(h));
      const wxIdx   = headers.findIndex(h => /weather/.test(h) || /condition/.test(h));

      const temps = [];
      const wxCounts = new Map();

      const normWx = (s)=>{
        if (s == null) return null;
        const v = String(s).trim().toLowerCase();
        if (!v) return null;
        if (/thunder|storm/.test(v)) return 'Storm';
        if (/snow|blizzard|sleet/.test(v)) return 'Snow';
        if (/rain|drizzle|shower/.test(v)) return 'Rain';
        if (/fog|mist|haze/.test(v)) return 'Fog';
        if (/cloud|overcast/.test(v)) return 'Cloudy';
        if (/clear|sun/.test(v)) return 'Clear';
        if (/wind/.test(v)) return 'Wind';
        return v.charAt(0).toUpperCase() + v.slice(1);
      };

      const parseTempFromValue = (val) => {
        if (val == null) return null;
        const s = String(val).trim();
        if (!s) return null;
        let m = s.match(/(-?\d+(?:[.,]\d+)?)\s*°?\s*c\b/i);
        if (!m) m = s.match(/temp(?:erature)?[^0-9\-]*(-?\d+(?:[.,]\d+)?)/i);
        if (!m) return null;
        const num = parseFloat(m[1].replace(',', '.'));
        return Number.isFinite(num) ? num : null;
      };

      for (let r = 1; r < rows.length; r++){
        const row = rows[r];
        if (tempIdx >= 0){
          const t = parseTempFromValue(row[tempIdx]);
          if (t != null) temps.push(t);
        } else {
          for (let c = 0; c < row.length; c++){
            const t = parseTempFromValue(row[c]);
            if (t != null){ temps.push(t); break; }
          }
        }

        if (wxIdx >= 0){
          const w = normWx(row[wxIdx]);
          if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
        } else {
          for (let c = 0; c < row.length; c++){
            const cell = row[c];
            if (cell == null) continue;
            const m = String(cell).match(/weather\s*:\s*([a-z][a-z\s\-]+)/i);
            if (m){
              const w = normWx(m[1]);
              if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
              break;
            }
          }
        }
      }

      const meanTempC = temps.length
        ? Math.round((temps.reduce((a,b)=>a+b,0) / temps.length) * 10) / 10
        : null;

      let weatherAgg = null;
      if (wxCounts.size){
        weatherAgg = Array.from(wxCounts.entries()).sort((a,b)=> b[1] - a[1])[0][0];
      }

      return { meanTempC, weatherAgg };
    }

    function computeTempWeatherFromIssues(wb){
      const issueSheets = wb.SheetNames.filter(n => /issue/i.test(n));
      for (const name of issueSheets){
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      for (const name of wb.SheetNames){
        if (name.toLowerCase() === 'sampling') continue;
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      return { meanTempC: null, weatherAgg: null };
    }

    function countIssuesFromWorkbook(wb) {
      const norm = s => String(s||'').toLowerCase().replace(/\s+/g,'');
      for (const name of wb.SheetNames) {
        if (name.toLowerCase() === 'sampling') continue;
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[name], { header: 1 });
        if (rows.length < 2) continue;
        const hdrs = rows[0].map(norm);
        const latIdx = hdrs.findIndex(h => h.includes('lat'));
        const lonIdx = hdrs.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
        if (latIdx < 0 || lonIdx < 0) continue;
        let count = 0;
        for (let i = 1; i < rows.length; i++) {
          const lat = parseFloat(rows[i][latIdx]);
          const lon = parseFloat(rows[i][lonIdx]);
          if (!isNaN(lat) && !isNaN(lon)) count++;
        }
        if (count > 0) return count;
      }
      return 0;
    }

    function fetchSessionSummary(filename) {
      if (summaryCache.has(filename)) return Promise.resolve(summaryCache.get(filename));
      return fetch(`${BASE_URL}/${filename}?${SAS_TOKEN}`)
        .then(res => {
          if (!res.ok) throw new Error(`Fetch XLSX failed ${res.status}`);
          return res.arrayBuffer();
        })
        .then(buf => {
          const wb = XLSX.read(new Uint8Array(buf), { type:'array' });
          const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
          let mileageKm = null, meanTempC = null, weatherAgg = null;
          if (samplingName) {
            const { km } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
            mileageKm = km;
          }
          const tw = computeTempWeatherFromIssues(wb);
          meanTempC = tw.meanTempC;
          weatherAgg = tw.weatherAgg;

          const issueCount = countIssuesFromWorkbook(wb);
          const summary = { mileageKm, issueCount, meanTempC, weatherAgg, loaded:true };
          summaryCache.set(filename, summary);
          return summary;
        })
        .catch(() => {
          const summary = { mileageKm: null, issueCount: 0, meanTempC: null, weatherAgg: null, loaded:true };
          summaryCache.set(filename, summary);
          return summary;
        });
    }

    // Read "Test details" sheet (col1=label, col2=value) → map
    function extractTestDetails(wb){
      const details = {};
      const sheetName = wb.SheetNames.find(n => /test\s*details/i.test(n));
      if (!sheetName) return details;

      const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1, blankrows: false });
      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        if (!row || row.length < 2) continue;
        const keyRaw = row[0];
        theVal = row[1];
        const valRaw = theVal;
        if (keyRaw == null || valRaw == null) continue;
        const key = String(keyRaw).trim().toLowerCase();
        const val = String(valRaw).trim();
        if (!key || !val) continue;
        details[key] = val;
      }
      return details;
    }

    // --- Countries parser (from "Country" sheet or fallback Test details) ---
    function fetchCountriesForFile(filename){
      if (countryCache.has(filename)) {
        const cached = countryCache.get(filename);
        return Array.isArray(cached) ? Promise.resolve(cached) : Promise.resolve(cached ? [cached] : []);
      }
      return fetch(`${BASE_URL}/${filename}?${SAS_TOKEN}`)
        .then(res => {
          if (!res.ok) throw new Error('Fetch XLSX failed for country');
          return res.arrayBuffer();
        })
        .then(buf => {
          const wb = XLSX.read(new Uint8Array(buf), { type:'array' });
          const out = new Set();
          const countrySheetName = wb.SheetNames.find(n => /country/i.test(n));
          if (countrySheetName) {
            const rows = XLSX.utils.sheet_to_json(wb.Sheets[countrySheetName], { header: 1, blankrows: false });
            if (rows.length) {
              const headers = rows[0].map(v => String(v ?? '').trim().toLowerCase());
              const colIdx = headers.findIndex(h => h.includes('country'));
              if (colIdx >= 0) {
                for (let r = 1; r < rows.length; r++) {
                  const v = rows[r][colIdx];
                  if (v != null && String(v).trim()) out.add(String(v).trim());
                }
              } else {
                for (let r = 0; r < rows.length; r++) {
                  const a = rows[r][0], b = rows[r][1];
                  const aStr = String(a ?? '').trim().toLowerCase();
                  if (aStr.includes('country') && b != null && String(b).trim()) out.add(String(b).trim());
                  if (!aStr && rows[r].length === 1) {
                    const val = rows[r][0];
                    if (val != null && String(val).trim()) out.add(String(val).trim());
                  }
                }
              }
            }
          }
          if (out.size === 0) {
            const details = extractTestDetails(wb);
            const maybe = details['country'] || details['test country'] || details['location country'] || null;
            if (maybe && String(maybe).trim()) out.add(String(maybe).trim());
          }
          const arr = Array.from(out);
          countryCache.set(filename, arr);
          return arr;
        })
        .catch(() => {
          countryCache.set(filename, []);
          return [];
        });
    }

// ---------- Europe country canonical names & centroids (EXPANDED) ----------
const EU_CENTROIDS = {
  // EU (unchanged)
  'Austria':[47.6,14.3],'Belgium':[50.6,4.7],'Bulgaria':[42.8,25.3],'Croatia':[45.1,15.4],
  'Cyprus':[35.1,33.4],'Czechia':[49.8,15.5],'Denmark':[56.0,10.0],'Estonia':[58.7,25.0],
  'Finland':[64.5,26.0],'France':[46.2,2.2],'Germany':[51.2,10.4],'Greece':[39.1,22.9],
  'Hungary':[47.2,19.5],'Ireland':[53.2,-8.0],'Italy':[42.8,12.5],'Latvia':[56.9,24.6],
  'Lithuania':[55.3,23.9],'Luxembourg':[49.8,6.1],'Malta':[35.9,14.4],'Netherlands':[52.2,5.3],
  'Poland':[52.0,19.1],'Portugal':[39.6,-8.0],'Romania':[45.9,24.9],'Slovakia':[48.7,19.5],
  'Slovenia':[46.1,14.8],'Spain':[40.3,-3.7],'Sweden':[62.0,15.0],

  // Non-EU Europe (added)
  'Albania':[41.2,20.2],
  'Andorra':[42.5,1.6],
  'Armenia':[40.3,44.9],
  'Azerbaijan':[40.1,47.8],
  'Belarus':[53.7,27.9],
  'Bosnia and Herzegovina':[44.2,17.7],
  'Iceland':[64.9,-18.6],
  'Kosovo':[42.6,20.9],
  'Liechtenstein':[47.1,9.6],
  'Moldova':[47.0,28.7],
  'Monaco':[43.73,7.42],
  'Montenegro':[42.8,19.2],
  'North Macedonia':[41.6,21.7],
  'Norway':[64.5,11.0],
  'Russia':[55.7,37.6],          // Moscow as European centroid
  'San Marino':[43.94,12.46],
  'Serbia':[44.0,20.8],
  'Switzerland':[46.8,8.2],
  'Turkey':[39.0,35.0],          // overall centroid; still fine for a single marker
  'Ukraine':[49.0,32.0],
  'United Kingdom':[54.2,-2.0],
  'Vatican City':[41.90,12.45],
  'Georgia':[42.3,43.4]
};
const EU_CANON_LOWER = {};
Object.keys(EU_CENTROIDS).forEach(k => EU_CANON_LOWER[k.toLowerCase()] = k);

// Common aliases / language variants → canonical keys above
const COUNTRY_ALIASES = {
  'czech republic':'czechia',
  'the netherlands':'netherlands',

  'românia':'romania','republic of moldova':'moldova',
  'deutschland':'germany','österreich':'austria','oesterreich':'austria',
  'españa':'spain','espana':'spain','italia':'italy',
  'magyarország':'hungary','polska':'poland','suomi':'finland',
  'elláda':'greece','ellada':'greece',

  'bosnia-herzegovina':'bosnia and herzegovina','bosnia':'bosnia and herzegovina',
  'macedonia':'north macedonia','fyrom':'north macedonia',

  'uk':'united kingdom','u.k.':'united kingdom','gb':'united kingdom',
  'great britain':'united kingdom','england':'united kingdom',
  'scotland':'united kingdom','wales':'united kingdom','northern ireland':'united kingdom',

  'russian federation':'russia',
  'türkiye':'turkey','turkiye':'turkey',

  'cote d’ivoire':'côte d’ivoire' // (example of normalization pattern; harmless if unused)
};

function canonicalEU(raw){
  if (!raw) return null;
  let s = String(raw).trim();

  // Drop bracket comments like "Serbia (RS)"
  s = s.replace(/\(.*?\)/g,'').trim();

  let k = s.toLowerCase();
  if (COUNTRY_ALIASES[k]) k = COUNTRY_ALIASES[k];

  // Exact match
  if (EU_CANON_LOWER[k]) return EU_CANON_LOWER[k];

  // Try simple title case fallback (e.g., "serbia" → "Serbia")
  const tc = k.replace(/\b\w/g, c => c.toUpperCase());
  return EU_CENTROIDS[tc] ? tc : null;
}

    // ---------- APP STATE ----------
    let issueCoords = [];
    let samplingCoords = [];
    let mapRef = null;
    let samplingLayerGroup = null;
    let allFiles = []; // used to re-render overview

    document.addEventListener('DOMContentLoaded', listBlobs);

    // Helper to render the default overview page
    function renderOverview(){
      const content = document.getElementById('content');
      content.innerHTML = `
        <h1 id="title-overview" data-title="Test activity overview" data-loading="1">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h1>
        <div id="overview" class="overview">
          <div><div id="heatmap-host"></div></div>
          <div><div id="country-host"></div></div>
          <div><div id="temp-host"></div></div>
          <div><div id="weather-host"></div></div>

          <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
            <h2 id="title-eu-mileage" data-title="Mileage vs country" data-loading="1" style="margin-top:16px;">
              <span>Loading</span>
              <span class="title-thinking">
                <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
              </span>
            </h2>
            <div id="eu-mileage-map" class="eu-mileage-map"></div>
          </div>

          <div class="routes-wrap" style="grid-column: 1 / -1;">
            <h2 id="title-latest-routes" data-title="Latest routes" data-loading="1" style="margin-top:16px;">
              <span>Loading</span>
              <span class="title-thinking">
                <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
              </span>
            </h2>
            <div id="routes-grid" class="route-grid"></div>
          </div>
        </div>
      `;
      if (allFiles.length){
        const h1 = document.getElementById('title-overview');
        const h2 = document.getElementById('title-latest-routes');
        const hEU = document.getElementById('title-eu-mileage');
        setTitleLoading(h1, true, 'Loading');
        setTitleLoading(h2, true, 'Loading');
        setTitleLoading(hEU, true, 'Loading');

        buildOverviewHeatmap(allFiles).finally(() => setTitleLoading(h1, false));
        buildCountryMonthChart(allFiles);
        buildTempMonthChart(allFiles);
        buildWeatherMonthChart(allFiles);
        buildEUMileageMap(allFiles).finally(() => setTitleLoading(hEU, false));
        buildLatestRoutePreviews(allFiles).finally(() => setTitleLoading(h2, false));
      }
    }

    function listBlobs() {
      fetch(`${BASE_URL}?restype=container&comp=list&${SAS_TOKEN}`)
        .then(r => r.text())
        .then(xml => {
          const doc = new DOMParser().parseFromString(xml, 'application/xml');

          // Read blobs with their Last-Modified timestamps
          const blobs = Array.from(doc.getElementsByTagName('Blob')).map(b => {
            const name = b.getElementsByTagName('Name')[0]?.textContent || '';
            const lmEl = b.getElementsByTagName('Last-Modified')[0] ||
                         b.getElementsByTagName('Properties')[0]?.getElementsByTagName('Last-Modified')[0];
            const lm   = lmEl?.textContent || '';
            return { name, lastModifiedMs: Date.parse(lm) || 0 };
          });

          const xlsx = blobs.filter(b => b.name.toLowerCase().endsWith('.xlsx'));
          if (xlsx.length === 0) { showError('No .xlsx files found.'); return; }

          // Cache for strict chronological sorting
          blobMeta.clear();
          xlsx.forEach(b => blobMeta.set(b.name, b.lastModifiedMs));

          const xlsxNames = xlsx.map(b => b.name);
          allFiles = xlsxNames; // remember for overview re-render

          buildSidebar(xlsxNames);

          const h1 = document.getElementById('title-overview');
          const h2 = document.getElementById('title-latest-routes');
          const hEU = document.getElementById('title-eu-mileage');
          setTitleLoading(h1, true, 'Loading');
          setTitleLoading(h2, true, 'Loading');
          setTitleLoading(hEU, true, 'Loading');

          buildOverviewHeatmap(xlsxNames).finally(() => setTitleLoading(h1, false));
          buildCountryMonthChart(xlsxNames);
          buildTempMonthChart(xlsxNames);
          buildWeatherMonthChart(xlsxNames);
          buildEUMileageMap(xlsxNames).finally(() => setTitleLoading(hEU, false));
          buildLatestRoutePreviews(xlsxNames).finally(() => setTitleLoading(h2, false));
        })
        .catch(err => showError('Failed to list blobs: ' + err));
    }

    // ---------- SIDEBAR ----------
    function buildSidebar(files) {
      const sb = document.getElementById('sidebar');
      sb.innerHTML = '';
      const header = document.createElement('h2');
      header.textContent = 'Test sessions';
      header.style.padding = '16px';
      header.style.margin = '0';
      header.style.borderBottom = '1px solid #ddd';
      header.style.cursor = 'pointer';
      header.title = 'Back to overview';
      header.addEventListener('click', (e) => { e.preventDefault(); renderOverview(); });
      sb.appendChild(header);

      const groups = files.reduce((acc, f) => {
        const m = f.match(/(\d{4}-\d{2}-\d{2})/);
        if (!m) return acc;
        (acc[m[1]] ||= []).push(f);
        return acc;
      }, {});

      Object.keys(groups).sort().reverse().forEach(day => {
        const hdr = document.createElement('div');
        hdr.className = 'day-header';
        hdr.textContent = day;

        const lst = document.createElement('ul');
        lst.className = 'session-list';

        groups[day].sort().forEach(f => {
          const namePretty = f.replace(`${day}_`, '').replace('.xlsx','');
          const li = document.createElement('li');
          li.className = 'session-item';
          li.onclick = () => loadFile(f);

          const title = document.createElement('div');
          title.textContent = namePretty;

          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.id = `meta_${cssSafeId(f)}`;
          meta.textContent = 'Loading…';

          li.appendChild(title);
          li.appendChild(meta);
          lst.appendChild(li);
        });

        let loadedThisGroup = false;
        hdr.onclick = () => {
          const expand = lst.style.display !== 'block';
          lst.style.display = expand ? 'block' : 'none';
          if (expand && !loadedThisGroup) {
            loadedThisGroup = true;
            groups[day].forEach(f => {
              fetchSessionSummary(f).then(({ mileageKm, issueCount }) => {
                const el = document.getElementById(`meta_${cssSafeId(f)}`);
                if (!el) return;
                const mileageText = (mileageKm ?? '–') + (mileageKm != null ? 'km' : '');
                el.textContent = `Mileage: ${mileageText}  No of issues: ${issueCount}`;
              });
            });
          }
        };

        sb.appendChild(hdr);
        sb.appendChild(lst);
      });
    }

    // ---------- OVERVIEW HEATMAP (Test activity) ----------
    function buildOverviewHeatmap(files){
      const byDay = new Map(); // 'YYYY-MM-DD' -> totalIssues (only sessions ≥1 km and issues > 0)
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(withDates.map(x => fetchSessionSummary(x.filename).then(s => ({...x, ...s})))).then(rows => {
        rows.forEach(r => {
          if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return;
          const prev = byDay.get(r.dayStr) || 0;
          byDay.set(r.dayStr, prev + (r.issueCount || 0));
        });

        const days = Array.from(byDay.keys()).sort();
        const host = document.getElementById('heatmap-host');
        if (days.length === 0){
          host.innerHTML = '<div style="color:#666;">No eligible sessions (≥ 1 km and &gt; 0 issues) to show yet.</div>';
          return;
        }

        const minDate = toDateOnly(days[0]);
        const maxDate = toDateOnly(days[days.length-1]);

        const start = new Date(minDate);
        const day = start.getDay(); // 0 Sun … 6 Sat
        const offsetToMonday = (day === 0 ? 6 : day - 1);
        start.setDate(start.getDate() - offsetToMonday);
        start.setHours(0,0,0,0);

        const end = new Date(maxDate);
        const endDay = end.getDay();
        const addToSunday = (7 - endDay) % 7;
        end.setDate(end.getDate() + addToSunday);
        end.setHours(0,0,0,0);

        const dense = [];
        let cur = new Date(start);
        while (cur <= end) {
          const ymd = cur.toISOString().slice(0,10);
          dense.push({ date: new Date(cur), count: byDay.get(ymd) || 0 });
          cur.setDate(cur.getDate() + 1);
        }

        renderHeatmap(dense);
      });
    }

    function renderHeatmap(denseDays){
      const host = document.getElementById('heatmap-host');
      host.innerHTML = '';

      const cell = 12, gap = 3, rows = 7;
      const weeks = Math.ceil(denseDays.length / 7);
      const width  = weeks * (cell + gap) + 40;
      const height = rows  * (cell + gap) + 20;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const level = v => (v === 0) ? 0 : (v < 5 ? 1 : (v < 10 ? 2 : (v < 20 ? 3 : 4)));

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      const months = document.createElementNS(NS, 'g'); months.setAttribute('class','heatmap-months');
      let lastMonth = -1;
      for (let w = 0; w < weeks; w++) {
        const idx = w * 7;
        if (idx >= denseDays.length) break;
        const d = denseDays[idx].date;
        const m = d.getMonth();
        if (m !== lastMonth) {
          lastMonth = m;
          const t = document.createElementNS(NS,'text');
          t.textContent = d.toLocaleString(undefined,{month:'short'});
          t.setAttribute('x', 40 + w*(cell+gap));
          t.setAttribute('y', 10);
          months.appendChild(t);
        }
      }
      svg.appendChild(months);

      const dow = document.createElementNS(NS,'g'); dow.setAttribute('class','heatmap-dow');
      [['Mon',0],['Wed',2],['Fri',4]].forEach(([name,row])=>{
        const t=document.createElementNS(NS,'text');
        t.textContent=name; t.setAttribute('x',0); t.setAttribute('y',24+row*(cell+gap));
        dow.appendChild(t);
      });
      svg.appendChild(dow);

      const cellsG = document.createElementNS(NS,'g');
      for (let i = 0; i < denseDays.length; i++) {
        const d = denseDays[i];
        const w = Math.floor(i / 7);
        const r = i % 7;
        const rect = document.createElementNS(NS,'rect');
        rect.setAttribute('x', 40 + w*(cell+gap));
        rect.setAttribute('y', 16 + r*(cell+gap));
        rect.setAttribute('width', cell);
        rect.setAttribute('height', cell);
        rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
        rect.setAttribute('fill', colors[level(d.count)]);
        rect.setAttribute('stroke', '#ccd3d9');
        rect.setAttribute('stroke-width', '1');
        cellsG.appendChild(rect);
      }
      svg.appendChild(cellsG);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Less
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Countries × Month (4 bins/month) ----------
    function buildCountryMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(
        withDates.map(x =>
          fetchSessionSummary(x.filename)
            .then(s => ({...x, ...s}))
            .then(r => {
              if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return null;
              return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
            })
        )
      ).then(rows => {
        const valid = rows.filter(Boolean).filter(r => Array.isArray(r.countries) && r.countries.length > 0);
        const host = document.getElementById('country-host');
        if (!host) return;

        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No country data found in the “Country” table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${country}` -> n
        const monthsSet = new Set();
        const countriesSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7))); // 1..4
          monthsSet.add(ym);

          const uniq = Array.from(new Set(r.countries.map(c => String(c).trim()).filter(Boolean)));
          uniq.forEach(country => {
            countriesSet.add(country);
            const key = `${ym}|${wb}|${country}`;
            counts.set(key, (counts.get(key)||0) + 1);
          });
        });

        const months = Array.from(monthsSet).sort();
        const countries = Array.from(countriesSet).sort((a,b) => {
          const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
          const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
          if (totalB !== totalA) return totalB - totalA;
          return a.localeCompare(b);
        });

        renderCountryMonthHeatmap({ months, countries, counts });
      });
    }

    function renderCountryMonthHeatmap({months, countries, counts}){
      const host = document.getElementById('country-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 110;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + countries.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => countries.flatMap(c => [1,2,3,4].map(w => counts.get(`${m}|${w}|${c}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Country labels (rows)
      const gCountries = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = countries[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gCountries.appendChild(t);
      }
      svg.appendChild(gCountries);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const country = countries[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${country}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Temperature × Month (4 bins/month) ----------
    function buildTempMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(
        withDates.map(x =>
          fetchSessionSummary(x.filename)
            .then(s => ({...x, ...s}))
        )
      ).then(rows => {
        const valid = rows.filter(r =>
          r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
          r.issueCount > 0 && r.meanTempC != null && !isNaN(r.meanTempC)
        );

        const host = document.getElementById('temp-host');
        if (!host) return;
        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No temperature data found in Issue/Issues table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${tempInt}` -> n
        const monthsSet = new Set();
        const tempsSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
          monthsSet.add(ym);

          const tempInt = Math.round(r.meanTempC);
          tempsSet.add(tempInt);
          const key = `${ym}|${wb}|${tempInt}`;
          counts.set(key, (counts.get(key)||0) + 1);
        });

        const months = Array.from(monthsSet).sort();
        const temps  = Array.from(tempsSet).sort((a,b)=>b-a); // highest first (y-axis reversed)
        renderTempMonthHeatmap({ months, temps, counts });
      });
    }

    function renderTempMonthHeatmap({months, temps, counts}){
      const host = document.getElementById('temp-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 54;  // numbers
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + temps.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => temps.flatMap(t => [1,2,3,4].map(w => counts.get(`${m}|${w}|${t}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Temperature labels (rows)
      const gTemps = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = `${temps[r]}°`;
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gTemps.appendChild(t);
      }
      svg.appendChild(gTemps);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const tempVal = temps[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${tempVal}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Weather × Month (4 bins/month) ----------
    function buildWeatherMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(
        withDates.map(x =>
          fetchSessionSummary(x.filename)
            .then(s => ({...x, ...s}))
        )
      ).then(rows => {
        const valid = rows.filter(r =>
          r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
          r.issueCount > 0 && r.weatherAgg
        );

        const host = document.getElementById('weather-host');
        if (!host) return;
        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No weather data found in Issues table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${wx}` -> n
        const monthsSet = new Set();
        const wxSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
          monthsSet.add(ym);

          const wx = String(r.weatherAgg);
          wxSet.add(wx);
          const key = `${ym}|${wb}|${wx}`;
          counts.set(key, (counts.get(key)||0) + 1);
        });

        const months = Array.from(monthsSet).sort();
        const wxs = Array.from(wxSet).sort((a,b) => {
          const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
          const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
          if (totalB !== totalA) return totalB - totalA;
          return a.localeCompare(b);
        });

        renderWeatherMonthHeatmap({ months, wxs, counts });
      });
    }

    function renderWeatherMonthHeatmap({months, wxs, counts}){
      const host = document.getElementById('weather-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 90;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + wxs.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => wxs.flatMap(w => [1,2,3,4].map(bin => counts.get(`${m}|${bin}|${w}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Weather labels (rows)
      const gWx = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = wxs[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gWx.appendChild(t);
      }
      svg.appendChild(gWx);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const wx = wxs[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${wx}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- EU Mileage Map (NEW) ----------
    function buildEUMileageMap(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(withDates.map(x =>
        fetchSessionSummary(x.filename)
          .then(s => ({...x, ...s}))
          .then(r => {
            if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return null;
            return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
          })
      )).then(rows => {
        const valid = rows.filter(Boolean);
        const agg = new Map(); // country -> total mileage (km)

        valid.forEach(r => {
          const euCountries = Array.isArray(r.countries)
            ? r.countries.map(canonicalEU).filter(Boolean)
            : [];
          if (!euCountries.length) return;

          // Split session mileage evenly across encountered EU countries
          const share = r.mileageKm / euCountries.length;
          euCountries.forEach(cty => {
            agg.set(cty, (agg.get(cty) || 0) + share);
          });
        });

        renderEUMileageMap(agg);
      });
    }

    function renderEUMileageMap(agg){
      const hostId = 'eu-mileage-map';
      const container = document.getElementById(hostId);
      if (!container) return;

      // Reset container
      container.innerHTML = '';

      // If no data, show a message and bail
      const entries = Array.from(agg.entries()).filter(([,km]) => km > 0);
      if (!entries.length){
        container.outerHTML = `<div id="${hostId}" class="eu-mileage-map" style="display:flex;align-items:center;justify-content:center;color:#666;">No EU mileage data available yet.</div>`;
        return;
      }

      const map = L.map(container, { attributionControl:true, zoomControl:true });
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // Compute bounds from centroids we will plot
      const latlngs = [];
      const maxKm = Math.max(...entries.map(([,km]) => km));
      const minR = 6, maxR = 30;

      entries.forEach(([country, km]) => {
        const [lat, lon] = EU_CENTROIDS[country] || [null, null];
        if (lat == null || lon == null) return;
        latlngs.push([lat, lon]);

        // radius in px; area ~ mileage
        const r = (function(){
          if (maxKm <= 0) return minR;
          const f = Math.sqrt(km / maxKm); // sqrt for perceptual scaling
          return Math.round(minR + f * (maxR - minR));
        })();

        const marker = L.circleMarker([lat,lon], {
          radius: r,
          color: '#900',
          weight: 1,
          fillColor: '#d00',
          fillOpacity: 0.7
        }).addTo(map);

        marker.bindTooltip(`${Math.round(km)} km`, {
          permanent: true,
          direction: 'center',
          className: 'eu-mileage-label'
        });
      });

      if (latlngs.length){
        map.fitBounds(latlngs, { padding:[20,20] });
      } else {
        // fallback: view central EU
        map.setView([54,15], 4);
      }

      // ensure proper sizing
      map.whenReady(() => map.invalidateSize());
      // also after a tick in case of CSS transitions/layout
      setTimeout(() => map.invalidateSize(), 100);
    }

    // ---------- LATEST ROUTE PREVIEWS (latest 10, ≥1 km, issues > 0) ----------
    function buildLatestRoutePreviews(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(withDates.map(x => fetchSessionSummary(x.filename).then(s => ({...x, ...s}))))
        .then(rows => {
          // Filter and sort strictly by Last-Modified DESC
          const take = rows
            .filter(r => r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW && r.issueCount > 0)
            .sort((a, b) => {
              const diff = (blobMeta.get(b.filename) ?? 0) - (blobMeta.get(a.filename) ?? 0);
              if (diff !== 0) return diff;
              const byDateStr = b.dayStr.localeCompare(a.dayStr);
              if (byDateStr !== 0) return byDateStr;
              return b.filename.localeCompare(a.filename);
            })
            .slice(0,10);

          const grid = document.getElementById('routes-grid');
          grid.innerHTML = '';
          if (take.length === 0) return;

          // 1) Create and append all cards in the sorted order (placeholders)
          const slots = take.map(item => {
            const card = document.createElement('div');
            card.className = 'route-card';

            const niceName = item.filename.replace(`${item.dayStr}_`, '').replace('.xlsx','');
            const title = document.createElement('div');
            title.className = 'route-title';

            // title as link to open the drive (styled)
            const link = document.createElement('a');
            link.className = 'route-link';
            link.href = '#';
            link.innerHTML = `<span class="u">${item.dayStr} — ${niceName}</span>`;
            link.addEventListener('click', (e)=>{ e.preventDefault(); loadFile(item.filename); });
            title.appendChild(link);
            card.appendChild(title);

            const mapDiv = document.createElement('div');
            mapDiv.className = 'route-map';
            mapDiv.id = `route_${cssSafeId(item.filename)}`;
            card.appendChild(mapDiv);

            const meta = document.createElement('div');
            meta.className = 'route-meta';
            meta.textContent = `Mileage: … km  •  Issues: ${item.issueCount}`;
            card.appendChild(meta);

            grid.appendChild(card);
            return { item, mapDiv, meta };
          });

          // 2) Fill each card asynchronously (order of appending is preserved)
          slots.forEach(({ item, mapDiv, meta }) => {
            fetch(`${BASE_URL}/${item.filename}?${SAS_TOKEN}`)
              .then(res => res.arrayBuffer())
              .then(buf => {
                const wb = XLSX.read(new Uint8Array(buf), { type:'array' });
                const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
                if (!samplingName) return;

                const { km, path } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
                if (!path || path.length < 2) return;

                // Read column-2 values from "Test details"
                const details = extractTestDetails(wb);
                const objVal = details['test object'] || details['object'] || details['vehicle'] || null;
                const purposeVal = details['purpose'] || details['test purpose'] || null;

                const leftParts = [];
                if (objVal) leftParts.push(`Test object: ${objVal}`);
                if (purposeVal) leftParts.push(`Purpose: ${purposeVal}`);
                const leftText = leftParts.length ? leftParts.join('  •  ') + '  •  ' : '';

                const kmText = (km ?? '–');
                meta.textContent = `${leftText}Mileage: ${kmText} km  •  Issues: ${item.issueCount}`;

                const mini = L.map(mapDiv, { attributionControl:false, zoomControl:false });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mini);
                const line = L.polyline(path, { color:'blue', weight:3, opacity:0.8 }).addTo(mini);
                mini.fitBounds(line.getBounds(), { padding:[8,8] });
                mini.whenReady(()=>mini.invalidateSize());
              })
              .catch(()=>{ /* ignore individual failures */ });
          });
        });
    }

    // ---------- SESSION VIEWER ----------
    function loadFile(filename) {
      const content = document.getElementById('content');
      content.innerHTML = '';
      issueCoords = [];
      samplingCoords = [];
      mapRef = null;

      const issueTableInfo = {
        sheetName: null,
        headerNames: { col1: '', col2: '', col3: '' },
        issueInfo: {}
      };

      const xlsxLink = document.createElement('a');
      xlsxLink.href = `${BASE_URL}/${filename}?${SAS_TOKEN}`;
      xlsxLink.textContent = 'Download XLSX';
      xlsxLink.className = 'download-button';
      xlsxLink.setAttribute('download', filename);
      content.appendChild(xlsxLink);

      const pdfFilename = filename.replace(/\.xlsx$/i, '.pdf');
      const pdfLink = document.createElement('a');
      pdfLink.href = `${BASE_URL}/${pdfFilename}?${SAS_TOKEN}`;
      pdfLink.textContent = 'Download PDF';
      pdfLink.className = 'download-button';
      pdfLink.setAttribute('download', pdfFilename);
      content.appendChild(pdfLink);

      fetch(`${BASE_URL}/${filename}?${SAS_TOKEN}`)
        .then(res => res.arrayBuffer())
        .then(buffer => {
          const wb = XLSX.read(new Uint8Array(buffer), { type: 'array' });

          const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
          if (samplingName) parseSamplingSheet(wb.Sheets[samplingName]);

          let nonSamplingCount = 0;
          let mapInserted = false;

          wb.SheetNames.forEach(sheet => {
            if (sheet.toLowerCase() === 'sampling') return;

            const html = XLSX.utils.sheet_to_html(wb.Sheets[sheet], { id: sheet });
            content.insertAdjacentHTML('beforeend', `<h2>${sheet}</h2>${html}`);

            if (!issueTableInfo.sheetName) {
              const tbl = document.getElementById(sheet);
              const rows = Array.from(tbl.querySelectorAll('tr'));
              if (rows.length > 1) {
                const hdrs = Array.from(rows[0].querySelectorAll('th,td')).map(c => c.textContent.trim().toLowerCase());
                const latIdx = hdrs.findIndex(h => h.includes('lat'));
                const lonIdx = hdrs.findIndex(h => h.includes('lon'));
                if (latIdx >= 0 && lonIdx >= 0) {
                  issueTableInfo.sheetName = sheet;
                  const rawHdrs = Array.from(rows[0].querySelectorAll('th,td'));
                  issueTableInfo.headerNames.col1 = rawHdrs[0].textContent.trim();
                  issueTableInfo.headerNames.col2 = rawHdrs[1].textContent.trim();
                  issueTableInfo.headerNames.col3 = (rawHdrs[12]?.textContent || '').trim();

                  rows.slice(1).forEach(row => {
                    const cells = Array.from(row.querySelectorAll('td'));
                    const issueNo = (cells[0]?.textContent || '').trim();
                    const col1 = issueNo;
                    const col2 = (cells[1]?.textContent || '').trim();
                    const col3 = (cells[12]?.textContent || '').trim();
                    const lat = parseFloat((cells[latIdx]?.textContent || '').trim());
                    const lon = parseFloat((cells[lonIdx]?.textContent || '').trim());
                    if (!isNaN(lat) && !isNaN(lon)) {
                      issueCoords.push({ issueNo, lat, lon });
                    }
                    if (issueNo) {
                      issueTableInfo.issueInfo[issueNo] = { issueNo, col1, col2, col3, lat, lon };
                    }
                  });
                }
              }
            }

            nonSamplingCount++;
            if (nonSamplingCount === 2 && !mapInserted) {
              const mapDiv = document.createElement('div');
              mapDiv.id = 'issue-map';
              mapDiv.style.width = '100%';
              mapDiv.style.height = '400px';
              mapDiv.style.margin = '20px 0';
              mapDiv.style.border = '1px solid #aaa';
              content.appendChild(mapDiv);
              mapInserted = true;
            }
          });
        })
        .then(() => {
          if (!document.getElementById('issue-map')) {
            const mapDiv = document.createElement('div');
            mapDiv.id = 'issue-map';
            mapDiv.style.width = '100%';
            mapDiv.style.height = '400px';
            mapDiv.style.margin = '20px 0';
            mapDiv.style.border = '1px solid #aaa';
            document.getElementById('content').appendChild(mapDiv);
          }
          if (issueCoords.length || samplingCoords.length) {
            initMap();
          } else {
            const ph = document.getElementById('issue-map');
            const err = document.createElement('div');
            err.className = 'error';
            err.innerHTML = `Need at least 1 issue or sampling point to plot a map (found ${issueCoords.length} issues, ${samplingCoords.length} sampling points).`;
            ph.replaceWith(err);
          }
        })
        .then(() => {
          const zipFilename = filename.replace(/\.xlsx$/i, '.zip');
          return fetch(`${BASE_URL}/${zipFilename}?${SAS_TOKEN}`)
            .then(resp => {
              if (!resp.ok) return Promise.reject('ZIP not found');
              return resp.arrayBuffer();
            })
            .then(buf => JSZip.loadAsync(buf))
            .then(zip => {
              const content = document.getElementById('content');
              const mapDiv = document.getElementById('issue-map');
              const title = document.createElement('h2');
              title.textContent = 'Issue snapshots';

              const table = document.createElement('table');
              table.id = 'issue-snapshots';
              table.style.width = 'auto';
              table.style.marginBottom = '2em';
              table.style.borderCollapse = 'collapse';

              const hdrRow = document.createElement('tr');
              ['col1','col2','col3','Location','Snapshot'].forEach(txt => {
                const th = document.createElement('th');
                th.textContent = (txt.startsWith('col') ? ( {col1:'',col2:'',col3:''}[txt] = 1, issueTableInfo.headerNames[txt] ) : txt) || txt;
                th.style.backgroundColor = '#f5f5f5';
                th.style.padding = '8px';
                th.style.border = '1px solid #ccc';
                hdrRow.appendChild(th);
              });
              table.appendChild(hdrRow);

              zip.forEach((path, entry) => {
                if (entry.dir || !/\.(jpe?g|png|gif)$/i.test(path)) return;
                const issueNo = path.replace(/\.[^/.]+$/, '');
                const info = issueTableInfo.issueInfo[issueNo];
                if (!info) return;

                const row = document.createElement('tr');
                [info.col1, info.col2, info.col3].forEach(val => {
                  const td = document.createElement('td');
                  td.textContent = val;
                  td.style.padding = '8px';
                  td.style.border = '1px solid #ccc';
                  row.appendChild(td);
                });

                const tdMap = document.createElement('td');
                tdMap.style.padding = '8px';
                tdMap.style.border = '1px solid #ccc';
                const miniDiv = document.createElement('div');
                miniDiv.id = `snapshot-map-${cssSafeId(issueNo)}`;
                miniDiv.style.width = '150px';
                miniDiv.style.height = '150px';
                tdMap.appendChild(miniDiv);
                row.appendChild(tdMap);

                const tdImg = document.createElement('td');
                tdImg.style.padding = '8px';
                tdImg.style.border = '1px solid #ccc';

                entry.async('blob').then(rawBlob => {
                  let mime = 'application/octet-stream';
                  if (/\.(jpe?g)$/i.test(path)) mime = 'image/jpeg';
                  else if (/\.png$/i.test(path)) mime = 'image/png';
                  else if (/\.gif$/i.test(path)) mime = 'image/gif';
                  const blob = new Blob([rawBlob], { type: mime });
                  const url  = URL.createObjectURL(blob);

                  const link = document.createElement('a');
                  link.href = url; link.target = '_blank'; link.rel = 'noopener noreferrer';

                  const img = document.createElement('img');
                  img.src = url; img.style.maxWidth = '200px'; img.style.maxHeight = '200px'; img.style.cursor = 'pointer';
                  link.appendChild(img);
                  tdImg.appendChild(link);

                  const miniMap = L.map(miniDiv, { attributionControl:false, zoomControl:false }).setView([info.lat, info.lon], 17);
                  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(miniMap);
                  const badgeIcon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
                  L.marker([info.lat, info.lon], { icon: badgeIcon }).addTo(miniMap);
                  const circle = L.circle([info.lat, info.lon], { radius: 100 }).addTo(miniMap);
                  miniMap.fitBounds(circle.getBounds(), { padding:[4,4] });
                  miniMap.invalidateSize();
                });

                row.appendChild(tdImg);
                table.appendChild(row);
              });

              if (mapDiv) {
                mapDiv.insertAdjacentElement('afterend', title);
                title.insertAdjacentElement('afterend', table);
              } else {
                content.appendChild(title);
                content.appendChild(table);
              }
            });
        })
        .catch(err => {
          console.error(err);
          document.getElementById('content').innerHTML += `<div class="error">Failed to load ${filename}: ${err}</div>`;
        });
    }

    function parseSamplingSheet(sheet) {
      const raw = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (raw.length < 2) return;
      const headers = raw[0].map(h => String(h).trim().toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return;
      for (let i = 1; i < raw.length; i++) {
        const row = raw[i];
        const lat = parseFloat(row[latIdx]);
        const lon = parseFloat(row[lonIdx]);
        if (!isNaN(lat) && !isNaN(lon)) samplingCoords.push({ lat, lon });
      }
    }

    function initMap() {
      mapRef = L.map('issue-map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(mapRef);

      const allPoints = [
        ...issueCoords.map(c => [c.lat, c.lon]),
        ...samplingCoords.map(c => [c.lat, c.lon]),
      ];
      if (allPoints.length > 0) mapRef.fitBounds(allPoints);

      issueCoords.forEach(c => {
        const icon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${c.issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
        L.marker([c.lat, c.lon], { icon }).addTo(mapRef);
      });

      samplingLayerGroup = L.layerGroup(
        samplingCoords.map(c => L.circleMarker([c.lat, c.lon], { radius: 3, color: 'blue', fillOpacity: 0.6, weight: 1 }))
      ).addTo(mapRef);

      mapRef.whenReady(() => mapRef.invalidateSize());
    }

    function showError(message) {
      document.getElementById('sidebar').innerHTML = `<div class="error">${message}</div>`;
    }
  </script>
</body>
</html>






