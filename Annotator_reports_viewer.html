<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Annotator Reports Viewer</title>
  <link rel="icon" href="data:;base64,iVBORw0KGgo=" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #fff; color: #000; }
#sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 320px; background: #f5f5f5; overflow-y: auto; border-right: 1px solid #ddd; }
#content { margin-left: 320px; padding: 20px; }

/* Sidebar accordion affordance */
.day-header{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  padding:10px 12px 10px 32px;           /* space for chevron */
  font-weight:600; background:#f8f9fb;   /* subtle card look */
  position:relative; cursor:pointer;
  border-bottom:1px solid #ddd;
}
.day-header:hover{ background:#eef2f9; }
.day-header:focus-visible{
  outline:2px solid var(--accent, #1f3de3);
  outline-offset:2px; border-radius:6px;
}
/* Chevron */
.day-header::before{
  content:'▶'; position:absolute; left:12px; top:50%;
  transform:translateY(-50%); font-size:12px; color:#555;
  transition: transform .2s ease;
}
.day-header[aria-expanded="true"]::before{
  transform:translateY(-50%) rotate(90deg);
}
/* Count pill on the right */
.day-count{
  background:#e9eefc; color:#1f3de3; font-weight:700; font-size:11px;
  padding:2px 6px; border-radius:999px; border:1px solid #cbd5ff;
}

/* Append small "tests" text inside the badge */
.day-count::after{
  content: " tests";
  font-size: 10px;
  font-weight: 600;
  opacity: .8;
  margin-left: 4px;
}
    .session-list { display: none; list-style: none; margin: 0; padding: 0; }
    .session-item { padding: 8px 32px; cursor: pointer; border-bottom: 1px solid #eee; }
    .session-item:hover { background: #f0f0f0; }
    .session-item .meta { font-size: 12px; color: #666; margin-top: 2px; }

    h1 { margin: 0 0 12px 0; }
    h2 { margin-top: 1.5em; border-bottom: 1px solid #ddd; padding-bottom: 4px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 2em; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #f5f5f5 !important; }
    .error { color: #d00; padding: 16px; }

    .issue-badge { display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: red; color: white; border-radius: 12px; font-size: 12px; font-weight: bold; pointer-events: none; }
    #issue-map { width: 100%; height: 400px; margin: 20px 0; border: 1px solid #aaa; }

    .download-button { display: inline-block; margin-right: 12px; margin-bottom: 16px; padding: 8px 12px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; font-size: 14px; }
    .download-button:hover { background: #0056b3; }

    /* Overview (four charts side by side) */
    .overview {
      max-width: none;
      width: 100%;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 20px;
      align-items: start;
    }
    .heatmap-months { font-size: 12px; fill: #333; }
    .heatmap-dow { font-size: 12px; fill: #666; }
    .legend{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:12px;
  color:#666;
  margin-top:10px;
  justify-content:flex-end; 
}
    .legend .box { width: 12px; height: 12px; border: 1px solid #ccd3d9; }

    /* Latest routes grid */
    .routes-wrap { margin-top: 18px; }
    .route-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px,1fr)); gap: 14px; max-width: none; width: 100%; }
    .route-card { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
    .route-title { font-size: 13px; color: #333; margin-bottom: 8px; }
    /* keep the old style for non-enhanced anchors only */
    .route-title a:not(.route-link) { color: inherit; text-decoration: none; }
    .route-title a:not(.route-link):hover { text-decoration: underline; }
    .route-meta { font-size: 12px; color: #666; margin-top: 6px; }
    .route-map { width: 100%; height: clamp(180px, 20vw, 320px); border: 1px solid #aaa; border-radius: 6px; }

    /* Make "Test activity overview" same size as "Latest routes" */
    #title-overview { font-size: 1.5em; }

    /* Remove the line under "Latest routes" only */
    .routes-wrap > h2{ border-bottom: none !important; padding-bottom: 0; }
    /* Remove the line under "Mileage per country" */
    .eu-mileage-wrap > h2 { border-bottom: none !important; padding-bottom: 0; }

    /* --- Link-stylish treatment for Latest routes title links --- */
    :root{ --accent:#1f3de3; }
    .route-link{
      display:inline-flex; align-items:center; gap:8px;
      color:var(--accent); font-weight:700; text-decoration:none;
    }
    .route-link .u{
      background-image: linear-gradient(currentColor,currentColor);
      background-repeat: no-repeat;
      background-size: 100% 2px;
      background-position: 0 100%;
      text-underline-offset: 4px;
      padding-bottom: 2px;
    }
    .route-link::after{
      content:"›"; font-size:1.05em; opacity:.6;
      transform: translateX(0);
      transition: transform .18s ease, opacity .18s ease;
    }
    .route-link:hover, .route-link:focus{ color:#1430c9; }
    .route-link:hover::after, .route-link:focus::after{ transform: translateX(3px); opacity:1; }
    .route-link:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:4px; }
    .route-link{ color:#000 !important; text-decoration:none !important; }
    .route-link .u{ background-image:none !important; padding-bottom:0; }
    .route-link:hover, .route-link:focus{ color:#000; text-decoration:none; }
    .route-title a.route-link:hover{ text-decoration:none; }

    .route-overlay .route-link{ color:#000; text-shadow:none; }
    .route-overlay .route-link .u{ background-image:none; }

    .route-link:focus-visible{ outline:2px solid #000; outline-offset:2px; border-radius:4px; }
    .route-title a.route-link:hover{ text-decoration:none; }

    /* ===== Typing indicator for titles ===== */
    .title-thinking { display:inline-flex; align-items:center; gap:6px; }
    .title-thinking .dots { display:inline-flex; gap:4px; }
    .title-thinking .dot {
      width:6px; height:6px; border-radius:50%;
      background:#888; opacity:.25;
      animation:titleBlink 1.2s infinite both;
    }
    .title-thinking .dot:nth-child(2){ animation-delay:.2s; }
    .title-thinking .dot:nth-child(3){ animation-delay:.4s; }
    @keyframes titleBlink {
      0%, 80%, 100% { opacity:.25; }
      40% { opacity:1; }
    }

    /* ===== Make chart SVGs scale to container width ===== */
    #heatmap-host svg,
    #country-host svg,
    #temp-host svg,
    #weather-host svg {
      width: 100%;
      height: auto;
      display: block;
    }
    /* === Active badge for live sessions === */
.active-badge{
  display:inline-flex; align-items:center; justify-content:center;
  padding:2px 8px; margin-left:8px;
  background:#e01616; color:#fff; font-weight:700; font-size:11px;
  border-radius:999px; border:1px solid rgba(0,0,0,.15);
  animation: activeBlink 2s steps(2, end) infinite; /* 0.5 Hz (on/off every 1s) */
}
@keyframes activeBlink{
  0%{ opacity:1; }
  50%{ opacity:0; }
  100%{ opacity:1; }
}
/* Row for session title + badge */
.session-title-row{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
}

    /* ===== EU Mileage Map styles (NEW) ===== */
    .eu-mileage-map{
      width: 100%;
      height: clamp(300px, 40vw, 560px);
      border: 1px solid #aaa;
      border-radius: 6px;
      margin-top: 8px;
    }
    /* white, bold numbers over red dots */
    .leaflet-tooltip.eu-mileage-label{
      background: transparent;
      border: none;
      box-shadow: none;
      color: #fff;
      font-weight: 800;
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
      pointer-events: none;
    }

    /* Hide 1px seams between Leaflet raster tiles (Chrome/DPR ≠ 1) */
.eu-mileage-map .leaflet-tile {
  width: 257px !important;   /* default tile is 256px → overlap by 1px */
  height: 257px !important;
}

    /* === KPI scoring legend (below KPI table) === */
.score-legend{display:flex;align-items:stretch;border:1px solid #ccc;border-radius:6px;overflow:hidden;margin:10px 0 22px}
.score-box{flex:1;min-width:0;text-align:center;color:#fff;line-height:1.1;padding:6px 6px}
.score-box strong{display:block;font-size:14px}
.score-box small{display:block;font-size:11px;opacity:.95}
.score-th{display:block;font-size:10px;background:#f5f5f5;color:#000;border-top:1px solid #ddd;padding:3px 0}

/* colors 1..10 (red → green) */
.s1{background:#c30000}.s2{background:#d62828}.s3{background:#e05d00}.s4{background:#ef8e00}.s5{background:#f4b400}
.s6{background:#ffe24a;color:#111}.s7{background:#b8df4a}.s8{background:#33a653}.s9{background:#0f9d8c}.s10{background:#216e39}

.kpi-avg{margin:8px 0 16px;font-size:13px;color:#222}
.kpi-avg .v{font-weight:700}

    /* highlight the selected score box + small caption */
.score-box.sel{ outline:3px solid rgba(0,0,0,.7); box-shadow: inset 0 0 0 2px rgba(255,255,255,.4); }
.score-legend-caption{ margin:6px 0 16px; font-size:12px; color:#333; }
/* Only the selected score box has black text + black frame */
.score-legend .score-box:not(.sel){ color:#fff; }                /* all others: white text */
.score-legend .score-box.sel{ color:#000 !important; }           /* selected: black text */
.score-legend .score-box.sel{ outline:3px solid #000; box-shadow: inset 0 0 0 2px rgba(255,255,255,.4); }   
/* Let outer frame be visible */
.score-legend{ overflow: visible !important; }

/* Make non-selected boxes use white text (overrides .s6 default) */
.score-legend .score-box:not(.sel){ color:#fff !important; }

/* Selected box: black text + thick black frame (tune --sel-frame) */
:root{ --sel-frame: 2px; } /* <- adjust thickness here */
.score-legend .score-box.sel{
  color:#000 !important;
  position: relative;
  z-index: 1;
  /* inner frame is always visible; outer frame gives extra thickness if not clipped */
  box-shadow:
    inset 0 0 0 var(--sel-frame) #000,
    0 0 0 calc(var(--sel-frame) - 1px) #000;
}
    .kpi-avg{
  text-align:right;
  margin: 4px 0 10px;   /* tighter gap below the table */
  font-size:13px; color:#222;
}

  </style>
</head>
<body>
  <div id="sidebar">
    <h2 style="padding:16px; margin:0; border-bottom:1px solid #ddd;">Test sessions</h2>
  </div>

  <div id="content">
    <!-- Pre-render headings in "Loading" state to avoid flicker -->
    <h1 id="title-overview" data-title="Test activity overview" data-loading="1">
      <span>Loading</span>
      <span class="title-thinking">
        <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
      </span>
    </h1>
    <div id="overview" class="overview">
      <div><div id="heatmap-host"></div></div>
      <div><div id="country-host"></div></div>
      <div><div id="temp-host"></div></div>
      <div><div id="weather-host"></div></div>

      <!-- NEW: EU Mileage map block (spans full width, before latest routes) -->
      <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
        <h2 id="title-eu-mileage" data-title="Mileage per country" data-loading="1" style="margin-top:16px;">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h2>
        <div id="eu-mileage-map" class="eu-mileage-map"></div>
      </div>

      <div class="routes-wrap" style="grid-column: 1 / -1;">
        <h2 id="title-latest-routes" data-title="Latest routes" data-loading="1" style="margin-top:16px;">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h2>
        <div id="routes-grid" class="route-grid"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>

  <script>
    // ---------- CONFIG ----------
    const ACCOUNT   = 'annotationcsv';
    const CONTAINER = 'csv';
    const SAS_TOKEN = 'sv=2024-11-04&ss=bfqt&srt=co&sp=rwdlacupiytfx&se=2025-12-30T14:44:25Z&st=2025-05-30T05:44:25Z&spr=https&sig=QriUtSG3IFzzE3cz7vpcXpE7Ed6QDwSYSZ6YvT2kM%2B0%3D';
    const BASE_URL  = `https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}`;
    const MIN_KM_FOR_OVERVIEW = 1;
    const ACTIVE_WINDOW_MS = 10 * 60 * 1000; // 10 minutes

    // ---------- CACHES / HELPERS ----------
    const summaryCache = new Map(); // filename -> { mileageKm, issueCount, meanTempC, weatherAgg, loaded:true }
    const blobMeta = new Map();     // filename -> lastModifiedMs (strict sort)
    const countryCache = new Map(); // filename -> array of countries

    function cssSafeId(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g,'_'); }
    function toDateOnly(d){ const t = new Date(d); t.setHours(0,0,0,0); return t; }

    // Append a timestamp so each request URL is unique → bypasses caches.
function nc(url){
  return url + (url.includes('?') ? '&' : '?') + 'ts=' + Date.now();
}

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    /* Title loading indicator helper (uses data-title, default "Loading") */
    function setTitleLoading(el, on, labelText = 'Loading') {
      if (!el) return;
      if (on) {
        if (el.dataset.loading === '1') return; // already loading
        el.dataset.loading = '1';
        el.dataset.originalText = el.dataset.title || el.textContent;
        el.innerHTML = `
          <span>${labelText}</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>`;
      } else {
        if (el.dataset.loading !== '1') return;
        const txt = el.dataset.title || el.dataset.originalText || el.textContent;
        el.textContent = txt;
        delete el.dataset.loading;
        delete el.dataset.originalText;
      }
    }

    function computeMileageAndPathFromSampling(sheet) {
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (rows.length < 3) return { km: null, path: [] };

      const headers = rows[0].map(h => String(h ?? '').toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return { km: null, path: [] };

      let km = 0, prev = null;
      const path = [];
      for (let i = 1; i < rows.length; i++) {
        const lat = parseFloat(rows[i][latIdx]);
        const lon = parseFloat(rows[i][lonIdx]);
        if (isNaN(lat) || isNaN(lon)) continue;
        path.push([lat, lon]);
        if (prev) km += haversine(prev[0], prev[1], lat, lon) / 1000;
        prev = [lat, lon];
      }
      return { km: Math.round(km), path };
    }

    // --- Mean Temp + Mode Weather from the "Issue/Issues" sheet ---
    function computeTempWeatherFromIssuesSheet(sheet){
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
      if (rows.length < 2) return { meanTempC: null, weatherAgg: null };

      const headers = rows[0].map(h => String(h ?? '').trim().toLowerCase());
      const tempIdx = headers.findIndex(h => /\btemp\b/.test(h) || /temperature/.test(h));
      const wxIdx   = headers.findIndex(h => /weather/.test(h) || /condition/.test(h));

      const temps = [];
      const wxCounts = new Map();

      const normWx = (s)=>{
        if (s == null) return null;
        const v = String(s).trim().toLowerCase();
        if (!v) return null;
        if (/thunder|storm/.test(v)) return 'Storm';
        if (/snow|blizzard|sleet/.test(v)) return 'Snow';
        if (/rain|drizzle|shower/.test(v)) return 'Rain';
        if (/fog|mist|haze/.test(v)) return 'Fog';
        if (/cloud|overcast/.test(v)) return 'Cloudy';
        if (/clear|sun/.test(v)) return 'Clear';
        if (/wind/.test(v)) return 'Wind';
        return v.charAt(0).toUpperCase() + v.slice(1);
      };

      const parseTempFromValue = (val) => {
        if (val == null) return null;
        const s = String(val).trim();
        if (!s) return null;
        let m = s.match(/(-?\d+(?:[.,]\d+)?)\s*°?\s*c\b/i);
        if (!m) m = s.match(/temp(?:erature)?[^0-9\-]*(-?\d+(?:[.,]\d+)?)/i);
        if (!m) return null;
        const num = parseFloat(m[1].replace(',', '.'));
        return Number.isFinite(num) ? num : null;
      };

      for (let r = 1; r < rows.length; r++){
        const row = rows[r];
        if (tempIdx >= 0){
          const t = parseTempFromValue(row[tempIdx]);
          if (t != null) temps.push(t);
        } else {
          for (let c = 0; c < row.length; c++){
            const t = parseTempFromValue(row[c]);
            if (t != null){ temps.push(t); break; }
          }
        }

        if (wxIdx >= 0){
          const w = normWx(row[wxIdx]);
          if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
        } else {
          for (let c = 0; c < row.length; c++){
            const cell = row[c];
            if (cell == null) continue;
            const m = String(cell).match(/weather\s*:\s*([a-z][a-z\s\-]+)/i);
            if (m){
              const w = normWx(m[1]);
              if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
              break;
            }
          }
        }
      }

      const meanTempC = temps.length
        ? Math.round((temps.reduce((a,b)=>a+b,0) / temps.length) * 10) / 10
        : null;

      let weatherAgg = null;
      if (wxCounts.size){
        weatherAgg = Array.from(wxCounts.entries()).sort((a,b)=> b[1] - a[1])[0][0];
      }

      return { meanTempC, weatherAgg };
    }

    function computeTempWeatherFromIssues(wb){
      const issueSheets = wb.SheetNames.filter(n => /issue/i.test(n));
      for (const name of issueSheets){
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      for (const name of wb.SheetNames){
        if (name.toLowerCase() === 'sampling') continue;
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      return { meanTempC: null, weatherAgg: null };
    }

    function countIssuesFromWorkbook(wb) {
      const norm = s => String(s||'').toLowerCase().replace(/\s+/g,'');
      for (const name of wb.SheetNames) {
        if (name.toLowerCase() === 'sampling') continue;
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[name], { header: 1 });
        if (rows.length < 2) continue;
        const hdrs = rows[0].map(norm);
        const latIdx = hdrs.findIndex(h => h.includes('lat'));
        const lonIdx = hdrs.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
        if (latIdx < 0 || lonIdx < 0) continue;
        let count = 0;
        for (let i = 1; i < rows.length; i++) {
          const lat = parseFloat(rows[i][latIdx]);
          const lon = parseFloat(rows[i][lonIdx]);
          if (!isNaN(lat) && !isNaN(lon)) count++;
        }
        if (count > 0) return count;
      }
      return 0;
    }
    // Reads "Statistics" sheet → row/col labeled "Total test distance" (e.g. "518.6 km")
function extractTotalDistanceKmFromStatistics(wb){
  const sheetName = wb.SheetNames.find(n => /statistics/i.test(n));
  if (!sheetName) return null;

  const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1, blankrows: false });
  if (!rows || !rows.length) return null;

  const norm = v => String(v ?? '').trim();
  const isLabel = v => /total\s*test\s*distance/i.test(String(v ?? ''));

  const parseKm = v => {
    if (v == null) return null;
    const s = norm(v);
    if (!s) return null;
    // match "518.6 km" or "518,6 km" or plain number
    let m = s.match(/(-?\d+(?:[.,]\d+)?)\s*km\b/i);
    if (!m) m = s.match(/-?\d+(?:[.,]\d+)?/);
    if (!m) return null;
    const val = parseFloat(m[0].replace(',', '.'));
    return Number.isFinite(val) ? Math.round(val) : null; // keep km as integer like before
  };

  // Try common key→value patterns
  for (let r = 0; r < rows.length; r++){
    const row = rows[r];
    for (let c = 0; c < row.length; c++){
      if (isLabel(row[c])){
        // prefer right cell, else cell below
        const right = (c + 1 < row.length) ? row[c+1] : null;
        const down  = (rows[r+1]?.[c]);
        const fromRight = parseKm(right);
        if (fromRight != null) return fromRight;
        const fromDown  = parseKm(down);
        if (fromDown  != null) return fromDown;
      }
    }
  }

  // Fallback: scan entire sheet for a lone "518.6 km"
  for (let r = 0; r < rows.length; r++){
    for (let c = 0; c < rows[r].length; c++){
      const km = parseKm(rows[r][c]);
      if (km != null) return km;
    }
  }
  return null;
}

function fetchSessionSummary(filename) {
  if (summaryCache.has(filename)) return Promise.resolve(summaryCache.get(filename));
  return fetch(nc(`${BASE_URL}/${filename}?${SAS_TOKEN}`), { cache:'default' })
    .then(res => {
      if (!res.ok) throw new Error(`Fetch XLSX failed ${res.status}`);
      return res.arrayBuffer();
    })
    .then(buf => {
      const wb = XLSX.read(new Uint8Array(buf), { type:'array' });

      // 1) Mileage from "Statistics" (preferred)
      let mileageKm = extractTotalDistanceKmFromStatistics(wb);

      // 2) Fallback to Sampling path distance
      if (mileageKm == null) {
        const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
        if (samplingName) {
          const { km } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
          mileageKm = km;
        }
      }

      // Temp/Weather
      const { meanTempC, weatherAgg } = computeTempWeatherFromIssues(wb);

      // Issue count
      const issueCount = countIssuesFromWorkbook(wb);

      // 🔹 NEW: pull Test purpose & Test object from “Test details”
      let testObject = null, testPurpose = null;
      try {
        const details = extractTestDetails(wb);
        testObject  = details['test object'] || details['object'] || details['vehicle'] || null;
        testPurpose = details['purpose'] || details['test purpose'] || null;
      } catch (e) {}

      const summary = { mileageKm, issueCount, meanTempC, weatherAgg, testObject, testPurpose, loaded:true };
      summaryCache.set(filename, summary);
      return summary;
    })
    .catch(() => {
      const summary = { mileageKm: null, issueCount: 0, meanTempC: null, weatherAgg: null, testObject: null, testPurpose: null, loaded:true };
      summaryCache.set(filename, summary);
      return summary;
    });
}

    // Read "Test details" sheet (col1=label, col2=value) → map
    function extractTestDetails(wb){
      const details = {};
      const sheetName = wb.SheetNames.find(n => /test\s*details/i.test(n));
      if (!sheetName) return details;

      const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1, blankrows: false });
      for (let r = 0; r < rows.length; r++) {
        const row = rows[r];
        if (!row || row.length < 2) continue;
        const keyRaw = row[0];
        theVal = row[1];
        const valRaw = theVal;
        if (keyRaw == null || valRaw == null) continue;
        const key = String(keyRaw).trim().toLowerCase();
        const val = String(valRaw).trim();
        if (!key || !val) continue;
        details[key] = val;
      }
      return details;
    }

    // --- Countries parser (from "Country" sheet or fallback Test details) ---
    function fetchCountriesForFile(filename){
      if (countryCache.has(filename)) {
        const cached = countryCache.get(filename);
        return Array.isArray(cached) ? Promise.resolve(cached) : Promise.resolve(cached ? [cached] : []);
      }
      return fetch(nc(`${BASE_URL}/${filename}?${SAS_TOKEN}`), { cache:'default' })
        .then(res => {
          if (!res.ok) throw new Error('Fetch XLSX failed for country');
          return res.arrayBuffer();
        })
        .then(buf => {
          const wb = XLSX.read(new Uint8Array(buf), { type:'array' });
          const out = new Set();
          const countrySheetName = wb.SheetNames.find(n => /country/i.test(n));
          if (countrySheetName) {
            const rows = XLSX.utils.sheet_to_json(wb.Sheets[countrySheetName], { header: 1, blankrows: false });
            if (rows.length) {
              const headers = rows[0].map(v => String(v ?? '').trim().toLowerCase());
              const colIdx = headers.findIndex(h => h.includes('country'));
              if (colIdx >= 0) {
                for (let r = 1; r < rows.length; r++) {
                  const v = rows[r][colIdx];
                  if (v != null && String(v).trim()) out.add(String(v).trim());
                }
              } else {
                for (let r = 0; r < rows.length; r++) {
                  const a = rows[r][0], b = rows[r][1];
                  const aStr = String(a ?? '').trim().toLowerCase();
                  if (aStr.includes('country') && b != null && String(b).trim()) out.add(String(b).trim());
                  if (!aStr && rows[r].length === 1) {
                    const val = rows[r][0];
                    if (val != null && String(val).trim()) out.add(String(val).trim());
                  }
                }
              }
            }
          }
          if (out.size === 0) {
            const details = extractTestDetails(wb);
            const maybe = details['country'] || details['test country'] || details['location country'] || null;
            if (maybe && String(maybe).trim()) out.add(String(maybe).trim());
          }
          const arr = Array.from(out);
          countryCache.set(filename, arr);
          return arr;
        })
        .catch(() => {
          countryCache.set(filename, []);
          return [];
        });
    }

// ---------- Europe country canonical names & centroids (EXPANDED) ----------
const EU_CENTROIDS = {
  // EU (unchanged)
  'Austria':[47.6,14.3],'Belgium':[50.6,4.7],'Bulgaria':[42.8,25.3],'Croatia':[45.1,15.4],
  'Cyprus':[35.1,33.4],'Czechia':[49.8,15.5],'Denmark':[56.0,10.0],'Estonia':[58.7,25.0],
  'Finland':[64.5,26.0],'France':[46.2,2.2],'Germany':[51.2,10.4],'Greece':[39.1,22.9],
  'Hungary':[47.2,19.5],'Ireland':[53.2,-8.0],'Italy':[42.8,12.5],'Latvia':[56.9,24.6],
  'Lithuania':[55.3,23.9],'Luxembourg':[49.8,6.1],'Malta':[35.9,14.4],'Netherlands':[52.2,5.3],
  'Poland':[52.0,19.1],'Portugal':[39.6,-8.0],'Romania':[45.9,24.9],'Slovakia':[48.7,19.5],
  'Slovenia':[46.1,14.8],'Spain':[40.3,-3.7],'Sweden':[62.0,15.0],

  // Non-EU Europe (added)
  'Albania':[41.2,20.2],
  'Andorra':[42.5,1.6],
  'Armenia':[40.3,44.9],
  'Azerbaijan':[40.1,47.8],
  'Belarus':[53.7,27.9],
  'Bosnia and Herzegovina':[44.2,17.7],
  'Iceland':[64.9,-18.6],
  'Kosovo':[42.6,20.9],
  'Liechtenstein':[47.1,9.6],
  'Moldova':[47.0,28.7],
  'Monaco':[43.73,7.42],
  'Montenegro':[42.8,19.2],
  'North Macedonia':[41.6,21.7],
  'Norway':[64.5,11.0],
  'Russia':[55.7,37.6],          // Moscow as European centroid
  'San Marino':[43.94,12.46],
  'Serbia':[44.0,20.8],
  'Switzerland':[46.8,8.2],
  'Turkey':[39.0,35.0],          // overall centroid; still fine for a single marker
  'Ukraine':[49.0,32.0],
  'United Kingdom':[54.2,-2.0],
  'Vatican City':[41.90,12.45],
  'Georgia':[42.3,43.4]
};
const EU_CANON_LOWER = {};
Object.keys(EU_CENTROIDS).forEach(k => EU_CANON_LOWER[k.toLowerCase()] = k);

// Common aliases / language variants → canonical keys above
const COUNTRY_ALIASES = {
  'czech republic':'czechia',
  'the netherlands':'netherlands',

  'românia':'romania','republic of moldova':'moldova',
  'deutschland':'germany','österreich':'austria','oesterreich':'austria',
  'españa':'spain','espana':'spain','italia':'italy',
  'magyarország':'hungary','polska':'poland','suomi':'finland',
  'elláda':'greece','ellada':'greece',

  'bosnia-herzegovina':'bosnia and herzegovina','bosnia':'bosnia and herzegovina',
  'macedonia':'north macedonia','fyrom':'north macedonia',

  'uk':'united kingdom','u.k.':'united kingdom','gb':'united kingdom',
  'great britain':'united kingdom','england':'united kingdom',
  'scotland':'united kingdom','wales':'united kingdom','northern ireland':'united kingdom',

  'russian federation':'russia',
  'türkiye':'turkey','turkiye':'turkey',

  'cote d’ivoire':'côte d’ivoire' // (example of normalization pattern; harmless if unused)
};

function canonicalEU(raw){
  if (!raw) return null;
  let s = String(raw).trim();

  // Drop bracket comments like "Serbia (RS)"
  s = s.replace(/\(.*?\)/g,'').trim();

  let k = s.toLowerCase();
  if (COUNTRY_ALIASES[k]) k = COUNTRY_ALIASES[k];

  // Exact match
  if (EU_CANON_LOWER[k]) return EU_CANON_LOWER[k];

  // Try simple title case fallback (e.g., "serbia" → "Serbia")
  const tc = k.replace(/\b\w/g, c => c.toUpperCase());
  return EU_CENTROIDS[tc] ? tc : null;
}

    // ---------- APP STATE ----------
    let issueCoords = [];
    let samplingCoords = [];
    let mapRef = null;
    let samplingLayerGroup = null;
    let allFiles = []; // used to re-render overview

    document.addEventListener('DOMContentLoaded', listBlobs);

    // Helper to render the default overview page
    function renderOverview(){
      const content = document.getElementById('content');
      content.innerHTML = `
        <h1 id="title-overview" data-title="Test activity overview" data-loading="1">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h1>
        <div id="overview" class="overview">
          <div><div id="heatmap-host"></div></div>
          <div><div id="country-host"></div></div>
          <div><div id="temp-host"></div></div>
          <div><div id="weather-host"></div></div>

          <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
            <h2 id="title-eu-mileage" data-title="Mileage vs country" data-loading="1" style="margin-top:16px;">
              <span>Loading</span>
              <span class="title-thinking">
                <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
              </span>
            </h2>
            <div id="eu-mileage-map" class="eu-mileage-map"></div>
          </div>

          <div class="routes-wrap" style="grid-column: 1 / -1;">
            <h2 id="title-latest-routes" data-title="Latest routes" data-loading="1" style="margin-top:16px;">
              <span>Loading</span>
              <span class="title-thinking">
                <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
              </span>
            </h2>
            <div id="routes-grid" class="route-grid"></div>
          </div>
        </div>
      `;
      if (allFiles.length){
        const h1 = document.getElementById('title-overview');
        const h2 = document.getElementById('title-latest-routes');
        const hEU = document.getElementById('title-eu-mileage');
        setTitleLoading(h1, true, 'Loading');
        setTitleLoading(h2, true, 'Loading');
        setTitleLoading(hEU, true, 'Loading');

        buildOverviewHeatmap(allFiles).finally(() => setTitleLoading(h1, false));
        buildCountryMonthChart(allFiles);
        buildTempMonthChart(allFiles);
        buildWeatherMonthChart(allFiles);
        buildEUMileageMap(allFiles).finally(() => setTitleLoading(hEU, false));
        buildLatestRoutePreviews(allFiles).finally(() => setTitleLoading(h2, false));
      }
    }

    function listBlobs() {
      fetch(nc(`${BASE_URL}?restype=container&comp=list&${SAS_TOKEN}`), { cache:'default' })
        .then(r => r.text())
        .then(xml => {
          const doc = new DOMParser().parseFromString(xml, 'application/xml');

          // Read blobs with their Last-Modified timestamps
          const blobs = Array.from(doc.getElementsByTagName('Blob')).map(b => {
            const name = b.getElementsByTagName('Name')[0]?.textContent || '';
            const lmEl = b.getElementsByTagName('Last-Modified')[0] ||
                         b.getElementsByTagName('Properties')[0]?.getElementsByTagName('Last-Modified')[0];
            const lm   = lmEl?.textContent || '';
            return { name, lastModifiedMs: Date.parse(lm) || 0 };
          });

          const xlsx = blobs.filter(b => b.name.toLowerCase().endsWith('.xlsx'));
          if (xlsx.length === 0) { showError('No .xlsx files found.'); return; }

          // Cache for strict chronological sorting
          blobMeta.clear();
          xlsx.forEach(b => blobMeta.set(b.name, b.lastModifiedMs));

          const xlsxNames = xlsx.map(b => b.name);
          allFiles = xlsxNames; // remember for overview re-render

          buildSidebar(xlsxNames);

          const h1 = document.getElementById('title-overview');
          const h2 = document.getElementById('title-latest-routes');
          const hEU = document.getElementById('title-eu-mileage');
          setTitleLoading(h1, true, 'Loading');
          setTitleLoading(h2, true, 'Loading');
          setTitleLoading(hEU, true, 'Loading');

          buildOverviewHeatmap(xlsxNames).finally(() => setTitleLoading(h1, false));
          buildCountryMonthChart(xlsxNames);
          buildTempMonthChart(xlsxNames);
          buildWeatherMonthChart(xlsxNames);
          buildEUMileageMap(xlsxNames).finally(() => setTitleLoading(hEU, false));
          buildLatestRoutePreviews(xlsxNames).finally(() => setTitleLoading(h2, false));
        })
        .catch(err => showError('Failed to list blobs: ' + err));
    }

    // ---------- SIDEBAR ----------
  function buildSidebar(files) {
  const sb = document.getElementById('sidebar');
  sb.innerHTML = '';
  const header = document.createElement('h2');
  header.textContent = 'Test sessions';
  header.style.padding = '16px';
  header.style.margin = '0';
  header.style.borderBottom = '1px solid #ddd';
  header.style.cursor = 'pointer';
  header.title = 'Back to overview';
  header.addEventListener('click', (e) => { e.preventDefault(); renderOverview(); });
  sb.appendChild(header);

  const groups = files.reduce((acc, f) => {
    const m = f.match(/(\d{4}-\d{2}-\d{2})/);
    if (!m) return acc;
    (acc[m[1]] ||= []).push(f);
    return acc;
  }, {});

  Object.keys(groups).sort().reverse().forEach(day => {
    const hdr = document.createElement('div');
    hdr.className = 'day-header';
    hdr.setAttribute('role','button');
    hdr.setAttribute('aria-expanded','false');
    hdr.tabIndex = 0;
    hdr.title = 'Show sessions';

    // Left label
    const label = document.createElement('span');
    label.textContent = day;
    hdr.appendChild(label);

    // Right badge with count
    const count = document.createElement('span');
    count.className = 'day-count';
    count.textContent = String(groups[day].length);
    hdr.appendChild(count);

    const lst = document.createElement('ul');
    lst.className = 'session-list';
    lst.style.display = 'none';

    groups[day].sort().forEach(f => {
      const namePretty = f.replace(`${day}_`, '').replace('.xlsx','');
      const li = document.createElement('li');
      li.className = 'session-item';
      li.onclick = () => loadFile(f);

      // Row: title + (optional) Active badge
      const row = document.createElement('div');
      row.className = 'session-title-row';

      const title = document.createElement('div');
      title.textContent = namePretty;

      // Decide if Active (Last-Modified within last 10 minutes)
      const lm = blobMeta.get(f) || 0;
      const isActive = (Date.now() - lm) <= ACTIVE_WINDOW_MS;

      const badge = document.createElement('span');
      badge.className = 'active-badge';
      badge.textContent = 'Active';
      // Store timestamp for periodic reevaluation
      badge.dataset.lm = String(lm);
      // If not currently active, hide (but keep node so it can appear if still within window on initial render)
      if (!isActive) badge.style.display = 'none';

      row.appendChild(title);
      row.appendChild(badge);

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.id = `meta_${cssSafeId(f)}`;
      meta.textContent = 'Loading…';

      li.appendChild(row);
      li.appendChild(meta);
      lst.appendChild(li);
    });

    let loadedThisGroup = false;
    const toggle = () => {
      const expand = lst.style.display !== 'block';
      lst.style.display = expand ? 'block' : 'none';
      hdr.setAttribute('aria-expanded', expand ? 'true' : 'false');
      hdr.title = expand ? 'Hide sessions' : 'Show sessions';
      if (expand && !loadedThisGroup) {
        loadedThisGroup = true;
        groups[day].forEach(f => {
  fetchSessionSummary(f).then(({ mileageKm, issueCount, testObject, testPurpose }) => {
    const el = document.getElementById(`meta_${cssSafeId(f)}`);
    if (!el) return;

    // no labels — just the values, then mileage/issues
    const parts = [];
    if (testPurpose) parts.push(String(testPurpose));
    if (testObject)  parts.push(String(testObject));

    const left = parts.length ? parts.join('  •  ') + '  •  ' : '';
    const mileageText = (mileageKm ?? '–') + (mileageKm != null ? 'km' : '');

    el.textContent = `${left}Mileage: ${mileageText}  No of issues: ${issueCount}`;
          });
        });
      }
    };

    hdr.addEventListener('click', toggle);
    hdr.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
    });

    sb.appendChild(hdr);
    sb.appendChild(lst);
  });

  // Start/refresh periodic badge visibility check
  ensureActiveBadgeUpdater();
}

    let _activeBadgeTimer = null;
function ensureActiveBadgeUpdater(){
  if (_activeBadgeTimer) return;
  const tick = () => {
    const now = Date.now();
    document.querySelectorAll('.active-badge[data-lm]').forEach(el => {
      const lm = Number(el.dataset.lm || 0);
      const show = (now - lm) <= ACTIVE_WINDOW_MS;
      el.style.display = show ? 'inline-flex' : 'none';
    });
  };
  tick(); // initial
  _activeBadgeTimer = setInterval(tick, 30000); // every 30s
}

    // ---------- OVERVIEW HEATMAP (Test activity) ----------
    function buildOverviewHeatmap(files){
      const byDay = new Map(); // 'YYYY-MM-DD' -> totalIssues (only sessions ≥1 km and issues > 0)
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(withDates.map(x => fetchSessionSummary(x.filename).then(s => ({...x, ...s})))).then(rows => {
        rows.forEach(r => {
          if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return;
          const prev = byDay.get(r.dayStr) || 0;
          byDay.set(r.dayStr, prev + (r.issueCount || 0));
        });

        const days = Array.from(byDay.keys()).sort();
        const host = document.getElementById('heatmap-host');
        if (days.length === 0){
          host.innerHTML = '<div style="color:#666;">No eligible sessions (≥ 1 km and &gt; 0 issues) to show yet.</div>';
          return;
        }

        const minDate = toDateOnly(days[0]);
        const maxDate = toDateOnly(days[days.length-1]);

        const start = new Date(minDate);
        const day = start.getDay(); // 0 Sun … 6 Sat
        const offsetToMonday = (day === 0 ? 6 : day - 1);
        start.setDate(start.getDate() - offsetToMonday);
        start.setHours(0,0,0,0);

        const end = new Date(maxDate);
        const endDay = end.getDay();
        const addToSunday = (7 - endDay) % 7;
        end.setDate(end.getDate() + addToSunday);
        end.setHours(0,0,0,0);

        const dense = [];
        let cur = new Date(start);
        while (cur <= end) {
          const ymd = cur.toISOString().slice(0,10);
          dense.push({ date: new Date(cur), count: byDay.get(ymd) || 0 });
          cur.setDate(cur.getDate() + 1);
        }

        renderHeatmap(dense);
      });
    }

    function renderHeatmap(denseDays){
      const host = document.getElementById('heatmap-host');
      host.innerHTML = '';

      const cell = 12, gap = 3, rows = 7;
      const weeks = Math.ceil(denseDays.length / 7);
      const width  = weeks * (cell + gap) + 40;
      const height = rows  * (cell + gap) + 20;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const level = v => (v === 0) ? 0 : (v < 5 ? 1 : (v < 10 ? 2 : (v < 20 ? 3 : 4)));

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      const months = document.createElementNS(NS, 'g'); months.setAttribute('class','heatmap-months');
      let lastMonth = -1;
      for (let w = 0; w < weeks; w++) {
        const idx = w * 7;
        if (idx >= denseDays.length) break;
        const d = denseDays[idx].date;
        const m = d.getMonth();
        if (m !== lastMonth) {
          lastMonth = m;
          const t = document.createElementNS(NS,'text');
          t.textContent = d.toLocaleString(undefined,{month:'short'});
          t.setAttribute('x', 40 + w*(cell+gap));
          t.setAttribute('y', 10);
          months.appendChild(t);
        }
      }
      svg.appendChild(months);

      const dow = document.createElementNS(NS,'g'); dow.setAttribute('class','heatmap-dow');
      [['Mon',0],['Wed',2],['Fri',4]].forEach(([name,row])=>{
        const t=document.createElementNS(NS,'text');
        t.textContent=name; t.setAttribute('x',0); t.setAttribute('y',24+row*(cell+gap));
        dow.appendChild(t);
      });
      svg.appendChild(dow);

      const cellsG = document.createElementNS(NS,'g');
      for (let i = 0; i < denseDays.length; i++) {
        const d = denseDays[i];
        const w = Math.floor(i / 7);
        const r = i % 7;
        const rect = document.createElementNS(NS,'rect');
        rect.setAttribute('x', 40 + w*(cell+gap));
        rect.setAttribute('y', 16 + r*(cell+gap));
        rect.setAttribute('width', cell);
        rect.setAttribute('height', cell);
        rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
        rect.setAttribute('fill', colors[level(d.count)]);
        rect.setAttribute('stroke', '#ccd3d9');
        rect.setAttribute('stroke-width', '1');
        cellsG.appendChild(rect);
      }
      svg.appendChild(cellsG);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Less
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Countries × Month (4 bins/month) ----------
    function buildCountryMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(
        withDates.map(x =>
          fetchSessionSummary(x.filename)
            .then(s => ({...x, ...s}))
            .then(r => {
              if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return null;
              return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
            })
        )
      ).then(rows => {
        const valid = rows.filter(Boolean).filter(r => Array.isArray(r.countries) && r.countries.length > 0);
        const host = document.getElementById('country-host');
        if (!host) return;

        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No country data found in the “Country” table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${country}` -> n
        const monthsSet = new Set();
        const countriesSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7))); // 1..4
          monthsSet.add(ym);

          const uniq = Array.from(new Set(r.countries.map(c => String(c).trim()).filter(Boolean)));
          uniq.forEach(country => {
            countriesSet.add(country);
            const key = `${ym}|${wb}|${country}`;
            counts.set(key, (counts.get(key)||0) + 1);
          });
        });

        const months = Array.from(monthsSet).sort();
        const countries = Array.from(countriesSet).sort((a,b) => {
          const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
          const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
          if (totalB !== totalA) return totalB - totalA;
          return a.localeCompare(b);
        });

        renderCountryMonthHeatmap({ months, countries, counts });
      });
    }

    function renderCountryMonthHeatmap({months, countries, counts}){
      const host = document.getElementById('country-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 110;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + countries.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => countries.flatMap(c => [1,2,3,4].map(w => counts.get(`${m}|${w}|${c}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Country labels (rows)
      const gCountries = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = countries[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gCountries.appendChild(t);
      }
      svg.appendChild(gCountries);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const country = countries[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${country}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Temperature × Month (4 bins/month) ----------
    function buildTempMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(
        withDates.map(x =>
          fetchSessionSummary(x.filename)
            .then(s => ({...x, ...s}))
        )
      ).then(rows => {
        const valid = rows.filter(r =>
          r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
          r.issueCount > 0 && r.meanTempC != null && !isNaN(r.meanTempC)
        );

        const host = document.getElementById('temp-host');
        if (!host) return;
        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No temperature data found in Issue/Issues table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${tempInt}` -> n
        const monthsSet = new Set();
        const tempsSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
          monthsSet.add(ym);

          const tempInt = Math.round(r.meanTempC);
          tempsSet.add(tempInt);
          const key = `${ym}|${wb}|${tempInt}`;
          counts.set(key, (counts.get(key)||0) + 1);
        });

        const months = Array.from(monthsSet).sort();
        const temps  = Array.from(tempsSet).sort((a,b)=>b-a); // highest first (y-axis reversed)
        renderTempMonthHeatmap({ months, temps, counts });
      });
    }

    function renderTempMonthHeatmap({months, temps, counts}){
      const host = document.getElementById('temp-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 54;  // numbers
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + temps.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => temps.flatMap(t => [1,2,3,4].map(w => counts.get(`${m}|${w}|${t}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Temperature labels (rows)
      const gTemps = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = `${temps[r]}°`;
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gTemps.appendChild(t);
      }
      svg.appendChild(gTemps);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const tempVal = temps[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${tempVal}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Weather × Month (4 bins/month) ----------
    function buildWeatherMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(
        withDates.map(x =>
          fetchSessionSummary(x.filename)
            .then(s => ({...x, ...s}))
        )
      ).then(rows => {
        const valid = rows.filter(r =>
          r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
          r.issueCount > 0 && r.weatherAgg
        );

        const host = document.getElementById('weather-host');
        if (!host) return;
        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No weather data found in Issues table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${wx}` -> n
        const monthsSet = new Set();
        const wxSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
          monthsSet.add(ym);

          const wx = String(r.weatherAgg);
          wxSet.add(wx);
          const key = `${ym}|${wb}|${wx}`;
          counts.set(key, (counts.get(key)||0) + 1);
        });

        const months = Array.from(monthsSet).sort();
        const wxs = Array.from(wxSet).sort((a,b) => {
          const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
          const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
          if (totalB !== totalA) return totalB - totalA;
          return a.localeCompare(b);
        });

        renderWeatherMonthHeatmap({ months, wxs, counts });
      });
    }

    function renderWeatherMonthHeatmap({months, wxs, counts}){
      const host = document.getElementById('weather-host');
      host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 90;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + wxs.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => wxs.flatMap(w => [1,2,3,4].map(bin => counts.get(`${m}|${bin}|${w}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Weather labels (rows)
      const gWx = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = wxs[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gWx.appendChild(t);
      }
      svg.appendChild(gWx);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const wx = wxs[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${wx}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- EU Mileage Map (NEW) ----------
    function buildEUMileageMap(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(withDates.map(x =>
        fetchSessionSummary(x.filename)
          .then(s => ({...x, ...s}))
          .then(r => {
            if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return null;
            return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
          })
      )).then(rows => {
        const valid = rows.filter(Boolean);
        const agg = new Map(); // country -> total mileage (km)

        valid.forEach(r => {
          const euCountries = Array.isArray(r.countries)
            ? r.countries.map(canonicalEU).filter(Boolean)
            : [];
          if (!euCountries.length) return;

          // Split session mileage evenly across encountered EU countries
          const share = r.mileageKm / euCountries.length;
          euCountries.forEach(cty => {
            agg.set(cty, (agg.get(cty) || 0) + share);
          });
        });

        renderEUMileageMap(agg);
      });
    }

    function renderEUMileageMap(agg){
      const hostId = 'eu-mileage-map';
      const container = document.getElementById(hostId);
      if (!container) return;

      // Reset container
      container.innerHTML = '';

      const h = Math.round(container.getBoundingClientRect().height);
      container.style.height = h + 'px';

      // If no data, show a message and bail
      const entries = Array.from(agg.entries()).filter(([,km]) => km > 0);
      if (!entries.length){
        container.outerHTML = `<div id="${hostId}" class="eu-mileage-map" style="display:flex;align-items:center;justify-content:center;color:#666;">No EU mileage data available yet.</div>`;
        return;
      }

      const map = L.map(container, { attributionControl:true, zoomControl:true });
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      // Compute bounds from centroids we will plot
      const latlngs = [];
      const maxKm = Math.max(...entries.map(([,km]) => km));
      const minR = 6, maxR = 30;

      entries.forEach(([country, km]) => {
        const [lat, lon] = EU_CENTROIDS[country] || [null, null];
        if (lat == null || lon == null) return;
        latlngs.push([lat, lon]);

        // radius in px; area ~ mileage
        const r = (function(){
          if (maxKm <= 0) return minR;
          const f = Math.sqrt(km / maxKm); // sqrt for perceptual scaling
          return Math.round(minR + f * (maxR - minR));
        })();

        const marker = L.circleMarker([lat,lon], {
          radius: r,
          color: '#900',
          weight: 1,
          fillColor: '#d00',
          fillOpacity: 0.7
        }).addTo(map);

        marker.bindTooltip(`${Math.round(km)} km`, {
          permanent: true,
          direction: 'center',
          className: 'eu-mileage-label'
        });
      });

      if (latlngs.length){
        map.fitBounds(latlngs, { padding:[20,20] });
      } else {
        // fallback: view central EU
        map.setView([54,15], 4);
      }

      // ensure proper sizing
      map.whenReady(() => map.invalidateSize());
      // also after a tick in case of CSS transitions/layout
      setTimeout(() => map.invalidateSize(), 100);
    }

    // ---------- LATEST ROUTE PREVIEWS (latest 10, ≥1 km, issues > 0) ----------
    function buildLatestRoutePreviews(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

      return Promise.all(withDates.map(x => fetchSessionSummary(x.filename).then(s => ({...x, ...s}))))
        .then(rows => {
          // Filter and sort strictly by Last-Modified DESC
          const take = rows
            .filter(r => r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW && r.issueCount > 0)
  .sort((a,b) =>
  b.dayStr.localeCompare(a.dayStr) ||                        // primary: YYYY-MM-DD DESC
  ((blobMeta.get(b.filename) ?? 0) - (blobMeta.get(a.filename) ?? 0)) ||
  b.filename.localeCompare(a.filename)
)
            .slice(0,10);

          const grid = document.getElementById('routes-grid');
          grid.innerHTML = '';
          if (take.length === 0) return;

          // 1) Create and append all cards in the sorted order (placeholders)
          const slots = take.map(item => {
            const card = document.createElement('div');
            card.className = 'route-card';

            const niceName = item.filename.replace(`${item.dayStr}_`, '').replace('.xlsx','');
            const title = document.createElement('div');
            title.className = 'route-title';

            // title as link to open the drive (styled)
            const link = document.createElement('a');
            link.className = 'route-link';
            link.href = '#';
            link.innerHTML = `<span class="u">${item.dayStr} — ${niceName}</span>`;
            link.addEventListener('click', (e)=>{ e.preventDefault(); loadFile(item.filename); });
            title.appendChild(link);
            card.appendChild(title);

            const mapDiv = document.createElement('div');
            mapDiv.className = 'route-map';
            mapDiv.id = `route_${cssSafeId(item.filename)}`;
            card.appendChild(mapDiv);

            const meta = document.createElement('div');
            meta.className = 'route-meta';
            meta.textContent = `Mileage: … km  •  Issues: ${item.issueCount}`;
            card.appendChild(meta);

            grid.appendChild(card);
            return { item, mapDiv, meta };
          });

          // 2) Fill each card asynchronously (order of appending is preserved)
          slots.forEach(({ item, mapDiv, meta }) => {
            fetch(`${BASE_URL}/${item.filename}?${SAS_TOKEN}`)
              .then(res => res.arrayBuffer())
              .then(buf => {
                const wb = XLSX.read(new Uint8Array(buf), { type:'array' });
                const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
                if (!samplingName) return;

                const { km, path } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
                if (!path || path.length < 2) return;

                // Read column-2 values from "Test details"
                const details = extractTestDetails(wb);
                const objVal = details['test object'] || details['object'] || details['vehicle'] || null;
                const purposeVal = details['purpose'] || details['test purpose'] || null;

                const leftParts = [];
                if (objVal) leftParts.push(`Test object: ${objVal}`);
                if (purposeVal) leftParts.push(`Purpose: ${purposeVal}`);
                const leftText = leftParts.length ? leftParts.join('  •  ') + '  •  ' : '';

                const kmText = (km ?? '–');
                meta.textContent = `${leftText}Mileage: ${kmText} km  •  Issues: ${item.issueCount}`;

                const mini = L.map(mapDiv, { attributionControl:false, zoomControl:false });
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mini);
                const line = L.polyline(path, { color:'blue', weight:3, opacity:0.8 }).addTo(mini);
                mini.fitBounds(line.getBounds(), { padding:[8,8] });
                mini.whenReady(()=>mini.invalidateSize());
              })
              .catch(()=>{ /* ignore individual failures */ });
          });
        });
    }

    function scoringLegendHtml(){
  return `
  <div class="score-legend" aria-label="Scoring legend (1 worst, 10 best)">
    <div class="score-box s1"><strong>1</strong><small>Worst</small><span class="score-th">≥ 100</span></div>
    <div class="score-box s2"><strong>2</strong><small>Too bad</small><span class="score-th">≥ 60</span></div>
    <div class="score-box s3"><strong>3</strong><small>Bad</small><span class="score-th">≥ 40</span></div>
    <div class="score-box s4"><strong>4</strong><small>Not good</small><span class="score-th">≥ 30</span></div>
    <div class="score-box s5"><strong>5</strong><small>Unacceptable</small><span class="score-th">≥ 20</span></div>
    <div class="score-box s6"><strong>6</strong><small>Marginal</small><span class="score-th">≥ 15</span></div>
    <div class="score-box s7"><strong>7</strong><small>Acceptable</small><span class="score-th">≥ 10</span></div>
    <div class="score-box s8"><strong>8</strong><small>Good</small><span class="score-th">≥ 5</span></div>
    <div class="score-box s9"><strong>9</strong><small>Impressive</small><span class="score-th">≥ 1</span></div>
    <div class="score-box s10"><strong>10</strong><small>Exceptional</small><span class="score-th">&lt; 1 (incl. 0)</span></div>
  </div>`;
}

    function extractAvgEventsPer1kFromSheet(sheet){
  const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
  if (!rows.length) return null;

  // Match headers like "Events per 1000 km", "Events/1000 km", spacing variants
  const isTargetHeader = (h) => /events?\s*(?:per|\/)\s*1000\s*km/i.test(String(h || ''));

  const hdr = rows[0];
  const colIdx = hdr.findIndex(isTargetHeader);
  if (colIdx < 0) return null;

  const toNum = (v) => {
    if (v == null) return null;
    const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  };

  const vals = [];
  for (let r = 1; r < rows.length; r++){
    const n = toNum(rows[r][colIdx]);
    if (n != null) vals.push(n);
  }
  if (!vals.length) return null;

  //const sum = vals.reduce((a,b)=>a+b,0);
  //return sum / vals.length; // exact mean (no rounding here)
  const sum = vals.reduce((a,b)=>a+b,0);
  return sum;                   // SUM
      
}

    // Map rate (events per 1000 km) -> score 1..10
function scoreFromRate(rate){
  if (rate == null || !isFinite(rate)) return null;
  if (rate >= 100) return 1;
  if (rate >= 50)  return 2;
  if (rate >= 20)  return 3;
  if (rate >= 10)  return 4;
  if (rate >= 5)  return 5;
  if (rate >= 2)  return 6;
  if (rate >= 1.5)  return 7;
  if (rate >= 0.5)   return 8;
  if (rate >= 0)   return 9;
  return 10;
}

const SCORE_LABEL = {
  1:'Worst',2:'Too bad',3:'Bad',4:'Not good',5:'Unacceptable',
  6:'Marginal',7:'Acceptable',8:'Good',9:'Impressive',10:'Exceptional'
};

// Legend with optional selected score (highlights the box)
function renderScoringLegend(selectedScore){
  const rows = [
    {n:1, cls:'s1',  lbl:'Worst',        thr:'≥ 100'},
    {n:2, cls:'s2',  lbl:'Too bad',      thr:'≥ 60'},
    {n:3, cls:'s3',  lbl:'Bad',          thr:'≥ 40'},
    {n:4, cls:'s4',  lbl:'Not good',     thr:'≥ 30'},
    {n:5, cls:'s5',  lbl:'Unacceptable', thr:'≥ 20'},
    {n:6, cls:'s6',  lbl:'Marginal',     thr:'≥ 15'},
    {n:7, cls:'s7',  lbl:'Acceptable',   thr:'≥ 10'},
    {n:8, cls:'s8',  lbl:'Good',         thr:'≥ 5'},
    {n:9, cls:'s9',  lbl:'Impressive',   thr:'≥ 1'},
    {n:10,cls:'s10', lbl:'Exceptional',  thr:'< 1 (incl. 0)'},
  ];
  const boxes = rows.map(r =>
    `<div class="score-box ${r.cls}${selectedScore===r.n?' sel':''}">
       <strong>${r.n}</strong><small>${r.lbl}</small><span class="score-th">${r.thr}</span>
     </div>`
  ).join('');
  return `<div class="score-legend">${boxes}</div>`;
}

    // ---------- SESSION VIEWER ----------
function loadFile(filename) {
  const content = document.getElementById('content');
  content.innerHTML = '';
  issueCoords = [];
  samplingCoords = [];
  mapRef = null;

  // --- Fallback helpers (use your globals if present) ---
  const _scoreFromRate = (typeof scoreFromRate === 'function') ? scoreFromRate : function(rate){
    if (rate == null || !isFinite(rate)) return null;
    if (rate >= 100) return 1;
    if (rate >= 60)  return 2;
    if (rate >= 40)  return 3;
    if (rate >= 30)  return 4;
    if (rate >= 20)  return 5;
    if (rate >= 15)  return 6;
    if (rate >= 10)  return 7;
    if (rate >= 5)   return 8;
    if (rate >= 1)   return 9;
    return 10;
  };
  const _SCORE_LABEL = (typeof SCORE_LABEL === 'object' && SCORE_LABEL) ? SCORE_LABEL : {
    1:'Worst',2:'Too bad',3:'Bad',4:'Not good',5:'Unacceptable',
    6:'Marginal',7:'Acceptable',8:'Good',9:'Impressive',10:'Exceptional'
  };
  const _renderScoringLegend = (typeof renderScoringLegend === 'function')
    ? renderScoringLegend
    : function(selectedScore){
        const rows = [
          {n:1,  cls:'s1',  lbl:'Worst',        thr:'≥ 100'},
          {n:2,  cls:'s2',  lbl:'Too bad',      thr:'≥ 60'},
          {n:3,  cls:'s3',  lbl:'Bad',          thr:'≥ 40'},
          {n:4,  cls:'s4',  lbl:'Not good',     thr:'≥ 30'},
          {n:5,  cls:'s5',  lbl:'Unacceptable', thr:'≥ 20'},
          {n:6,  cls:'s6',  lbl:'Marginal',     thr:'≥ 15'},
          {n:7,  cls:'s7',  lbl:'Acceptable',   thr:'≥ 10'},
          {n:8,  cls:'s8',  lbl:'Good',         thr:'≥ 5'},
          {n:9,  cls:'s9',  lbl:'Impressive',   thr:'≥ 1'},
          {n:10, cls:'s10', lbl:'Exceptional',  thr:'< 1 (incl. 0)'},
        ];
        return '<div class="score-legend">' + rows.map(function(r){
          return '<div class="score-box ' + r.cls + (selectedScore===r.n?' sel':'') + '">' +
                   '<strong>' + r.n + '</strong><small>' + r.lbl + '</small><span class="score-th">' + r.thr + '</span>' +
                 '</div>';
        }).join('') + '</div>';
      };

  // --- Extract SUM of numeric cells in "Events per 1000 km" column from KPI sheet ---
  function extractSumEventsPer1kFromSheet(sheet){
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
    if (!rows.length) return null;
    const isTargetHeader = function(h){ return /events?\s*(?:per|\/)\s*1000\s*km/i.test(String(h || '')); };
    const hdr = rows[0];
    const colIdx = hdr.findIndex(isTargetHeader);
    if (colIdx < 0) return null;

    const toNum = function(v){
      if (v == null) return null;
      const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
      const n = parseFloat(s);
      return Number.isFinite(n) ? n : null;
    };

    var sum = 0, have = false;
    for (let r = 1; r < rows.length; r++){
      const n = toNum(rows[r][colIdx]);
      if (n != null){ sum += n; have = true; }
    }
    return have ? sum : null;
  }

// Count total KPIs from KPI_buttons.csv:
// - First try the file next to the app (relative path)
// - If that fails, fall back to the Azure container path
// Returns a Promise<number|null>. Caches the result in window.__TOTAL_KPIS__.
function getTotalKpis(){
  if (typeof window.__TOTAL_KPIS__ === 'number') {
    return Promise.resolve(window.__TOTAL_KPIS__);
  }

  const relUrl   = 'KPI_buttons.csv';
  const azureUrl = `${BASE_URL}/KPI_buttons.csv?${SAS_TOKEN}`;

  const fetchAndCount = (url) =>
    fetch(nc(url), { cache: 'default' })
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.text();
      })
      .then(txt => {
        const lines = txt.split(/\r?\n/);
        const count = lines.reduce((n, line) => n + (line.indexOf('redButton') !== -1 ? 1 : 0), 0);
        window.__TOTAL_KPIS__ = count;  // memoize for this session
        return count;
      });

  // Try relative file first; if it 404s, try Azure; otherwise return null
  return fetchAndCount(relUrl)
    .catch(() => fetchAndCount(azureUrl))
    .catch(() => null);
}

  const issueTableInfo = {
    sheetName: null,
    headerNames: { col1: '', col2: '', col3: '' },
    issueInfo: {}
  };

  // Download links
  const xlsxLink = document.createElement('a');
  xlsxLink.href = BASE_URL + '/' + filename + '?' + SAS_TOKEN;
  xlsxLink.textContent = 'Download XLSX';
  xlsxLink.className = 'download-button';
  xlsxLink.setAttribute('download', filename);
  content.appendChild(xlsxLink);

  const pdfFilename = filename.replace(/\.xlsx$/i, '.pdf');
  const pdfLink = document.createElement('a');
  pdfLink.href = BASE_URL + '/' + pdfFilename + '?' + SAS_TOKEN;
  pdfLink.textContent = 'Download PDF';
  pdfLink.className = 'download-button';
  pdfLink.setAttribute('download', pdfFilename);
  content.appendChild(pdfLink);

  // Keep your current no-cache fetch
  fetch(nc(BASE_URL + '/' + filename + '?' + SAS_TOKEN), { cache:'default' })
    .then(function(res){ return res.arrayBuffer(); })
    .then(function(buffer){
      const wb = XLSX.read(new Uint8Array(buffer), { type: 'array' });

      const samplingName = wb.SheetNames.find(function(n){ return n.toLowerCase() === 'sampling'; });
      if (samplingName) parseSamplingSheet(wb.Sheets[samplingName]);

      let nonSamplingCount = 0;
      let mapInserted = false;

      // Pre-fetch total KPIs once for this render (promise)
      const totalKpisPromise = getTotalKpis();

      wb.SheetNames.forEach(function(sheet){
        if (sheet.toLowerCase() === 'sampling') return;

        const html = XLSX.utils.sheet_to_html(wb.Sheets[sheet], { id: sheet });
        content.insertAdjacentHTML('beforeend', '<h2>' + sheet + '</h2>' + html);

        // First GPS-capable sheet → extract issues + headers
        if (!issueTableInfo.sheetName) {
          const tbl = document.getElementById(sheet);
          const rows = Array.from(tbl.querySelectorAll('tr'));
          if (rows.length > 1) {
            const hdrs = Array.from(rows[0].querySelectorAll('th,td')).map(function(c){ return c.textContent.trim().toLowerCase(); });
            const latIdx = hdrs.findIndex(function(h){ return h.includes('lat'); });
            const lonIdx = hdrs.findIndex(function(h){ return h.includes('lon'); });
            if (latIdx >= 0 && lonIdx >= 0) {
              issueTableInfo.sheetName = sheet;
              const rawHdrs = Array.from(rows[0].querySelectorAll('th,td'));
              issueTableInfo.headerNames.col1 = (rawHdrs[0]?.textContent || '').trim();
              issueTableInfo.headerNames.col2 = (rawHdrs[1]?.textContent || '').trim();
              issueTableInfo.headerNames.col3 = (rawHdrs[12]?.textContent || '').trim();

              rows.slice(1).forEach(function(row){
                const cells = Array.from(row.querySelectorAll('td'));
                const issueNo = (cells[0]?.textContent || '').trim();
                const col1 = issueNo;
                const col2 = (cells[1]?.textContent || '').trim();
                const col3 = (cells[12]?.textContent || '').trim();
                const lat = parseFloat((cells[latIdx]?.textContent || '').trim());
                const lon = parseFloat((cells[lonIdx]?.textContent || '').trim());
                if (!isNaN(lat) && !isNaN(lon)) {
                  issueCoords.push({ issueNo: issueNo, lat: lat, lon: lon });
                }
                if (issueNo) {
                  issueTableInfo.issueInfo[issueNo] = { issueNo: issueNo, col1: col1, col2: col2, col3: col3, lat: lat, lon: lon };
                }
              });
            }
          }
        }

        // === KPI extras: AVERAGE = SUM(column) / TOTAL_KPIS(from KPI_buttons.csv) ===
        if (/kpi/i.test(sheet)) {
          const kpiTable = document.getElementById(sheet);
          if (kpiTable) {
            // tighten spacing so the metric sits closer to the KPI table
            kpiTable.style.marginBottom = '6px';

            totalKpisPromise.then(function(totalKpis){
              const inserts = [];
              const sum = extractSumEventsPer1kFromSheet(wb.Sheets[sheet]); // sum of KPI table column
              if (sum != null && typeof totalKpis === 'number' && totalKpis > 0) {
                const avg = sum / totalKpis;
                const avg1 = Math.round(avg * 10) / 10; // 1 decimal for calc + display
                inserts.push(
                  '<div class="kpi-avg">Average <em>events per 1000 km</em>: <span class="v">' + avg1.toFixed(1) + '</span></div>'
                );
                const score = _scoreFromRate(avg1);
                inserts.push(_renderScoringLegend(score));
                inserts.push(
                  '<div class="score-legend-caption">Score: <strong>' + score + '</strong> — ' +
                    _SCORE_LABEL[score] + ' (sum ÷ total KPIs = ' + sum.toFixed(1) + ' ÷ ' + totalKpis + ')</div>'
                );
              } else {
                // No KPI_buttons.csv found or zero redButton lines → show legend without selection
                inserts.push(_renderScoringLegend(null));
                inserts.push('<div class="score-legend-caption">Total KPIs unavailable — cannot compute average.</div>');
              }
              if (inserts.length) kpiTable.insertAdjacentHTML('afterend', inserts.join(''));
            });
          }
        }

        nonSamplingCount++;
        if (nonSamplingCount === 2 && !mapInserted) {
          const mapDiv = document.createElement('div');
          mapDiv.id = 'issue-map';
          mapDiv.style.width = '100%';
          mapDiv.style.height = '400px';
          mapDiv.style.margin = '20px 0';
          mapDiv.style.border = '1px solid #aaa';
          content.appendChild(mapDiv);
          mapInserted = true;
        }
      });
    })
    .then(function(){
      if (!document.getElementById('issue-map')) {
        const mapDiv = document.createElement('div');
        mapDiv.id = 'issue-map';
        mapDiv.style.width = '100%';
        mapDiv.style.height = '400px';
        mapDiv.style.margin = '20px 0';
        mapDiv.style.border = '1px solid #aaa';
        document.getElementById('content').appendChild(mapDiv);
      }
      if (issueCoords.length || samplingCoords.length) {
        initMap();
      } else {
        const ph = document.getElementById('issue-map');
        const err = document.createElement('div');
        err.className = 'error';
        err.innerHTML = 'Need at least 1 issue or sampling point to plot a map (found ' + issueCoords.length + ' issues, ' + samplingCoords.length + ' sampling points).';
        ph.replaceWith(err);
      }
    })
    .then(function(){
      // --- Issue snapshots LAST (below Phase and everything else) ---
      const zipFilename = filename.replace(/\.xlsx$/i, '.zip');
      fetch(nc(BASE_URL + '/' + zipFilename + '?' + SAS_TOKEN), { cache:'default' })
        .then(function(resp){
          if (!resp.ok) return Promise.reject('ZIP not found');
          return resp.arrayBuffer();
        })
        .then(function(buf){ return JSZip.loadAsync(buf); })
        .then(function(zip){
          const title = document.createElement('h2');
          title.textContent = 'Issue snapshots';

          const table = document.createElement('table');
          table.id = 'issue-snapshots';
          table.style.width = 'auto';
          table.style.marginBottom = '2em';
          table.style.borderCollapse = 'collapse';

          const hdrRow = document.createElement('tr');
          ['col1','col2','col3','Location','Snapshot'].forEach(function(txt){
            const th = document.createElement('th');
            th.textContent = (txt.startsWith('col') ? ( {col1:'',col2:'',col3:''}[txt] = 1, issueTableInfo.headerNames[txt] ) : txt) || txt;
            th.style.backgroundColor = '#f5f5f5';
            th.style.padding = '8px';
            th.style.border = '1px solid #ccc';
            hdrRow.appendChild(th);
          });
          table.appendChild(hdrRow);

          zip.forEach(function(path, entry){
            if (entry.dir || !/\.(jpe?g|png|gif)$/i.test(path)) return;
            const issueNo = path.replace(/\.[^/.]+$/, '');
            const info = issueTableInfo.issueInfo[issueNo];
            if (!info) return;

            const row = document.createElement('tr');
            [info.col1, info.col2, info.col3].forEach(function(val){
              const td = document.createElement('td');
              td.textContent = val;
              td.style.padding = '8px';
              td.style.border = '1px solid #ccc';
              row.appendChild(td);
            });

            const tdMap = document.createElement('td');
            tdMap.style.padding = '8px';
            tdMap.style.border = '1px solid #ccc';
            const miniDiv = document.createElement('div');
            miniDiv.id = 'snapshot-map-' + cssSafeId(issueNo);
            miniDiv.style.width = '150px';
            miniDiv.style.height = '150px';
            tdMap.appendChild(miniDiv);
            row.appendChild(tdMap);

            const tdImg = document.createElement('td');
            tdImg.style.padding = '8px';
            tdImg.style.border = '1px solid #ccc';

            entry.async('blob').then(function(rawBlob){
              var mime = 'application/octet-stream';
              if (/\.(jpe?g)$/i.test(path)) mime = 'image/jpeg';
              else if (/\.png$/i.test(path)) mime = 'image/png';
              else if (/\.gif$/i.test(path)) mime = 'image/gif';
              const blob = new Blob([rawBlob], { type: mime });
              const url  = URL.createObjectURL(blob);

              const link = document.createElement('a');
              link.href = url; link.target = '_blank'; link.rel = 'noopener noreferrer';

              const img = document.createElement('img');
              img.src = url; img.style.maxWidth = '200px'; img.style.maxHeight = '200px'; img.style.cursor = 'pointer';
              link.appendChild(img);
              tdImg.appendChild(link);

              const miniMap = L.map(miniDiv, { attributionControl:false, zoomControl:false }).setView([info.lat, info.lon], 17);
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(miniMap);
              const badgeIcon = L.divIcon({ className: 'issue-label', html: '<div class="issue-badge">' + issueNo + '</div>', iconSize: [24,24], iconAnchor: [12,12] });
              L.marker([info.lat, info.lon], { icon: badgeIcon }).addTo(miniMap);
              const circle = L.circle([info.lat, info.lon], { radius: 100 }).addTo(miniMap);
              miniMap.fitBounds(circle.getBounds(), { padding:[4,4] });
              miniMap.invalidateSize();
            });

            row.appendChild(tdImg);
            table.appendChild(row);
          });

          // Append at the very end
          content.appendChild(title);
          content.appendChild(table);
        })
        .catch(function(){ /* optional ZIP; ignore */ });
    })
    .catch(function(err){
      console.error(err);
      document.getElementById('content').innerHTML += '<div class="error">Failed to load ' + filename + ': ' + err + '</div>';
    });
}

    function parseSamplingSheet(sheet) {
      const raw = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (raw.length < 2) return;
      const headers = raw[0].map(h => String(h).trim().toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return;
      for (let i = 1; i < raw.length; i++) {
        const row = raw[i];
        const lat = parseFloat(row[latIdx]);
        const lon = parseFloat(row[lonIdx]);
        if (!isNaN(lat) && !isNaN(lon)) samplingCoords.push({ lat, lon });
      }
    }

    function initMap() {
      mapRef = L.map('issue-map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(mapRef);

      const allPoints = [
        ...issueCoords.map(c => [c.lat, c.lon]),
        ...samplingCoords.map(c => [c.lat, c.lon]),
      ];
      if (allPoints.length > 0) mapRef.fitBounds(allPoints);

      issueCoords.forEach(c => {
        const icon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${c.issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
        L.marker([c.lat, c.lon], { icon }).addTo(mapRef);
      });

      samplingLayerGroup = L.layerGroup(
        samplingCoords.map(c => L.circleMarker([c.lat, c.lon], { radius: 3, color: 'blue', fillOpacity: 0.6, weight: 1 }))
      ).addTo(mapRef);

      mapRef.whenReady(() => mapRef.invalidateSize());
    }

    function showError(message) {
      document.getElementById('sidebar').innerHTML = `<div class="error">${message}</div>`;
    }
  </script>
</body>
</html>
















