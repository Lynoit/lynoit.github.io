<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Annotator</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  
  <!-- JSZip for zipping snapshots -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>

  <!-- XLSX + html2pdf -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>

  <!-- Azure Speech SDK -->
  <script defer src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@1.31.0/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle.js"></script>

  <!-- Charts (needed for sidebar sparkline + main charts) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; padding: 0; font-family: Arial, sans-serif; }
    #sidebar {
      position: fixed; top: 0; left: 0; height: 100%; width: 182px;
      transform: translateX(-152px); transition: transform .3s ease;
      background: #121212; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto; padding: 50px 10px 10px; z-index: 1000; color:#e0e0e0;
    }

    body { background-color: #121212; color: #e0e0e0; }

    #sidebar * { color: #e0e0e0; }

    /* Sidebar slides in/out */
    #sidebar.expanded  { transform: translateX(0); }
    #sidebar.collapsed { transform: translateX(-152px); }

    /* Main content shifts based on sidebar state */
    #sidebar.expanded  ~ #mainContent { margin-left: 202px; }
    #sidebar.collapsed ~ #mainContent { margin-left: 45px; }
    
    #toggleSidebar {
      position: fixed; top: 10px; left: 10px;
      background: #007bff; border: none; color: #fff;
      font-size: 1.5em; padding: 4px 8px; cursor: pointer;
      border-radius: 4px; z-index: 1100;
    }

    .issue-label {
      background: rgba(255, 255, 255, 0.9);
      color: #000; font-weight: bold; padding: 2px 6px; border-radius: 4px;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3); white-space: nowrap;
    }

    .spinner { border: 2px solid rgba(0,0,0,0.1); border-left-color: #333; border-radius: 50%; width: 16px; height: 16px; animation: spin .8s linear infinite; display: inline-block; vertical-align: middle; }
    @keyframes spin { to { transform: rotate(360deg); } }

    #totalDistance.updated { transition: background .5s; background: yellow; }

    .bigButton { display: block; width: 80%; min-width: 80px; padding: 12px; font-size: 14px; border-radius: 4px; cursor: pointer; margin: 8px auto; }
    .orangeButton { background-color: orange; color: white; }
    .blueButton   { background-color: blue;   color: white; }
    .greyButton   { background-color: grey;   color: white; }
    .greenButton  { background-color: green;  color: white; }
    .redButton    { background-color: red;    color: white; }

    #mainContent { height: 100vh; overflow-y: auto; padding: 20px; box-sizing: border-box; transition: margin-left .3s ease; }

    /* Manual Annotation Layout */
    #manualAnnotation { display: grid; grid-template-columns: auto 1fr auto; grid-template-rows: auto auto; gap: 10px; align-items: center; margin-bottom: 20px; }
    #manualAnnotation #micLamp { grid-column: 1; grid-row: 1; }
    #manualAnnotation #micToggle { grid-column: 2; grid-row: 1; }
    #manualAnnotation textarea { grid-column: 1 / 3; grid-row: 2; resize: vertical; font-size: 14px; padding: 8px; }
    #manualAnnotation .blueButton { grid-column: 3; grid-row: 2; padding: 6px 10px; font-size: 12px; white-space: nowrap; }

    table { width: 100%; margin: 10px 0; border-collapse: collapse; }
    td, th { text-align: center; padding: 10px; }

    #logTableContainer table { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #logTableContainer table th, #logTableContainer table td { border: 1px solid #444; padding: 6px 8px; text-align: center; }

    #countTable { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #countTable th, #countTable td { border: 1px solid #444 !important; padding: 6px 8px; text-align: center; margin-bottom: 80px; }

    #mapContainer { margin-bottom: 80px; }
    #countContainer { margin-bottom: 80px; }
    #chartsContainer { margin-bottom: 80px; }
    #chartsContainer .chartBox + .chartBox { margin-top: 80px; }

    #streetTable { border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #streetTable th, #streetTable td { border: 1px solid #444; padding: 6px 8px; text-align: center; }

    #statsTable { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #statsTable th, #statsTable td { border: 1px solid #444; padding: 6px 8px; text-align: center; overflow-wrap:anywhere; word-wrap:break-word; word-break:break-word; hyphens:auto; }

    #metaTable { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #metaTable th, #metaTable td { border: 1px solid #444; padding: 6px 8px; text-align: center; }

    #metaForm { background-color: #dddddd; color: #000000; }
    #metaForm h2, #metaForm label, #metaForm input, #metaForm button { color: #000000; }

    #countryTable { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #countryTable th, #countryTable td { border: 1px solid #444; padding: 6px 8px; text-align: center; }
    
    #weatherTable { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #weatherTable th, #weatherTable td { border: 1px solid #444; padding: 6px 8px; text-align: center; }

    #phaseTable { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #phaseTable th, #phaseTable td { border: 1px solid #444; padding: 6px 8px; text-align: center; }

    #snapshotTableContainer table { width: 100%; border-collapse: collapse; border: 1px solid #444; margin-bottom: 80px; }
    #snapshotTableContainer table th, #snapshotTableContainer table td { border: 1px solid #444; padding: 6px 8px; text-align: center; }

    .center-groups { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }

    .section { margin-bottom: 30px; }
    .page-break { page-break-after: always; }

    /* circular speed-limit sign */
    .speedSign{ width: 46px; height: 46px; border: 4px solid red; border-radius: 50%; background: #fff; color: #000; display: flex; align-items: center; justify-content: center; font: bold 14px/1 Arial, sans-serif; margin: 6px 0; }
    .speedLimitRow{ display:flex; align-items:center; gap:6px; }
    .speedLabel{ font-weight: normal; font-size: inherit; }

    @media print {
      html, body { height: auto !important; overflow: visible !important; }
      #sidebar, #toggleSidebar { display: none !important; }
      body * { visibility: hidden !important; }
      #mainContent, #mainContent * { visibility: visible !important; }
      #mainContent { position: absolute !important; top: 0 !important; left: 0 !important; margin: 0 !important; width: 100% !important; height: auto !important; max-height: none !important; overflow: visible !important; }
    }

    /* hide the tiny weather icon in sidebar */
    #weatherIcon { display: none !important; }

    .distance-label { pointer-events: none; font-weight: bold; background: rgba(255,255,255,0.8); padding: 2px 6px; border-radius: 4px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); white-space: nowrap; }

    /* Camera visibility overrides (fix invalid nested CSS) */
    #camera { display: none; }
    #cameraContainer > h3 { display: none !important; }

    /* Perf sparkline canvas fits sidebar width */
    #sidePerf { width: 100%; }
#sidePerf canvas { display:block; width:100% !important; }

    /* simple full-screen modal */
    #metaOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 2000; }
    #metaForm { background: #fff; padding: 20px; border-radius: 8px; max-width: 400px; width: 90%; }
    #metaForm label { display: block; margin-top: 10px; }
    #metaForm input { width: 100%; padding: 6px; margin-top: 4px; }
    #metaForm button { margin-top: 20px; padding: 8px 12px; }
  </style>
  
  <script>
  // 1) pull in questions from CSV
  function loadMetaQueries() {
    console.log('⏳ loading meta-questions…');
    return fetch('Metaqueries.csv')
      .then(r => { if (!r.ok) throw new Error('CSV not found'); return r.text(); })
      .then(csv => { const { data } = Papa.parse(csv, { header: true, skipEmptyLines: true }); const qs = data.map(r => r.question).filter(q => q); renderMetaForm(qs); });
  }

  // 2) build the form fields
  function renderMetaForm(questions) {
    const form    = document.getElementById('metaForm');
    const submit  = form.querySelector('button[type=submit]');
    const skipBtn = document.getElementById('skipButton');

    // Wire up the Skip button
    skipBtn.addEventListener('click', () => {
      window.metaAnswers = {}; questions.forEach(q => { window.metaAnswers[q] = 'Not filled in'; });
      document.getElementById('metaOverlay').style.display = 'none';
      renderMetaTable(); startApp();
    });

    // Inject question inputs just before the submit button
    questions.forEach((q, i) => {
      const lbl = document.createElement('label');
      lbl.htmlFor = `mq-${i}`; lbl.textContent = q;
      const inp = document.createElement('input');
      inp.id = `mq-${i}`; inp.name = q; inp.required = true;
      form.insertBefore(lbl, submit); form.insertBefore(inp, submit);
    });

    // Handle the OK (submit) action
    form.addEventListener('submit', e => {
      e.preventDefault(); window.metaAnswers = {}; questions.forEach(q => { window.metaAnswers[q] = form.elements[q].value.trim(); });
      document.getElementById('metaOverlay').style.display = 'none'; renderMetaTable(); startApp();
    });
  }

  // 3) show the answers in your new table
  function renderMetaTable() {
    const tbl = document.getElementById('metaTable');
    Object.entries(window.metaAnswers).forEach(([q,a]) => {
      const row = document.createElement('tr'); row.innerHTML = `<td>${q}</td><td>${a}</td>`; tbl.appendChild(row);
    });
  }

  // 4) start sequence
  window.addEventListener('DOMContentLoaded', () => {
    loadMetaQueries().catch(err => {
      console.error('MetaQueries load failed:', err);
      document.getElementById('metaOverlay').style.display = 'none';
      startApp();
    });
  });
  </script>
</head>
<body>

  <div id="metaOverlay">
    <form id="metaForm">
      <h2>Please fill in test details</h2>
      <!-- question inputs get injected here -->     
      <button type="submit">OK</button>
      <button type="button" id="skipButton">Skip</button>
    </form>
  </div>
  
  <button id="toggleSidebar" aria-expanded="true">☰</button>
  <div id="sidebar" class="expanded">
    <p id="dateTime"></p>
    <p id="dayPhase">Phase: N/A</p>
    <div class="weatherSection">
      <img id="weatherIcon" src="" alt="Weather">
      <p id="temperature">Temp: N/A</p>
    </div>
    <p id="streetCity">Street: N/A<br>City: N/A<br>Country: N/A</p>
    <p id="location"></p>
    <p id="roadType">Road type: N/A</p>
    <p id="speed">Speed: N/A</p>
    <div class="speedLimitRow">
      <span class="speedLabel">Speed&nbsp;limit:</span>
      <div id="legalSpeed" class="speedSign">–</div>
    </div>
    <div class="distanceContainer">
      <p id="totalDistance">Distance: 0.0 km</p>
    </div>

    <!-- NEW: Sidebar perf sparkline + last upload label -->
    <div id="sidePerf" style="margin:12px 0 6px;">
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <span style="font-size:12px;opacity:.9;">App load</span>
        <small id="uploadAgo" style="opacity:.8;">Last upload: Never</small>
      </div>
      <canvas id="busySpark"></canvas>
    </div>

    <button class="bigButton orangeButton" id="uploadNowButton">Upload data to cloud</button>
    <button class="bigButton greenButton" onclick="saveAndPrint()">Save report to PDF</button>
  </div>

  <div id="mainContent">

    <div id="manualAnnotation" class="section">
      <span id="micLamp" title="Voice control ready" style="display:inline-block;width:10px;height:10px; margin-right:6px;border-radius:50%;background:#888;"></span>
      <button id="micToggle" class="greyButton" style="width:auto;">Start voice control</button>
      <textarea id="textBox" rows="2" placeholder="Speak after you say “Annotator”…"></textarea>
      <button class="blueButton" onclick="logButton('Manual annotation', false)">Manual annotation</button>
    </div>

    <style>
      /* start hidden */
      #buttonGroups { display: none; }
      #showButtons:checked ~ #buttonGroups { display: flex; align-items: flex-start; gap: 6px; }
    </style>

    <div style="margin-bottom: 10px; display: flex; flex-wrap: wrap; align-items: center; gap: 6px;">
      <input type="checkbox" id="showButtons" checked>
      <label for="showButtons">Show KPI buttons</label>
      <label for="buttonConfig" style="margin-left:8px;">Button setup:</label>
      <select id="buttonConfig">
        <option value="KPI_buttons.csv">ADAS KPI</option>
        <option value="buttons.csv">ADAS KPI (old)</option>
        <option value="Tuning_buttons.csv">China tuning 25w23</option>
        <option value="annotator_gt_buttons.csv">KPI groundtruth</option>
        <option value="annotator_gt_buttons_YN.csv">KPI groundtruth YN</option>
        <option value="tablet_annotator_2025week37_buttons.csv">Benchmark_25w37_buttons</option>
      </select>
      <div id="buttonGroups" class="center-groups" style="margin-top:6px; margin-bottom:30px;"></div>
    </div>

    <div class="page-break"></div>

    <h3>Issue list</h3>
    <div id="logTableContainer" class="section"></div>
    <div class="page-break"></div>

    <div id="snapshotContainer" class="section">
      <h3>Issue Snapshots</h3>
      <div id="snapshotTableContainer"></div>
    </div>
    
    <div id="cameraContainer" class="section">
      <h3 style="display:none">Camera preview</h3>
      <video id="camera" autoplay playsinline style="border:1px solid #444;"></video>
    </div>
    
    <canvas id="cameraCanvas" width="320" height="240" style="display:none;"></canvas>

    <div id="countContainer" class="section">
      <h3>KPI Calculation</h3>
      <table id="countTable">
        <tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>
        <tr><td colspan="3">&nbsp;</td></tr>
      </table>
    </div>
    <div class="page-break"></div>

    <div id="map2Container" class="section">
      <h3>Street View</h3>
      <div id="map2" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>

    <div id="mapContainer" class="section">
      <h3>Route view</h3>
      <div id="map" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>

    <div id="metaContainer" class="section">
      <h3>Test details</h3>
      <table id="metaTable"></table>
    </div>
    
    <div id="statsContainer" class="section">
      <h3>Statistics</h3>
      <table id="statsTable">
        <tr><th>Metric</th><th>Value</th></tr>
        <tr><td colspan="2">&nbsp;</td></tr>
      </table>
    </div>

    <div id="streetsContainer" class="section">
      <h3>Road Types</h3>
      <table id="streetTable"><tr><th>Road type</th></tr></table>
    </div>

    <div id="countryContainer" class="section">
      <h3>Countries</h3>
      <table id="countryTable">
        <tr><th>Country</th><th>Distance&nbsp;(km)</th><th>No&nbsp;of&nbsp;issues</th></tr>
      </table>
    </div>

    <div id="weatherContainer" class="section">
      <h3>Weather</h3>
      <table id="weatherTable"><tr><th>Condition</th><th>Distance (km)</th></tr></table>
    </div>

    <div id="phaseContainer" class="section">
      <h3>Phase</h3>
      <table id="phaseTable"><tr><th>Phase</th><th>Distance (km)</th></tr></table>
    </div>

    <!-- NEW: Charts section so existing distance/speed charts work -->
    <div id="chartsContainer" class="section">
      <h3>Charts</h3>
      <canvas id="distanceChart" height="120"></canvas>
      <div class="page-break"></div>
      <canvas id="speedChart" height="120"></canvas>
    </div>

    <footer style="text-align:center; padding:10px; font-size:12px; color:#666;">
      Ver 1.16 — © Lynoit Tech 2025
    </footer>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-image@0.4.0/leaflet-image.js"></script>

  <script>
    console.log('main script executing');
    
    // DOM refs & globals
    const appStartTime = new Date();
    const metaAnswers = {};
    const toggleBtn = document.getElementById('toggleSidebar');
    const sidebar   = document.getElementById('sidebar');
    const locEl     = document.getElementById('location');
    const roadTypeEl= document.getElementById('roadType');
    const streetCityEl=document.getElementById('streetCity');
    const tempEl    = document.getElementById('temperature');
    const iconEl    = document.getElementById('weatherIcon');
    const distEl    = document.getElementById('totalDistance');
    const speedEl   = document.getElementById('speed');
    const countTbl  = document.getElementById('countTable');
    const streetTbl = document.getElementById('streetTable');
    const countryTable = document.getElementById('countryTable');
    const logContainer = document.getElementById('logTableContainer');
    const buttonGroups = document.getElementById('buttonGroups');
    const micLamp   = document.getElementById('micLamp');
    const textBox   = document.getElementById('textBox');
    const countryDistances  = {};
    const weatherDistances = {};
    const phaseDistances = {};
    const AZURE_KEY    = '31mglZQASLS9g4mcaTvMpznyzYYJyFr7I3ERTm84jeQrPNOlp5tXJQQJ99BEACi5YpzXJ3w3AAAYACOGJuNe';
    const AZURE_REGION = 'northeurope';
    const PHASE_THROTTLE = 5 * 60 * 1000;
    const TABLE_THROTTLE = 30 * 1000;
    const UPLOAD_THROTTLE = 5 * 60 * 1000
    const citySet = new Set();
    const legalSpeedEl = document.getElementById('legalSpeed');
    const samplingTable = [];

    let lastLimit = null; let limitChanges = 0;
    let roundaboutCount = 0; let trafficLightCount = 0; let lastWasRoundabout = false; let lastWasTrafficLight = false;
    let bridgeCount = 0; let tunnelCount = 0; let lastWasBridge = false; let lastWasTunnel = false; let bridgeStreak = 0;
    let corrections = {}; let lastUploadTime = 0;
    
    const allowedRoadTypes = new Set(['motorway','motorway_link','trunk','trunk_link','primary','primary_link','secondary','secondary_link','tertiary','tertiary_link','unclassified','residential','service','construction']);

    const workbookTables = [
      { id: 'metaTable',    name: 'Test details'  },
      { id: 'logTable',     name: 'Issues'     },
      { id: 'countTable',   name: 'KPI'        },
      { id: 'statsTable',   name: 'Statistics' },
      { id: 'streetTable',  name: 'Road types' },
      { id: 'countryTable', name: 'Country'    },
      { id: 'weatherTable', name: 'Weather'    },
      { id: 'phaseTable',   name: 'Phase'      }
    ];

    let startTime = null;
    const topSpeeds = [];
    let maxSpeed  = 0;    
    let lastTableUpdate = 0; let lastPhaseUpdate = 0;
    let logTable=[], redCounts={}, lastPos=null, totalDist=0;
    let positions=[], timeData=[], distData=[], speedData=[];
    let map, trackLine, distanceChart, speedChart;
    let roadTypes=new Set(), lastChartTs=0, posCount=0, lastCity=null; let lastCountry = null;
    let roadDistances = {}; let currentDistMarker = null; let map2, circle2; let roadRedCounts = {}; let countryRedCounts   = {}; let weatherRedCounts   = {}; let phaseRedCounts = {}; let isDirty = false; let wakeLock = null; let lastSpeedKmh = 0;

    function markDirty() { isDirty = true; }
    function markClean()  { isDirty = false; }

    function formatAppStartTimestamp() {
      const d = appStartTime; const pad = n => String(n).padStart(2, '0');
      const YYYY = d.getFullYear(); const MM   = pad(d.getMonth() + 1); const DD   = pad(d.getDate());
      const hh   = pad(d.getHours()); const mm   = pad(d.getMinutes()); const ss   = pad(d.getSeconds());
      return `${YYYY}-${MM}-${DD}_${hh}${mm}${ss}`;
    }

    const reportBaseName = `Annotator_report_${formatAppStartTimestamp()}`; 
    
    window.addEventListener('beforeunload', e => { if (!isDirty) return; e.preventDefault(); e.returnValue = ''; });
    
    toggleBtn.onclick = () => {
      const exp = sidebar.classList.toggle('expanded');
      sidebar.classList.toggle('collapsed', !exp);
      toggleBtn.setAttribute('aria-expanded', exp);
      // ensure sparkline resizes after slide animation
      setTimeout(() => window._busySparkChart?.resize(), 320);
    };

    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try { wakeLock = await navigator.wakeLock.request('screen'); console.log('Wake lock acquired'); wakeLock.addEventListener('release', () => console.log('Wake lock released')); }
        catch (err) { console.error('Failed to acquire wake lock:', err); }
      } else { console.warn('Wake Lock API not supported on this browser'); }
    }

    async function releaseWakeLock() { if (wakeLock) { try { await wakeLock.release(); wakeLock = null; } catch (err) { console.error('Error releasing wake lock:', err); } } }
    document.addEventListener('visibilitychange', () => { if (wakeLock !== null && document.visibilityState === 'visible') { requestWakeLock(); } });

    // ───────────── Sidebar "load" sparkline & last-upload timer ─────────────
    const perfLite = (() => {
      const state = { busy: [], expected: performance.now() + 100, longBucket: 0, lagSum: 0, bucketStart: performance.now() };
      function pushBusy(y, max = 120) { state.busy.push({ x: new Date(), y: Math.max(0, Math.min(100, +y.toFixed(1))) }); if (state.busy.length > max) state.busy.shift(); }
      function tick(interval = 100) {
        state.expected = performance.now() + interval;
        setInterval(() => {
          const now = performance.now();
          const lag = Math.max(0, now - state.expected);
          state.expected += interval; state.lagSum += lag;
          const span = now - state.bucketStart;
          if (span >= 1000) {
            const busyPct = ((state.lagSum + state.longBucket) / span) * 100;
            pushBusy(busyPct);
            state.lagSum = 0; state.longBucket = 0; state.bucketStart = now;
            if (window._busySparkChart) window._busySparkChart.update();
          }
        }, interval);
      }
      function watchLongTasks() {
        if (!('PerformanceObserver' in window)) return;
        try { const obs = new PerformanceObserver(list => { for (const e of list.getEntries()) state.longBucket += e.duration; }); obs.observe({ type: 'longtask', buffered: true }); } catch {}
      }
      return { state, tick, watchLongTasks };
    })();

    function initSidePerf() {
      const canvas = document.getElementById('busySpark');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      $1
      // Ensure the sparkline always fits the sidebar width/height
      const container = document.getElementById('sidePerf');
      const sizeCanvas = () => {
        const w = container?.clientWidth || 180;
        // Set height proportionally to width for readability (≈ 0.4x)
        const h = Math.max(40, Math.round(w * 0.4));
        const canvas = document.getElementById('busySpark');
        if (canvas) canvas.style.height = h + 'px';
        window._busySparkChart?.resize();
      };
      // Initial sizing and responsive observers
      sizeCanvas();
      try {
        const ro = new ResizeObserver(sizeCanvas);
        if (container) ro.observe(container);
      } catch (e) { /* ResizeObserver may be unavailable */ }
      window.addEventListener('orientationchange', sizeCanvas);
      window.addEventListener('resize', sizeCanvas);
      perfLite.tick(100); perfLite.watchLongTasks();
    }

    function formatAgo(ms) {
      if (!ms || ms < 0) return 'Never';
      const s = Math.floor(ms / 1000); if (s < 60) return `${s}s ago`;
      const m = Math.floor(s / 60), r = s % 60; if (m < 60) return `${m}m ${r}s ago`;
      const h = Math.floor(m / 60), rm = m % 60; return `${h}h ${rm}m ago`;
    }

    function startUploadAgoTicker() {
      const lbl = document.getElementById('uploadAgo'); if (!lbl) return;
      const show = () => { const ago = (lastUploadTime && lastUploadTime > 0) ? formatAgo(Date.now() - lastUploadTime) : 'Never'; lbl.textContent = `Last upload: ${ago}`; };
      show(); setInterval(show, 1000);
    }

    function startApp() {
      requestWakeLock();
      loadCorrections().then(() => console.log('Corrections loaded:', corrections)).catch(err => console.warn('Corrections load failed:', err));  
      initMap(); initMap2(); updateDateTime(); setInterval(updateDateTime, 1000);

      // start perf UI & label
      initSidePerf(); startUploadAgoTicker();

      // Charts
      initCharts();

      // 10s sampling (comment says 30s earlier)
      setInterval(() => {
        if (!lastPos) return;
        const rowNo = samplingTable.length + 1;
        const timestamp = new Date().toISOString();
        const latitude  = lastPos.lat; const longitude = lastPos.lon;
        const distanceKm  = (totalDist / 1000).toFixed(3);
        const speed       = lastSpeedKmh.toFixed(1);
        const maxSpd      = maxSpeed.toFixed(1);
        const legal       = /^\d+$/.test(legalSpeedEl.textContent) ? Number(legalSpeedEl.textContent) : '';
        samplingTable.push({ no: rowNo, timestamp, lat: latitude, lon: longitude, distance: distanceKm, speed, maxspeed: maxSpd, legalSpeed: legal });
      }, 10 * 1000);
      
      navigator.geolocation.watchPosition(showPosition, showError, { enableHighAccuracy: true, maximumAge: 5000, timeout: 10000 });

      const configSelect = document.getElementById('buttonConfig');
      configSelect.addEventListener('change', e => { buildButtons(e.target.value); });
      buildButtons(configSelect.value);
      startCamera();
    }

    let recognizer;  // Azure continuous recogniser
    let recogniserReady   = false;   // built at least once?
    let recogniserRunning = false;   // currently listening?

    document.getElementById('micToggle').onclick = async event => {
      if (!recogniserReady) { await initAzureSpeech(); recogniserReady = true; }
      if (recogniserRunning) { recognizer.stopContinuousRecognitionAsync(); recogniserRunning = false; micLamp.style.background = '#4caf50'; event.target.textContent = 'Start voice control'; }
      else { recognizer.startContinuousRecognitionAsync(); recogniserRunning = true; micLamp.style.background = '#f44336'; event.target.textContent = 'Stop voice control'; }
    };

    function loadCorrections() { return fetch('corrections.csv').then(r => r.ok ? r.text() : Promise.reject('CSV load failed')).then(csv => { const { data } = Papa.parse(csv, { header: true, skipEmptyLines: true }); data.forEach(({ misheard, correct }) => { if (misheard && correct) corrections[misheard.trim().toLowerCase()] = correct.trim(); }); }); }
    function applyCorrections(text) { return text.replace(/\b\w+\b/g, w => corrections[w.toLowerCase()] || w); }

    function updateCountryTable() {
      let html = `<tr><th>Country</th><th>Distance (km)</th><th>Distance (%)</th><th>No of issues</th></tr>`;
      for (const c in countryDistances) {
        const meters = countryDistances[c] || 0; const km = (meters / 1000).toFixed(1);
        const pct = totalDist > 0 ? ((meters / totalDist) * 100).toFixed(1) : '0.0';
        const count  = countryRedCounts[c] || 0;
        html += `<tr><td>${c}</td><td>${km}</td><td>${pct}%</td><td>${count}</td></tr>`;
      }
      countryTable.innerHTML = html;
    }

    function stripHotWord(text) { const match = text.match(/^\s*annotator[,:]?\s*/i); if (!match) return null; return text.slice(match[0].length).trim(); }

    async function initAzureSpeech() {
      console.log('initAzureSpeech started'); const warn = msg => console.warn('Speech init:', msg);
      if (!window.SpeechSDK) { warn('SpeechSDK global missing – script failed to load?'); micLamp.style.background = '#ffc107'; return; }
      try {
        const speechConfig = SpeechSDK.SpeechConfig.fromSubscription(AZURE_KEY, AZURE_REGION);
        speechConfig.speechRecognitionLanguage = 'en-US';
        speechConfig.setProperty(SpeechSDK.PropertyId.SpeechServiceResponse_PostProcessingOption, 'TrueText');
        const audioConfig  = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
        recognizer = new SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);
      } catch (e) { warn(e); micLamp.style.background = '#ffc107'; return; }
      recognizer.sessionStarted = ()  => micLamp.style.background = '#f44336';
      recognizer.sessionStopped = ()  => micLamp.style.background = '#4caf50';
      recognizer.canceled       = (_,e)=> { console.warn('Canceled: ' + e.errorDetails); micLamp.style.background = '#ffc107'; };
      recognizer.recognizing = (_,e)=> { const draft = stripHotWord(e.result.text); if (draft) textBox.value = draft + ' [draft]'; };
      recognizer.recognized  = (_,e)=> { if (e.result.reason !== SpeechSDK.ResultReason.RecognizedSpeech) return; const cleaned = stripHotWord(e.result.text); if (cleaned) { textBox.value = cleaned; logButton('Manual annotation', false); } };
      recognizer.startContinuousRecognitionAsync();
    }

    function parseMaxSpeed(tag){ const m = /(\d+)/.exec(tag); return m ? m[1] : null; }
    
    function initMap () {
      map = L.map('map', { zoomControl:false, scrollWheelZoom:false, doubleClickZoom:false, touchZoom:false, boxZoom:false, keyboard:false, dragging:false, tap:false }).setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(map);
      trackLine = L.polyline([], { weight: 4 }).addTo(map);
    }

    function initMap2 () {
      map2 = L.map('map2', { zoomControl:false, scrollWheelZoom:false, doubleClickZoom:false, touchZoom:false, boxZoom:false, keyboard:false, dragging:false, tap:false, attributionControl:false }).setView([0, 0], 18);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(map2);
      circle2 = L.circle([0, 0], { radius: 100, color: 'blue', fillOpacity: 0.1 }).addTo(map2);
      currentPosMarker2 = L.circleMarker([0, 0], { radius: 8, color: 'red', fillColor: 'red', fillOpacity: 1 }).addTo(map2);
    }
    
    function initCharts(){
      const dctx = document.getElementById('distanceChart').getContext('2d');
      const sctx = document.getElementById('speedChart').getContext('2d');
      distanceChart=new Chart(dctx,{type:'line',data:{labels:timeData,datasets:[{label:'Distance (km)',data:distData,fill:false,tension:0.1}]},options:{responsive:true,animation:false,scales:{x:{type:'time',time:{unit:'minute',tooltipFormat:'HH:mm:ss'}},y:{beginAtZero:true}}}});
      speedChart=new Chart(sctx,{type:'line',data:{labels:distData,datasets:[{label:'Speed (km/h)',data:speedData,fill:false,tension:0.1}]},options:{responsive:true,animation:false,scales:{x:{type:'linear',title:{display:true,text:'Distance (km)'}},y:{beginAtZero:true,title:{display:true,text:'Speed (km/h)'}}}}});
    }

    function startCamera() {
      const video = document.getElementById('camera');
      if (!navigator.mediaDevices?.getUserMedia) { console.warn('getUserMedia not supported'); return; }
      navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
        .then(stream => { video.srcObject = stream; })
        .catch(err   => { console.error('Camera error', err); });
    }
    
    function showPosition(pos) {
      const { latitude: lat, longitude: lon } = pos.coords; const ts = pos.timestamp; let segDist = 0;
      if (!startTime) startTime = ts;
      if (lastPos) {
        segDist = calculateDistance(lastPos.lat, lastPos.lon, lat, lon);
        if (segDist < 10) return; // ignore tiny jitters
        totalDist += segDist;
        const phaseText = document.getElementById('dayPhase').textContent.split(': ')[1] || 'Unknown';
        phaseDistances[phaseText] = (phaseDistances[phaseText] || 0) + segDist;
        const condition = iconEl.alt || 'Unknown';
        weatherDistances[condition] = (weatherDistances[condition] || 0) + segDist;

        const distKm = (totalDist / 1000).toFixed(2);
        const labelHtml = `<div class="distance-label">${distKm} km</div>`;
        if (!currentDistMarker) {
          currentDistMarker = L.marker([lat, lon], { icon: L.divIcon({ className: '', html: labelHtml, iconSize: [0, 0], iconAnchor: [0, -10] }) }).addTo(map);
        } else {
          currentDistMarker.setLatLng([lat, lon]); currentDistMarker.setIcon(L.divIcon({ className: '', html: labelHtml, iconSize: [0, 0], iconAnchor: [0, -10] }));
        }
      }

      const prevPos = lastPos; lastPos = { lat, lon, ts }; posCount++; trackLine.addLatLng([lat, lon]);
      if (positions.length === 0) { map.setView([lat, lon], 15); } else if (posCount % 20 === 0) { map.fitBounds(trackLine.getBounds().pad(0.2)); }
      positions.push([lat, lon]);

      if (prevPos) {
        const dt = (ts - prevPos.ts) / 1000; const speedKmh = dt > 0 ? (segDist / dt) * 3.6 : 0;
        if (speedKmh > 250) { console.warn(`Discarded unrealistic speed: ${speedKmh.toFixed(1)} km/h`); speedEl.textContent = 'Speed: N/A'; }
        else {
          lastSpeedKmh = speedKmh;
          topSpeeds.push(speedKmh); topSpeeds.sort((a, b) => b - a); if (topSpeeds.length > 10) topSpeeds.pop();
          maxSpeed = topSpeeds.length === 10 ? topSpeeds[9] : topSpeeds[0];
          speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;
        }
      }

      distEl.textContent = `Distance: ${(totalDist / 1000).toFixed(1)} km`;
      distEl.classList.add('updated'); setTimeout(() => distEl.classList.remove('updated'), 500);

      if (Date.now() - lastChartTs > 5000) {
        timeData.push(new Date(ts)); distData.push((totalDist / 1000).toFixed(3)); speedData.push(speedEl.textContent.split(' ')[1]);
        requestAnimationFrame(() => { if (distanceChart && speedChart) { distanceChart.update(); speedChart.update(); } maybeUpdateTables(); });
        lastChartTs = Date.now();
      }

      locEl.innerHTML = `Lat: ${lat}<br>Lon: ${lon}`;

      const now = Date.now(); if (now - lastPhaseUpdate > PHASE_THROTTLE) { updateDayPhase(lat, lon); lastPhaseUpdate = now; }

      fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&extratags=1&lat=${lat}&lon=${lon}`)
        .then(r => r.json())
        .then(data => {
          const rawRt = data.extratags?.highway || data.type || 'unknown';
          const displayRt = allowedRoadTypes.has(rawRt) ? rawRt : 'Other';
          const tags = data.extratags || {};

          const isBridge = tags.bridge === 'yes';
          const isRoundabout = tags.junction === 'roundabout' || tags.highway === 'mini_roundabout';
          const isTrafficLight = tags.highway === 'traffic_signals';
          const isTunnel = tags.tunnel === 'yes';
          if (isRoundabout && !lastWasRoundabout) roundaboutCount++;
          if (isTrafficLight && !lastWasTrafficLight) trafficLightCount++;
          if (isTunnel && !lastWasTunnel) tunnelCount++;
          lastWasRoundabout = isRoundabout; lastWasTrafficLight = isTrafficLight; lastWasBridge = isBridge; lastWasTunnel = isTunnel;
          if (tags.bridge === 'yes') { bridgeStreak++; if (bridgeStreak === 8) { bridgeCount++; } } else { bridgeStreak = 0; }
          const maxTag = data.extratags?.maxspeed || data.extratags?.['maxspeed:forward'] || data.extratags?.['maxspeed:backward'];
          const limit = maxTag ? parseMaxSpeed(maxTag) : null; legalSpeedEl.textContent = limit ?? '–';
          if (limit !== null && limit !== lastLimit) { if (lastLimit !== null) limitChanges++; lastLimit = limit; }
          if (segDist > 0) { roadDistances[displayRt] = (roadDistances[displayRt] || 0) + segDist; }
          roadTypeEl.textContent = `Road type: ${displayRt}`; if (allowedRoadTypes.has(rawRt)) roadTypes.add(rawRt);
          const street = data.address.road || data.address.pedestrian || data.address.footway || 'Unknown street';
          const city = data.address.city || data.address.town || data.address.village || 'Unknown city';
          const country = data.address.country || 'Unknown country';
          if (segDist > 0) { countryDistances[country] = (countryDistances[country] || 0) + segDist; }
          streetCityEl.innerHTML = `Street: ${street}<br>City: ${city}<br>Country: ${country}`;
          if (country !== lastCountry && lastCountry !== null) { logButton(`Entered ${country}`, false); }
          lastCountry = country;
          if (city !== lastCity) { lastCity = city; citySet.add(city); getWeather(city); }
          maybeUpdateTables();
        })
        .catch(err => { streetCityEl.textContent = 'Error: ' + err.message; console.error('Reverse geocode error', err); });

      if (map2) { map2.setView([lat, lon], 20); currentPosMarker2.setLatLng([lat, lon]); }
    }
    
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6_371_000; const toRad = Math.PI / 180;
      const φ1 = lat1 * toRad; const φ2 = lat2 * toRad; const dφ = (lat2 - lat1) * toRad; const dλ = (lon2 - lon1) * toRad;
      const a = Math.sin(dφ/2)**2 + Math.cos(φ1) * Math.cos(φ2) * Math.sin(dλ/2)**2;
      const oneMinusA = Math.max(0, 1 - a);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(oneMinusA));
      return R * c;
    }
    
    function updateStreetTable() {
      let html = `<tr><th>Road type</th><th>Distance (km)</th><th>Distance (%)</th><th>No of issues</th></tr>`;
      for (const rt of roadTypes) {
        const meters = roadDistances[rt] || 0; const km = (meters / 1000).toFixed(1);
        const pct = totalDist > 0 ? ((meters / totalDist) * 100).toFixed(1) : '0.0';
        const count  = roadRedCounts[rt] || 0;
        html += `<tr><td>${rt}</td><td>${km}</td><td>${pct}%</td><td>${count}</td></tr>`;
      }
      streetTbl.innerHTML = html;
    }

    function updateStatsTable () {
      const totalMs   = startTime ? (lastPos.ts - startTime) : 0; const timeStr = new Date(totalMs).toISOString().substring(11, 19);
      const km = (totalDist / 1000).toFixed(1); const hrs = totalMs / 3_600_000; const meanSpd = hrs > 0 ? (km / hrs).toFixed(1) : '—';
      const citiesList = Array.from(citySet).join(' - ') || '—';
      const countriesList = Object.keys(countryDistances).join(' - ') || '—';
      document.getElementById('statsTable').innerHTML = `
        <tr><th>Metric</th><th>Value</th></tr>
        <tr><td>Total test time</td><td>${timeStr}</td></tr>
        <tr><td>Total test distance</td><td>${km} km</td></tr>
        <tr><td>Max speed</td><td>${maxSpeed.toFixed(1)} km/h</td></tr>
        <tr><td>Mean speed</td><td>${meanSpd} km/h</td></tr>
        <tr><td>Speed limit changes</td><td>${limitChanges}</td></tr>
        <tr><td>Roundabouts</td><td>${roundaboutCount}</td></tr>
        <tr><td>Traffic-light junctions</td><td>${trafficLightCount}</td></tr>
        <tr><td>Bridges</td><td>${bridgeCount}</td></tr>
        <tr><td>Tunnels</td><td>${tunnelCount}</td></tr>
        <tr><td>Cities</td><td>${citiesList}</td></tr>
        <tr><td>Countries</td><td>${countriesList}</td></tr>`;
    }
    
    function resetDistance(){ totalDist=0; lastPos=null; positions=[]; roadTypes.clear(); distEl.textContent='Distance: 0.0 km'; speedEl.textContent='Speed: N/A'; roadTypeEl.textContent = 'Road type: N/A'; timeData=[]; distData=[]; speedData=[]; trackLine.setLatLngs([]); map.setView([0,0],2); updateStreetTable(); updateCountTable(); }
    function saveAndPrint () { const btn  = event.currentTarget; btn.disabled = true; const orig = btn.textContent; btn.innerHTML = '<span class="spinner"></span> Generating…'; setTimeout(() => { window.print(); btn.disabled  = false; btn.textContent = orig; }, 500); }
    function showError(e){ locEl.textContent='Error: '+e.message; speedEl.textContent='Speed: N/A'; }
    function getWeather(city){ fetch(`https://api.weatherapi.com/v1/current.json?key=ad8caecea06c43d1912181938230407&q=${encodeURIComponent(city)}`).then(r=>r.json()).then(d=>{ const iconPath=d.current.condition.icon||''; const iconUrl=iconPath.startsWith('//')?'https:'+iconPath:iconPath; iconEl.src=iconUrl; iconEl.alt=d.current.condition.text||'weather'; tempEl.textContent=`Temp: ${d.current.temp_c}°C`; }).catch(err=>{ tempEl.textContent='Temp: N/A'; console.error('Weather error',err); }); }

    function logButton(name, isRed) {
      const dt = new Date(); const date = dt.toLocaleDateString(); const time = dt.toLocaleTimeString();
      const fullPhase = document.getElementById('dayPhase').textContent; const phase = fullPhase.split(': ')[1] || fullPhase; const condition = iconEl.alt || 'Unknown';
      const [lat, lon] = locEl.innerHTML.split('<br>').map(l => l.split(': ')[1]);
      const dist = (totalDist / 1000).toFixed(1); const spd  = speedEl.textContent.split(' ')[1]; const rt = roadTypeEl.textContent.split(': ')[1];
      let comment = document.getElementById('textBox').value; comment = applyCorrections(comment);
      let camDataUrl = null;
      try {
        const video  = document.getElementById('camera'); const canvas = document.getElementById('cameraCanvas'); const ctx = canvas.getContext('2d');
        canvas.width  = video.videoWidth  || 640; canvas.height = video.videoHeight || 480; ctx.drawImage(video, 0, 0, canvas.width, canvas.height); camDataUrl = canvas.toDataURL('image/jpeg', 0.8);
      } catch (e) { console.warn('Camera frame failed', e); }
      logTable.push([ name, date, time, phase, tempEl.textContent, condition, lat, lon, dist, spd, rt, comment, camDataUrl ]);
      markDirty(); displayLogTable(); displayCameraTable();
      const issueNumber = logTable.length;
      L.marker([+lat, +lon], { icon: L.divIcon({ className: 'issue-label', html: `<strong>${issueNumber}</strong>` }) }).addTo(map);
      if (isRed) {
        redCounts[name] = (redCounts[name] || 0) + 1; roadRedCounts[rt] = (roadRedCounts[rt] || 0) + 1; countryRedCounts[lastCountry] = (countryRedCounts[lastCountry] || 0) + 1; weatherRedCounts[condition] = (weatherRedCounts[condition] || 0) + 1; weatherDistances[condition] = weatherDistances[condition] || 0; phaseRedCounts[phase] = (phaseRedCounts[phase] || 0) + 1; phaseDistances[phase] = phaseDistances[phase] || 0;
        updateStreetTable(); updateCountryTable(); updateWeatherTable(); updatePhaseTable(); updateCountTable();
      }
      document.getElementById('textBox').value = '';
    }

    function displayCameraTable() {
      const target = document.getElementById('cameraTableContainer'); if (!target) return;
      let html = `<table><tr><th>No.</th><th>Snapshot</th></tr>`;
      logTable.forEach((row, i) => { const img = row[12]; const cell = img ? `<img src="${img}" alt="Camera ${i+1}" style="width:320px;height:240px;object-fit:cover;border:1px solid #444;">` : '—'; html += `<tr><td>${i+1}</td><td>${cell}</td></tr>`; });
      html += '</table>'; target.innerHTML = html;
    }
    
    function displayLogTable() {
      let mainHtml = `<table id="logTable"><tr><th>No.</th><th>Issue</th><th>Date</th><th>Time</th><th>Phase</th><th>Temp</th><th>Weather</th><th>Lat</th><th>Lon</th><th>Distance (km)</th><th>Speed (km/h)</th><th>Road</th><th>Comment</th></tr>`;
      logTable.forEach((row, i) => { mainHtml += `<tr><td>${i + 1}</td>` + row.slice(0, 12).map(v => `<td>${v ?? '—'}</td>`).join('') + `</tr>`; });
      mainHtml += `</table>`; logContainer.innerHTML = mainHtml;

      let snapHtml = `<table id="snapshotTable" style="width:100%;border-collapse:collapse; border:1px solid #444;margin-bottom:80px;"><tr><th style="border:1px solid #444;padding:6px 8px;">No.</th><th style="border:1px solid #444;padding:6px 8px;">Issue</th><th style="border:1px solid #444;padding:6px 8px;">Map</th><th style="border:1px solid #444;padding:6px 8px;">Photo</th></tr>`;
      logTable.forEach((row, i) => {
        const [issue,,,,,, lat, lon, , , , , camUrl] = row;
        snapHtml += `<tr><td style="border:1px solid #444;padding:6px 8px;">${i + 1}</td><td style=\"border:1px solid #444;padding:6px 8px;\">${issue}</td><td id="mapcell-${i}" style="border:1px solid #444;padding:6px 8px;"><div id="snapmap-${i}" style="width:300px;height:200px;"></div></td><td style="border:1px solid #444;padding:6px 8px;">${ camUrl ? `<img src="${camUrl}" alt="Photo ${i + 1}" style="width:300px;height:200px; object-fit:cover;border:1px solid #444;">` : '—' }</td></tr>`;
      });
      snapHtml += `</table>`; document.getElementById('snapshotTableContainer').innerHTML = snapHtml;

      logTable.forEach((row, i) => {
        const lat = parseFloat(row[6]), lon = parseFloat(row[7]); const mapId = `snapmap-${i}`;
        const mini = L.map(mapId, { zoomControl:false, attributionControl:false, dragging:false, scrollWheelZoom:false, doubleClickZoom:false, boxZoom:false, keyboard:false, tap:false, preferCanvas:true }).setView([lat, lon], 17);
        const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OSM contributors', crossOrigin: true }).addTo(mini);
        L.circleMarker([lat, lon], { radius: 6, color: 'red', fillColor: 'red', fillOpacity: 1 }).addTo(mini);
        mini.invalidateSize();
        tiles.once('load', () => { leafletImage(mini, function(err, canvas) { if (err) { console.error('leaflet-image error', err); return; } const imgUrl = canvas.toDataURL('image/png'); const cell = document.getElementById(`mapcell-${i}`); cell.innerHTML = `<img src="${imgUrl}" width="300" height="200" style="object-fit:cover;border:1px solid #444;" alt="Map snapshot ${i+1}"/>`; mini.remove(); }); });
      });
    }

    function updateCountTable(){ let html='<tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>'; const km=totalDist/1000; for(let issue in redCounts){ const c=redCounts[issue]; const per=km>0?((c/km)*1000).toFixed(1):'—'; html+=`<tr><td>${issue}</td><td>${c}</td><td>${per}</td></tr>`; } countTbl.innerHTML=html; }

    function buildButtons(csvFile = 'KPI_buttons.csv') {
      const buttonGroups = document.getElementById('buttonGroups'); buttonGroups.innerHTML = '';
      fetch(csvFile)
        .then(response => { if (!response.ok) throw new Error(`Failed to load ${csvFile}: ${response.status} ${response.statusText}`); return response.text(); })
        .then(csvText => {
          const { data, errors } = Papa.parse(csvText, { header: true, skipEmptyLines: true }); if (errors.length) console.error('CSV parse errors:', errors);
          const groups = {};
          data.forEach(row => {
            const { group = '', label = '', cssClass = '', logName = label } = row;
            if (!group || !label) return;
            if (!groups[group]) { const wrap = document.createElement('div'); wrap.className = 'button-group'; buttonGroups.appendChild(wrap); groups[group] = wrap; }
            const btn = document.createElement('button'); btn.textContent = label; btn.classList.add('bigButton', ...cssClass.trim().split(/\s+/));
            const isRed = btn.classList.contains('redButton');
            btn.addEventListener('click', () => logButton(logName, isRed));
            groups[group].appendChild(btn);
          });
        })
        .catch(err => { console.error('Error building buttons:', err); });
    }
      
    function updateDayPhase(lat, lon) {
      fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&formatted=0`)
        .then(r => r.json())
        .then(data => {
          const now   = new Date();
          const dawn  = new Date(data.results.civil_twilight_begin);
          const sunrise = new Date(data.results.sunrise);
          const sunset  = new Date(data.results.sunset);
          const dusk    = new Date(data.results.civil_twilight_end);
          let phase;
          if (now < dawn) phase = 'Night';
          else if (now < sunrise) phase = 'Dawn';
          else if (now < sunset) phase = 'Daylight';
          else if (now < dusk) phase = 'Dusk';
          else phase = 'Night';
          document.getElementById('dayPhase').textContent = `Phase: ${phase}`;
        }).catch(err => console.error('Sun API error', err));
    }

    function updateWeatherTable() {
      let html = `<tr><th>Condition</th><th>Distance (km)</th><th>Distance (%)</th><th>No of issues</th></tr>`;
      for (const cond in weatherDistances) {
        const meters = weatherDistances[cond] || 0; const km = (meters / 1000).toFixed(1);
        const pct = totalDist > 0 ? ((meters / totalDist) * 100).toFixed(1) : '0.0';
        const count  = weatherRedCounts[cond] || 0;
        html += `<tr><td>${cond}</td><td>${km}</td><td>${pct}%</td><td>${count}</td></tr>`;
      }
      document.getElementById('weatherTable').innerHTML = html;
    }

    const tablesToUpload = ['logTable','statsTable','countTable','streetTable','metaTable','countryTable','weatherTable','phaseTable'];

    async function maybeUpdateTables() {
      const now = Date.now();
      if (now - lastTableUpdate > TABLE_THROTTLE) {
        displayLogTable(); updateStatsTable(); updateCountTable(); updateStreetTable(); updateCountryTable(); updateWeatherTable(); updatePhaseTable();
        uploadSnapshotsZip().catch(err => console.error('Snapshot ZIP upload failed:', err));
        uploadWorkbookToAzure().then(() => console.log('Workbook auto-uploaded')).catch(err => console.error('Workbook upload failed:', err));
        lastTableUpdate = now;
      }
      if (now - lastUploadTime > UPLOAD_THROTTLE) {
        lastUploadTime = now; // used by the sidebar label
        exportCustomSectionsToAzure().then(() => console.log('PDF report uploaded')).catch(err => console.error('PDF upload failed:', err));
      }
    }

    function updatePhaseTable() {
      let html = `<tr><th>Phase</th><th>Distance (km)</th><th>Distance (%)</th><th>No of issues</th></tr>`;
      for (const ph in phaseDistances) {
        const meters = phaseDistances[ph] || 0; const km = (meters / 1000).toFixed(1);
        const pct = totalDist > 0 ? ((meters / totalDist) * 100).toFixed(1) : '0.0';
        const count  = phaseRedCounts[ph] || 0;
        html += `<tr><td>${ph}</td><td>${km}</td><td>${pct}%</td><td>${count}</td></tr>`;
      }
      document.getElementById('phaseTable').innerHTML = html;
    }

    function updateDateTime() { document.getElementById('dateTime').textContent = new Date().toLocaleString(); }

    function tableToCSV(tableEl) { const rows = Array.from(tableEl.querySelectorAll('tr')); return rows.map(row => { const cells = Array.from(row.querySelectorAll('th,td')); return cells.map(cell => { const txt = cell.textContent.replace(/"/g, '""'); return `"${txt}"`; }).join(','); }).join('\n'); }

    const containerSasUrl = "https://annotationcsv.blob.core.windows.net/csv?sv=2024-11-04&ss=b&srt=co&sp=rwdlaciytfx&sr=c&se=2025-12-30T15:55:03Z&st=2025-07-01T06:55:03Z&spr=https&sig=NeNMbZI0PsppH4amjEmNcqMI00oC35rO8cV2swmbsyw%3D";
    
    async function uploadCSVtoAzure(tableId) {
      const table = document.getElementById(tableId); const csv = tableToCSV(table);
      const ts = formatAppStartTimestamp(); const blobName = `${tableId}-${ts}.csv`;
      const [baseUrl, token] = containerSasUrl.split('?'); const uploadUrl = `${baseUrl}/${blobName}?${token}`;
      const resp = await fetch(uploadUrl, { method: 'PUT', headers: { 'x-ms-blob-type': 'BlockBlob', 'Content-Type':'text/csv' }, body: csv });
      if (!resp.ok) throw new Error(`Upload failed: ${resp.status} ${resp.statusText}`);
      console.log(`✔ Uploaded ${blobName}`);
    }

    async function uploadWorkbookToAzure() {
      const wb = XLSX.utils.book_new();
      workbookTables.forEach(({ id, name }) => { const tblEl = document.getElementById(id); if (!tblEl) { console.warn(`Table #${id} not found—skipping sheet "${name}"`); return; } const ws = XLSX.utils.table_to_sheet(tblEl); if (['Road types', 'Country', 'Weather', 'Phase'].includes(name)) { const range = XLSX.utils.decode_range(ws['!ref']); for (let row = range.s.r + 1; row <= range.e.r; ++row) { const cellRef = XLSX.utils.encode_cell({ r: row, c: 2 }); const cell = ws[cellRef]; if (cell && typeof cell.v === 'number') { cell.v = cell.v * 100; } } } XLSX.utils.book_append_sheet(wb, ws, name); });
      const samplingAoA = [["No","Timestamp","Latitude","Longitude","Distance (km)","Speed (km/h)","Legal Speed (km/h)"]];
      samplingTable.forEach(entry => { samplingAoA.push([ entry.no, entry.timestamp, entry.lat, entry.lon, entry.distance, entry.speed, entry.legalSpeed ]); });
      const wsSampling = XLSX.utils.aoa_to_sheet(samplingAoA); XLSX.utils.book_append_sheet(wb, wsSampling, "Sampling");
      const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
      const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      const blobName = `${reportBaseName}.xlsx`;
      const [baseUrl, token] = containerSasUrl.split('?'); const uploadUrl = `${baseUrl}/${blobName}?${token}`;
      const resp = await fetch(uploadUrl, { method: 'PUT', headers: { 'x-ms-blob-type': 'BlockBlob', 'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }, body: blob });
      if (!resp.ok) throw new Error(`Workbook upload failed: ${resp.status} ${resp.statusText}`);
      console.log(`✔ Uploaded workbook: ${blobName}`);
    }
    
    async function exportMainContentToAzure() {
      const mainEl = document.getElementById('mainContent');
      const htmlDoc = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Annotation Report</title><style>body { font-family: Arial,sans-serif; margin:0; padding:0; } #mainContent { padding:20px; }</style></head><body>${mainEl.outerHTML}</body></html>`.trim();
      const blob = new Blob([htmlDoc], { type: 'text/html' });
      const blobName = `${reportBaseName}.html`;
      const [baseUrl, token] = containerSasUrl.split('?'); const uploadUrl = `${baseUrl}/${blobName}?${token}`;
      const resp = await fetch(uploadUrl, { method: 'PUT', headers: { 'x-ms-blob-type': 'BlockBlob', 'Content-Type': 'text/html' }, body: blob });
      if (!resp.ok) throw new Error(`HTML export failed: ${resp.status} ${resp.statusText}`);
      console.log(`✔ Uploaded HTML report: ${blobName}`);
    }

    async function exportPDFToAzure() {
      const map2El = document.getElementById('map2'); const wrapper = map2El.parentElement;  const reportName = `${reportBaseName}.pdf`;
      let snapEl = wrapper.querySelector('#map2-snapshot'); if (!snapEl) { snapEl = document.createElement('div'); snapEl.id = 'map2-snapshot'; snapEl.style.display = 'none'; snapEl.style.width  = map2El.style.width  || '100%'; snapEl.style.height = map2El.style.height || 'auto'; wrapper.appendChild(snapEl); }
      await new Promise(resolve => { leafletImage(map2, (err, canvas) => { if (!err && canvas) { const imgUrl = canvas.toDataURL('image/png'); snapEl.innerHTML = `<img src="${imgUrl}" alt="Street View Snapshot" style="width:100%; height:auto; object-fit:cover;">`; } resolve(); }); });
      map2El.style.display  = 'none'; snapEl.style.display  = 'block';
      const mainEl = document.getElementById('mainContent'); const origHeight  = mainEl.style.height; const origOverflow= mainEl.style.overflow; mainEl.style.height   = 'auto'; mainEl.style.overflow = 'visible';
      try {
        const opt = { margin: 0.2, filename: reportName, image: { type: 'jpeg', quality: 0.98 }, html2canvas: { scale: 1.5, useCORS: true }, jsPDF: { unit: 'in', format: 'a4', orientation: 'landscape' } };
        const pdfBlob = await html2pdf().set(opt).from(mainEl).outputPdf('blob');
        const [baseUrl, token] = containerSasUrl.split('?'); const uploadUrl = `${baseUrl}/${reportName}?${token}`;
        const resp = await fetch(uploadUrl, { method: 'PUT', headers: { 'x-ms-blob-type': 'BlockBlob', 'Content-Type': 'application/pdf' }, body: pdfBlob }); if (!resp.ok) throw new Error(`PDF upload failed: ${resp.status} ${resp.statusText}`);
      } finally { mainEl.style.height = origHeight; mainEl.style.overflow = origOverflow; snapEl.style.display = 'none'; map2El.style.display  = 'block'; }
    }

    const SECTIONS_TO_EXPORT = ['metaContainer','statsContainer','logTableContainer','snapshotContainer','countContainer','mapContainer','streetsContainer','countryContainer','weatherContainer','phaseContainer','chartsContainer'];
    let sectionTexts = {};
    async function loadSectionTexts() { try { const resp = await fetch('sectionTexts.json'); if (!resp.ok) throw new Error(`HTTP ${resp.status}`); sectionTexts = await resp.json(); } catch (err) { console.warn('Could not load section-text mapping:', err); sectionTexts = {}; } }

    async function exportCustomSectionsToAzure() {
      await loadSectionTexts();
      const blobName = `${reportBaseName}.pdf`; const [baseUrl, token] = containerSasUrl.split('?'); const uploadUrl = `${baseUrl}/${blobName}?${token}`;
      const tmp = document.createElement('div'); tmp.id = 'pdf-custom-clone'; Object.assign(tmp.style, { position:'relative', width:'180mm', margin:'0 auto', background:'#fff', boxSizing:'border-box' }); document.body.appendChild(tmp);
      const style = document.createElement('style'); style.textContent = `#pdf-custom-clone h2{font-size:18px;margin:0.5em 0 0.2em;} #pdf-custom-clone p{font-size:11px;margin:0 0 8px;} #pdf-custom-clone table{width:100%!important;table-layout:fixed;word-wrap:break-word;font-size:9px;border-collapse:collapse;} #pdf-custom-clone th,#pdf-custom-clone td{padding:4px;border:1px solid #444;vertical-align:top;} #pdf-custom-clone #snapshotTableContainer table th:nth-child(1), #pdf-custom-clone #snapshotTableContainer table td:nth-child(1), #pdf-custom-clone #snapshotTableContainer table th:nth-child(2), #pdf-custom-clone #snapshotTableContainer table td:nth-child(2){width:5%;} #pdf-custom-clone #snapshotTableContainer table th:nth-child(3), #pdf-custom-clone #snapshotTableContainer table td:nth-child(3), #pdf-custom-clone #snapshotTableContainer table th:nth-child(4), #pdf-custom-clone #snapshotTableContainer table td:nth-child(4){width:45%;} .page-break{page-break-after:always;}`; tmp.appendChild(style);
      SECTIONS_TO_EXPORT.forEach((id, idx) => {
        const info = sectionTexts[id]; if (info) { const h2 = document.createElement('h2'); h2.textContent = info.header; tmp.appendChild(h2); const p = document.createElement('p'); p.textContent = info.text; tmp.appendChild(p); }
        if (id === 'chartsContainer') { const wrapper = document.createElement('div'); wrapper.id = 'chartsContainer'; const distImg = new Image(); distImg.src = distanceChart.toBase64Image(); distImg.style.width = '100%'; wrapper.appendChild(distImg); wrapper.appendChild(Object.assign(document.createElement('div'), { className: 'page-break' })); const speedImg = new Image(); speedImg.src = speedChart.toBase64Image(); speedImg.style.width = '100%'; wrapper.appendChild(speedImg); tmp.appendChild(wrapper); }
        else { const src = document.getElementById(id); if (src) { const clone = src.cloneNode(true); clone.querySelectorAll('button,input').forEach(n => n.remove()); tmp.appendChild(clone); } }
        if (idx < SECTIONS_TO_EXPORT.length - 1) { const pbr = document.createElement('div'); pbr.className = 'page-break'; tmp.appendChild(pbr); }
      });
      const htmlEl = document.documentElement; const bodyEl = document.body; const origHtmlOv = htmlEl.style.overflow; const origBodyOv = bodyEl.style.overflow; htmlEl.style.overflow = 'visible'; bodyEl.style.overflow = 'visible';
      let pdfBlob; try { const opt = { margin:5, filename: blobName, image:{ type:'jpeg', quality:0.98 }, html2canvas:{ scale:1, useCORS:true, scrollX:0, scrollY:0 }, jsPDF:{ unit:'mm', format:'a4', orientation:'portrait' } }; pdfBlob = await html2pdf().set(opt).from(tmp).outputPdf('blob'); }
      catch (err) { console.error('PDF generation failed:', err); }
      finally { htmlEl.style.overflow = origHtmlOv; bodyEl.style.overflow = origBodyOv; document.body.removeChild(tmp); }
      if (!pdfBlob) return;
      try { const resp = await fetch(uploadUrl, { method: 'PUT', headers: { 'x-ms-blob-type': 'BlockBlob', 'Content-Type': 'application/pdf' }, body: pdfBlob }); if (!resp.ok) throw new Error(`${resp.status} ${resp.statusText}`); console.log(`✔ Uploaded custom PDF as ${blobName}`); } catch (err) { console.error('Custom PDF upload failed:', err); }
    }

    async function uploadSnapshotsZip() {
      console.log('💾 uploadSnapshotsZip() called; logTable.length =', logTable.length);
      const zip = new JSZip();
      logTable.forEach((row, i) => { const dataUrl = row[12]; if (!dataUrl) return; const [meta, base64] = dataUrl.split(','); const ext = meta.includes('png') ? 'png' : 'jpg'; const filename = `${i+1}.${ext}`; zip.file(filename, base64, { base64: true }); });
      const content = await zip.generateAsync({ type: 'blob' });
      const blobName = `${reportBaseName}.zip`;
      const [baseUrl, token] = containerSasUrl.split('?'); const uploadUrl = `${baseUrl}/${blobName}?${token}`;
      const resp = await fetch(uploadUrl, { method: 'PUT', headers: { 'x-ms-blob-type': 'BlockBlob', 'Content-Type': 'application/zip' }, body: content });
      if (!resp.ok) throw new Error(`Snapshot ZIP upload failed: ${resp.status} ${resp.statusText}`);
      console.log(`✔ Uploaded snapshots ZIP as ${blobName}`);
    }
    
    const uploadNowBtn = document.getElementById('uploadNowButton');
    function withSpinner(btn, fn) { const orig = btn.innerHTML; btn.disabled = true; btn.innerHTML = '<span class="spinner"></span> Uploading…'; return fn().catch(err => console.error('Manual upload failed:', err)).finally(() => { btn.disabled = false; btn.innerHTML = orig; }); }

    uploadNowBtn.addEventListener('click', () => {
      withSpinner(uploadNowBtn, async () => {
        await uploadWorkbookToAzure();
        await uploadSnapshotsZip();
        // optional: await exportCustomSectionsToAzure();
        lastUploadTime = Date.now();
        const lbl = document.getElementById('uploadAgo'); if (lbl) lbl.textContent = `Last upload: ${formatAgo(0)}`;
        console.log('✔ All uploads complete');
      });
    });

    function updateSnapshotTable() {
      const container = document.getElementById('snapshotTableContainer'); if (!container) return;
      let html = `<table><tr><th>No.</th><th>Snapshot</th><th>Issue</th></tr>`;
      logTable.forEach((row, i) => {
        const [ name,, , , , , lat, lon ] = row;
        const mapUrl = `https://staticmap.openstreetmap.de/staticmap.php?center=${lat},${lon}&zoom=17&size=300x200&markers=${lat},${lon},red-pushpin`;
        html += `<tr><td>${i+1}</td><td><img src="${mapUrl}" alt="Map at ${lat},${lon}" style="width:300px; height:200px; object-fit:cover; border:1px solid #ccc;"/></td><td>${name}</td></tr>`;
      });
      html += `</table>`; container.innerHTML = html;
    }
  </script>
</body>
</html>
