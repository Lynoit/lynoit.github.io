<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Annotator</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />

  <!-- Chart.js core + Luxon adapter -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1"></script>

  <!-- PapaParse for CSV parsing -->
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.3.2/papaparse.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-image/0.4.0/leaflet-image.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/microsoft-cognitiveservices-speech-sdk@1.31.0/distrib/browser/microsoft.cognitiveservices.speech.sdk.bundle.js"></script>

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; padding: 0; font-family: Arial, sans-serif; }
    #sidebar {
      position: fixed; top: 0; left: 0; height: 100%; width: 182px;
      transform: translateX(-152px); transition: transform .3s ease;
      background: #fff; box-shadow: 2px 0 5px rgba(0,0,0,0.1);
      overflow-y: auto; padding: 50px 10px 10px; z-index: 1000;
    }
    #sidebar.collapsed { transform: translateX(-152px); }
    #sidebar.expanded  { transform: translateX(0); }
    #toggleSidebar {
      position: fixed; top: 10px; left: 10px;
      background: #007bff; border: none; color: #fff;
      font-size: 1.5em; padding: 4px 8px; cursor: pointer;
      border-radius: 4px; z-index: 1100;
    }

    .spinner {
      border: 2px solid rgba(0,0,0,0.1);
      border-left-color: #333;
      border-radius: 50%; width: 16px; height: 16px;
      animation: spin .8s linear infinite; display: inline-block;
      vertical-align: middle;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    #totalDistance.updated { transition: background .5s; background: yellow; }

    .bigButton { display: block; width: 80%; min-width: 80px; padding: 12px; font-size: 14px; border-radius: 4px; cursor: pointer; margin: 8px auto; }
    .orangeButton { background-color: orange; color: white; }
    .blueButton   { background-color: blue;   color: white; }
    .greyButton   { background-color: grey;   color: white; }
    .greenButton  { background-color: green;  color: white; }
    .redButton    { background-color: red;    color: white; }

    #mainContent { height: 100vh; overflow-y: auto; margin-left: 202px; padding: 20px; box-sizing: border-box; }

    /* ── Manual Annotation Layout ── */
    #manualAnnotation {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      margin-bottom: 20px;
    }
    #manualAnnotation textarea {
      flex: 1;
      resize: vertical;
      font-size: 14px;
      padding: 8px;
    }
    #manualAnnotation button {
      display: inline-block;
      width: auto;
      padding: 6px 10px;
      font-size: 12px;
      margin: 0;
      white-space: nowrap;
    }

    table { width: 100%; margin: 10px 0; border-collapse: collapse; }
    td, th { text-align: center; padding: 10px; }
    #logTableContainer table {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #logTableContainer table th,
    #logTableContainer table td {
      border: 1px solid #444;
      padding: 6px 8px;
      text-align: center;
    }
    #countTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
    #countTable th,
    #countTable td {
    border: 1px solid #444 !important;
    padding: 6px 8px;
    text-align: center;
    margin-bottom: 80px;
    }
    #mapContainer {
      margin-bottom: 80px;
    }
    #countContainer {
      margin-bottom: 80px;
    }
    #chartsContainer {
      margin-bottom: 80px;
    }
    #chartsContainer .chartBox + .chartBox {
      margin-top: 80px;
    }
    #streetTable {
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
    }
   #streetTable th,
   #streetTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }

  #statsTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#statsTable th,
#statsTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}

#countryTable {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#countryTable th,
#countryTable td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}
    
    #weatherTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #weatherTable th,
   #weatherTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
   #phaseTable {
      width: 100%;
      border-collapse: collapse;
      border: 1px solid #444;
      margin-bottom: 80px;
   }
   #phaseTable th,
   #phaseTable td {
     border: 1px solid #444;
     padding: 6px 8px;
     text-align: center;
   }
 #snapshotTableContainer table {
  width: 100%;
  border-collapse: collapse;
  border: 1px solid #444;
  margin-bottom: 80px;
}
#snapshotTableContainer table th,
#snapshotTableContainer table td {
  border: 1px solid #444;
  padding: 6px 8px;
  text-align: center;
}
   }

    .center-groups { display: flex; justify-content: center; align-items: flex-start; gap: 20px; }

    .section { margin-bottom: 30px; }
    .page-break { page-break-after: always; }

    /* circular speed-limit sign */
.speedSign{
  width: 46px;
  height: 46px;
  border: 4px solid red;   /* red rim */
  border-radius: 50%;
  background: #fff;        /* white face */
  color: #000;             /* black digits */
  display: flex;
  align-items: center;
  justify-content: center;
  font: bold 14px/1 Arial, sans-serif;
  margin: 6px 0;
}

.speedLimitRow{
  display:flex;
  align-items:center;   /* vertical centring */
  gap:6px;              /* space between label and sign */
}

.speedLabel{
  font-weight: normal;
  font-size: inherit;
}
    
@media print {
  /* reset page‐sizing so we don’t clip */
  html, body {
    height: auto !important;
    overflow: visible !important;
  }

  /* hide the sidebar and toggle button */
  #sidebar,
  #toggleSidebar {
    display: none !important;
  }

  /* hide everything except mainContent */
  body * {
    visibility: hidden !important;
  }
  #mainContent,
  #mainContent * {
    visibility: visible !important;
  }

  /* stretch mainContent to fill the page and show all of it */
  #mainContent {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    margin: 0 !important;
    width: 100% !important;
    height: auto !important;         /* ← override the 100vh */
    max-height: none !important;     /* ← remove any implicit max */
    overflow: visible !important;    /* ← show all the content */
  }
  }

  /* hide the tiny weather icon in sidebar */
  #weatherIcon {
    display: none !important;
  }

    .distance-label {
  pointer-events: none;
  font-weight: bold;
  background: rgba(255,255,255,0.8);
  padding: 2px 6px;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
  white-space: nowrap;
}

 #camera {
  display: none;          /* Removes it from layout */
  /*  (alt ideas)
  visibility: hidden;     Keeps its slot but hides it
  height: 0;
  width: 0;
  */
  #cameraContainer > h3 {
  display: none !important;
  }
}    
  </style>
</head>
<body>
  <button id="toggleSidebar" aria-expanded="false">☰</button>
  <div id="sidebar" class="collapsed">
    <p id="dateTime"></p>
    <p id="dayPhase">Phase: N/A</p>
    <div class="weatherSection">
      <img id="weatherIcon" src="" alt="Weather">
      <p id="temperature">Temp: N/A</p>
    </div>
    <p id="streetCity">Street: N/A<br>City: N/A<br>Country: N/A</p>
    <p id="location"></p>
    <p id="roadType">Road type: N/A</p>
    <p id="speed">Speed: N/A</p>
    <div class="speedLimitRow">
      <span class="speedLabel">Speed&nbsp;limit:</span>
      <div id="legalSpeed" class="speedSign">–</div>
    </div>   
    <div class="distanceContainer">
      <p id="totalDistance">Distance: 0.0 km</p>
      <button class="bigButton orangeButton" onclick="resetDistance()">Reset distance</button>
    </div>
    <button class="bigButton greenButton" onclick="saveAndPrint()">Save report to PDF</button>
  </div>

  <div id="mainContent">
    <!-- ── Manual Annotation Section (moved & resized) ── -->
<div id="manualAnnotation" class="section">
  <span id="micLamp"
        title="Voice control ready"
        style="display:inline-block;width:10px;height:10px;
               margin-right:6px;border-radius:50%;background:#888;"></span>
  <button id="micToggle" class="greyButton" style="width:auto;">
       Start voice control
  </button>
  <textarea id="textBox" rows="2"
            placeholder="Speak after you say “Annotator”…"></textarea>
  <button class="blueButton"
          onclick="logButton('Manual annotation', false)">
    Manual annotation
  </button>
</div>

    <style>
      /* start hidden */
      #buttonGroups {
    display: none;
      }
  /* when checkbox is checked, show it */
      #showButtons:checked ~ #buttonGroups {
        display: flex;         /* or block, grid, whatever layout you need */
        align-items: flex-start;   /* if you want centering like your parent */
        gap: 6px;              /* if you want that spacing */
      }
    </style>

    <div style="margin-bottom:10px;
            display:flex;
            flex-wrap:wrap;
            align-items:center;
            gap:6px;">
      <input type="checkbox" id="showButtons" checked>
      <label for="showButtons">Show KPI Hot Keys</label>

<div id="buttonGroups" class="center-groups" style="margin-top:6px; margin-bottom:30px;">
   <div class="center-groups inner-button-wrapper" style="margin-top: 6px; margin-bottom: 30px;">
  </div>
</div>
      
    </div>
    <div class="page-break"></div>

    <h3>Issue list</h3>
    <div id="logTableContainer" class="section"></div>
    <div class="page-break"></div>

     <div id="snapshotContainer" class="section">
       <h3>Issue Snapshots</h3>
       <div id="snapshotTableContainer"></div>
     </div>
    
    <div id="cameraContainer" class="section">
      <h3 style="display:none">Camera preview</h3>
      <video id="camera" autoplay playsinline
         width="320" height="240"
         style="border:1px solid #444;"></video>
      </div>
    <canvas id="cameraCanvas" width="320" height="240" style="display:none;"></canvas>

    <div id="countContainer" class="section">
      <h3>KPI Calculation</h3>
      <table id="countTable">
        <tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>
        <tr><td colspan="3">&nbsp;</td></tr>
      </table>
    </div>
    <div class="page-break"></div>
    
    <div id="map2Container" class="section">
      <h3>Street View</h3>
      <div id="map2" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>
    
    <div id="mapContainer" class="section">
      <h3>Route view</h3>
      <div id="map" style="height:300px;width:100%;"></div>
    </div>
    <div class="page-break"></div>

    <div id="statsContainer" class="section">
      <h3>Statistics</h3>
      <table id="statsTable">
        <tr><th>Metric</th><th>Value</th></tr>
        <tr><td colspan="2">&nbsp;</td></tr>
      </table>
    </div>

    <div id="chartsContainer" class="section">
      <div class="chartBox">
        <h3>Distance vs Time</h3>
        <canvas id="distanceChart"></canvas>
      </div>
      <div class="chartBox">
        <h3>Speed vs Distance</h3>
        <canvas id="speedChart"></canvas>
      </div>
    </div>
    <div class="page-break"></div>

    <div id="streetsContainer" class="section">
      <h3>Road Types</h3>
      <table id="streetTable"><tr><th>Road type</th></tr></table>
    </div>

    <div id="countryContainer" class="section">
       <h3>Countries</h3>
       <table id="countryTable">
       <tr>
         <th>Country</th>
         <th>Distance&nbsp;(km)</th>
         <th>No&nbsp;of&nbsp;issues</th>
       </tr>
       </table>
     </div>

    <div id="weatherContainer" class="section">
      <h3>Weather</h3>
      <table id="weatherTable">
         <tr><th>Condition</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <div id="phaseContainer" class="section">
      <h3>Phase</h3>
      <table id="phaseTable">
         <tr><th>Phase</th><th>Distance (km)</th></tr>
      </table>
    </div>

    <footer style="text-align:center; padding:10px; font-size:12px; color:#666;">
      © Lynoit Tech 2025
    </footer>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <script>

    console.log('main script executing');
    
    // DOM refs
    const toggleBtn = document.getElementById('toggleSidebar');
    const sidebar   = document.getElementById('sidebar');
    const locEl     = document.getElementById('location');
    const roadTypeEl= document.getElementById('roadType');
    const streetCityEl=document.getElementById('streetCity');
    const tempEl    = document.getElementById('temperature');
    const iconEl    = document.getElementById('weatherIcon');
    const distEl    = document.getElementById('totalDistance');
    const speedEl   = document.getElementById('speed');
    const countTbl  = document.getElementById('countTable');
    const streetTbl = document.getElementById('streetTable');
    const countryTable = document.getElementById('countryTable');
    const logContainer = document.getElementById('logTableContainer');
    const buttonGroups = document.getElementById('buttonGroups');
    const micLamp   = document.getElementById('micLamp');
    const textBox   = document.getElementById('textBox');
    const countryDistances  = {};
    const weatherDistances = {};
    const phaseDistances = {};
    const AZURE_KEY    = '3T1KzqWzaLVhz37OFOOvGJy6xwndsk5NCiI6hIEpqWDvHVffObirJQQJ99BEACi5YpzXJ3w3AAAYACOGKvFo';
    const AZURE_REGION = 'northeurope';
    const PHASE_THROTTLE = 5 * 60 * 1000;
    const TABLE_THROTTLE = 30 * 1000;
    const citySet = new Set();   // unique city names encountered
    const legalSpeedEl = document.getElementById('legalSpeed');

    let lastLimit = null;
    let limitChanges = 0;
    let roundaboutCount     = 0;
    let trafficLightCount   = 0;
    let lastWasRoundabout   = false;   // debounce flags
    let lastWasTrafficLight = false;
    let bridgeCount   = 0;
    let tunnelCount   = 0;
    let lastWasBridge = false;
    let bridgeSegmentStartDist = null;
    let lastWasTunnel = false;
    
    // ── Whitelist of road types we care about ──
    const allowedRoadTypes = new Set([
     'motorway','motorway_link',
     'trunk','trunk_link',
     'primary','primary_link',
     'secondary','secondary_link',
     'tertiary','tertiary_link',
     'unclassified','residential','service','construction'
    ]);

    let startTime = null;        // timestamp of the first GPS fix (ms)
    const topSpeeds = [];   // running list of the 10 highest samples
    
    let maxSpeed  = 0;    // value that ends up in the Statistics table
    let lastTableUpdate = 0;
    let lastPhaseUpdate = 0;
    let logTable=[], redCounts={}, lastPos=null, totalDist=0;
    let positions=[], timeData=[], distData=[], speedData=[];
    let map, trackLine, distanceChart, speedChart;
    let roadTypes=new Set(), lastChartTs=0, posCount=0, lastCity=null;
    let lastCountry = null;
    let roadDistances = {};
    let currentDistMarker = null;
    let map2, circle2;
    let roadRedCounts = {};
    let countryRedCounts   = {};
    let weatherRedCounts   = {};    // red presses per weather condition
    let phaseRedCounts     = {};    // (optional) red presses per day phase
    let isDirty = false;

    function markDirty() { isDirty = true; }
    function markClean()  { isDirty = false; }

    window.addEventListener('beforeunload', e => {
      if (!isDirty) return;
      e.preventDefault();
      e.returnValue = '';
    });
    
    toggleBtn.onclick = () => {
      const exp = sidebar.classList.toggle('expanded');
      sidebar.classList.toggle('collapsed', !exp);
      toggleBtn.setAttribute('aria-expanded', exp);
    };

    window.onload = () => {
      initMap(); initMap2(); initCharts(); updateDateTime(); setInterval(updateDateTime,1000);
      navigator.geolocation.watchPosition(showPosition,showError,{enableHighAccuracy:true,maximumAge:5000,timeout:10000});
      buildButtons();
      startCamera();
    };

    let recognizer;  // Azure continuous recogniser
    let recogniserReady   = false;   // built at least once?
    let recogniserRunning = false;   // currently listening?

    // ─── Voice‑control start/stop ───────────────────────────
document.getElementById('micToggle').onclick = async event => {
  // 1. Build recogniser only the first time the button is pressed
  if (!recogniserReady) {
    await initAzureSpeech();           // creates the recogniser object
    recogniserReady = true;
  }

  // 2. Toggle listening state
  if (recogniserRunning) {
    recognizer.stopContinuousRecognitionAsync();
    recogniserRunning = false;
    micLamp.style.background = '#4caf50';          // 🟢 idle
    event.target.textContent = 'Start voice control';
  } else {
    recognizer.startContinuousRecognitionAsync();
    recogniserRunning = true;
    micLamp.style.background = '#f44336';          // 🔴 listening
    event.target.textContent = 'Stop voice control';
  }
};

 function updateCountryTable() {
  let html = `
    <tr>
      <th>Country</th>
      <th>Distance&nbsp;(km)</th>
      <th>No&nbsp;of&nbsp;issues</th>
    </tr>`;

  for (const c in countryDistances) {
    const km    = (countryDistances[c] / 1000).toFixed(1);
    const count = countryRedCounts[c] || 0;
    html += `
      <tr>
        <td>${c}</td>
        <td>${km}</td>
        <td>${count}</td>
      </tr>`;
  }
  countryTable.innerHTML = html;
}

function stripHotWord(text) {
  const match = text.match(/^\s*annotator[,:]?\s*/i);   // any leading spaces
  if (!match) return null;                              // ← hot‑word not found
  return text.slice(match[0].length).trim();            // rest of the phrase
}

    async function checkTrafficLight(lat, lon) {
  const radius = 10;  // meters
  const query = `
    [out:json];
    node(around:${radius},${lat},${lon})[highway=traffic_signals];
    out 1;
  `.trim().replace(/\s+/g, ' ');
  const url = 'https://overpass-api.de/api/interpreter?data='
            + encodeURIComponent(query);

  try {
    const res  = await fetch(url);
    const obj  = await res.json();
    const found = Array.isArray(obj.elements) && obj.elements.length > 0;

    if (found && !lastWasTrafficLight) {
      trafficLightCount++;
    }
    lastWasTrafficLight = found;
  } catch (err) {
    console.error('Overpass error', err);
  }
}

 async function checkBridge(lat, lon) {
  const radius = 10;  // meters
  const query = `
    [out:json];
    (
      way(around:${radius},${lat},${lon})[bridge=yes];
      node(around:${radius},${lat},${lon})[bridge=yes];
    );
    out 1;
  `.trim().replace(/\s+/g,' ');
  const url = 'https://overpass-api.de/api/interpreter?data='
            + encodeURIComponent(query);

  try {
    const res = await fetch(url);
    const obj = await res.json();
    const found = Array.isArray(obj.elements) && obj.elements.length > 0;

    if (found) {
      // we’re currently on (or above) a bridge element
      if (!lastWasBridge) {
        // just entered—mark the distance baseline
        bridgeSegmentStartDist = totalDist;  
      }
      // have we gone at least 100 m since that baseline?
      if (
        bridgeSegmentStartDist !== null &&
        totalDist - bridgeSegmentStartDist >= 100
      ) {
        bridgeCount++;
        lastWasBridge = true;
        bridgeSegmentStartDist = null;    // reset so we only count once
      }
    } else {
      // not on a bridge → reset everything
      lastWasBridge = false;
      bridgeSegmentStartDist = null;
    }
  } catch (err) {
    console.error('Overpass bridge error', err);
  }
}

async function initAzureSpeech() {
  console.log('initAzureSpeech started');    //  ← already added last time?
  const warn = msg => console.warn('Speech init:', msg);

  if (!window.SpeechSDK) {
    warn('SpeechSDK global missing – script failed to load?');
    micLamp.style.background = '#ffc107';   // 🟡  error
    return;
  }

  let recognizer;
  try {
    const speechConfig = SpeechSDK.SpeechConfig.fromSubscription(
      AZURE_KEY, AZURE_REGION
    );
    speechConfig.speechRecognitionLanguage = 'en-US';
    speechConfig.setProperty(
      SpeechSDK.PropertyId.SpeechServiceResponse_PostProcessingOption,
      'TrueText'
    );

    const audioConfig  = SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
    recognizer         = new SpeechSDK.SpeechRecognizer(
      speechConfig, audioConfig
    );
  } catch (e) {
    warn(e);
    micLamp.style.background = '#ffc107';   // 🟡
    return;
  }

  /* Lamp colours */
  recognizer.sessionStarted = ()  => micLamp.style.background = '#f44336'; // 🔴 listening
  recognizer.sessionStopped = ()  => micLamp.style.background = '#4caf50'; // 🟢 ready
  recognizer.canceled       = (_,e)=> {
    warn('Canceled: ' + e.errorDetails);
    micLamp.style.background = '#ffc107';   // 🟡 error
  };

  /* Hot‑word gate */
  recognizer.recognizing = (_,e)=> {
    const draft = stripHotWord(e.result.text);
    if (draft) textBox.value = draft + ' [draft]';
  };
  recognizer.recognized  = (_,e)=> {
    if (e.result.reason !== SpeechSDK.ResultReason.RecognizedSpeech) return;
    const cleaned = stripHotWord(e.result.text);
    if (cleaned) {
      textBox.value = cleaned;
      logButton('Manual annotation', false);
    }
  };

  recognizer.startContinuousRecognitionAsync();
}

 function parseMaxSpeed(tag){
  const m = /(\d+)/.exec(tag);        // first number in the tag
  return m ? m[1] : null;             // e.g. "80"  (null if none)
}
    
  function initMap () {
    map = L.map('map', {
    zoomControl:       false,
    scrollWheelZoom:   false,
    doubleClickZoom:   false,
    touchZoom:         false,
    boxZoom:           false,
    keyboard:          false,
    dragging:          false,   // ⟵ blocks mouse & touch drag
    tap:               false    // ⟵ blocks iOS “tap-drag” panning
    }).setView([0, 0], 2);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map);

    trackLine = L.polyline([], { weight: 4 }).addTo(map);
  }

  /* ── Street-view radius map ───────────────── */
  function initMap2 () {
    map2 = L.map('map2', {
    zoomControl:       false,
    scrollWheelZoom:   false,
    doubleClickZoom:   false,
    touchZoom:         false,
    boxZoom:           false,
    keyboard:          false,
    dragging:          false,
    tap:               false,
    attributionControl:false
    }).setView([0, 0], 18);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(map2);

    circle2 = L.circle([0, 0], { radius: 100, color: 'blue', fillOpacity: 0.1 }).addTo(map2);
    currentPosMarker2 = L.circleMarker([0, 0], { radius: 8, color: 'red', fillColor: 'red', fillOpacity: 1 }).addTo(map2);
  }
    
    function initCharts(){
      distanceChart=new Chart(document.getElementById('distanceChart').getContext('2d'),{type:'line',data:{labels:timeData,datasets:[{label:'Distance (km)',data:distData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'time',time:{unit:'minute',tooltipFormat:'HH:mm:ss'}},y:{beginAtZero:true}}}});
      speedChart=new Chart(document.getElementById('speedChart').getContext('2d'),{type:'line',data:{labels:distData,datasets:[{label:'Speed (km/h)',data:speedData,fill:false,tension:0.1}]},options:{responsive:true,scales:{x:{type:'linear',title:{display:true,text:'Distance (km)'}},y:{beginAtZero:true,title:{display:true,text:'Speed (km/h)'}}}}});
    }

    function startCamera() {
      const video = document.getElementById('camera');
      if (!navigator.mediaDevices?.getUserMedia) {
        console.warn('getUserMedia not supported');
        return;
    }
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
      .then(stream => { video.srcObject = stream; })
      .catch(err   => { console.error('Camera error', err); });
   }
    
  function showPosition(pos) {
  const { latitude: lat, longitude: lon } = pos.coords;
  const ts = pos.timestamp;
  let segDist = 0; // in meters

  if (!startTime) startTime = ts;
    
  // 1) Calculate segment distance & apply noise threshold
  if (lastPos) {
    segDist = calculateDistance(lastPos.lat, lastPos.lon, lat, lon);
    if (segDist < 10) return; // ignore tiny jitters

    // accumulate total and per‐weather
    totalDist += segDist;
    const phaseText = document.getElementById('dayPhase').textContent.split(': ')[1] || 'Unknown';
    phaseDistances[phaseText] = (phaseDistances[phaseText] || 0) + segDist;
    const condition = iconEl.alt || 'Unknown';
    weatherDistances[condition] = (weatherDistances[condition] || 0) + segDist;

        const distKm = (totalDist / 1000).toFixed(2);
    const labelHtml = `<div class="distance-label">${distKm} km</div>`;

    if (!currentDistMarker) {
      currentDistMarker = L.marker([lat, lon], {
        icon: L.divIcon({
          className: '',        // styling lives in .distance-label
          html: labelHtml,
          iconSize: [0, 0],     // let the inner div size itself
          iconAnchor: [0, -10]  // float just above the point
        })
      }).addTo(map);
    } else {
      currentDistMarker.setLatLng([lat, lon]);
      currentDistMarker.setIcon(L.divIcon({
        className: '',
        html: labelHtml,
        iconSize: [0, 0],
        iconAnchor: [0, -10]
      }));
    }    
  }

  // 2) Update position state & map
  const prevPos = lastPos;
  lastPos = { lat, lon, ts };
  posCount++;
  trackLine.addLatLng([lat, lon]);
  if (positions.length === 0) {
    map.setView([lat, lon], 15);
  } else if (posCount % 20 === 0) {
    map.fitBounds(trackLine.getBounds().pad(0.2));
  }
  positions.push([lat, lon]);

  // 3) Update speed display
  if (prevPos) {
    const dt = (ts - prevPos.ts) / 1000; // seconds
    const speedKmh = dt > 0 ? (segDist / dt) * 3.6 : 0;

      /* ── reject implausible spikes ───────────────────────── */
  if (speedKmh > 250) {
    console.warn(`Discarded unrealistic speed: ${speedKmh.toFixed(1)} km/h`);
    speedEl.textContent = 'Speed: N/A';
    // skip max-speed bookkeeping and chart push for this sample
  } else {
    /* existing “valid sample” logic — keep exactly as you have it */

    // 1. maintain the top-10 speeds list
    topSpeeds.push(speedKmh);
    topSpeeds.sort((a, b) => b - a);
    if (topSpeeds.length > 10) topSpeeds.pop();
    maxSpeed = topSpeeds.length === 10 ? topSpeeds[9] : topSpeeds[0];

    // 2. show live speed read-out
    speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;

    // 3. later (in the chart-update section) you already push
    //    speedData.push(speedKmh);  ← keep that line; it now runs only here
  }

    if (speedKmh > 0) {                    // ignore the very first 0 km/h
  topSpeeds.push(speedKmh);

  // keep the array sorted descending and trimmed to 10 values
  topSpeeds.sort((a, b) => b - a);
  if (topSpeeds.length > 10) topSpeeds.pop();

  // once we have 10 samples, maxSpeed = the lowest of them
  // (otherwise just use the current highest seen so far)
  maxSpeed = topSpeeds.length === 10
               ? topSpeeds[9]                 // index 9 = smallest of the top 10
               : topSpeeds[0];                // highest sample so far
}
    
    speedEl.textContent = `Speed: ${speedKmh.toFixed(1)} km/h`;
  }

  // 4) Update distance display & charts
  distEl.textContent = `Distance: ${(totalDist / 1000).toFixed(1)} km`;
  distEl.classList.add('updated');
  setTimeout(() => distEl.classList.remove('updated'), 500);

  if (Date.now() - lastChartTs > 5000) {
    timeData.push(new Date(ts));
    distData.push((totalDist / 1000).toFixed(3));
    speedData.push(speedEl.textContent.split(' ')[1]);
    requestAnimationFrame(() => {
      distanceChart.update();
      speedChart.update();
      maybeUpdateTables();
    });
    lastChartTs = Date.now();
  }

  // 5) Update raw lat/lon display
  locEl.innerHTML = `Lat: ${lat}<br>Lon: ${lon}`;

  const now = Date.now();
  if (now - lastPhaseUpdate > PHASE_THROTTLE) {
    updateDayPhase(lat, lon);
    lastPhaseUpdate = now;
  }

  // 6) Reverse‐geocode + whitelist + accumulate per‐type distance
  fetch(`https://nominatim.openstreetmap.org/reverse?format=jsonv2&extratags=1&lat=${lat}&lon=${lon}`)
    .then(r => r.json())
    .then(data => {
      const rawRt = data.extratags?.highway || data.type || 'unknown';
      const displayRt = allowedRoadTypes.has(rawRt) ? rawRt : 'Other';
      const tags = data.extratags || {};

        const isRoundabout =
       tags.junction === 'roundabout'
    || tags.highway  === 'mini_roundabout';

const isTunnel = tags.tunnel === 'yes';

// existing debounce/count logic…
if (isRoundabout && !lastWasRoundabout) roundaboutCount++;
if (isTunnel     && !lastWasTunnel)     tunnelCount++;

lastWasRoundabout = isRoundabout;
lastWasTunnel     = isTunnel;
      
      const maxTag =
      data.extratags?.maxspeed
   || data.extratags?.['maxspeed:forward']
   || data.extratags?.['maxspeed:backward'];

const limit = maxTag ? parseMaxSpeed(maxTag) : null;
legalSpeedEl.textContent = limit ?? '–';

/* ── count speed-limit transitions ─────────────── */
if (limit !== null && limit !== lastLimit) {
  if (lastLimit !== null) limitChanges++;   // skip the very first limit
  lastLimit = limit;
}

     if (segDist > 0) {    
       roadDistances[displayRt] =
      (roadDistances[displayRt] || 0) + segDist;
     }

      // update sidebar & sets
      roadTypeEl.textContent = `Road type: ${displayRt}`;
      if (allowedRoadTypes.has(rawRt)) roadTypes.add(rawRt);

      // street & city display
      const street = data.address.road
        || data.address.pedestrian
        || data.address.footway
        || 'Unknown street';
      const city = data.address.city
        || data.address.town
        || data.address.village
        || 'Unknown city';

      const country = data.address.country || 'Unknown country';

      if (segDist > 0) {
         countryDistances[country] = (countryDistances[country] || 0) + segDist;
      }
      
      streetCityEl.innerHTML = `Street: ${street}<br>City: ${city}<br>Country: ${country}`;

      // ── NEW: auto‑log when the country changes ──
      if (country !== lastCountry && lastCountry !== null) {
      // Re‑use the regular logger so it shows up everywhere
      logButton(`Entered ${country}`, false);   // false ⇒ not a KPI “red” event
      }
      lastCountry = country;

      // fetch weather on city change
      if (city !== lastCity) {
        lastCity = city;
        citySet.add(city);
        getWeather(city);
      }

      // refresh all tables
      maybeUpdateTables();
      checkTrafficLight(lat, lon);
      checkBridge(lat, lon);
    })
    .catch(err => {
      streetCityEl.textContent = 'Error: ' + err.message;
      console.error('Reverse geocode error', err);
    });

    if (map2) {
      map2.setView([lat, lon], 20);  // zoom level 20 ≃ 100 m across
      currentPosMarker2.setLatLng([lat, lon]);
    } 
        
}
    
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6_371_000;          // earth’s radius in meters
      const toRad = Math.PI / 180;
      const φ1 = lat1 * toRad;
      const φ2 = lat2 * toRad;
      const dφ = (lat2 - lat1) * toRad;
      const dλ = (lon2 - lon1) * toRad;

      const a = Math.sin(dφ/2)**2
          + Math.cos(φ1) * Math.cos(φ2) * Math.sin(dλ/2)**2;

      // clamp (1 - a) to [0,1] to avoid small floating‑point overshoot
      const oneMinusA = Math.max(0, 1 - a);

      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(oneMinusA));
      return R * c;  // distance in meters
    }
    
function updateStreetTable() {
  let html = `
    <tr>
      <th>Road type</th>
      <th>Distance (km)</th>
      <th>No of issues</th>
    </tr>`;

  for (const rt of roadTypes) {
    const meters = roadDistances[rt] || 0;
    const km     = (meters / 1000).toFixed(1);
    const count  = roadRedCounts[rt] || 0;

    html += `
      <tr>
        <td>${rt}</td>
        <td>${km}</td>
        <td>${count}</td>
      </tr>`;
  }

  streetTbl.innerHTML = html;
}

  function updateStatsTable () {
  // ① readable total time hh:mm:ss
  const totalMs  = startTime ? (lastPos.ts - startTime) : 0;
  const timeStr  = new Date(totalMs).toISOString().substring(11, 19);

  // ② distance & speeds
  const km       = (totalDist / 1000).toFixed(1);
  const hrs      = totalMs / 3_600_000;
  const meanSpd  = hrs > 0 ? (km / hrs).toFixed(1) : '—';

  // ③ counts
  const cityCnt  = citySet.size;
  const ctryCnt  = Object.keys(countryDistances).length;

  document.getElementById('statsTable').innerHTML = `
    <tr><th>Metric</th><th>Value</th></tr>
    <tr><td>Total test time</td>          <td>${timeStr}</td></tr>
    <tr><td>Total test distance</td>      <td>${km} km</td></tr>
    <tr><td>Max speed</td>           <td>${maxSpeed.toFixed(1)} km/h</td></tr>
    <tr><td>Mean speed</td>          <td>${meanSpd} km/h</td></tr>
    <tr><td>Speed limit changes</td><td>${limitChanges}</td></tr>
    <tr><td>Roundabouts</td> <td>${roundaboutCount}</td></tr>
    <tr><td>Traffic-light junctions</td><td>${trafficLightCount}</td></tr>
    <tr><td>Bridges</td><td>${bridgeCount}</td></tr>
    <tr><td>Tunnels</td><td>${tunnelCount}</td></tr>
    <tr><td>Cities</td>       <td>${cityCnt}</td></tr>
    <tr><td>Countries</td><td>${ctryCnt}</td></tr>`;
}
    
 function resetDistance(){totalDist=0;lastPos=null;positions=[];roadTypes.clear();distEl.textContent='Distance: 0.0 km';speedEl.textContent='Speed: N/A';roadTypeEl.textContent = 'Road type: N/A';timeData=[];distData=[];speedData=[];trackLine.setLatLngs([]);map.setView([0,0],2);updateStreetTable();updateCountTable();}
 function saveAndPrint () {
  const btn  = event.currentTarget;
  btn.disabled = true;

  const orig = btn.textContent;
  btn.innerHTML = '<span class="spinner"></span> Generating…';

  // Removed: logButton('Save report to PDF', false);

  // Give the spinner a brief moment to show, then print
  setTimeout(() => {
    window.print();
    btn.disabled  = false;
    btn.textContent = orig;
  }, 500);
}
    function showError(e){locEl.textContent='Error: '+e.message;speedEl.textContent='Speed: N/A';}
    function getWeather(city){fetch(`https://api.weatherapi.com/v1/current.json?key=ad8caecea06c43d1912181938230407&q=${encodeURIComponent(city)}`)
        .then(r=>r.json()).then(d=>{const iconPath=d.current.condition.icon||'';const iconUrl=iconPath.startsWith('//')?'https:'+iconPath:iconPath;iconEl.src=iconUrl;iconEl.alt=d.current.condition.text||'weather';tempEl.textContent=`Temp: ${d.current.temp_c}°C`;}).catch(err=>{tempEl.textContent='Temp: N/A';console.error('Weather error',err);});}

  function logButton(name, isRed) {
  const dt    = new Date(),
        date  = dt.toLocaleDateString(),
        time  = dt.toLocaleTimeString();

  // ── read phase & weather from the sidebar DOM ──
  const fullPhase = document.getElementById('dayPhase').textContent;
  const phase     = fullPhase.split(': ')[1] || fullPhase;
  const condition = iconEl.alt || 'Unknown';    // ← must do this!

  // parse lat/lon from sidebar
  const [lat, lon] = locEl.innerHTML
    .split('<br>')
    .map(l => l.split(': ')[1]);

  // current distance, speed, road type, comment
  const dist    = (totalDist / 1000).toFixed(1),
        spd     = speedEl.textContent.split(' ')[1],
        rt      = roadTypeEl.textContent.split(': ')[1],
        comment = document.getElementById('textBox').value;

  // optional camera snapshot…
  let camDataUrl = null;
  try {
    const video  = document.getElementById('camera');
    const canvas = document.getElementById('cameraCanvas');
    const ctx    = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    camDataUrl = canvas.toDataURL('image/jpeg', 0.8);
  } catch (e) {
    console.warn('Camera frame failed', e);
  }

  // push to the log
  logTable.push([
    name, date, time, phase,
    tempEl.textContent, condition,
    lat, lon, dist, spd, rt,
    comment, camDataUrl
  ]);

  markDirty();  

  // redraw logs & map marker
  displayLogTable();
  displayCameraTable();
  L.marker([+lat, +lon], {
    icon: L.divIcon({ className: 'issue-label', html: `<strong>${name}</strong>` })
  }).addTo(map);

  if (isRed) {
    // per-issue
    redCounts[name] = (redCounts[name] || 0) + 1;

    // per-road-type
    roadRedCounts[rt] = (roadRedCounts[rt] || 0) + 1;

    countryRedCounts[lastCountry] = (countryRedCounts[lastCountry] || 0) + 1;

    // per-weather-condition
    weatherRedCounts[condition] = (weatherRedCounts[condition] || 0) + 1;
    // ← pre-seed the distance bucket so updateWeatherTable will include it
    weatherDistances[condition] = weatherDistances[condition] || 0;

    // per-day-phase
    phaseRedCounts[phase]    = (phaseRedCounts[phase] || 0) + 1;
    // ← pre-seed the distance bucket so updatePhaseTable will include it
    phaseDistances[phase]    = phaseDistances[phase]   || 0;

    // now redraw all three KPI tables immediately
    updateStreetTable();
    updateCountryTable(); 
    updateWeatherTable();
    updatePhaseTable();
    updateCountTable();
  }

  // clear the text box
  document.getElementById('textBox').value = '';
}

function displayCameraTable() {
  const target = document.getElementById('cameraTableContainer');
  if (!target) return;

  let html = `
    <table>
      <tr><th>No.</th><th>Snapshot</th></tr>`;
  logTable.forEach((row, i) => {
    const img = row[12];          // index of the picture we just added
    const cell = img
      ? `<img src="${img}"
              alt="Camera ${i+1}"
              style="width:320px;height:240px;object-fit:cover;border:1px solid #444;">`
      : '—';
    html += `<tr><td>${i+1}</td><td>${cell}</td></tr>`;
  });
  html += '</table>';
  target.innerHTML = html;
}
    
function displayLogTable() {
/* ───────────────────────────────────────────────────────────
   1.  “Issue list” table (unchanged)
─────────────────────────────────────────────────────────── */
  let mainHtml = `
    <table>
      <tr>
        <th>No.</th><th>Issue</th><th>Date</th><th>Time</th>
        <th>Phase</th><th>Temp</th><th>Weather</th>
        <th>Lat</th><th>Lon</th><th>Distance (km)</th>
        <th>Speed (km/h)</th><th>Road</th><th>Comment</th>
      </tr>`;
  logTable.forEach((row, i) => {
    mainHtml += `<tr><td>${i + 1}</td>` +
                row.slice(0, 12).map(v => `<td>${v ?? '—'}</td>`).join('') +
                `</tr>`;
  });
  mainHtml += `</table>`;
  logContainer.innerHTML = mainHtml;



/* ───────────────────────────────────────────────────────────
   2.  “Issue Snapshots” table
       → Leaflet mini-map + camera frame
─────────────────────────────────────────────────────────── */
  let snapHtml = `
    <table id="snapshotTable"
           style="width:100%;border-collapse:collapse;
                  border:1px solid #444;margin-bottom:80px;">
      <tr>
        <th style="border:1px solid #444;padding:6px 8px;">No.</th>
        <th style="border:1px solid #444;padding:6px 8px;">Issue</th>
        <th style="border:1px solid #444;padding:6px 8px;">Map</th>
        <th style="border:1px solid #444;padding:6px 8px;">Photo</th>
      </tr>`;

  logTable.forEach((row, i) => {
    const [issue,,,,,, lat, lon, , , , , camUrl] = row;

    snapHtml += `
      <tr>
        <td style="border:1px solid #444;padding:6px 8px;">${i + 1}</td>
        <td style="border:1px solid #444;padding:6px 8px;">${issue}</td>

        <!-- map cell gets an empty div we’ll turn into a Leaflet map -->
        <td id="mapcell-${i}"
            style="border:1px solid #444;padding:6px 8px;">
            <div id="snapmap-${i}"
                 style="width:300px;height:200px;"></div>
        </td>

        <td style="border:1px solid #444;padding:6px 8px;">
          ${
            camUrl
              ? `<img src="${camUrl}"
                      alt="Photo ${i + 1}"
                      style="width:300px;height:200px;
                             object-fit:cover;border:1px solid #444;">`
              : '—'
          }
        </td>
      </tr>`;
  });

  snapHtml += `</table>`;
  document.getElementById('snapshotTableContainer').innerHTML = snapHtml;



/* ───────────────────────────────────────────────────────────
   3.  Turn each “snapmap-x” div into a tiny Leaflet map
─────────────────────────────────────────────────────────── */
  logTable.forEach((row, i) => {
    const lat = parseFloat(row[6]), lon = parseFloat(row[7]);

    const mini = L.map(`snapmap-${i}`, {
      zoomControl: false,
      attributionControl: false,
      dragging: false,
      scrollWheelZoom: false,
      doubleClickZoom: false,
      boxZoom: false,
      keyboard: false,
      tap: false
    }).setView([lat, lon], 17);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(mini);

    L.circleMarker([lat, lon], {
      radius: 6,
      color: 'red',
      fillColor: 'red',
      fillOpacity: 1
    }).addTo(mini);

    mini.invalidateSize();
  });
}


    function updateCountTable(){let html='<tr><th>Issue</th><th>Total No of events</th><th>Events per 1000 km</th></tr>';const km=totalDist/1000;for(let issue in redCounts){const c=redCounts[issue];const per=km>0?((c/km)*1000).toFixed(1):'—';html+=`<tr><td>${issue}</td><td>${c}</td><td>${per}</td></tr>`;}countTbl.innerHTML=html;}

    // Build buttons from CSV using fetch + PapaParse
   function buildButtons () {
  fetch('KPI_buttons.csv')
    .then(response => {
      if (!response.ok) throw new Error('Failed to load buttons.csv');
      return response.text();
    })
    .then(csvText => {
      // Parse CSV → array of objects {group,label,cssClass,logName,isRed}
      const { data, errors } = Papa.parse(csvText, {
        header: true,
        skipEmptyLines: true
      });
      if (errors.length) console.error('CSV parse errors', errors);

      const groups = {};   // <div> elements keyed by group name

      data.forEach(row => {
        const {
          group       = '',
          label       = '',
          cssClass    = '',
          logName     = label,   // fall back to the visible label
          /* isRed from CSV is ignored – we decide by cssClass */
        } = row;

        if (!group || !label) return;      // skip incomplete rows

        // Create the group container the first time we see this group
        if (!groups[group]) {
          const wrap = document.createElement('div');
          wrap.className = 'button-group';
          groups[group]  = wrap;
          buttonGroups.appendChild(wrap);
        }

        // Build the button element
        const btn = document.createElement('button');
        btn.textContent = label;
        btn.classList.add('bigButton', ...cssClass.trim().split(/\s+/));

        // KPI flag: ONLY red-styled buttons count
        const kpiEvent = btn.classList.contains('redButton');  // true → updates countTable

        btn.onclick = () => logButton(logName, kpiEvent);

        groups[group].appendChild(btn);
      });
    })
    .catch(err => console.error(err));
}
    function updateDayPhase(lat, lon) {
    fetch(`https://api.sunrise-sunset.org/json?lat=${lat}&lng=${lon}&formatted=0`)
    .then(r => r.json())
    .then(data => {
      const now   = new Date();
      const dawn  = new Date(data.results.civil_twilight_begin);
      const sunrise = new Date(data.results.sunrise);
      const sunset  = new Date(data.results.sunset);
      const dusk    = new Date(data.results.civil_twilight_end);

      let phase;
      if (now < dawn) {
        phase = 'Night';
      } else if (now < sunrise) {
        phase = 'Dawn';
      } else if (now < sunset) {
        phase = 'Daylight';
      } else if (now < dusk) {
        phase = 'Dusk';
      } else {
        phase = 'Night';
      }

      document.getElementById('dayPhase').textContent = `Phase: ${phase}`;
    })
    .catch(err => console.error('Sun API error', err));
}

    function updateWeatherTable() {
  let html = `
    <tr>
      <th>Condition</th>
      <th>Distance (km)</th>
      <th>No of issues</th>
    </tr>`;

  for (const cond in weatherDistances) {
    const km    = (weatherDistances[cond] / 1000).toFixed(1);
    const count = weatherRedCounts[cond] || 0;

    html += `
      <tr>
        <td>${cond}</td>
        <td>${km}</td>
        <td>${count}</td>
      </tr>`;
  }

  document.getElementById('weatherTable').innerHTML = html;
}

 function maybeUpdateTables() {
  const now = Date.now();
  if (now - lastTableUpdate > TABLE_THROTTLE) {
    updateStreetTable();
    updateCountryTable();
    updateCountTable();
    updateWeatherTable();
    updatePhaseTable();
    updateStatsTable();
    lastTableUpdate = now;
  }
}

 function updatePhaseTable() {
  let html = `
    <tr>
      <th>Phase</th>
      <th>Distance (km)</th>
      <th>No of issues</th>
    </tr>`;

  for (const ph in phaseDistances) {
    const km    = (phaseDistances[ph] / 1000).toFixed(1);
    const count = phaseRedCounts[ph] || 0;

    html += `
      <tr>
        <td>${ph}</td>
        <td>${km}</td>
        <td>${count}</td>
      </tr>`;
  }

  document.getElementById('phaseTable').innerHTML = html;
}

    function updateDateTime() { document.getElementById('dateTime').textContent = new Date().toLocaleString();
    }

    function updateSnapshotTable() {
  const container = document.getElementById('snapshotTableContainer');
  if (!container) return;
  
  // start the table
  let html = `
    <table>
      <tr>
        <th>No.</th>
        <th>Snapshot</th>
        <th>Issue</th>
      </tr>`;

  // one row per log entry
  logTable.forEach((row, i) => {
    const [ name,, , , , , lat, lon ] = row;
    // build a URL for a small static map centered on [lat,lon]
    const mapUrl = 
      `https://staticmap.openstreetmap.de/staticmap.php`
      + `?center=${lat},${lon}`
      + `&zoom=17`
      + `&size=300x200`
      + `&markers=${lat},${lon},red-pushpin`;

    html += `
      <tr>
        <td>${i+1}</td>
        <td>
          <img 
            src="${mapUrl}" 
            alt="Map at ${lat},${lon}" 
            style="width:300px; height:200px; object-fit:cover; border:1px solid #ccc;"
          />
        </td>
        <td>${name}</td>
      </tr>`;
  });

  html += `</table>`;
  container.innerHTML = html;
}
    
  </script>
</body>
</html>
