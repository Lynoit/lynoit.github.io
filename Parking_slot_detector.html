<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Parking Slot Detector (jsfeat, Direct Homography)</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background: #f3f3f3;
    }
    #status {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      background: #222;
      color: #fff;
      font-size: 14px;
      text-align: center;
      border-radius: 4px;
    }
    #controls {
      width: 100%;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: center;
      margin-bottom: 10px;
    }
    button {
      padding: 6px 12px;
      font-size: 14px;
    }
    input[type="number"] {
      width: 70px;
      font-size: 14px;
    }
    label {
      font-size: 14px;
      margin-right: 4px;
    }
    #videoContainer {
      position: relative;
      display: inline-block;
    }
    #video, 
    #overlayCanvas, 
    #canvasOut, 
    #birdCanvas {
      border: 1px solid #ccc;
      max-width: 100%;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin-top: 20px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 4px;
      text-align: center;
      font-size: 14px;
    }
    th {
      background: #e0e0e0;
    }
    img.snapshot {
      width: 100px;
      border: 1px solid #000;
    }
  </style>

  <!-- jsfeat library (pure‐JS computer vision) -->
  <script src="https://cdn.jsdelivr.net/npm/jsfeat@0.0.8/build/jsfeat.min.js"></script>
</head>
<body>
  <div id="status">Waiting to start…</div>

  <h1>Parking Slot Detector (jsfeat)</h1>

  <div id="controls">
    <button id="btnStart">Start Camera</button>
    <button id="btnCalibrate" disabled>Calibrate Perspective</button>

    <label for="calibWidth">Calib rect W (m):</label>
    <input type="number" id="calibWidth" value="2" step="0.1" min="0.1" />

    <label for="calibHeight">Calib rect H (m):</label>
    <input type="number" id="calibHeight" value="5" step="0.1" min="0.1" />

    <label for="calibPxPerM">Scale (px/m):</label>
    <input type="number" id="calibPxPerM" value="100" step="1" min="1" />
  </div>

  <div id="videoContainer">
    <video id="video" autoplay muted playsinline width="640" height="480" style="display:none;"></video>
    <canvas id="overlayCanvas" width="640" height="480"
            style="position:absolute; left:0; top:0; display:none; cursor: crosshair;"></canvas>
  </div>

  <canvas id="canvasOut" width="640" height="480" style="display:none; margin-top:10px;"></canvas>
  <canvas id="birdCanvas" width="640" height="480" style="display:none; margin-top:10px;"></canvas>

  <h2>Recorded Slots</h2>
  <table id="slotsTable">
    <thead>
      <tr>
        <th>Slot #</th>
        <th>Latitude</th>
        <th>Longitude</th>
        <th>Length (m)</th>
        <th>Width (m)</th>
        <th>Std Dev (m)</th>
        <th>Snapshot</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <script>
    // -------------------------------------------------------
    // Utility: updateStatus(text)
    // -------------------------------------------------------
    function updateStatus(msg) {
      document.getElementById('status').innerText = msg;
    }

    // -------------------------------------------------------
    // SlotTracker: tracks slots, accumulates measurements, stats
    // -------------------------------------------------------
    class SlotTracker {
      constructor() {
        this.slots = [];
        this.nextId = 1;
        this.MATCH_DIST_PX = 50;
        this.MIN_SAMPLES = 5;
        this.STABLE_STD_M = 0.05;
      }
      update(detections) {
        this.slots.forEach(s => s.updated = false);
        for (let det of detections) {
          let best = null, bestD = Infinity;
          for (let s of this.slots) {
            let dx = det.cx - s.lastCx;
            let dy = det.cy - s.lastCy;
            let d = Math.hypot(dx, dy);
            if (d < this.MATCH_DIST_PX && d < bestD) {
              bestD = d;
              best = s;
            }
          }
          if (best) {
            best.widthHistory.push(det.widthM);
            best.heightHistory.push(det.heightM);
            best.lastCx = det.cx;
            best.lastCy = det.cy;
            best.lastRectOrig = det.rectOrig;
            best.updated = true;
          } else {
            this.slots.push({
              id: this.nextId++,
              lastCx: det.cx,
              lastCy: det.cy,
              lastRectOrig: det.rectOrig,
              widthHistory: [det.widthM],
              heightHistory: [det.heightM],
              updated: true,
              recorded: false,
              meanWidth: det.widthM,
              meanHeight: det.heightM,
              stdWidth: 0,
              stdHeight: 0,
              isStable: false
            });
          }
        }
        this.slots = this.slots.filter(s => s.updated);
        for (let s of this.slots) {
          s.meanWidth  = this._mean(s.widthHistory);
          s.meanHeight = this._mean(s.heightHistory);
          s.stdWidth   = this._std(s.widthHistory, s.meanWidth);
          s.stdHeight  = this._std(s.heightHistory, s.meanHeight);
          s.isStable   = (
            s.widthHistory.length >= this.MIN_SAMPLES &&
            s.stdWidth <= this.STABLE_STD_M &&
            s.stdHeight <= this.STABLE_STD_M
          );
        }
      }
      _mean(arr) {
        return arr.reduce((a, b) => a + b, 0) / arr.length;
      }
      _std(arr, mean) {
        let varSum = arr.reduce((acc, v) => acc + (v - mean) ** 2, 0) / arr.length;
        return Math.sqrt(varSum);
      }
    }
    const tracker = new SlotTracker();

    // -------------------------------------------------------
    // Globals / DOM elements
    // -------------------------------------------------------
    const video          = document.getElementById('video');
    const overlayCanvas  = document.getElementById('overlayCanvas');
    const ovCtx          = overlayCanvas.getContext('2d');
    const outCanvas      = document.getElementById('canvasOut');
    const outCtx         = outCanvas.getContext('2d');
    const birdCanvas     = document.getElementById('birdCanvas');
    const birdCtx        = birdCanvas.getContext('2d');
    const btnStart       = document.getElementById('btnStart');
    const btnCalibrate   = document.getElementById('btnCalibrate');
    const calibWidthInp  = document.getElementById('calibWidth');
    const calibHeightInp = document.getElementById('calibHeight');
    const calibPxInp     = document.getElementById('calibPxPerM');
    const slotsTableBody = document.querySelector('#slotsTable tbody');

    let streaming       = false;
    let calibrationMode = false;
    let clickedPoints   = [];
    let H = null, H_inv = null;
    const width = 640, height = 480;

    // jsfeat buffers
    let srcImage, grayImg, blurredImg, edgeImg;

    // -------------------------------------------------------
    // After load, enable Start
    // -------------------------------------------------------
    window.addEventListener('load', () => {
      updateStatus('Click “Start Camera” to begin.');
      btnStart.disabled = false;
    });

    // -------------------------------------------------------
    // Start camera & initialize jsfeat mats
    // -------------------------------------------------------
    btnStart.addEventListener('click', async () => {
      updateStatus('Accessing camera…');
      btnStart.disabled = true;

      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: width, height: height },
          audio: false
        });
        video.srcObject = stream;
        video.style.display = 'block';
        overlayCanvas.style.display = 'block';
        outCanvas.style.display     = 'block';
        birdCanvas.style.display    = 'block';
        video.play();
        updateStatus('Camera started. Click “Calibrate Perspective” when ready.');
        btnCalibrate.disabled = false;
      } catch (err) {
        console.error('Camera error:', err);
        updateStatus('⛔ Could not access camera. Check permissions and HTTPS.');
        btnStart.disabled = false;
        return;
      }

      video.addEventListener('loadedmetadata', () => {
        if (!streaming) {
          streaming = true;
          srcImage   = new jsfeat.U8_t(width * height * 4);
          grayImg    = new jsfeat.U8_t(width * height);
          blurredImg = new jsfeat.U8_t(width * height);
          edgeImg    = new jsfeat.U8_t(width * height);
          requestAnimationFrame(processFrame);
        }
      });
    });

    // -------------------------------------------------------
    // Calibrate Perspective: click four corners
    // -------------------------------------------------------
    btnCalibrate.addEventListener('click', () => {
      if (!streaming) return;
      calibrationMode = true;
      clickedPoints = [];
      ovCtx.clearRect(0, 0, width, height);
      updateStatus('Calibration mode: click 4 corners (TL→TR→BR→BL).');
    });

    overlayCanvas.addEventListener('click', ev => {
      if (!calibrationMode) return;
      const rect = overlayCanvas.getBoundingClientRect();
      const x = ev.clientX - rect.left;
      const y = ev.clientY - rect.top;
      clickedPoints.push({ x, y });
      ovCtx.fillStyle = 'red';
      ovCtx.beginPath();
      ovCtx.arc(x, y, 5, 0, 2 * Math.PI);
      ovCtx.fill();
      updateStatus(`Clicked point ${clickedPoints.length}/4 at (${x.toFixed(0)},${y.toFixed(0)})`);
      if (clickedPoints.length === 4) {
        finishCalibration();
      }
    });

    function finishCalibration() {
      calibrationMode = false;
      updateStatus('Computing homography…');

      const Wm = parseFloat(calibWidthInp.value);
      const Hm = parseFloat(calibHeightInp.value);
      const pxPerM = parseFloat(calibPxInp.value);
      if (!(Wm > 0 && Hm > 0 && pxPerM > 0)) {
        alert('Invalid calibration values.');
        updateStatus('Click “Calibrate Perspective” again.');
        return;
      }
      const Wpx = Wm * pxPerM;
      const Hpx = Hm * pxPerM;

      // Build flat arrays of 4 corner pairs
      const imgPts = new Float32Array([
        clickedPoints[0].x, clickedPoints[0].y,
        clickedPoints[1].x, clickedPoints[1].y,
        clickedPoints[2].x, clickedPoints[2].y,
        clickedPoints[3].x, clickedPoints[3].y
      ]);
      const dstPts = new Float32Array([
        0,   0,
        Wpx, 0,
        Wpx, Hpx,
        0,   Hpx
      ]);

      // Direct homography solver (no RANSAC). Requires 4 non‐collinear points.
      H = new jsfeat.matrix_t(3, 3, jsfeat.F32C1_t);
      const ok = jsfeat.motion_estimator.homography2d(imgPts, dstPts, H);
      if (!ok) {
        updateStatus('❌ Homography failed—points may be collinear. Try again.');
        H = null;
        return;
      }
      H_inv = new jsfeat.matrix_t(3, 3, jsfeat.F32C1_t);
      jsfeat.matmath.invert_3x3(H, H_inv);

      updateStatus('Perspective calibrated. Starting detection…');
    }

    // -------------------------------------------------------
    // Main loop: grab frame, warp, Canny, find quads, draw
    // -------------------------------------------------------
    function processFrame() {
      if (!streaming) return;
      // 1) Copy video frame into srcImage RGBA buffer
      outCtx.drawImage(video, 0, 0, width, height);
      const rgbaData = outCtx.getImageData(0, 0, width, height).data;
      for (let i = 0; i < rgbaData.length; i++) {
        srcImage[i] = rgbaData[i];
      }

      if (H) {
        // 2) Warp into bird’s‐eye
        jsfeat.imgproc.warp_perspective(srcImage, birdCanvas, width, height, H, jsfeat.constants.INTERPOLATE_LINEAR);

        // 3) Grab the warped RGBA → grayscale → blur → Canny
        const birdRGBA = birdCtx.getImageData(0, 0, width, height).data;
        jsfeat.imgproc.grayscale(birdRGBA, width, height, grayImg);
        jsfeat.imgproc.gaussian_blur(grayImg, blurredImg, 5);
        jsfeat.imgproc.canny(blurredImg, edgeImg, 50, 150);

        // 4) Find raw contours in edgeImg
        const contours = simpleFindContours(edgeImg, width, height);

        // 5) Approximate to quadrilaterals
        const quads = [];
        for (let cnt of contours) {
          if (cnt.length < 50) continue;
          const approx = approxPoly(cnt, 2.0);
          if (approx.length === 4) {
            let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
            for (let p of approx) {
              minX = Math.min(minX, p.x);
              minY = Math.min(minY, p.y);
              maxX = Math.max(maxX, p.x);
              maxY = Math.max(maxY, p.y);
            }
            const w_px = maxX - minX;
            const h_px = maxY - minY;
            const widthM  = w_px / parseFloat(calibPxInp.value);
            const heightM = h_px / parseFloat(calibPxInp.value);
            const cx = minX + w_px / 2;
            const cy = minY + h_px / 2;

            // 6) Back‐project corners to original view using H_inv
            const srcCorners = new Float32Array([
              approx[0].x, approx[0].y, 1,
              approx[1].x, approx[1].y, 1,
              approx[2].x, approx[2].y, 1,
              approx[3].x, approx[3].y, 1
            ]);
            const dstCorners = new Float32Array(12);
            jsfeat.matmath.multiply_3x3src(H_inv, srcCorners, dstCorners);

            const rectOrig = [];
            for (let i = 0; i < 12; i += 3) {
              const invW = 1.0 / dstCorners[i + 2];
              rectOrig.push({
                x: dstCorners[i]   * invW,
                y: dstCorners[i+1] * invW
              });
            }

            quads.push({
              cx, cy,
              widthM, heightM,
              rectOrig
            });
          }
        }

        // 7) Track slots over time
        tracker.update(quads);

        // 8) Draw on the output canvas
        outCtx.drawImage(video, 0, 0, width, height);
        for (let slot of tracker.slots) {
          let best = null, bestD = Infinity;
          for (let q of quads) {
            const dx = q.cx - slot.lastCx;
            const dy = q.cy - slot.lastCy;
            const d = Math.hypot(dx, dy);
            if (d < bestD) {
              bestD = d;
              best = q;
            }
          }
          if (!best) continue;
          outCtx.lineWidth   = 3;
          outCtx.strokeStyle = slot.isStable ? 'lime' : 'yellow';
          outCtx.beginPath();
          outCtx.moveTo(best.rectOrig[0].x, best.rectOrig[0].y);
          for (let k = 1; k < 4; k++) {
            outCtx.lineTo(best.rectOrig[k].x, best.rectOrig[k].y);
          }
          outCtx.closePath();
          outCtx.stroke();

          outCtx.font = '16px Arial';
          outCtx.fillStyle = slot.isStable ? 'lime' : 'yellow';
          if (slot.isStable) {
            const wM = slot.meanWidth.toFixed(2);
            const hM = slot.meanHeight.toFixed(2);
            outCtx.fillText(`#${slot.id}: ${wM}×${hM}m`,
                             best.rectOrig[0].x, best.rectOrig[0].y - 10);
            if (!slot.recorded) {
              addSlotToTable(slot);
            }
          } else {
            outCtx.fillText(`#${slot.id}`,
                             best.rectOrig[0].x, best.rectOrig[0].y - 10);
          }
        }
      } else {
        // If no homography yet, just show the raw video
        outCtx.drawImage(video, 0, 0, width, height);
      }

      requestAnimationFrame(processFrame);
    }

    // -------------------------------------------------------
    // Simple contour finder for binary edge image
    // -------------------------------------------------------
    function simpleFindContours(binImg, w, h) {
      const contours = [];
      const visited = new Uint8Array(w * h);
      function idx(x, y) { return y * w + x; }

      for (let y = 1; y < h - 1; y++) {
        for (let x = 1; x < w - 1; x++) {
          const i = idx(x, y);
          if (binImg[i] !== 0 && !visited[i]) {
            const contour = [];
            let cx = x, cy = y;
            let dir = 0;
            do {
              visited[idx(cx, cy)] = 1;
              contour.push({ x: cx, y: cy });
              let found = false;
              for (let k = 0; k < 8; k++) {
                const d = (dir + k) % 8;
                const nx = cx + [1,1,0,-1,-1,-1,0,1][d];
                const ny = cy + [0,1,1,1,0,-1,-1,-1][d];
                if (nx >= 0 && nx < w && ny >= 0 && ny < h) {
                  if (binImg[idx(nx, ny)] !== 0) {
                    cx = nx; cy = ny;
                    dir = (d + 5) % 8;
                    found = true;
                    break;
                  }
                }
              }
              if (!found) break;
            } while (!(cx === x && cy === y));
            if (contour.length > 0) {
              contours.push(contour);
            }
          }
        }
      }
      return contours;
    }

    // -------------------------------------------------------
    // Ramer–Douglas–Peucker polygon approximation
    // -------------------------------------------------------
    function approxPoly(points, epsilon) {
      function rdp(start, end, arr, eps, out) {
        let maxDist = 0, index = -1;
        const x1 = arr[start].x,  y1 = arr[start].y;
        const x2 = arr[end].x,    y2 = arr[end].y;
        for (let i = start + 1; i < end; i++) {
          const px = arr[i].x, py = arr[i].y;
          const num = Math.abs((y2 - y1) * px - (x2 - x1) * py + x2 * y1 - y2 * x1);
          const den = Math.hypot(y2 - y1, x2 - x1);
          const dist = den === 0 ? 0 : num / den;
          if (dist > maxDist) {
            maxDist = dist;
            index = i;
          }
        }
        if (maxDist > eps) {
          rdp(start, index, arr, eps, out);
          rdp(index, end, arr, eps, out);
        } else {
          out.push(arr[start]);
        }
      }
      const out = [];
      rdp(0, points.length - 1, points, epsilon, out);
      out.push(points[points.length - 1]);
      return out;
    }

    // -------------------------------------------------------
    // addSlotToTable: append a new row for a stable slot
    // -------------------------------------------------------
    function addSlotToTable(slot) {
      const tr = document.createElement('tr');

      const tdId = document.createElement('td');
      tdId.textContent = slot.id;
      tr.appendChild(tdId);

      const tdLat = document.createElement('td'); tdLat.textContent = 'N/A'; tr.appendChild(tdLat);
      const tdLon = document.createElement('td'); tdLon.textContent = 'N/A'; tr.appendChild(tdLon);

      const tdLen = document.createElement('td');
      tdLen.textContent = slot.meanHeight.toFixed(2);
      tr.appendChild(tdLen);

      const tdWid = document.createElement('td');
      tdWid.textContent = slot.meanWidth.toFixed(2);
      tr.appendChild(tdWid);

      const tdStd = document.createElement('td');
      const avgStd = ((slot.stdWidth + slot.stdHeight) / 2).toFixed(2);
      tdStd.textContent = avgStd;
      tr.appendChild(tdStd);

      const tdSnap = document.createElement('td');
      const snapCanvas = document.createElement('canvas');
      const rectPts = slot.lastRectOrig;
      let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
      for (let p of rectPts) {
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      }
      const wBox = maxX - minX, hBox = maxY - minY;
      minX = Math.max(0, minX);
      minY = Math.max(0, minY);
      const cw = Math.min(outCanvas.width - minX, wBox);
      const ch = Math.min(outCanvas.height - minY, hBox);
      snapCanvas.width  = cw;
      snapCanvas.height = ch;
      const sctx = snapCanvas.getContext('2d');
      sctx.drawImage(outCanvas, minX, minY, cw, ch, 0, 0, cw, ch);
      const img = document.createElement('img');
      img.className = 'snapshot';
      img.src = snapCanvas.toDataURL('image/png');
      tdSnap.appendChild(img);
      tr.appendChild(tdSnap);

      slotsTableBody.appendChild(tr);
      slot.recorded = true;
    }
  </script>
</body>
</html>
