<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Annotator Reports Viewer</title>
  <link rel="icon" href="./favicon_speed_R_carbon_bold.svg" type="image/svg+xml" sizes="any">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body { margin: 0; font-family: system-ui, Segoe UI, Roboto, Arial, sans-serif; background: #fff; color: #000; }
#sidebar { position: fixed; left: 0; top: 0; bottom: 0; width: 320px; background: #f5f5f5; overflow-y: auto; border-right: 1px solid #ddd; }
#content {
  margin-left: 320px;
  padding: 16px 20px 20px 20px; /* top right bottom left */
}

/* Sidebar accordion affordance */
.day-header{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
  padding:10px 12px 10px 32px;           /* space for chevron */
  font-weight:600; background:#f8f9fb;   /* subtle card look */
  position:relative; cursor:pointer;
  border-bottom:1px solid #ddd;
}
.day-header:hover{ background:#eef2f9; }
.day-header:focus-visible{
  outline:2px solid var(--accent, #1f3de3);
  outline-offset:2px; border-radius:6px;
}
/* Chevron */
.day-header::before{
  content:'▶'; position:absolute; left:12px; top:50%;
  transform:translateY(-50%); font-size:12px; color:#555;
  transition: transform .2s ease;
}
.day-header[aria-expanded="true"]::before{
  transform:translateY(-50%) rotate(90deg);
}
/* Count pill on the right */
.day-count{
  background:#e9eefc; color:#1f3de3; font-weight:700; font-size:11px;
  padding:2px 6px; border-radius:999px; border:1px solid #cbd5ff;
}

/* Append small "tests" text inside the badge */
.day-count::after{
  content: " tests";
  font-size: 10px;
  font-weight: 600;
  opacity: .8;
  margin-left: 4px;
}
    .session-list { display: none; list-style: none; margin: 0; padding: 0; }
    .session-item { padding: 8px 32px; cursor: pointer; border-bottom: 1px solid #eee; }
    .session-item:hover { background: #f0f0f0; }
    .session-item .meta { font-size: 12px; color: #666; margin-top: 2px; }

/* === Highlight the session currently shown in main window === */
.session-item.is-active{
  background:#dbe7ff;
  border-left:4px solid var(--accent, #1f3de3);
  padding-left:28px;           /* compensate for the left border */
}
.session-item.is-active:hover{
  background:#cfe0ff;
}
    
    h1 { margin: 0 0 12px 0; }
    h2 { margin-top: 1.5em; border-bottom: 1px solid #ddd; padding-bottom: 4px; }
    table { width: 100%; border-collapse: collapse; margin-bottom: 2em; }
    th, td { border: 1px solid #ccc; padding: 8px; }
    th { background-color: #f5f5f5 !important; }
    .error { color: #d00; padding: 16px; }

    .issue-badge { display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; background: red; color: white; border-radius: 12px; font-size: 12px; font-weight: bold; pointer-events: none; }
    #issue-map { width: 100%; height: 400px; margin: 20px 0; border: 1px solid #aaa; }

    .download-button { display: inline-block; margin-right: 12px; margin-bottom: 16px; padding: 8px 12px; background: #007bff; color: white; text-decoration: none; border-radius: 4px; font-size: 14px; }
    .download-button:hover { background: #0056b3; }

.download-button.danger-button {
  background: #dc3545;
}
.download-button.danger-button:hover {
  background: #b02a37;
}

/* Simple modal overlay + dialog */
.modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,.4);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
}
.modal-dialog {
  background: #fff;
  padding: 16px 20px;
  border-radius: 8px;
  max-width: 420px;
  width: 90%;
  box-shadow: 0 4px 12px rgba(0,0,0,.2);
  font-size: 14px;
}
.modal-dialog h3 {
  margin-top: 0;
  margin-bottom: 8px;
}
.modal-dialog p {
  margin: 0 0 8px;
}
.modal-dialog ul {
  margin: 8px 0 12px 20px;
  padding: 0;
}
.modal-dialog .modal-buttons {
  margin-top: 12px;
  text-align: right;
}
.modal-dialog button {
  margin-left: 8px;
  padding: 6px 10px;
  font-size: 13px;
}
.modal-dialog .danger-button {
  background: #dc3545;
  color: #fff;
  border: none;
}
.modal-dialog .danger-button:hover {
  background: #b02a37;
}
.modal-dialog .secondary-button {
  background: #e0e0e0;
  border: none;
}
.modal-dialog .secondary-button:hover {
  background: #cfcfcf;
}
.modal-dialog .modal-error {
  color: #c00;
  font-size: 12px;
  margin-top: 4px;
}
.modal-dialog label {
  display: block;
  font-size: 13px;
  margin: 6px 0 4px;
}
.modal-dialog input {
  width: 100%;
  padding: 4px 6px;
  font-size: 14px;
  box-sizing: border-box;
}

.ai-summary-body {
  max-height: 70vh;
  overflow-y: auto;
  padding: 8px 0;
  font-size: 13px;
  line-height: 1.4;
}

.ai-summary-body ul {
  padding-left: 20px;
  margin: 4px 0 8px;
}

.ai-summary-body li {
  margin: 2px 0;
}

.ai-summary-body p {
  margin: 4px 0;
}

.ai-summary-timestamp {
  font-size: 11px;
  color: #666;
  margin-bottom: 6px;
}

.ai-summary-body h4 {
  margin: 8px 0 4px;
  font-size: 14px;
}
    
    /* Unified report tables (applies to all xlsx-rendered tables + TP table) */
.report-table{ width:100%; border-collapse:collapse; margin-bottom:2em; }
.report-table th, .report-table td{ border:1px solid #ccc; padding:8px; }
.report-table thead th{ background:#f5f5f5 !important; font-weight:700; } /* grey + bold */
.report-table tbody td{ font-weight:400; } /* body not bold */

    /* Overview (four charts side by side) */
    .overview {
      max-width: none;
      width: 100%;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 20px;
      align-items: start;
    }
    .heatmap-months { font-size: 12px; fill: #333; }
    .heatmap-dow { font-size: 12px; fill: #666; }
    .legend{
  display:flex;
  align-items:center;
  gap:6px;
  font-size:12px;
  color:#666;
  margin-top:10px;
  justify-content:flex-end; 
}
    .legend .box { width: 12px; height: 12px; border: 1px solid #ccd3d9; }

    /* Latest routes grid */
    .routes-wrap { margin-top: 0px; }
    .route-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px,1fr)); gap: 14px; max-width: none; width: 100%; }
    .route-card { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
    .route-title { font-size: 13px; color: #333; margin-bottom: 8px; }
    /* keep the old style for non-enhanced anchors only */
    .route-title a:not(.route-link) { color: inherit; text-decoration: none; }
    .route-title a:not(.route-link):hover { text-decoration: underline; }
    .route-meta { font-size: 12px; color: #666; margin-top: 6px; }
    .route-map { width: 100%; height: clamp(180px, 20vw, 320px); border: 1px solid #aaa; border-radius: 6px; }

    /* Make "Test activity overview" same size as "Latest routes" */
    #title-overview { font-size: 1.5em; }

    /* Remove the line under "Latest routes" only */
    .routes-wrap > h2{ border-bottom: none !important; padding-bottom: 0; }
    /* Remove the line under "Mileage per country" */
    .eu-mileage-wrap > h2 { border-bottom: none !important; padding-bottom: 0; }

    /* --- Link-stylish treatment for Latest routes title links --- */
    :root{ --accent:#1f3de3; }
    .route-link{
      display:inline-flex; align-items:center; gap:8px;
      color:var(--accent); font-weight:700; text-decoration:none;
    }
    .route-link .u{
      background-image: linear-gradient(currentColor,currentColor);
      background-repeat: no-repeat;
      background-size: 100% 2px;
      background-position: 0 100%;
      text-underline-offset: 4px;
      padding-bottom: 2px;
    }
    .route-link::after{
      content:"›"; font-size:1.05em; opacity:.6;
      transform: translateX(0);
      transition: transform .18s ease, opacity .18s ease;
    }
    .route-link:hover, .route-link:focus{ color:#1430c9; }
    .route-link:hover::after, .route-link:focus::after{ transform: translateX(3px); opacity:1; }
    .route-link:focus-visible{ outline:2px solid var(--accent); outline-offset:2px; border-radius:4px; }
    .route-link{ color:#000 !important; text-decoration:none !important; }
    .route-link .u{ background-image:none !important; padding-bottom:0; }
    .route-link:hover, .route-link:focus{ color:#000; text-decoration:none; }
    .route-title a.route-link:hover{ text-decoration:none; }

    .route-overlay .route-link{ color:#000; text-shadow:none; }
    .route-overlay .route-link .u{ background-image:none; }

    .route-link:focus-visible{ outline:2px solid #000; outline-offset:2px; border-radius:4px; }
    .route-title a.route-link:hover{ text-decoration:none; }

    /* ===== Typing indicator for titles ===== */
    .title-thinking { display:inline-flex; align-items:center; gap:6px; }
    .title-thinking .dots { display:inline-flex; gap:4px; }
    .title-thinking .dot {
      width:6px; height:6px; border-radius:50%;
      background:#888; opacity:.25;
      animation:titleBlink 1.2s infinite both;
    }
    .title-thinking .dot:nth-child(2){ animation-delay:.2s; }
    .title-thinking .dot:nth-child(3){ animation-delay:.4s; }
    @keyframes titleBlink {
      0%, 80%, 100% { opacity:.25; }
      40% { opacity:1; }
    }

    /* ===== Make chart SVGs scale to container width ===== */
    #heatmap-host svg,
    #country-host svg,
    #temp-host svg,
    #weather-host svg {
      width: 100%;
      height: auto;
      display: block;
    }

/* === Global loading status bar === */
.loading-status{
  background:#ffffff;
  color: #000000;
  border:1px solid #000000;
  padding:8px 12px;
  border-radius:6px;
  margin-bottom:12px;
  font-size:13px;
  display:flex;
  flex-direction:column;
  gap:6px;
  max-width:520px;
  box-shadow:0 1px 2px rgba(0,0,0,.04);
}
.loading-status.hidden{
  display:none;
}
.loading-text{
  font-weight:500;
  color:#8c6b00;
}
.loading-bar-wrap{
  width:100%;
  height:6px;
  border-radius:999px;
  background:#f5f5f5;
  overflow:hidden;
}
.loading-bar{
  height:100%;
  width:0;
  border-radius:999px;
  background:linear-gradient(90deg,#faad14,#52c41a);
  transition:width .25s ease;
}

/* Progress bar container */
.loading-status {
  background: #fff;          /* white background */
  color: #000;               /* black text */
  border: 1px solid #000;    /* black border */
}

/* Text inside the progress bar */
.loading-text {
  color: #000;               /* make sure message text is black */
}

/* The filled part of the bar – make it solid blue */
.loading-bar-fill,
#loading-fill {
  background: #007bff;       /* solid blue bar */
  /* remove gradients if you had them before */
  background-image: none;
}
    
 /* KPI badge (uses same s1..s10 colors as score boxes) */
.kpi-badge{
  display:inline-flex; align-items:center; justify-content:center;
  padding:1px 6px;              /* was 2px 8px */
  margin-left:6px;              /* was 8px */
  border-radius:999px;
  font-size:10px;               /* was 11px */
  line-height:1;                /* tighter box */
  font-weight:700;
  border:1px solid rgba(0,0,0,.15);
  vertical-align:middle;        /* nicer alignment next to text */
}

    /* === Active badge for live sessions === */
.active-badge{
  display:inline-flex; align-items:center; justify-content:center;
  padding:2px 8px; margin-left:8px;
  background:#e01616; color:#fff; font-weight:700; font-size:11px;
  border-radius:999px; border:1px solid rgba(0,0,0,.15);
  animation: activeBlink 2s steps(2, end) infinite; /* 0.5 Hz (on/off every 1s) */
}
@keyframes activeBlink{
  0%{ opacity:1; }
  50%{ opacity:0; }
  100%{ opacity:1; }
}
/* Row for session title + badge */
.session-title-row{
  display:flex; align-items:center; justify-content:space-between; gap:8px;
}

    /* ===== EU Mileage Map styles (NEW) ===== */
    .eu-mileage-map{
      width: 100%;
      height: clamp(300px, 40vw, 560px);
      border: 1px solid #aaa;
      border-radius: 6px;
      margin-top: 8px;
    }
    /* white, bold numbers over red dots */
    .leaflet-tooltip.eu-mileage-label{
      background: transparent;
      border: none;
      box-shadow: none;
      color: #fff;
      font-weight: 800;
      text-shadow: 0 1px 2px rgba(0,0,0,.6);
      pointer-events: none;
    }

    /* Hide 1px seams between Leaflet raster tiles (Chrome/DPR ≠ 1) */
.eu-mileage-map .leaflet-tile {
  width: 257px !important;   /* default tile is 256px → overlap by 1px */
  height: 257px !important;
}

    /* === KPI scoring legend (below KPI table) === */
.score-legend{display:flex;align-items:stretch;border:1px solid #ccc;border-radius:6px;overflow:hidden;margin:10px 0 22px}
.score-box{flex:1;min-width:0;text-align:center;color:#fff;line-height:1.1;padding:6px 6px}
.score-box strong{display:block;font-size:14px}
.score-box small{display:block;font-size:11px;opacity:.95}
.score-th{display:block;font-size:10px;background:#f5f5f5;color:#000;border-top:1px solid #ddd;padding:3px 0}

/* colors 0..10 (0 = no function, 1..10 red → green) */
.s0{background:#808080}
.s1{background:#c30000}.s2{background:#d62828}.s3{background:#e05d00}.s4{background:#ef8e00}.s5{background:#f4b400}
.s6{background:#ffe24a;color:#111}.s7{background:#b8df4a}.s8{background:#33a653}.s9{background:#0f9d8c}.s10{background:#216e39}

.kpi-avg{margin:8px 0 16px;font-size:13px;color:#222}
.kpi-avg .v{font-weight:700}

    /* highlight the selected score box + small caption */
.score-box.sel{ outline:3px solid rgba(0,0,0,.7); box-shadow: inset 0 0 0 2px rgba(255,255,255,.4); }
.score-legend-caption{ margin:6px 0 16px; font-size:12px; color:#333; }
/* Only the selected score box has black text + black frame */
.score-legend .score-box:not(.sel){ color:#fff; }                /* all others: white text */
.score-legend .score-box.sel{ color:#000 !important; }           /* selected: black text */
.score-legend .score-box.sel{ outline:3px solid #000; box-shadow: inset 0 0 0 2px rgba(255,255,255,.4); }   
/* Let outer frame be visible */
.score-legend{ overflow: visible !important; }

/* Make non-selected boxes use white text (overrides .s6 default) */
.score-legend .score-box:not(.sel){ color:#fff !important; }

/* Selected box: black text + thick black frame (tune --sel-frame) */
:root{ --sel-frame: 2px; } /* <- adjust thickness here */
.score-legend .score-box.sel{
  color:#000 !important;
  position: relative;
  z-index: 1;
  /* inner frame is always visible; outer frame gives extra thickness if not clipped */
  box-shadow:
    inset 0 0 0 var(--sel-frame) #000,
    0 0 0 calc(var(--sel-frame) - 1px) #000;
}
    .kpi-avg{
  text-align:right;
  margin: 4px 0 10px;   /* tighter gap below the table */
  font-size:13px; color:#222;
}

/* Override loading bar style */
.loading-bar{
  background:#007bff !important;   /* solid blue */
  background-image:none !important;
}

/* Ensure text is black */
.loading-status{
  background:#ffffff;
  color:#000000;
  border:1px solid #000000;
}

.loading-text{
  color:#000000 !important;
}
  
/* ===== Extra vertical spacing between main sections ===== */

/* Space below "Latest routes" block */
.routes-wrap{
  margin-bottom: 40px !important;   /* tweak value to taste */
}

/* Space around "Test activity overview" */
#title-overview{
  margin-top: 40px !important;      /* gap above overview */
  margin-bottom: 24px !important;   /* gap below the H1 */
}

/* Slightly more space before the EU mileage map inside the overview */
.eu-mileage-wrap{
  margin-top: 32px !important;
}

/* A bit more vertical separation between rows inside the overview grid */
.overview{
  row-gap: 28px;                    /* vertical spacing between tiles */
}

/* === Mini progress overlay for Latest route maps === */
.route-map{ position: relative; }  /* needed for absolute overlay */

.mini-loading{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background: rgba(255,255,255,.92);
  border-radius:6px;
  z-index: 500; /* above tiles while loading */
}

.mini-loading .loading-status{
  margin:0;
  max-width: 240px;     /* smaller than global */
  width: calc(100% - 24px);
  box-shadow:0 1px 2px rgba(0,0,0,.08);
}

.mini-loading .loading-bar-wrap{ height:6px; }
.mini-loading .loading-text{ font-size:12px; }
    
/* Hide main overview stuff while the initial progress bar is active */
body.initial-loading #title-latest-routes,
body.initial-loading #title-overview,
body.initial-loading #title-eu-mileage,
body.initial-loading #overview {
  display: none;
}

/* ✅ ADD THIS CSS (somewhere in your <style>) */
.issue-mountain-wrap{
  width:100%;
  border:1px solid #ddd;
  border-radius:8px;
  padding:10px;
  margin:14px 0 22px;
  background:#fff;
}
.issue-mountain-title{
  font-size:13px;
  font-weight:700;
  margin:0 0 8px 0;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.issue-mountain-sub{
  font-size:12px;
  color:#666;
  font-weight:500;
}
.issue-mountain-svg{
  width:100%;
  height:auto;
  display:block;
}
.issue-mountain-tooltip{
  position:fixed;
  z-index:20000;
  pointer-events:none;
  background:#fff;
  border:1px solid #111;
  border-radius:6px;
  padding:8px 10px;
  font-size:12px;
  box-shadow:0 6px 18px rgba(0,0,0,.15);
  max-width:320px;
  display:none;
  color:#000;
}
.issue-mountain-tooltip .t{ font-weight:700; margin-bottom:4px; }
.issue-mountain-tooltip .r{ color:#333; }
.issue-mountain-legend{
  margin-top:8px;
  display:flex;
  gap:14px;
  flex-wrap:wrap;
  font-size:11px;
  color:#666;
}
.issue-mountain-legend .k{
  display:inline-flex;
  align-items:center;
  gap:6px;
}
.issue-mountain-legend .b{
  width:10px;height:10px;border:1px solid #bbb;border-radius:2px;
}   
  </style>
</head>
<body class="initial-loading">
  <div id="sidebar">
    <h2 style="padding:16px; margin:0; border-bottom:1px solid #ddd;">Test sessions</h2>
  </div>

<div id="content">
  <div id="loading-status" class="loading-status">
    <div id="loading-text" class="loading-text">Loading…</div>
    <div class="loading-bar-wrap">
      <div id="loading-bar"
           class="loading-bar"
           role="progressbar"
           aria-valuemin="0"
           aria-valuemax="100"
           aria-valuenow="0"></div>
    </div>
  </div>
  
  <!-- Latest routes FIRST -->
  <div class="routes-wrap" style="grid-column: 1 / -1;">
    <h2 id="title-latest-routes" data-title="Latest tests" data-loading="1" style="margin-top:0;">
      <span>Loading</span>
      <span class="title-thinking">
        <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
      </span>
    </h2>
    <div id="routes-grid" class="route-grid"></div>
  </div>

  <!-- Then Test activity overview -->
  <h1 id="title-overview" data-title="Test activity overview" data-loading="1" style="margin-top:24px;">
    <span>Loading</span>
    <span class="title-thinking">
      <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
    </span>
  </h1>

  <div id="overview" class="overview">
    <div><div id="heatmap-host"></div></div>
    <div><div id="country-host"></div></div>
    <div><div id="temp-host"></div></div>
    <div><div id="weather-host"></div></div>

    <!-- EU Mileage map still part of overview grid -->
    <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
      <h2 id="title-eu-mileage" data-title="Mileage per country" data-loading="1" style="margin-top:16px;">
        <span>Loading</span>
        <span class="title-thinking">
          <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
        </span>
      </h2>
      <div id="eu-mileage-map" class="eu-mileage-map"></div>
    </div>
  </div>
</div>

  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.0/jszip.min.js"></script>

  <script>
    // ---------- CONFIG ----------
    const ACCOUNT   = 'annotationcsv';
    const CONTAINER = 'csv';
    const SAS_TOKEN = 'sv=2024-11-04&ss=bfqt&srt=co&sp=rwdlacupiytfx&se=2026-12-31T14:25:22Z&st=2026-01-02T06:10:22Z&spr=https&sig=EYJzJkVswHh9jljAsy506gTIQ7fQMGuF6kJUCSIx%2BZQ%3D';    
    const BASE_URL  = `https://${ACCOUNT}.blob.core.windows.net/${CONTAINER}`;
    const MIN_KM_FOR_OVERVIEW = 1;
    const ACTIVE_WINDOW_MS = 10 * 60 * 1000; // 10 minutes

    // ---------- CACHES / HELPERS ----------
    const summaryCache = new Map(); // filename -> { mileageKm, issueCount, meanTempC, weatherAgg, loaded:true }
    const blobMeta = new Map();     // filename -> lastModifiedMs (strict sort)
    const countryCache = new Map(); // filename -> array of countries
    const fileToTestGroup = new Map();

    // Parse each workbook at most once per session

  // ===== PASSWORD GATE (client-side; not truly secure) =====

  // Hosts where we SKIP the password gate
  const TRUSTED_HOSTS = new Set([
    "172.19.84.72",
  ]);

  const isTrusted =
    TRUSTED_HOSTS.has(window.location.hostname) &&
    window.location.protocol === "http:"; // optional

  const APP_PASSWORD = "adasfleet"; // change to your own
  const SESSION_KEY = "annotator_viewer_ok";

  (function requirePasswordIfNeeded() {
    // ✅ skip on http://172.19.84.72:8080
    if (isTrusted) {
      sessionStorage.setItem(SESSION_KEY, "1");
      return;
    }

    // already authenticated this tab
    if (sessionStorage.getItem(SESSION_KEY) === "1") return;

    let ok = false;
    for (let tries = 0; tries < 3; tries++) {
      const input = prompt("Enter password to open Reports Viewer:");
      if (input === null) {
        document.body.innerHTML =
          '<h2 style="padding:20px;color:#900;">Access cancelled.</h2>';
        throw new Error("User cancelled password prompt");
      }
      if (input === APP_PASSWORD) {
        ok = true;
        break;
      }
      alert("Wrong password, try again.");
    }

    if (!ok) {
      document.body.innerHTML =
        '<h2 style="padding:20px;color:#900;">Access denied.</h2>';
      throw new Error("Access denied (wrong password)");
    }

    sessionStorage.setItem(SESSION_KEY, "1");
  })();
    
const workbookCache = new Map(); // filename -> Promise<{ wb, buf }>

// === Per-map mini loading overlay helpers ===
function showMiniMapLoading(mapDiv, message, percent){
  if (!mapDiv) return;

  let overlay = mapDiv.querySelector('.mini-loading');
  if (!overlay){
    overlay = document.createElement('div');
    overlay.className = 'mini-loading';
    overlay.innerHTML = `
      <div class="loading-status">
        <div class="loading-text">Loading…</div>
        <div class="loading-bar-wrap">
          <div class="loading-bar" role="progressbar" aria-valuemin="0" aria-valuemax="100"></div>
        </div>
      </div>`;
    mapDiv.appendChild(overlay);
  }

  const msgEl = overlay.querySelector('.loading-text');
  if (msgEl && message) msgEl.textContent = message;

  const barEl = overlay.querySelector('.loading-bar');
  if (barEl && typeof percent === 'number'){
    const clamped = Math.max(0, Math.min(100, percent));
    barEl.style.width = clamped + '%';
    barEl.setAttribute('aria-valuenow', String(Math.round(clamped)));
  }
}

function hideMiniMapLoading(mapDiv){
  const overlay = mapDiv?.querySelector('.mini-loading');
  if (overlay) overlay.remove();
}

function showMiniMapError(mapDiv, message){
  hideMiniMapLoading(mapDiv);
  if (!mapDiv) return;
  mapDiv.innerHTML = `<div style="padding:10px;font-size:12px;color:#666;">${escapeHtml(message || 'No data')}</div>`;
}
    
function endInitialLoading(){
  document.body.classList.remove('initial-loading');
}
    
function formatTimestampForLabel(d = new Date()) {
  const pad = n => String(n).padStart(2, '0');
  const yyyy = d.getFullYear();
  const mm   = pad(d.getMonth() + 1);
  const dd   = pad(d.getDate());
  const hh   = pad(d.getHours());
  const mi   = pad(d.getMinutes());
  return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
}
    
function loadWorkbook(filename) {
  if (workbookCache.has(filename)) return workbookCache.get(filename);

  const p = (async () => {
    // use nc() to add a timestamp → avoid stale HTTP cache
    const url = nc(`${BASE_URL}/${filename}?${SAS_TOKEN}`);
    const res = await fetch(url, { cache: 'no-store' });  // ← was 'default'
    const buf = await res.arrayBuffer();
    const wb  = XLSX.read(new Uint8Array(buf), { type:'array' });
    return { wb, buf };
  })();

  workbookCache.set(filename, p);
  return p;
}

    function cssSafeId(s){ return String(s).replace(/[^a-zA-Z0-9_-]/g,'_'); }
    function toDateOnly(d){ const t = new Date(d); t.setHours(0,0,0,0); return t; }

function escapeHtml(str){
  return String(str)
    .replace(/&/g,'&amp;')
    .replace(/</g,'&lt;')
    .replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;')
    .replace(/'/g,'&#39;');
}
    
// Map OSM highway types → 5 categories:
// Highway, Country road, City road, Construction, Unclassified
function classifyRoadType(osmType) {
  const t = String(osmType || '').toLowerCase();

  // High-speed roads
  if (
    t === 'motorway'      || t === 'motorway_link' ||
    t === 'trunk'         || t === 'trunk_link'
  ) {
    return 'Highway';
  }

  // City / urban roads
  if (
    t === 'residential'   || t === 'living_street' ||
    t === 'service'       || t === 'track'
  ) {
    return 'City road';
  }

  // Explicit separate buckets
  if (t === 'construction') return 'Construction';
  if (t === 'unclassified') return 'Unclassified';

  // Everything else: treat as "Country road"
  // (primary / secondary / tertiary / *_link / etc.)
  return 'Country road';
}

/* ✅ ADD THESE HELPERS (place near your other helpers, e.g. below escapeHtml / classifyRoadType) */

function parseLooseNumber(v){
  if (v == null) return null;
  const s = String(v).trim();
  if (!s) return null;
  const m = s.replace(',', '.').match(/-?\d+(?:\.\d+)?/);
  if (!m) return null;
  const n = parseFloat(m[0]);
  return Number.isFinite(n) ? n : null;
}

function parseDistanceKmFromCell(v){
  if (v == null) return null;
  const s = String(v).trim();
  if (!s) return null;
  // supports "12.3", "12,3", "12.3 km", "12345 m"
  const num = parseLooseNumber(s);
  if (num == null) return null;
  if (/\bm\b/i.test(s) && !/\bkm\b/i.test(s)) return num / 1000;
  return num; // assume km
}

function parseTimeToMs(v){
  if (v == null) return null;

  // If it's already a number, it could be an Excel serial or seconds/ms
  if (typeof v === 'number' && Number.isFinite(v)){
    // Heuristic:
    // - Excel serial date ~ 45000
    // - seconds ~ 0..200000
    // - ms epoch ~ 1e12+
    if (v > 1e12) return Math.round(v);
    if (v > 30000 && v < 70000){
      // Excel serial date (days since 1899-12-30)
      const ms = (v - 25569) * 86400 * 1000; // 25569 days between 1899-12-30 and 1970-01-01
      return Math.round(ms);
    }
    if (v > 0 && v < 300000){
      // treat as seconds
      return Math.round(v * 1000);
    }
    return null;
  }

  const s = String(v).trim();
  if (!s) return null;

  // ISO-ish parse
  const d = Date.parse(s);
  if (Number.isFinite(d)) return d;

  // "HH:MM:SS" -> treat as relative time (ms from 00:00)
  const m = s.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?$/);
  if (m){
    const hh = parseInt(m[1],10);
    const mm = parseInt(m[2],10);
    const ss = m[3] ? parseInt(m[3],10) : 0;
    return ((hh*3600 + mm*60 + ss) * 1000);
  }

  return null;
}

function normCat(v){
  const s = String(v ?? '').trim();
  return s ? s : null;
}

function roadCatFromCell(v){
  const s = String(v ?? '').trim();
  if (!s) return null;

  // If already categorized:
  const low = s.toLowerCase();
  if (low.includes('highway') || low === 'motorway' || low === 'trunk') return 'Highway';
  if (low.includes('city') || low.includes('urban') || low === 'residential') return 'City';
  if (low.includes('country')) return 'Country';

  // Otherwise interpret as OSM highway type and classify
  const cat = classifyRoadType(s); // your existing function
  if (!cat) return null;

  if (cat === 'Highway') return 'Highway';
  if (cat === 'City road') return 'City';
  // everything else -> Country (as requested)
  return 'Country';
}

function pickMostCommon(arr){
  const m = new Map();
  for (const v of arr){
    if (!v) continue;
    m.set(v, (m.get(v)||0)+1);
  }
  let best = null, bestN = -1;
  for (const [k,n] of m.entries()){
    if (n > bestN){ bestN = n; best = k; }
  }
  return best;
}

function issueMountainColorForRoad(cat){
  // simple, readable mapping
  if (cat === 'Highway') return '#111';
  if (cat === 'Country') return '#555';
  if (cat === 'City')    return '#888';
  return '#bbb';
}

function issueMountainColorForPhase(cat){
  if (!cat) return '#ddd';
  const s = cat.toLowerCase();
  if (s.includes('baseline')) return '#111';
  if (s.includes('test')) return '#444';
  if (s.includes('validation')) return '#666';
  return '#888';
}

function issueMountainColorForWeather(cat){
  if (!cat) return '#ddd';
  const s = cat.toLowerCase();
  if (s.includes('rain')) return '#222';
  if (s.includes('snow')) return '#444';
  if (s.includes('fog')) return '#666';
  if (s.includes('cloud')) return '#777';
  if (s.includes('clear') || s.includes('sun')) return '#999';
  return '#888';
}

function issueMountainGrayForTime(ms, minMs, maxMs){
  if (ms == null || minMs == null || maxMs == null || maxMs <= minMs) return '#ddd';
  const t = (ms - minMs) / (maxMs - minMs);
  const clamped = Math.max(0, Math.min(1, t));
  // 10%..90% gray
  const L = 10 + clamped * 80;
  return `hsl(0 0% ${L}%)`;
}

/**
 * data: [{distKm, timeMs, phase, weather, roadCat}]
 * Renders:
 * - Mountain = issue histogram along Distance
 * - Below bars: Time, Phase, Weather, Road
 */
function renderIssueMountain(data, hostId){
  const host = document.getElementById(hostId);
  if (!host) return;

  host.innerHTML = '';

  const clean = (data || [])
    .filter(d => Number.isFinite(d.distKm))
    .sort((a,b) => a.distKm - b.distKm);

  if (!clean.length){
    host.innerHTML = `<div style="color:#666;font-size:12px;">No distance-tagged issues found (cannot build Issue mountain).</div>`;
    return;
  }

  const maxDist = clean[clean.length-1].distKm;
  const minDist = clean[0].distKm;

  const BIN_COUNT = Math.max(40, Math.min(180, Math.round(maxDist * 2))); // heuristic: ~2 bins per km, clamped
  const binW = (maxDist - minDist) / BIN_COUNT || 1;

  const bins = Array.from({length: BIN_COUNT}, (_,i)=>({
    x0: minDist + i*binW,
    x1: minDist + (i+1)*binW,
    n: 0,
    times: [],
    phases: [],
    weathers: [],
    roads: []
  }));

  for (const d of clean){
    const i = Math.max(0, Math.min(BIN_COUNT-1, Math.floor((d.distKm - minDist) / binW)));
    const b = bins[i];
    b.n++;
    if (d.timeMs != null) b.times.push(d.timeMs);
    if (d.phase) b.phases.push(d.phase);
    if (d.weather) b.weathers.push(d.weather);
    if (d.roadCat) b.roads.push(d.roadCat);
  }

  const maxN = Math.max(1, ...bins.map(b=>b.n));
  const timeAll = clean.map(d=>d.timeMs).filter(v=>v!=null);
  const minMs = timeAll.length ? Math.min(...timeAll) : null;
  const maxMs = timeAll.length ? Math.max(...timeAll) : null;

  // Layout
  const W = 1000;                // viewBox width
  const padL = 60;
  const padR = 20;
  const mountainH = 140;
  const barH = 18;
  const barGap = 6;
  const labelW = 56;
  const bars = [
    { key:'time',    label:'Time',    colorFn:(b)=>issueMountainGrayForTime(b.tMid, minMs, maxMs) },
    { key:'phase',   label:'Phase',   colorFn:(b)=>issueMountainColorForPhase(b.phase) },
    { key:'weather', label:'Weather', colorFn:(b)=>issueMountainColorForWeather(b.weather) },
    { key:'road',    label:'Road',    colorFn:(b)=>issueMountainColorForRoad(b.road) },
  ];

  // Precompute per-bin category picks
  for (const b of bins){
    const tMid = b.times.length ? Math.round(b.times.reduce((a,c)=>a+c,0)/b.times.length) : null;
    b.tMid = tMid;
    b.phase = pickMostCommon(b.phases);
    b.weather = pickMostCommon(b.weathers);
    b.road = pickMostCommon(b.roads);
  }

  const xScale = (distKm) => {
    const f = (distKm - minDist) / (maxDist - minDist || 1);
    return padL + f * (W - padL - padR);
  };
  const yBase = 20 + mountainH;
  const yScale = (n) => {
    const f = n / maxN;
    return yBase - f * mountainH;
  };

  const H = yBase + 20 + bars.length*(barH+barGap) + 28;

  // Build wrapper
  const wrap = document.createElement('div');
  wrap.className = 'issue-mountain-wrap';

  const title = document.createElement('div');
  title.className = 'issue-mountain-title';
  title.innerHTML = `
    <span>Issue mountain</span>
    <span class="issue-mountain-sub">Distance: ${minDist.toFixed(1)} → ${maxDist.toFixed(1)} km · Issues: ${clean.length} · Bins: ${BIN_COUNT}</span>
  `;
  wrap.appendChild(title);

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.classList.add('issue-mountain-svg');
  svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
  svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

  // Mountain area path
  let dPath = `M ${xScale(minDist)} ${yBase} `;
  for (const b of bins){
    const xc = xScale((b.x0+b.x1)/2);
    dPath += `L ${xc} ${yScale(b.n)} `;
  }
  dPath += `L ${xScale(maxDist)} ${yBase} Z`;

  const area = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  area.setAttribute('d', dPath);
  area.setAttribute('fill', '#ddd');
  area.setAttribute('stroke', '#000');
  area.setAttribute('stroke-width', '2');
  svg.appendChild(area);

  // X axis line
  const axis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
  axis.setAttribute('x1', padL);
  axis.setAttribute('x2', W - padR);
  axis.setAttribute('y1', yBase);
  axis.setAttribute('y2', yBase);
  axis.setAttribute('stroke', '#000');
  axis.setAttribute('stroke-width', '2');
  svg.appendChild(axis);

  // X ticks (nice ~10)
  const tickN = 10;
  for (let i = 0; i <= tickN; i++){
    const dist = minDist + (i/tickN) * (maxDist - minDist);
    const x = xScale(dist);

    const t = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    t.setAttribute('x1', x); t.setAttribute('x2', x);
    t.setAttribute('y1', yBase); t.setAttribute('y2', yBase + 6);
    t.setAttribute('stroke', '#000');
    t.setAttribute('stroke-width', '1');
    svg.appendChild(t);

    const lbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    lbl.textContent = dist.toFixed(1);
    lbl.setAttribute('x', x);
    lbl.setAttribute('y', yBase + 20);
    lbl.setAttribute('font-size', '11');
    lbl.setAttribute('text-anchor', 'middle');
    lbl.setAttribute('fill', '#000');
    svg.appendChild(lbl);
  }

  const xLbl = document.createElementNS('http://www.w3.org/2000/svg', 'text');
  xLbl.textContent = 'Distance (km)';
  xLbl.setAttribute('x', (padL + (W - padR)) / 2);
  xLbl.setAttribute('y', yBase + 36);
  xLbl.setAttribute('font-size', '12');
  xLbl.setAttribute('text-anchor', 'middle');
  xLbl.setAttribute('fill', '#000');
  svg.appendChild(xLbl);

  // Bars (Time, Phase, Weather, Road)
  const barsTop = yBase + 50;

  function addRowLabel(y, txt){
    const lb = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    lb.textContent = txt;
    lb.setAttribute('x', 8);
    lb.setAttribute('y', y + barH - 4);
    lb.setAttribute('font-size','12');
    lb.setAttribute('fill','#000');
    svg.appendChild(lb);
  }

  // tooltip
  let tip = document.getElementById('issue-mountain-tooltip');
  if (!tip){
    tip = document.createElement('div');
    tip.id = 'issue-mountain-tooltip';
    tip.className = 'issue-mountain-tooltip';
    document.body.appendChild(tip);
  }
  const showTip = (html, ev) => {
    tip.innerHTML = html;
    tip.style.display = 'block';
    const x = ev.clientX + 12;
    const y = ev.clientY + 12;
    tip.style.left = x + 'px';
    tip.style.top  = y + 'px';
  };
  const hideTip = () => { tip.style.display = 'none'; };

  for (let r = 0; r < bars.length; r++){
    const rowY = barsTop + r*(barH+barGap);
    addRowLabel(rowY, bars[r].label);

    for (let i = 0; i < bins.length; i++){
      const b = bins[i];
      const x0 = xScale(b.x0);
      const x1 = xScale(b.x1);
      const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      rect.setAttribute('x', x0);
      rect.setAttribute('y', rowY);
      rect.setAttribute('width', Math.max(0.5, x1-x0));
      rect.setAttribute('height', barH);
      rect.setAttribute('fill', bars[r].colorFn(b));
      rect.setAttribute('stroke', '#000');
      rect.setAttribute('stroke-width', '0.5');
      rect.setAttribute('opacity', '0.95');

      rect.addEventListener('mousemove', (ev) => {
        const dist0 = b.x0.toFixed(2);
        const dist1 = b.x1.toFixed(2);
        const timeTxt = (b.tMid != null && minMs != null && maxMs != null && maxMs > 1e10)
          ? new Date(b.tMid).toLocaleString()
          : (b.tMid != null ? `${Math.round(b.tMid/1000)} s` : '–');

        const html = `
          <div class="t">${dist0}–${dist1} km</div>
          <div class="r"><strong>Issues:</strong> ${b.n} (bin max ${maxN})</div>
          <div class="r"><strong>Time:</strong> ${escapeHtml(timeTxt)}</div>
          <div class="r"><strong>Phase:</strong> ${escapeHtml(b.phase || '–')}</div>
          <div class="r"><strong>Weather:</strong> ${escapeHtml(b.weather || '–')}</div>
          <div class="r"><strong>Road:</strong> ${escapeHtml(b.road || '–')}</div>
        `;
        showTip(html, ev);
      });
      rect.addEventListener('mouseleave', hideTip);

      svg.appendChild(rect);
    }
  }

  // Invisible hover strips over the mountain itself (for count tooltip)
  for (let i = 0; i < bins.length; i++){
    const b = bins[i];
    const x0 = xScale(b.x0);
    const x1 = xScale(b.x1);
    const h = (yBase - yScale(b.n));
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', x0);
    rect.setAttribute('y', yScale(b.n));
    rect.setAttribute('width', Math.max(0.5, x1-x0));
    rect.setAttribute('height', Math.max(2, h));
    rect.setAttribute('fill', 'transparent');

    rect.addEventListener('mousemove', (ev) => {
      const html = `
        <div class="t">${b.x0.toFixed(2)}–${b.x1.toFixed(2)} km</div>
        <div class="r"><strong>Issues in bin:</strong> ${b.n}</div>
      `;
      showTip(html, ev);
    });
    rect.addEventListener('mouseleave', hideTip);
    svg.appendChild(rect);
  }

  wrap.appendChild(svg);

  // Simple legends
  const leg = document.createElement('div');
  leg.className = 'issue-mountain-legend';
  leg.innerHTML = `
    <span class="k"><span class="b" style="background:#ddd;"></span>Issue density (higher = more issues)</span>
    <span class="k"><span class="b" style="background:${issueMountainColorForRoad('Highway')};"></span>Road: Highway</span>
    <span class="k"><span class="b" style="background:${issueMountainColorForRoad('Country')};"></span>Road: Country</span>
    <span class="k"><span class="b" style="background:${issueMountainColorForRoad('City')};"></span>Road: City</span>
  `;
  wrap.appendChild(leg);

  host.appendChild(wrap);
}

/* ✅ END helpers */
   
    
// Append a timestamp so each request URL is unique → bypasses caches.
function nc(url){
  return url + (url.includes('?') ? '&' : '?') + 'ts=' + Date.now();
}

    function haversine(lat1, lon1, lat2, lon2) {
      const toRad = d => d * Math.PI / 180;
      const R = 6371000;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    /* Title loading indicator helper (uses data-title, default "Loading") */
    function setTitleLoading(el, on, labelText = 'Loading') {
      if (!el) return;
      if (on) {
        if (el.dataset.loading === '1') return; // already loading
        el.dataset.loading = '1';
        el.dataset.originalText = el.dataset.title || el.textContent;
        el.innerHTML = `
          <span>${labelText}</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>`;
      } else {
        if (el.dataset.loading !== '1') return;
        const txt = el.dataset.title || el.dataset.originalText || el.textContent;
        el.textContent = txt;
        delete el.dataset.loading;
        delete el.dataset.originalText;
      }
    }

// === Global loading progress bar helpers ===
function setGlobalLoading(message, percent){
  const box = document.getElementById('loading-status');
  if (!box) return;
  box.classList.remove('hidden');

  const msgEl = document.getElementById('loading-text');
  if (msgEl && message) {
    msgEl.textContent = message;
  }

  const barEl = document.getElementById('loading-bar');
  if (barEl && typeof percent === 'number') {
    const clamped = Math.max(0, Math.min(100, percent));
    barEl.style.width = clamped + '%';
    barEl.setAttribute('aria-valuenow', String(Math.round(clamped)));
  }
}

function hideGlobalLoading(){
  const box = document.getElementById('loading-status');
  if (!box) return;
  box.classList.add('hidden');
}

// --- Simple stateful progress helpers for the "reading sessions" phase ---
let globalProgressTotalFiles = 0;

function initGlobalProgress(totalFiles) {
  globalProgressTotalFiles = totalFiles || 0;
  if (globalProgressTotalFiles > 0) {
    // start at 0%
    setGlobalLoading(
      `Reading 0 of ${globalProgressTotalFiles} sessions…`,
      0
    );
  }
}

function updateGlobalProgress(doneCount) {
  if (!globalProgressTotalFiles) return;

  const safeDone = Math.min(doneCount, globalProgressTotalFiles);
  const pct = (safeDone / globalProgressTotalFiles) * 100;  // 88/88 = 100%

  setGlobalLoading(
    `Reading session ${safeDone} of ${globalProgressTotalFiles}…`,
    pct
  );
}
    
    function computeMileageAndPathFromSampling(sheet) {
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (rows.length < 3) return { km: null, path: [] };

      const headers = rows[0].map(h => String(h ?? '').toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return { km: null, path: [] };

      let km = 0, prev = null;
      const path = [];
      for (let i = 1; i < rows.length; i++) {
        const lat = parseFloat(rows[i][latIdx]);
        const lon = parseFloat(rows[i][lonIdx]);
        if (isNaN(lat) || isNaN(lon)) continue;
        path.push([lat, lon]);
        if (prev) km += haversine(prev[0], prev[1], lat, lon) / 1000;
        prev = [lat, lon];
      }
      return { km: Math.round(km), path };
    }

    // --- Mean Temp + Mode Weather from the "Issue/Issues" sheet ---
    function computeTempWeatherFromIssuesSheet(sheet){
      const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
      if (rows.length < 2) return { meanTempC: null, weatherAgg: null };

      const headers = rows[0].map(h => String(h ?? '').trim().toLowerCase());
      const tempIdx = headers.findIndex(h => /\btemp\b/.test(h) || /temperature/.test(h));
      const wxIdx   = headers.findIndex(h => /weather/.test(h) || /condition/.test(h));

      const temps = [];
      const wxCounts = new Map();

      const normWx = (s)=>{
        if (s == null) return null;
        const v = String(s).trim().toLowerCase();
        if (!v) return null;
        if (/thunder|storm/.test(v)) return 'Storm';
        if (/snow|blizzard|sleet/.test(v)) return 'Snow';
        if (/rain|drizzle|shower/.test(v)) return 'Rain';
        if (/fog|mist|haze/.test(v)) return 'Fog';
        if (/cloud|overcast/.test(v)) return 'Cloudy';
        if (/clear|sun/.test(v)) return 'Clear';
        if (/wind/.test(v)) return 'Wind';
        return v.charAt(0).toUpperCase() + v.slice(1);
      };

      const parseTempFromValue = (val) => {
        if (val == null) return null;
        const s = String(val).trim();
        if (!s) return null;
        let m = s.match(/(-?\d+(?:[.,]\d+)?)\s*°?\s*c\b/i);
        if (!m) m = s.match(/temp(?:erature)?[^0-9\-]*(-?\d+(?:[.,]\d+)?)/i);
        if (!m) return null;
        const num = parseFloat(m[1].replace(',', '.'));
        return Number.isFinite(num) ? num : null;
      };

      for (let r = 1; r < rows.length; r++){
        const row = rows[r];
        if (tempIdx >= 0){
          const t = parseTempFromValue(row[tempIdx]);
          if (t != null) temps.push(t);
        } else {
          for (let c = 0; c < row.length; c++){
            const t = parseTempFromValue(row[c]);
            if (t != null){ temps.push(t); break; }
          }
        }

        if (wxIdx >= 0){
          const w = normWx(row[wxIdx]);
          if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
        } else {
          for (let c = 0; c < row.length; c++){
            const cell = row[c];
            if (cell == null) continue;
            const m = String(cell).match(/weather\s*:\s*([a-z][a-z\s\-]+)/i);
            if (m){
              const w = normWx(m[1]);
              if (w) wxCounts.set(w, (wxCounts.get(w)||0) + 1);
              break;
            }
          }
        }
      }

      const meanTempC = temps.length
        ? Math.round((temps.reduce((a,b)=>a+b,0) / temps.length) * 10) / 10
        : null;

      let weatherAgg = null;
      if (wxCounts.size){
        weatherAgg = Array.from(wxCounts.entries()).sort((a,b)=> b[1] - a[1])[0][0];
      }

      return { meanTempC, weatherAgg };
    }

    function computeTempWeatherFromIssues(wb){
      const issueSheets = wb.SheetNames.filter(n => /issue/i.test(n));
      for (const name of issueSheets){
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      for (const name of wb.SheetNames){
        if (name.toLowerCase() === 'sampling') continue;
        const res = computeTempWeatherFromIssuesSheet(wb.Sheets[name]);
        if (res.meanTempC != null || res.weatherAgg != null) return res;
      }
      return { meanTempC: null, weatherAgg: null };
    }

    function countIssuesFromWorkbook(wb) {
      const norm = s => String(s||'').toLowerCase().replace(/\s+/g,'');
      for (const name of wb.SheetNames) {
        if (name.toLowerCase() === 'sampling') continue;
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[name], { header: 1 });
        if (rows.length < 2) continue;
        const hdrs = rows[0].map(norm);
        const latIdx = hdrs.findIndex(h => h.includes('lat'));
        const lonIdx = hdrs.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
        if (latIdx < 0 || lonIdx < 0) continue;
        let count = 0;
        for (let i = 1; i < rows.length; i++) {
          const lat = parseFloat(rows[i][latIdx]);
          const lon = parseFloat(rows[i][lonIdx]);
          if (!isNaN(lat) && !isNaN(lon)) count++;
        }
        if (count > 0) return count;
      }
      return 0;
    }
    
    // Reads "Statistics" sheet → row/col labeled "Total test distance" (e.g. "518.6 km")
function extractTotalDistanceKmFromStatistics(wb){
  const sheetName = wb.SheetNames.find(n => /statistics/i.test(n));
  if (!sheetName) return null;

  const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1, blankrows: false });
  if (!rows || !rows.length) return null;

  const norm = v => String(v ?? '').trim();
  const isLabel = v => /total\s*test\s*distance/i.test(String(v ?? ''));

  const parseKm = v => {
    if (v == null) return null;
    const s = norm(v);
    if (!s) return null;
    // match "518.6 km" or "518,6 km" or plain number
    let m = s.match(/(-?\d+(?:[.,]\d+)?)\s*km\b/i);
    if (!m) m = s.match(/-?\d+(?:[.,]\d+)?/);
    if (!m) return null;
    const val = parseFloat(m[0].replace(',', '.'));
    return Number.isFinite(val) ? Math.round(val) : null; // keep km as integer like before
  };

  // Try common key→value patterns
  for (let r = 0; r < rows.length; r++){
    const row = rows[r];
    for (let c = 0; c < row.length; c++){
      if (isLabel(row[c])){
        // prefer right cell, else cell below
        const right = (c + 1 < row.length) ? row[c+1] : null;
        const down  = (rows[r+1]?.[c]);
        const fromRight = parseKm(right);
        if (fromRight != null) return fromRight;
        const fromDown  = parseKm(down);
        if (fromDown  != null) return fromDown;
      }
    }
  }

  // Fallback: scan entire sheet for a lone "518.6 km"
  for (let r = 0; r < rows.length; r++){
    for (let c = 0; c < rows[r].length; c++){
      const km = parseKm(rows[r][c]);
      if (km != null) return km;
    }
  }
  return null;
}

// Extract [lat, lon] points from the first non-Sampling sheet that has lat/lon
function extractIssueCoordsFast(wb){
  const out = [];
  const isOK = (lat, lon) =>
    Number.isFinite(lat) && Number.isFinite(lon) &&
    lat >= -90 && lat <= 90 && lon >= -180 && lon <= 180;

  for (const name of wb.SheetNames){
    if (name.toLowerCase() === 'sampling') continue;

    const rows = XLSX.utils.sheet_to_json(wb.Sheets[name], { header: 1, blankrows: false });
    if (rows.length < 2) continue;

    const hdrs = rows[0].map(h => String(h ?? '').toLowerCase());
    const latIdx = hdrs.findIndex(h => h.includes('lat'));
    const lonIdx = hdrs.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
    if (latIdx < 0 || lonIdx < 0) continue;

    for (let r = 1; r < rows.length; r++){
      const lat = parseFloat(rows[r][latIdx]);
      const lon = parseFloat(rows[r][lonIdx]);
      if (isOK(lat, lon)) out.push([lat, lon]);
    }
    break; // first sheet with coords is enough
  }
  return out;
}
    
// Uses loadWorkbook(filename) → Promise<{ wb, buf }>
async function fetchSessionSummary(filename) {
  if (summaryCache.has(filename)) return summaryCache.get(filename);

  const { wb } = await loadWorkbook(filename);

  // 1) Mileage (Statistics preferred, Sampling fallback)
  let mileageKm = extractTotalDistanceKmFromStatistics(wb);
  if (mileageKm == null) {
    const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
    if (samplingName) {
      const { km } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
      mileageKm = km;
    }
  }

  // 2) Temp/Weather + issue count
  const { meanTempC, weatherAgg } = computeTempWeatherFromIssues(wb);
  const issueCount = countIssuesFromWorkbook(wb);

  // 3) Test details
  let testObject = null, testPurpose = null;
  let adcuSoftware = null, participants = null;
  try {
    const details = extractTestDetails(wb);

    // Keys are all lowercased by extractTestDetails
    testObject  = details['test object'] || details['object'] || details['vehicle'] || null;
    testPurpose = details['purpose'] || details['test purpose'] || null;

    // ADCU software variants
    adcuSoftware =
      details['adcu software'] ||
      details['adcu sw'] ||
      details['adcu sw version'] ||
      details['ecu software'] ||
      null;

    // Participants / Participant
    participants =
      details['participants'] ||
      details['participant'] ||
      null;
  } catch {}
  
  // 4) Additional comment (used for test grouping)
  let additionalComment = null;
  try {
    additionalComment = extractAdditionalComment(wb) || null;
  } catch (e) {
    // ignore errors from extractAdditionalComment
  }

  // 4) KPI score (sum column / total KPIs → 1 decimal → scoreFromRate)
  let kpiScore = null, kpiAvgPer1k = null;

  try {
    const totalKpis = await getTotalKpis();
    if (typeof totalKpis === 'number' && totalKpis > 0) {
      const kpiSheetName = wb.SheetNames.find(n => /kpi/i.test(n));
      if (kpiSheetName && typeof extractAvgEventsPer1kFromSheet === 'function') {
        // NOTE: your extractAvgEventsPer1kFromSheet returns the SUM (by design)
        const sum = extractAvgEventsPer1kFromSheet(wb.Sheets[kpiSheetName]);
        if (sum != null) {
          const avg = sum / totalKpis;
          kpiAvgPer1k = Math.round(avg * 10) / 10;   // 1 decimal
          kpiScore    = scoreFromRate(kpiAvgPer1k);  // 1..10
        }
      }
    }
  } catch {}

  const summary = {
    mileageKm, issueCount, meanTempC, weatherAgg,
    testObject, testPurpose,
    adcuSoftware, participants,
    kpiScore, kpiAvgPer1k,
    additionalComment,
    loaded: true
  };

  summaryCache.set(filename, summary);
  return summary;
}

    // Read "Test details" sheet (col1=label, col2=value) → map
function extractTestDetails(wb){
  const details = {};
  const sheetName = wb.SheetNames.find(n => /test\s*details/i.test(n));
  if (!sheetName) return details;

  const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1, blankrows: false });
  for (let r = 0; r < rows.length; r++) {
    const row = rows[r];
    if (!row || row.length < 2) continue;
    const keyRaw = row[0];
    const valRaw = row[1];
    if (keyRaw == null || valRaw == null) continue;
    const key = String(keyRaw).trim().toLowerCase();
    const val = String(valRaw).trim();
    if (!key || !val) continue;
    details[key] = val;
  }
  return details;
}

// Read "Additional comment" from Test details sheet.
// Returns the last non-empty value whose label starts with "Additional comment".
function extractAdditionalComment(wb){
  const sheetName = wb.SheetNames.find(n => /test\s*details/i.test(n));
  if (!sheetName) return null;

  const rows = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], {
    header: 1,
    blankrows: false
  });
  if (!rows || !rows.length) return null;

  let latest = null;
  for (let r = 0; r < rows.length; r++){
    const row = rows[r];
    if (!row || row.length < 2) continue;
    const label = String(row[0] ?? '').trim().toLowerCase();
    const val   = String(row[1] ?? '').trim();
    if (!label || !val) continue;

    // Matches both "Additional comment" and "Additional comment (2026-01-07 ...)"
    if (label === 'additional comment' || label.startsWith('additional comment')) {
      latest = val;   // keep last seen
    }
  }
  return latest;
}
    
function rerenderTestDetailsTable(wb) {
  // Find the Test details sheet
  const sheetName = wb.SheetNames.find(n => /test\s*details/i.test(n));
  if (!sheetName) return;

  const ws = wb.Sheets[sheetName];

  // Generate fresh HTML for that sheet
  const html = XLSX.utils.sheet_to_html(ws, { id: sheetName });

  // Parse HTML into a temporary container so we can grab the <table>
  const tmp = document.createElement('div');
  tmp.innerHTML = html;
  const newTable = tmp.querySelector('table');
  if (!newTable) return;

  // Find the existing table in the DOM and replace it
  const oldTable = document.getElementById(sheetName);
  if (oldTable) {
    oldTable.replaceWith(newTable);
  }
}
    
// --- Countries parser (from "Country" sheet or fallback Test details) ---
// Uses loadWorkbook(filename) → Promise<{ wb, buf }>
function fetchCountriesForFile(filename){
  if (countryCache.has(filename)) {
    const cached = countryCache.get(filename);
    return Promise.resolve(Array.isArray(cached) ? cached : (cached ? [cached] : []));
  }

  return loadWorkbook(filename)
    .then(({ wb }) => {
      const out = new Set();

      // Prefer a sheet that looks like "Country"
      const countrySheetName = wb.SheetNames.find(n => /country/i.test(n));
      if (countrySheetName) {
        const rows = XLSX.utils.sheet_to_json(wb.Sheets[countrySheetName], { header: 1, blankrows: false });
        if (rows.length) {
          const headers = rows[0].map(v => String(v ?? '').trim().toLowerCase());
          const colIdx = headers.findIndex(h => h.includes('country'));
          if (colIdx >= 0) {
            for (let r = 1; r < rows.length; r++) {
              const v = rows[r][colIdx];
              if (v != null && String(v).trim()) out.add(String(v).trim());
            }
          } else {
            // Fallback: try simple key/value style or single-column lists
            for (let r = 0; r < rows.length; r++) {
              const a = rows[r][0], b = rows[r][1];
              const aStr = String(a ?? '').trim().toLowerCase();
              if (aStr.includes('country') && b != null && String(b).trim()) out.add(String(b).trim());
              if (!aStr && rows[r].length === 1) {
                const val = rows[r][0];
                if (val != null && String(val).trim()) out.add(String(val).trim());
              }
            }
          }
        }
      }

      // If still empty, fall back to "Test details"
      if (out.size === 0) {
        const details = extractTestDetails(wb);
        const maybe = details['country'] || details['test country'] || details['location country'] || null;
        if (maybe && String(maybe).trim()) out.add(String(maybe).trim());
      }

      // Normalize to English when possible (e.g., "Sverige" -> "Sweden"),
      // but keep original label if we don't have a mapping.
      const normalized = Array.from(out)
        .map(s => String(s).trim())
        .filter(Boolean)
        .map(s => (typeof canonicalEU === 'function' ? (canonicalEU(s) || s) : s));

      countryCache.set(filename, normalized);
      return normalized;
    })
    .catch(() => {
      countryCache.set(filename, []);
      return [];
    });
}

// ---------- Europe country canonical names & centroids (EXPANDED) ----------
const EU_CENTROIDS = {
  // EU (unchanged)
  'Austria':[47.6,14.3],'Belgium':[50.6,4.7],'Bulgaria':[42.8,25.3],'Croatia':[45.1,15.4],
  'Cyprus':[35.1,33.4],'Czechia':[49.8,15.5],'Denmark':[56.0,10.0],'Estonia':[58.7,25.0],
  'Finland':[64.5,26.0],'France':[46.2,2.2],'Germany':[51.2,10.4],'Greece':[39.1,22.9],
  'Hungary':[47.2,19.5],'Ireland':[53.2,-8.0],'Italy':[42.8,12.5],'Latvia':[56.9,24.6],
  'Lithuania':[55.3,23.9],'Luxembourg':[49.8,6.1],'Malta':[35.9,14.4],'Netherlands':[52.2,5.3],
  'Poland':[52.0,19.1],'Portugal':[39.6,-8.0],'Romania':[45.9,24.9],'Slovakia':[48.7,19.5],
  'Slovenia':[46.1,14.8],'Spain':[40.3,-3.7],'Sweden':[62.0,15.0],

  // Non-EU Europe (added)
  'Albania':[41.2,20.2],
  'Andorra':[42.5,1.6],
  'Armenia':[40.3,44.9],
  'Azerbaijan':[40.1,47.8],
  'Belarus':[53.7,27.9],
  'Bosnia and Herzegovina':[44.2,17.7],
  'Iceland':[64.9,-18.6],
  'Kosovo':[42.6,20.9],
  'Liechtenstein':[47.1,9.6],
  'Moldova':[47.0,28.7],
  'Monaco':[43.73,7.42],
  'Montenegro':[42.8,19.2],
  'North Macedonia':[41.6,21.7],
  'Norway':[64.5,11.0],
  'Russia':[55.7,37.6],          // Moscow as European centroid
  'San Marino':[43.94,12.46],
  'Serbia':[44.0,20.8],
  'Switzerland':[46.8,8.2],
  'Turkey':[39.0,35.0],          // overall centroid; still fine for a single marker
  'Ukraine':[49.0,32.0],
  'United Kingdom':[54.2,-2.0],
  'Vatican City':[41.90,12.45],
  'Georgia':[42.3,43.4]
};
const EU_CANON_LOWER = {};
Object.keys(EU_CENTROIDS).forEach(k => EU_CANON_LOWER[k.toLowerCase()] = k);

// Common aliases / language variants → canonical keys above
const COUNTRY_ALIASES = {
  'czech republic':'czechia',
  'the netherlands':'netherlands',
  'sverige': 'sweden',
  'tyskland': 'germany',
  'kina': 'china',

  'românia':'romania','republic of moldova':'moldova',
  'deutschland':'germany','österreich':'austria','oesterreich':'austria',
  'españa':'spain','espana':'spain','italia':'italy',
  'magyarország':'hungary','polska':'poland','suomi':'finland',
  'elláda':'greece','ellada':'greece',

  'bosnia-herzegovina':'bosnia and herzegovina','bosnia':'bosnia and herzegovina',
  'macedonia':'north macedonia','fyrom':'north macedonia',

  'uk':'united kingdom','u.k.':'united kingdom','gb':'united kingdom',
  'great britain':'united kingdom','england':'united kingdom',
  'scotland':'united kingdom','wales':'united kingdom','northern ireland':'united kingdom',

  'russian federation':'russia',
  'türkiye':'turkey','turkiye':'turkey',

  'cote d’ivoire':'côte d’ivoire' // (example of normalization pattern; harmless if unused)
};

function canonicalEU(raw){
  if (!raw) return null;
  let s = String(raw).trim();

  // Drop bracket comments like "Serbia (RS)"
  s = s.replace(/\(.*?\)/g,'').trim();

  let k = s.toLowerCase();
  if (COUNTRY_ALIASES[k]) k = COUNTRY_ALIASES[k];

  // Exact match
  if (EU_CANON_LOWER[k]) return EU_CANON_LOWER[k];

  // Try simple title case fallback (e.g., "serbia" → "Serbia")
  const tc = k.replace(/\b\w/g, c => c.toUpperCase());
  return EU_CENTROIDS[tc] ? tc : null;
}

    // ---------- APP STATE ----------
    let issueCoords = [];
    let samplingCoords = [];
    let mapRef = null;
    let samplingLayerGroup = null;
    let allFiles = []; // used to re-render overview
    // Track which session is highlighted in the sidebar (global)
let _activeSessionFilename = null;

// Highlight current session in sidebar, expand its day, and scroll into view (global)
function setActiveSessionInSidebar(filename){
  // remove previous highlight
  if (_activeSessionFilename){
    const prevEl = document.getElementById(`sess_${cssSafeId(_activeSessionFilename)}`);
    if (prevEl) prevEl.classList.remove('is-active');
  }

  _activeSessionFilename = filename || null;
  if (!filename) return;

  const el = document.getElementById(`sess_${cssSafeId(filename)}`);
  if (!el) return;

  el.classList.add('is-active');

  // expand its day accordion
  const ul = el.closest('.session-list');
  const hdr = ul ? ul.previousElementSibling : null;
  if (ul && hdr && ul.style.display !== 'block'){
    ul.style.display = 'block';
    hdr.setAttribute('aria-expanded', 'true');
    hdr.title = 'Hide sessions';
  }

  // bring into view
  el.scrollIntoView({ block: 'nearest' });
}

document.addEventListener('DOMContentLoaded', () => {

  // Show the loading box immediately with a more specific message
  // and 0% progress so "Loading…" is never shown.
  setGlobalLoading('Preparing to read test sessions…', 0);

  listBlobs();
});

    // Track which report is currently open (for AI summary .txt)
    let currentReportFileName = null;

function renderAiSummaryHtml(rawText) {
  const lines = String(rawText || '').replace(/\r\n/g, '\n').split('\n');

  // Optional first line: "AI summary generated at 2026-01-07 11:36:27"
  let timestampHtml = '';
  if (lines.length && /^ai summary generated at/i.test(lines[0].trim())) {
    const tsLine = lines.shift().trim();
    timestampHtml = `<div class="ai-summary-timestamp">${escapeHtml(tsLine)}</div>`;
    while (lines.length && !lines[0].trim()) lines.shift(); // drop blank line after timestamp
  }

  const parts = [];
  let inList = false;
  const closeList = () => {
    if (inList) {
      parts.push('</ul>');
      inList = false;
    }
  };

  // 🔹 NEW: turn **text** into <strong>text</strong>
  const applyBold = (s) => s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');

  for (const line of lines) {
    const trimmed = line.trim();
    if (!trimmed) {
      closeList();
      continue;
    }

    // 1) Section headings: "- **Session overview (Sheet ...)**"
    let m = trimmed.match(/^[-*]\s+\*\*(.+?)\*\*\s*$/);
    if (m) {
      closeList();
      // escape first, then apply bold (in case any ** are inside)
      const headingText = applyBold(escapeHtml(m[1]));
      parts.push(`<h4>${headingText}</h4>`);
      continue;
    }

    // 2) Normal bullets: "- something"
    if (/^[-*]\s+/.test(trimmed)) {
      if (!inList) {
        parts.push('<ul>');
        inList = true;
      }
      let text = trimmed.replace(/^[-*]\s+/, '');
      text = escapeHtml(text);
      text = applyBold(text);              // 🔹 bold in bullets
      parts.push(`<li>${text}</li>`);
      continue;
    }

    // 3) Plain paragraph line
    closeList();
    let text = escapeHtml(trimmed);
    text = applyBold(text);                // 🔹 bold in paragraphs
    parts.push(`<p>${text}</p>`);
  }

  closeList();
  return {
    timestampHtml,
    bodyHtml: parts.join('')
  };
}
    
// Open the AI summary .txt in a modal popup
function openAiSummaryPopup(forFilename) {
  const file = forFilename || currentReportFileName;
  if (!file) {
    alert('No report selected for AI summary.');
    return;
  }

  // Replace .xlsx/.xls with .txt
  const txtName = file.replace(/\.(xlsx|xls)$/i, '.txt');
  const url = `${BASE_URL}/${encodeURIComponent(txtName)}?${SAS_TOKEN}`;

  fetch(url, { cache: 'no-store' })
    .then(res => {
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}`);
      }
      return res.text();
    })
    .then(text => {
      const { timestampHtml, bodyHtml } = renderAiSummaryHtml(text);

      const overlay = createModal(`
        <h3>Generated report</h3>
        ${timestampHtml}
        <div class="ai-summary-body">${bodyHtml}</div>
        <div class="modal-buttons">
          <button type="button" class="secondary-button close-btn">Close</button>
        </div>
      `);

      const closeBtn = overlay.querySelector('.close-btn');
      if (closeBtn) {
        closeBtn.addEventListener('click', () => {
          document.body.removeChild(overlay);
        });
      }
    })
    .catch(err => {
      alert(
        'Could not load AI summary file (.txt).\n' +
        'It may not exist yet for this session.\n\n' +
        err.message
      );
    });
}

// Add a row "Generated report | [Open report]" to the Test details table,
// inserted directly below the "Participant" row if present.
// If an old row labeled "AI summary" exists (from XLSX), rename it.
function addAiSummaryRow(testDetailsTableEl) {
  if (!testDetailsTableEl) return;

  const tbl   = testDetailsTableEl;
  const tbody = tbl.tBodies[0] || tbl;

  const rows = Array.from(tbody.rows);
  if (!rows.length) return;

  const colCount = rows[0].cells.length || 2;

  // 1) If there is already a row labeled "AI summary" or "Generated report",
  //    just rename it and ensure it has the correct button.
  for (const row of rows) {
    const c0 = row.cells[0];
    if (!c0) continue;
    const lbl = c0.textContent.trim().toLowerCase();
    if (lbl === 'ai summary' || lbl === 'generated report') {
      // Rename label
      c0.textContent = 'Generated report';

      // Ensure value cell with Open report button
      let valueTd = row.cells[1];
      if (!valueTd) {
        valueTd = row.insertCell(1);
      }
      // Clear existing content and insert button if needed
      if (!valueTd.querySelector('button')) {
        valueTd.textContent = '';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = 'Open report';
        btn.addEventListener('click', () => openAiSummaryPopup());
        valueTd.appendChild(btn);
      }

      // Span remaining columns if table has more than 2 columns
      if (colCount > 2) {
        valueTd.colSpan = colCount - 1;
      }

      return; // we're done
    }
  }

  // 2) Otherwise, create a new row
  const tr = document.createElement('tr');

  const labelTd = document.createElement('td');
  labelTd.textContent = 'Generated report';

  const valueTd = document.createElement('td');
  const btn = document.createElement('button');
  btn.type = 'button';
  btn.textContent = 'Open report';
  btn.addEventListener('click', () => openAiSummaryPopup());
  valueTd.appendChild(btn);

  if (colCount > 2) {
    valueTd.colSpan = colCount - 1;
  }

  tr.appendChild(labelTd);
  tr.appendChild(valueTd);

  // Insert below "Participant" row if present, else at end
  let insertAfterRow = null;
  for (const row of rows) {
    const c0 = row.cells[0];
    if (!c0) continue;
    const lbl = c0.textContent.trim().toLowerCase();
    if (lbl === 'participant' || lbl.includes('participant')) {
      insertAfterRow = row;
      break;
    }
  }

  if (insertAfterRow && insertAfterRow.nextSibling) {
    tbody.insertBefore(tr, insertAfterRow.nextSibling);
  } else {
    tbody.appendChild(tr);
  }
}
    
    // Helper to render the default overview page
    function renderOverview(){
      setActiveSessionInSidebar(null);
      endInitialLoading(); // ✅ ensure overview is not hidden when returning
  const content = document.getElementById('content');
  content.innerHTML = `
    <!-- Latest routes FIRST -->
    <div class="routes-wrap" style="grid-column: 1 / -1;">
      <h2 id="title-latest-routes" data-title="Latest tests" data-loading="1" style="margin-top:0;">
        <span>Loading</span>
        <span class="title-thinking">
          <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
        </span>
      </h2>
      <div id="routes-grid" class="route-grid"></div>
    </div>

    <!-- Then Test activity overview -->
    <h1 id="title-overview" data-title="Test activity overview" data-loading="1" style="margin-top:24px;">
      <span>Loading</span>
      <span class="title-thinking">
        <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
      </span>
    </h1>

    <div id="overview" class="overview">
      <div><div id="heatmap-host"></div></div>
      <div><div id="country-host"></div></div>
      <div><div id="temp-host"></div></div>
      <div><div id="weather-host"></div></div>

      <div class="eu-mileage-wrap" style="grid-column: 1 / -1;">
        <h2 id="title-eu-mileage" data-title="Mileage per country" data-loading="1" style="margin-top:16px;">
          <span>Loading</span>
          <span class="title-thinking">
            <span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>
          </span>
        </h2>
        <div id="eu-mileage-map" class="eu-mileage-map"></div>
      </div>
    </div>
  `;

  if (allFiles.length){
    const h1  = document.getElementById('title-overview');
    const h2  = document.getElementById('title-latest-routes');
    const hEU = document.getElementById('title-eu-mileage');

    setTitleLoading(h1, true, 'Loading');
    setTitleLoading(h2, true, 'Loading');
    setTitleLoading(hEU, true, 'Loading');

    buildOverviewHeatmap(allFiles).finally(() => setTitleLoading(h1, false));
    buildCountryMonthChart(allFiles);
    buildTempMonthChart(allFiles);
    buildWeatherMonthChart(allFiles);
    buildEUMileageMap(allFiles).finally(() => setTitleLoading(hEU, false));
    
    // Latest routes
    buildLatestRoutePreviews(allFiles).finally(() => setTitleLoading(h2, false));

    // 🔹 Test groups (between Latest routes & overview)
    buildTestGroupsSection(allFiles);  }
}

function listBlobs() {
  fetch(nc(`${BASE_URL}?restype=container&comp=list&${SAS_TOKEN}`), { cache: 'default' })
    .then(r => r.text())
    .then(xml => {
      const doc = new DOMParser().parseFromString(xml, 'application/xml');

      // Read blobs with their Last-Modified timestamps
      const blobs = Array.from(doc.getElementsByTagName('Blob')).map(b => {
        const name = b.getElementsByTagName('Name')[0]?.textContent || '';
        const lmEl = b.getElementsByTagName('Last-Modified')[0] ||
                     b.getElementsByTagName('Properties')[0]?.getElementsByTagName('Last-Modified')[0];
        const lm   = lmEl?.textContent || '';
        return { name, lastModifiedMs: Date.parse(lm) || 0 };
      });

      // 1) Cache Last-Modified for *all* blobs
      blobMeta.clear();
      blobs.forEach(b => {
        blobMeta.set(b.name, b.lastModifiedMs);
      });

      // 2) Filter xlsx
      const xlsx = blobs.filter(b => b.name.toLowerCase().endsWith('.xlsx'));
      if (xlsx.length === 0) {
        showError('No .xlsx files found.');
        return;
      }

      // Sort newest → oldest
      xlsx.sort((a, b) => {
        const la = a.lastModifiedMs || 0;
        const lb = b.lastModifiedMs || 0;
        if (lb !== la) return lb - la;
        return b.name.localeCompare(a.name);
      });

      const xlsxNames = xlsx.map(b => b.name);
      allFiles = xlsxNames;

      buildSidebar(xlsxNames);

      const h1  = document.getElementById('title-overview');
      const h2  = document.getElementById('title-latest-routes');
      const hEU = document.getElementById('title-eu-mileage');
      setTitleLoading(h1, true, 'Loading');
      setTitleLoading(h2, true, 'Loading');
      setTitleLoading(hEU, true, 'Loading');

      initGlobalProgress(xlsxNames.length);

      // SEQUENTIAL preload
      return preloadSummariesSequentially(xlsxNames)
        .then(() => {
          endInitialLoading(); // ✅ make overview visible BEFORE rendering charts/maps
          
          return Promise.all([
            buildOverviewHeatmap(xlsxNames)
              .finally(() => setTitleLoading(h1, false)),
            buildCountryMonthChart(xlsxNames),
            buildTempMonthChart(xlsxNames),
            buildWeatherMonthChart(xlsxNames),
            buildEUMileageMap(xlsxNames)
              .finally(() => setTitleLoading(hEU, false)),
            buildLatestRoutePreviews(xlsxNames)
              .finally(() => setTitleLoading(h2, false)),
            buildTestGroupsSection(xlsxNames)
          ]);
        })
        .then(() => {
          hideGlobalLoading();
          setTimeout(hideGlobalLoading, 800);
        });
    });  // <-- closes .then(xml => { ... })
}         // <-- closes function listBlobs

    // ---------- SIDEBAR ----------
 function buildSidebar(files) {
  const sb = document.getElementById('sidebar');
  sb.innerHTML = '';

  const header = document.createElement('h2');
  header.textContent = 'Test sessions';
  header.style.padding = '16px';
  header.style.margin = '0';
  header.style.borderBottom = '1px solid #ddd';
  header.style.cursor = 'pointer';
  header.title = 'Back to overview';
  header.addEventListener('click', (e) => {
    e.preventDefault();
    renderOverview();
  });
  sb.appendChild(header);

  // Group by day
  const groups = files.reduce((acc, f) => {
    const m = f.match(/(\d{4}-\d{2}-\d{2})/);
    if (!m) return acc;
    (acc[m[1]] ||= []).push(f);
    return acc;
  }, {});

  // Days: newest → oldest (string sort works for YYYY-MM-DD)
  Object.keys(groups).sort().reverse().forEach(day => {
    const hdr = document.createElement('div');
    hdr.className = 'day-header';
    hdr.setAttribute('role','button');
    hdr.setAttribute('aria-expanded','false');
    hdr.tabIndex = 0;
    hdr.title = 'Show sessions';

    const label = document.createElement('span');
    label.textContent = day;
    hdr.appendChild(label);

    const count = document.createElement('span');
    count.className = 'day-count';
    count.textContent = String(groups[day].length);
    hdr.appendChild(count);

    const lst = document.createElement('ul');
    lst.className = 'session-list';
    lst.style.display = 'none';

    // Sessions within a day: newest → oldest (by Last-Modified, then name)
    groups[day]
      .sort((a, b) => {
        const la = blobMeta.get(a) || 0;
        const lb = blobMeta.get(b) || 0;
        if (lb !== la) return lb - la;
        return b.localeCompare(a);
      })
      .forEach(f => {
        const namePretty = f.replace(`${day}_`, '').replace('.xlsx','');
        const li = document.createElement('li');
        li.className = 'session-item';
        li.id = `sess_${cssSafeId(f)}`;
        li.onclick = () => loadFile(f);

        const row = document.createElement('div');
        row.className = 'session-title-row';

        const title = document.createElement('div');
        title.textContent = namePretty;

        // KPI badge (will be filled by preloader)
        const kpiBadge = document.createElement('span');
        kpiBadge.className = 'kpi-badge';
        kpiBadge.id = `kpi_${cssSafeId(f)}`;
        kpiBadge.style.display = 'none';

        // Active badge (kept as before)
        const lm = blobMeta.get(f) || 0;
        const isActive = (Date.now() - lm) <= ACTIVE_WINDOW_MS;
        const activeBadge = document.createElement('span');
        activeBadge.className = 'active-badge';
        activeBadge.textContent = 'Active';
        activeBadge.dataset.lm = String(lm);
        if (!isActive) activeBadge.style.display = 'none';

        row.appendChild(title);
        row.appendChild(kpiBadge);
        row.appendChild(activeBadge);

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.id = `meta_${cssSafeId(f)}`;
        meta.textContent = 'Loading…';   // will be replaced by preloader

        li.appendChild(row);
        li.appendChild(meta);
        lst.appendChild(li);
      });

    const toggle = () => {
      const expand = lst.style.display !== 'block';
      lst.style.display = expand ? 'block' : 'none';
      hdr.setAttribute('aria-expanded', expand ? 'true' : 'false');
      hdr.title = expand ? 'Hide sessions' : 'Show sessions';
    };

    hdr.addEventListener('click', toggle);
    hdr.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggle();
      }
    });

    sb.appendChild(hdr);
    sb.appendChild(lst);
  });

  ensureActiveBadgeUpdater();
}

    let _activeBadgeTimer = null;
function ensureActiveBadgeUpdater(){
  if (_activeBadgeTimer) return;
  const tick = () => {
    const now = Date.now();
    document.querySelectorAll('.active-badge[data-lm]').forEach(el => {
      const lm = Number(el.dataset.lm || 0);
      const show = (now - lm) <= ACTIVE_WINDOW_MS;
      el.style.display = show ? 'inline-flex' : 'none';
    });
  };
  tick(); // initial
  _activeBadgeTimer = setInterval(tick, 30000); // every 30s
}

async function preloadSummariesSequentially(files) {
  let done = 0;

  for (const f of files) {
    try {
      const summary = await ensureSummary(f);   // 🔄 use ensureSummary
      applySummaryToSidebar(f, summary);
    } catch (e) {
      console.error('Failed to preload summary for', f, e);
    }
    done++;
    updateGlobalProgress(done);
  }
}

async function ensureSummary(filename) {
  // already cached for this session?
  if (summaryCache.has(filename)) {
    return summaryCache.get(filename);
  }

  const base = filename.replace(/\.xlsx$/i, '');
  const jsonName = base + '.json';

  const xMs = blobMeta.get(filename) || 0;
  const jMs = blobMeta.get(jsonName) || 0;

  // 1) If JSON exists and is not older than XLSX → try using it
  if (jMs && jMs >= xMs) {
    try {
      const url = `${BASE_URL}/${encodeURIComponent(jsonName)}?${SAS_TOKEN}`;
      const res = await fetch(url, { cache: 'no-store' });
      if (res.ok) {
        const summary = await res.json();
        summaryCache.set(filename, summary);
        return summary;
      }
    } catch (e) {
      console.warn('Failed to load summary JSON for', filename, e);
      // fall through to XLSX parsing
    }
  }

  // 2) Otherwise: fall back to full XLSX parse (your existing logic)
  const summary = await fetchSessionSummary(filename);  // you already have this
  summaryCache.set(filename, summary);

  // 3) Try to upload JSON so next app open can reuse it
  try {
    const jsonUrl = `${BASE_URL}/${encodeURIComponent(jsonName)}?${SAS_TOKEN}`;
    await fetch(jsonUrl, {
      method: 'PUT',
      headers: {
        'x-ms-blob-type': 'BlockBlob',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(summary)
    });
    // locally update the meta so in this session we know JSON exists
    blobMeta.set(jsonName, Date.now());
  } catch (e) {
    console.warn('Failed to upload summary JSON for', filename, e);
  }

  return summary;
}
    
// Fill sidebar meta line + KPI badge for a single session
function applySummaryToSidebar(filename, summary) {
  if (!summary) return;
  const { mileageKm, issueCount, testObject, testPurpose, kpiScore } = summary;

  const metaEl = document.getElementById(`meta_${cssSafeId(filename)}`);
  if (metaEl) {
    const parts = [];
    if (testPurpose) parts.push(String(testPurpose));
    if (testObject)  parts.push(String(testObject));
    const left = parts.length ? parts.join('  •  ') + '  •  ' : '';
    const mileageText = (mileageKm ?? '–') + (mileageKm != null ? 'km' : '');
    metaEl.textContent = `${left}Mileage: ${mileageText}  No of issues: ${issueCount ?? 0}`;
  }

  const kb = document.getElementById(`kpi_${cssSafeId(filename)}`);
  if (kb) {
    if (typeof kpiScore === 'number' && kpiScore >= 1 && kpiScore <= 10) {
      kb.textContent = `KPI ${kpiScore}`;
      kb.className = `kpi-badge s${kpiScore}`;
      kb.style.display = 'inline-flex';
    } else {
      kb.style.display = 'none';
    }
  }
}
   
    // ---------- OVERVIEW HEATMAP (Test activity) ----------
function buildOverviewHeatmap(files){
  const byDay = new Map(); // 'YYYY-MM-DD' -> totalIssues (only sessions ≥1 km and issues > 0)
  const withDates = files
    .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.f, dayStr: x.m[1] }));

  return Promise.all(
    withDates.map(x =>
      ensureSummary(x.filename).then(s => ({ ...x, ...s }))
    )
  ).then(rows => {
rows.forEach(r => {
  // ✅ activity = number of tests, not issue count
  if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW) return;
  const prev = byDay.get(r.dayStr) || 0;
  byDay.set(r.dayStr, prev + 1);
});

    const days = Array.from(byDay.keys()).sort();
    const host = document.getElementById('heatmap-host');
    if (days.length === 0){
      host.innerHTML = '<div style="color:#666;">No eligible sessions (≥ 1 km and &gt; 0 issues) to show yet.</div>';
      return;
    }

    const minDate = toDateOnly(days[0]);
    const maxDate = toDateOnly(days[days.length-1]);

    const start = new Date(minDate);
    const day = start.getDay(); // 0 Sun … 6 Sat
    const offsetToMonday = (day === 0 ? 6 : day - 1);
    start.setDate(start.getDate() - offsetToMonday);
    start.setHours(0,0,0,0);

    const end = new Date(maxDate);
    const endDay = end.getDay();
    const addToSunday = (7 - endDay) % 7;
    end.setDate(end.getDate() + addToSunday);
    end.setHours(0,0,0,0);

    const dense = [];
    let cur = new Date(start);
    while (cur <= end) {
      const ymd = cur.toISOString().slice(0,10);
      dense.push({ date: new Date(cur), count: byDay.get(ymd) || 0 });
      cur.setDate(cur.getDate() + 1);
    }

    renderHeatmap(dense);
  });
}

   function renderHeatmap(denseDays){
  const host = document.getElementById('heatmap-host');
  if (!host) return;              // ← user navigated away; do nothing

  host.innerHTML = '';

  const cell = 12, gap = 3, rows = 7;
  const weeks = Math.ceil(denseDays.length / 7);
  const width  = weeks * (cell + gap) + 40;
  const height = rows  * (cell + gap) + 20;

  const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
  const level = v => (v === 0) ? 0 : (v < 5 ? 1 : (v < 10 ? 2 : (v < 20 ? 3 : 4)));

  const NS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(NS, 'svg');
  svg.setAttribute('width', width);
  svg.setAttribute('height', height);
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

  const months = document.createElementNS(NS, 'g'); months.setAttribute('class','heatmap-months');
  let lastMonth = -1;
  const weeksCount = weeks;
  for (let w = 0; w < weeksCount; w++) {
    const idx = w * 7;
    if (idx >= denseDays.length) break;
    const d = denseDays[idx].date;
    const m = d.getMonth();
    if (m !== lastMonth) {
      lastMonth = m;
      const t = document.createElementNS(NS,'text');
      t.textContent = d.toLocaleString(undefined,{month:'short'});
      t.setAttribute('x', 40 + w*(cell+gap));
      t.setAttribute('y', 10);
      months.appendChild(t);
    }
  }
  svg.appendChild(months);

  const dow = document.createElementNS(NS,'g'); dow.setAttribute('class','heatmap-dow');
  [['Mon',0],['Wed',2],['Fri',4]].forEach(([name,row])=>{
    const t=document.createElementNS(NS,'text');
    t.textContent=name; t.setAttribute('x',0); t.setAttribute('y',24+row*(cell+gap));
    dow.appendChild(t);
  });
  svg.appendChild(dow);

  const cellsG = document.createElementNS(NS,'g');
  for (let i = 0; i < denseDays.length; i++) {
    const d = denseDays[i];
    const w = Math.floor(i / 7);
    const r = i % 7;
    const rect = document.createElementNS(NS,'rect');
    rect.setAttribute('x', 40 + w*(cell+gap));
    rect.setAttribute('y', 16 + r*(cell+gap));
    rect.setAttribute('width', cell);
    rect.setAttribute('height', cell);
    rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
    rect.setAttribute('fill', colors[level(d.count)]);
    rect.setAttribute('stroke', '#ccd3d9');
    rect.setAttribute('stroke-width', '1');
    cellsG.appendChild(rect);
  }
  svg.appendChild(cellsG);

  host.appendChild(svg);

  const legend = document.createElement('div');
  legend.className = 'legend';
  legend.innerHTML = `Less
    <span class="box" style="background:${colors[0]}"></span>
    <span class="box" style="background:${colors[1]}"></span>
    <span class="box" style="background:${colors[2]}"></span>
    <span class="box" style="background:${colors[3]}"></span>
    <span class="box" style="background:${colors[4]}"></span>
    More`;
  host.appendChild(legend);
}

    // ---------- Countries × Month (4 bins/month) ----------
    function buildCountryMonthChart(files){
  const withDates = files
    .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.f, dayStr: x.m[1] }));

  const cleanTitleCase = (s) => {
    const t = String(s || '').trim()
      .replace(/\(.*?\)/g, '')        // drop bracket comments e.g. "Sweden (SE)"
      .replace(/\s+/g, ' ');
    return t.replace(/\b\w/g, c => c.toUpperCase());
  };

return Promise.all(
  withDates.map(x =>
    ensureSummary(x.filename)
      .then(s => ({...x, ...s}))
      .then(r => {
        if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW) return null;
        return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
      })
  )
).then(rows => {
    const valid = rows.filter(Boolean).filter(r => Array.isArray(r.countries) && r.countries.length > 0);
    const host = document.getElementById('country-host');
    if (!host) return;

    if (!valid.length){
      host.innerHTML = '<div style="color:#666;">No country data found in the “Country” table.</div>';
      return;
    }

    const counts = new Map(); // `${ym}|${wb}|${country}` -> n
    const monthsSet = new Set();
    const countriesSet = new Set();

    valid.forEach(r => {
      const ym  = r.dayStr.slice(0,7);
      const day = parseInt(r.dayStr.slice(8,10), 10);
      const wb  = Math.min(4, Math.max(1, Math.ceil(day/7))); // 1..4
      monthsSet.add(ym);

      // 🔹 Normalize each country:
      const normed = r.countries
        .map(c => canonicalEU(c) || cleanTitleCase(c)) // EU → English; others → cleaned title case
        .filter(Boolean);

      const uniq = Array.from(new Set(normed));
      uniq.forEach(country => {
        countriesSet.add(country);
        const key = `${ym}|${wb}|${country}`;
        counts.set(key, (counts.get(key)||0) + 1);
      });
    });

    const months = Array.from(monthsSet).sort();
    const countries = Array.from(countriesSet).sort((a,b) => {
      const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
      const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
      if (totalB !== totalA) return totalB - totalA;
      return a.localeCompare(b);
    });

    renderCountryMonthHeatmap({ months, countries, counts });
  });
}

    function renderCountryMonthHeatmap({months, countries, counts}){
  const host = document.getElementById('country-host');
  if (!host) return;              // ← added

  host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 110;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + countries.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => countries.flatMap(c => [1,2,3,4].map(w => counts.get(`${m}|${w}|${c}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Country labels (rows)
      const gCountries = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = countries[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gCountries.appendChild(t);
      }
      svg.appendChild(gCountries);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < countries.length; r++){
        const country = countries[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${country}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Temperature × Month (4 bins/month) ----------
    function buildTempMonthChart(files){
      const withDates = files
        .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
        .filter(x => x.m)
        .map(x => ({ filename: x.f, dayStr: x.m[1] }));

return Promise.all(
  withDates.map(x =>
    ensureSummary(x.filename).then(s => ({ ...x, ...s }))
  )
).then(rows => {
        const valid = rows.filter(r =>
          r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
          r.issueCount > 0 && r.meanTempC != null && !isNaN(r.meanTempC)
        );

        const host = document.getElementById('temp-host');
        if (!host) return;
        if (!valid.length){
          host.innerHTML = '<div style="color:#666;">No temperature data found in Issue/Issues table.</div>';
          return;
        }

        const counts = new Map(); // `${ym}|${wb}|${tempInt}` -> n
        const monthsSet = new Set();
        const tempsSet = new Set();

        valid.forEach(r => {
          const ym  = r.dayStr.slice(0,7);
          const day = parseInt(r.dayStr.slice(8,10), 10);
          const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
          monthsSet.add(ym);

          const tempInt = Math.round(r.meanTempC);
          tempsSet.add(tempInt);
          const key = `${ym}|${wb}|${tempInt}`;
          counts.set(key, (counts.get(key)||0) + 1);
        });

        const months = Array.from(monthsSet).sort();
        const temps  = Array.from(tempsSet).sort((a,b)=>b-a); // highest first (y-axis reversed)
        renderTempMonthHeatmap({ months, temps, counts });
      });
    }

    function renderTempMonthHeatmap({months, temps, counts}){
  const host = document.getElementById('temp-host');
  if (!host) return;              // ← added

  host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 54;  // numbers
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + temps.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => temps.flatMap(t => [1,2,3,4].map(w => counts.get(`${m}|${w}|${t}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Temperature labels (rows)
      const gTemps = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = `${temps[r]}°`;
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gTemps.appendChild(t);
      }
      svg.appendChild(gTemps);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < temps.length; r++){
        const tempVal = temps[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${tempVal}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- Weather × Month (4 bins/month) ----------
    function buildWeatherMonthChart(files){
  const withDates = files
    .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.f, dayStr: x.m[1] }));

  // Treat these as placeholders → ignore in chart
  const isPlaceholderWx = (w) => {
    if (!w) return true;
    const s = String(w).trim();
    return s === '' || /^weather$/i.test(s) || /^conditions?$/i.test(s) || /^n\/?a$/i.test(s) || /^unknown$/i.test(s);
  };

return Promise.all(
  withDates.map(x =>
    ensureSummary(x.filename).then(s => ({ ...x, ...s }))
  )
).then(rows => {
    const valid = rows.filter(r =>
      r && r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW &&
      r.issueCount > 0 && r.weatherAgg
    );

    const host = document.getElementById('weather-host');
    if (!host) return;

    const counts = new Map(); // `${ym}|${wb}|${wx}` -> n
    const monthsSet = new Set();
    const wxSet = new Set();

    valid.forEach(r => {
      const wx = String(r.weatherAgg).trim();
      if (isPlaceholderWx(wx)) return; // 🔹 skip "Weather" etc.

      const ym  = r.dayStr.slice(0,7);
      const day = parseInt(r.dayStr.slice(8,10), 10);
      const wb  = Math.min(4, Math.max(1, Math.ceil(day/7)));
      monthsSet.add(ym);
      wxSet.add(wx);

      const key = `${ym}|${wb}|${wx}`;
      counts.set(key, (counts.get(key)||0) + 1);
    });

    const months = Array.from(monthsSet).sort();
    const wxs = Array.from(wxSet).sort((a,b) => {
      const totalA = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${a}`)||0), 0), 0);
      const totalB = months.reduce((s, m) => s + [1,2,3,4].reduce((t,w)=> t + (counts.get(`${m}|${w}|${b}`)||0), 0), 0);
      if (totalB !== totalA) return totalB - totalA;
      return a.localeCompare(b);
    });

    if (!wxs.length){
      host.innerHTML = '<div style="color:#666;">No weather data found (placeholders ignored).</div>';
      return;
    }

    renderWeatherMonthHeatmap({ months, wxs, counts });
  });
}

    function renderWeatherMonthHeatmap({months, wxs, counts}){
  const host = document.getElementById('weather-host');
  if (!host) return;              // ← added

  host.innerHTML = '';

      const cell = 14, gap = 4;
      const leftLabelsW = 90;
      const topLabelsH  = 18;

      const subColsPerMonth = 4;
      const totalCols = months.length * subColsPerMonth;

      const width  = leftLabelsW + totalCols * (cell + gap) + 8;
      const height = topLabelsH  + wxs.length * (cell + gap) + 8;

      const colors = ['#eaeef2','#c6e48b','#7bc96f','#239a3b','#196127'];
      const maxVal = Math.max(1, ...months.flatMap(m => wxs.flatMap(w => [1,2,3,4].map(bin => counts.get(`${m}|${bin}|${w}`)||0))));
      const bucket = v => {
        if (v === 0) return 0;
        const f = v / maxVal;
        return (f < .2) ? 1 : (f < .4) ? 2 : (f < .7) ? 3 : 4;
      };

      const NS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(NS, 'svg');
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');

      // Month labels
      const gMonths = document.createElementNS(NS, 'g');
      for (let m = 0; m < months.length; m++){
        const d = new Date(`${months[m]}-01`);
        const label = d.toLocaleString(undefined, { month: 'short' });
        const x = leftLabelsW + (m * subColsPerMonth) * (cell + gap);
        const t = document.createElementNS(NS,'text');
        t.textContent = label;
        t.setAttribute('x', x);
        t.setAttribute('y', 10);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gMonths.appendChild(t);
      }
      svg.appendChild(gMonths);

      // Weather labels (rows)
      const gWx = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const t = document.createElementNS(NS,'text');
        t.textContent = wxs[r];
        t.setAttribute('x', 4);
        t.setAttribute('y', topLabelsH + r*(cell+gap) + cell - 2);
        t.setAttribute('font-size','12');
        t.setAttribute('fill','#333');
        gWx.appendChild(t);
      }
      svg.appendChild(gWx);

      // Cells
      const gCells = document.createElementNS(NS, 'g');
      for (let r = 0; r < wxs.length; r++){
        const wx = wxs[r];
        for (let m = 0; m < months.length; m++){
          for (let w = 1; w <= 4; w++){
            const val = counts.get(`${months[m]}|${w}|${wx}`) || 0;
            const colIndex = m * 4 + (w - 1);
            const rect = document.createElementNS(NS,'rect');
            rect.setAttribute('x', leftLabelsW + colIndex*(cell+gap));
            rect.setAttribute('y', topLabelsH  + r*(cell+gap));
            rect.setAttribute('width', cell);
            rect.setAttribute('height', cell);
            rect.setAttribute('rx', 2); rect.setAttribute('ry', 2);
            rect.setAttribute('fill', colors[bucket(val)]);
            rect.setAttribute('stroke', '#ccd3d9');
            rect.setAttribute('stroke-width', '1');
            rect.setAttribute('data-val', String(val));
            gCells.appendChild(rect);
          }
        }
      }
      svg.appendChild(gCells);

      host.appendChild(svg);

      const legend = document.createElement('div');
      legend.className = 'legend';
      legend.innerHTML = `Fewer
        <span class="box" style="background:${colors[0]}"></span>
        <span class="box" style="background:${colors[1]}"></span>
        <span class="box" style="background:${colors[2]}"></span>
        <span class="box" style="background:${colors[3]}"></span>
        <span class="box" style="background:${colors[4]}"></span>
        More`;
      host.appendChild(legend);
    }

    // ---------- EU Mileage Map (NEW) ----------
function buildEUMileageMap(files){
  const withDates = files
    .map(f => ({ f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.f, dayStr: x.m[1] }));

return Promise.all(withDates.map(x =>
  ensureSummary(x.filename)
    .then(s => ({...x, ...s}))
    .then(r => {
      if (r.mileageKm == null || r.mileageKm < MIN_KM_FOR_OVERVIEW || !(r.issueCount > 0)) return null;
      return fetchCountriesForFile(r.filename).then(countries => ({...r, countries}));
    })
)).then(async rows => {
    const valid = rows.filter(Boolean);
    const agg = new Map();           // country -> total mileage (km)
    const issuePoints = [];          // all issue coordinates across valid sessions

    // Gather mileage + issue coordinates
    for (const r of valid){
      const euCountries = Array.isArray(r.countries)
        ? r.countries.map(canonicalEU).filter(Boolean)
        : [];
      if (euCountries.length){
        const share = r.mileageKm / euCountries.length;
        euCountries.forEach(cty => agg.set(cty, (agg.get(cty)||0) + share));
      }

      // Pull issue points from the workbook (fast scan)
      try{
        const { wb } = await loadWorkbook(r.filename);
        const pts = extractIssueCoordsFast(wb);
        if (pts && pts.length) issuePoints.push(...pts);
      }catch(e){ /* ignore */ }
    }

    renderEUMileageMap(agg, issuePoints);
  });
}

function renderEUMileageMap(agg, issuePoints = []){
  const hostId = 'eu-mileage-map';
  const container = document.getElementById(hostId);
  if (!container) return;

  container.innerHTML = '';

  const entries = Array.from(agg.entries()).filter(([,km]) => km > 0);
  if (!entries.length && (!issuePoints || !issuePoints.length)){
    container.outerHTML = `<div id="${hostId}" class="eu-mileage-map" style="display:flex;align-items:center;justify-content:center;color:#666;">No EU mileage data available yet.</div>`;
    return;
  }

  const map = L.map(container, { attributionControl:true, zoomControl:true });
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
  }).addTo(map);

  const vectorRenderer = L.canvas({ padding: 0.5 });
  map.addLayer(vectorRenderer);

  // --- Black trace layer (tiny dots) ---
if (issuePoints && issuePoints.length){
  const MAX_POINTS = 25000;
  const stride = Math.max(1, Math.ceil(issuePoints.length / MAX_POINTS));
  const isOK = (p) => Array.isArray(p) && p.length === 2 &&
    Number.isFinite(p[0]) && Number.isFinite(p[1]) &&
    p[0] >= -90 && p[0] <= 90 && p[1] >= -180 && p[1] <= 180;

  const dots = [];
  for (let i = 0; i < issuePoints.length; i += stride){
    const p = issuePoints[i];
    if (!isOK(p)) continue;
    dots.push(L.circleMarker(p, {
      renderer: vectorRenderer,
      radius: 1.5,
      color: '#000',
      weight: 0,
      fillColor: '#000',
      fillOpacity: 0.45
    }));
  }
  if (dots.length) L.layerGroup(dots).addTo(map);
}

  // --- Country bubbles (same as before) ---
  const latlngs = [];
  const maxKm = entries.length ? Math.max(...entries.map(([,km]) => km)) : 0;
  const minR = 6, maxR = 30;

  entries.forEach(([country, km]) => {
    const [lat, lon] = EU_CENTROIDS[country] || [null, null];
    if (lat == null || lon == null) return;
    latlngs.push([lat, lon]);

    const r = (function(){
      if (maxKm <= 0) return minR;
      const f = Math.sqrt(km / maxKm);
      return Math.round(minR + f * (maxR - minR));
    })();

    const marker = L.circleMarker([lat,lon], {
      radius: r,
      color: '#900',
      weight: 1,
      fillColor: '#d00',
      fillOpacity: 0.7
    }).addTo(map);

    marker.bindTooltip(`${Math.round(km)} km`, {
      permanent: true,
      direction: 'center',
      className: 'eu-mileage-label'
    });
  });

const allBounds = latlngs.slice();

const isOKBound = (p) => Array.isArray(p) && p.length === 2 &&
  Number.isFinite(p[0]) && Number.isFinite(p[1]) &&
  p[0] >= -90 && p[0] <= 90 && p[1] >= -180 && p[1] <= 180;

if (issuePoints && issuePoints.length){
  const MAX_BOUNDS_SAMPLES = 2000;
  const jump = Math.max(1, Math.ceil(issuePoints.length / MAX_BOUNDS_SAMPLES));
  for (let i = 0; i < issuePoints.length; i += jump){
    const p = issuePoints[i];
    if (isOKBound(p)) allBounds.push(p);
  }
}

if (allBounds.length){
  map.fitBounds(allBounds, { padding:[20,20] });
} else {
  map.setView([54,15], 4);
}

requestAnimationFrame(() => map.invalidateSize());
setTimeout(() => map.invalidateSize(), 200);

  map.whenReady(() => map.invalidateSize());
  setTimeout(() => map.invalidateSize(), 100);
}

    // ---------- LATEST ROUTE PREVIEWS (latest 10, ≥1 km, issues > 0) ----------
function buildLatestRoutePreviews(files){
  const withDates = files
    .map(f => ({ filename: f, m: f.match(/(\d{4}-\d{2}-\d{2})/) }))
    .filter(x => x.m)
    .map(x => ({ filename: x.filename, dayStr: x.m[1] }));

return Promise.all(
  withDates.map(x =>
    ensureSummary(x.filename).then(s => ({ ...x, ...s }))
  )
).then(rows => {
    // Filter and sort strictly by date + last-modified
    const take = rows
      .filter(r => r.mileageKm != null && r.mileageKm >= MIN_KM_FOR_OVERVIEW && r.issueCount > 0)
      .sort((a, b) => {
        const d = b.dayStr.localeCompare(a.dayStr);                 // YYYY-MM-DD DESC
        if (d) return d;
        const lmDiff = (blobMeta.get(b.filename) || 0) - (blobMeta.get(a.filename) || 0); // Last-Modified DESC
        if (lmDiff) return lmDiff;
        return b.filename.localeCompare(a.filename);                // tie-break
      })
      .slice(0, 5);

    const grid = document.getElementById('routes-grid');
    if (!grid) return;
    grid.innerHTML = '';
    if (!take.length) return;

    // 1) Place all cards (with summary data, no workbook parsing yet)
    const slots = take.map(item => {
      const card = document.createElement('div');
      card.className = 'route-card';

      const niceName = item.filename.replace(`${item.dayStr}_`, '').replace('.xlsx','');

      const title = document.createElement('div');
      title.className = 'route-title';
      const link = document.createElement('a');
      link.className = 'route-link';
      link.href = '#';
      link.innerHTML = `<span class="u">${item.dayStr} — ${niceName}</span>`;
      link.addEventListener('click', (e)=>{ e.preventDefault(); loadFile(item.filename); });
      title.appendChild(link);
      card.appendChild(title);

      const mapDiv = document.createElement('div');
      mapDiv.className = 'route-map';
      mapDiv.id = `route_${cssSafeId(item.filename)}`;
      card.appendChild(mapDiv);
      showMiniMapLoading(mapDiv, 'Preparing map…', 5);

      const meta = document.createElement('div');
      meta.className = 'route-meta';

      // Build left-side details from summary (no extra XLSX parsing)
      const leftParts = [];
      if (item.testObject)  leftParts.push(`Test object: ${item.testObject}`);
      if (item.testPurpose) leftParts.push(`Purpose: ${item.testPurpose}`);
      const leftText = leftParts.length ? leftParts.join('  •  ') + '  •  ' : '';

      const kmText = (item.mileageKm ?? '–');
      meta.textContent = `${leftText}Mileage: ${kmText} km  •  Issues: ${item.issueCount}`;
      card.appendChild(meta);

      grid.appendChild(card);
      return { item, mapDiv, meta };
    });

    // 2) For each card, draw the mini route map using the cached workbook
slots.forEach(({ item, mapDiv }) => {
  showMiniMapLoading(mapDiv, 'Loading route…', null);
  loadWorkbook(item.filename)
    .then(({ wb }) => {
      const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
      if (!samplingName) return;

      const { path } = computeMileageAndPathFromSampling(wb.Sheets[samplingName]);
      if (!path || path.length < 2) return;

const mini = L.map(mapDiv, {
  attributionControl: false,
  zoomControl: false,
  scrollWheelZoom: false,
  doubleClickZoom: false,
  touchZoom: false,
  boxZoom: false,
  keyboard: false
});

const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(mini);

// ✅ hide the progress overlay when tiles are ready (or fail)
let done = false;
const finish = () => {
  if (done) return;
  done = true;
  hideMiniMapLoading(mapDiv);
  requestAnimationFrame(() => mini.invalidateSize(true));
};

tiles.once('load', finish);
tiles.once('tileerror', finish);
setTimeout(finish, 2000); // fallback so it never gets stuck

      const line = L.polyline(path, { color:'blue', weight:3, opacity:0.8 }).addTo(mini);
      mini.fitBounds(line.getBounds(), { padding:[8,8] });

      // Lock zoom level after fitBounds (so user can’t zoom in/out)
      const fixedZoom = mini.getZoom();
      mini.setMinZoom(fixedZoom);
      mini.setMaxZoom(fixedZoom);

      mini.whenReady(() => mini.invalidateSize());
    })
    .catch(() => { /* ignore individual failures for a single card */ });
});
  });
}

// Build "Test groups" section (between Latest tests and Test activity overview).
// A group qualifies only if the same Additional comment appears in ≥ 2 sessions.
function buildTestGroupsSection(files){
  if (!files || !files.length) return Promise.resolve();

  // Make sure we have summaries (uses cache after first run)
const promises = files.map(f =>
  ensureSummary(f).then(summary => ({ filename: f, summary }))
);

  return Promise.all(promises).then(all => {
    // Group by additionalComment
    const byComment = new Map();

all.forEach(({ filename, summary }) => {
  const raw = summary && summary.additionalComment;
  if (!raw) return;
  const key = raw.trim();
  if (!key) return;

  // 🔹 remember which group this file belongs to
  fileToTestGroup.set(filename, key);

  if (!byComment.has(key)) byComment.set(key, []);
  byComment.get(key).push({ filename, summary });
});

    // Only keep groups with ≥ 2 sessions
    const groups = Array.from(byComment.entries())
      .map(([comment, sessions]) => ({ comment, sessions }))
      .filter(g => g.sessions.length > 1);

    // Create wrapper if needed (inserted right after .routes-wrap)
    let wrap = document.getElementById('test-groups-wrap');
    if (!wrap) {
      const routesWrap = document.querySelector('.routes-wrap');
      if (!routesWrap) return;

      wrap = document.createElement('div');
      wrap.id = 'test-groups-wrap';
      wrap.style.margin = '24px 0';
      wrap.innerHTML = `
        <h2>Test groups</h2>
        <div id="test-groups-body"></div>
      `;
      routesWrap.insertAdjacentElement('afterend', wrap);
    }

    const body = document.getElementById('test-groups-body');
    if (!body) return;

    if (!groups.length) {
      body.innerHTML = `
        <div style="color:#666;">
          No test groups yet. Add the same “Additional comment” to more than one session to create a group.
        </div>`;
      return;
    }

    // Sort groups by newest session in the group (using blobMeta for strict time)
    groups.sort((g1, g2) => {
      const latest1 = Math.max(...g1.sessions.map(s => blobMeta.get(s.filename) || 0));
      const latest2 = Math.max(...g2.sessions.map(s => blobMeta.get(s.filename) || 0));
      return latest2 - latest1;
    });

    const rowsHtml = groups.map(g => {
      const nSessions = g.sessions.length;
      const totalKm   = g.sessions.reduce((acc, s) => acc + (s.summary.mileageKm || 0), 0);
      const totalIssues = g.sessions.reduce((acc, s) => acc + (s.summary.issueCount || 0), 0);
      const eventsPer1k = totalKm > 0 ? (totalIssues / totalKm) * 1000 : null;

      return `
        <tr>
          <td>
            <a href="#" class="route-link test-group-link">
              <span class="u">${escapeHtml(g.comment)}</span>
            </a>
          </td>
          <td>${nSessions}</td>
          <td>${totalKm ? totalKm.toFixed(0) : '–'}</td>
          <td>${totalIssues}</td>
          <td>${eventsPer1k != null ? eventsPer1k.toFixed(1) : '–'}</td>
        </tr>`;
    }).join('');

    body.innerHTML = `
      <table class="report-table">
        <thead>
          <tr>
            <th>Test group</th>
            <th>Sessions</th>
            <th>Mileage (km)</th>
            <th>Issues</th>
            <th>Events / 1000 km</th>
          </tr>
        </thead>
        <tbody>${rowsHtml}</tbody>
      </table>
    `;

    // Attach click handlers to open group view
    const links = body.querySelectorAll('.test-group-link');
    links.forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const label = link.textContent.trim();
        const group = groups.find(g => g.comment === label);
        if (group) openTestGroupView(group);
      });
    });
  });
}

// Open a test group when we only know its label (Additional comment text)
function openTestGroupViewByLabel(label) {
  setActiveSessionInSidebar(null);
  const commentKey = (label || '').trim();
  if (!commentKey) return;

  // Use allFiles if we have it; otherwise fall back to whatever is in the cache
  const files = (allFiles && allFiles.length)
    ? allFiles
    : Array.from(summaryCache.keys());
  
const promises = files.map(f =>
  ensureSummary(f)
    .then(summary => ({ filename: f, summary }))
    .catch(() => null)
);

  Promise.all(promises).then(rows => {
    const sessions = rows.filter(r =>
      r &&
      r.summary &&
      r.summary.additionalComment &&
      r.summary.additionalComment.trim() === commentKey
    );

    if (!sessions.length) {
      alert('No sessions found for this test group (it may have been renamed or removed).');
      return;
    }

    const group = { comment: commentKey, sessions };
    openTestGroupView(group);  // use the existing renderer
  });
}

// Show a dedicated view for one test group
function openTestGroupView(group){
  const content = document.getElementById('content');
  if (!content) return;

  const nSessions   = group.sessions.length;
  const totalKm     = group.sessions.reduce((acc, s) => acc + (s.summary.mileageKm || 0), 0);
  const totalIssues = group.sessions.reduce((acc, s) => acc + (s.summary.issueCount || 0), 0);
  const eventsPer1k = totalKm > 0 ? (totalIssues / totalKm) * 1000 : null;

  // Sort sessions in group by date + Last-Modified (newest first)
  const sessionsSorted = [...group.sessions].sort((a, b) => {
    const mA = a.filename.match(/(\d{4}-\d{2}-\d{2})/);
    const mB = b.filename.match(/(\d{4}-\d{2}-\d{2})/);
    const dA = mA ? mA[1] : '';
    const dB = mB ? mB[1] : '';
    const cmpDate = dB.localeCompare(dA);
    if (cmpDate) return cmpDate;
    const lmA = blobMeta.get(a.filename) || 0;
    const lmB = blobMeta.get(b.filename) || 0;
    return lmB - lmA;
  });

  const rowsHtml = sessionsSorted.map(s => {
    const filename = s.filename;
    const summary  = s.summary;
    const m = filename.match(/(\d{4}-\d{2}-\d{2})/);
    const dayStr = m ? m[1] : '';
    const niceName = dayStr
      ? filename.replace(`${dayStr}_`, '').replace('.xlsx','')
      : filename.replace('.xlsx','');

    const km         = summary.mileageKm != null ? summary.mileageKm : '–';
    const issues     = summary.issueCount != null ? summary.issueCount : 0;
    const kpi        = summary.kpiScore != null ? summary.kpiScore : '–';
    const testObj    = summary.testObject || '–';
    const adcuSw     = summary.adcuSoftware || '–';
    const parts      = summary.participants || '–';

    const safeId = cssSafeId(filename);

    return `
      <tr>
        <td>${escapeHtml(dayStr)}</td>
        <td>${escapeHtml(niceName)}</td>
        <td>${escapeHtml(testObj)}</td>
        <td>${escapeHtml(adcuSw)}</td>
        <td>${escapeHtml(parts)}</td>
        <td>
          <button type="button"
                  class="download-button"
                  data-session="${escapeHtml(filename)}"
                  id="gen_${safeId}">
            Open report
          </button>
        </td>
        <td>${km}</td>
        <td>${issues}</td>
        <td>${kpi}</td>
        <td>
          <button type="button"
                  class="download-button"
                  data-session="${escapeHtml(filename)}"
                  id="open_${safeId}">
            Open
          </button>
        </td>
      </tr>`;
  }).join('');

  content.innerHTML = `
    <button type="button" class="download-button" id="back-to-overview-btn">
      ← Back to overview
    </button>

    <h1 style="margin-top:16px;">Test group: ${escapeHtml(group.comment)}</h1>

    <div style="margin:12px 0 24px;font-size:14px;">
      <strong>Sessions:</strong> ${nSessions}&nbsp;&nbsp;
      <strong>Mileage:</strong> ${totalKm ? totalKm.toFixed(0) : '–'} km&nbsp;&nbsp;
      <strong>Issues:</strong> ${totalIssues}&nbsp;&nbsp;
      <strong>Events / 1000 km:</strong> ${eventsPer1k != null ? eventsPer1k.toFixed(1) : '–'}
    </div>

    <h2>Sessions in this group</h2>
    <table class="report-table">
      <thead>
        <tr>
          <th>Date</th>
          <th>Session</th>
          <th>Test object</th>
          <th>ADCU Software</th>
          <th>Participants</th>
          <th>Generated report</th>
          <th>Mileage (km)</th>
          <th>Issues</th>
          <th>KPI score</th>
          <th>Session</th>
        </tr>
      </thead>
      <tbody>
        ${rowsHtml}
      </tbody>
    </table>
  `;

  // Back button → overview
  document.getElementById('back-to-overview-btn')
    ?.addEventListener('click', () => renderOverview());

  // Attach "Open" buttons → loadFile(filename)
  content.querySelectorAll('button.download-button[id^="open_"][data-session]')
    .forEach(btn => {
      btn.addEventListener('click', () => {
        const f = btn.getAttribute('data-session');
        if (f) loadFile(f);
      });
    });

  // Attach "Generated report" buttons → openAiSummaryPopup(filename)
  content.querySelectorAll('button.download-button[id^="gen_"][data-session]')
    .forEach(btn => {
      btn.addEventListener('click', () => {
        const f = btn.getAttribute('data-session');
        if (f) openAiSummaryPopup(f);
      });
    });
}
    
function scoringLegendHtml(){
  return `
  <div class="score-legend" aria-label="Scoring legend (1 worst, 10 best)">
    <div class="score-box s1"><strong>1</strong><small>Worst</small><span class="score-th">≥ 100</span></div>
    <div class="score-box s2"><strong>2</strong><small>Too bad</small><span class="score-th">≥ 50</span></div>
    <div class="score-box s3"><strong>3</strong><small>Bad</small><span class="score-th">≥ 20</span></div>
    <div class="score-box s4"><strong>4</strong><small>Not good</small><span class="score-th">≥ 10</span></div>
    <div class="score-box s5"><strong>5</strong><small>Unacceptable</small><span class="score-th">≥ 5</span></div>
    <div class="score-box s6"><strong>6</strong><small>Marginal</small><span class="score-th">≥ 2</span></div>
    <div class="score-box s7"><strong>7</strong><small>Acceptable</small><span class="score-th">≥ 1.5</span></div>
    <div class="score-box s8"><strong>8</strong><small>Good</small><span class="score-th">≥ 1</span></div>
    <div class="score-box s9"><strong>9</strong><small>Impressive</small><span class="score-th">≥ 0.50</span></div>
    <div class="score-box s10"><strong>10</strong><small>Exceptional</small><span class="score-th">&lt; < 0.50 (</span></div>
  </div>`;
}

    function extractAvgEventsPer1kFromSheet(sheet){
  const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
  if (!rows.length) return null;

  // Match headers like "Events per 1000 km", "Events/1000 km", spacing variants
  const isTargetHeader = (h) => /events?\s*(?:per|\/)\s*1000\s*km/i.test(String(h || ''));

  const hdr = rows[0];
  const colIdx = hdr.findIndex(isTargetHeader);
  if (colIdx < 0) return null;

  const toNum = (v) => {
    if (v == null) return null;
    const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  };

  const vals = [];
  for (let r = 1; r < rows.length; r++){
    const n = toNum(rows[r][colIdx]);
    if (n != null) vals.push(n);
  }
  if (!vals.length) return null;

  //const sum = vals.reduce((a,b)=>a+b,0);
  //return sum / vals.length; // exact mean (no rounding here)
  const sum = vals.reduce((a,b)=>a+b,0);
  return sum;                   // SUM
      
}

    // Map rate (events per 1000 km) -> score 1..10
function scoreFromRate(rate){
  if (rate == null || !isFinite(rate)) return null;
  if (rate >= 100) return 1;
  if (rate >= 50)  return 2;
  if (rate >= 20)  return 3;
  if (rate >= 10)  return 4;
  if (rate >= 5)   return 5;
  if (rate >= 2)   return 6;
  if (rate >= 1.5) return 7;
  if (rate >= 0.5) return 8;
  if (rate >= 0)   return 9;
  return 10;
}

const SCORE_LABEL = {
  1:'Worst',2:'Too bad',3:'Bad',4:'Not good',5:'Unacceptable',
  6:'Marginal',7:'Acceptable',8:'Good',9:'Impressive',10:'Exceptional'
};

function renderScoringLegend(selectedScore){
  const rows = [
    {n:1,  cls:'s1',  lbl:'Worst',        thr:'≥ 100'},
    {n:2,  cls:'s2',  lbl:'Too bad',      thr:'≥ 50'},
    {n:3,  cls:'s3',  lbl:'Bad',          thr:'≥ 20'},
    {n:4,  cls:'s4',  lbl:'Not good',     thr:'≥ 10'},
    {n:5,  cls:'s5',  lbl:'Unacceptable', thr:'≥ 5'},
    {n:6,  cls:'s6',  lbl:'Marginal',     thr:'≥ 2'},
    {n:7,  cls:'s7',  lbl:'Acceptable',   thr:'≥ 1.5'},
    {n:8,  cls:'s8',  lbl:'Good',         thr:'≥ 1'},
    {n:9,  cls:'s9',  lbl:'Impressive',   thr:'≥ 0.5'},
    {n:10, cls:'s10', lbl:'Exceptional',  thr:'< 0.5'},
  ];
  const boxes = rows.map(r =>
    `<div class="score-box ${r.cls}${selectedScore===r.n?' sel':''}">
       <strong>${r.n}</strong><small>${r.lbl}</small><span class="score-th">${r.thr}</span>
     </div>`).join('');
  return `<div class="score-legend">${boxes}</div>`;
}

// Build "Score per function" section based on KPI sheet + KPI_buttons.csv
async function buildScorePerFunctionSection(wb){
  const meta = await getKpiButtonsMeta().catch(() => null);
  if (!meta || !meta.groups || !(meta.groups instanceof Map) || meta.groups.size === 0) {
    console.warn('[KPI] No KPI_buttons.csv meta (groups) found');
    return '';
  }

  const kpiSheetName = wb.SheetNames.find(n => /kpi/i.test(n));
  if (!kpiSheetName) {
    console.warn('[KPI] No KPI sheet found in workbook');
    return '';
  }

  const sheet = wb.Sheets[kpiSheetName];
  const rows  = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
  if (!rows.length) return '';

  const header = rows[0].map(v => String(v ?? '').trim());
  const lower  = header.map(h => h.toLowerCase());

  // "Events per 1000 km" column
  const kpiColIdx = lower.findIndex(h =>
    /events?\s*(?:per|\/)\s*1000\s*km/.test(h)
  );
  if (kpiColIdx < 0) {
    console.warn('[KPI] No "Events per 1000 km" column in KPI sheet');
    return '';
  }

  // Optional explicit group/function/feature/system column
  let groupIdx = lower.findIndex(h => h === 'group');
  if (groupIdx < 0) groupIdx = lower.findIndex(h => /\bgroup\b/.test(h));
  if (groupIdx < 0) groupIdx = lower.findIndex(h => /\bfunction\b/.test(h) || /\bfeature\b/.test(h) || /\bsystem\b/.test(h));

  // Issue column – used both for inference and to detect "No function" KPI
  let issueIdx = lower.findIndex(h => h === 'issue');
  if (issueIdx < 0) issueIdx = lower.findIndex(h => /\bissue\b/.test(h) || /kpi.*id/.test(h) || /\bid\b/.test(h));

  const functionNames = Array.from(meta.groups.keys());
  const issueToGroup  = meta.issueToGroup || new Map();

  // Sort by length desc so "LCC+" matches before "LCC"
  const fnSortedByLen = [...functionNames].sort((a, b) => b.length - a.length);

  const toNum = (v) => {
    if (v == null) return null;
    const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  };

  // Normalise any string (group cell or issue text) to one of our function names
  function normalizeFunctionName(raw){
    if (raw == null) return null;
    const txt = String(raw).trim();
    if (!txt) return null;

    const low = txt.toLowerCase();

    // 1) exact case-insensitive match
    for (const fn of functionNames){
      if (low === fn.toLowerCase()) return fn;
    }

    // 2) substring match (e.g. "ACC – Cut in" → "ACC")
    for (const fn of fnSortedByLen){
      if (low.includes(fn.toLowerCase())) return fn;
    }

    return null;
  }

  // Accumulate data per function
  const data = new Map();
  functionNames.forEach(fn => {
    data.set(fn, {
      hasRow: false,
      hasNumeric: false,
      sum: 0,
      hasNoFunctionKpi: false   // <-- NEW flag
    });
  });

  for (let r = 1; r < rows.length; r++){
    const row = rows[r];
    let fnName = null;

    // 1) Explicit group column (if present)
    if (groupIdx >= 0){
      fnName = normalizeFunctionName(row[groupIdx]);
    }

    // 2) Join via Issue→Group from KPI_buttons.csv
    if (!fnName && issueIdx >= 0 && issueToGroup.size){
      const issueVal = row[issueIdx];
      const key = issueVal == null ? '' : String(issueVal).trim();
      if (issueToGroup.has(key)){
        fnName = issueToGroup.get(key);
      }
    }

    // 3) Infer directly from Issue text
    if (!fnName && issueIdx >= 0){
      fnName = normalizeFunctionName(row[issueIdx]);
    }

    if (!fnName || !data.has(fnName)) continue;

    const entry = data.get(fnName);
    entry.hasRow = true;

    // --- Detect "No function" KPI for this function ---
    const issueText = (issueIdx >= 0 && row[issueIdx] != null)
      ? String(row[issueIdx]).trim().toLowerCase()
      : '';
    const groupText = (groupIdx >= 0 && row[groupIdx] != null)
      ? String(row[groupIdx]).trim().toLowerCase()
      : '';

    if (issueText.startsWith('no function') || groupText.startsWith('no function')){
      entry.hasNoFunctionKpi = true;
    }

    // Sum numeric KPI values
    const rate = toNum(row[kpiColIdx]);
    if (rate != null){
      entry.hasNumeric = true;
      entry.sum += rate;
    }
  }

  // Build table rows with new scoring rules:
  // - If hasNoFunctionKpi → score 0 (No function)
  // - Else if no rows at all → 10 (Exceptional)
  // - Else if rows but no numeric KPI → 10 (Exceptional)
  // - Else → normal scoreFromRate(avg)
  const bodyRows = functionNames
    .sort((a,b) => a.localeCompare(b))
    .map(fn => {
      const entry = data.get(fn) || {
        hasRow:false, hasNumeric:false, sum:0, hasNoFunctionKpi:false
      };
      const expectedKpis = meta.groups.get(fn) || 0;

      let score = null;
      let label = '';
      let rateStr = '–';

      if (entry.hasNoFunctionKpi){
        // Explicit KPI "No function" for this function
        score = 0;
        label = 'No function';
      } else if (!entry.hasRow){
        // Function exists in global KPI list but not used in this session
        score = 10;
        label = 'Exceptional';
      } else if (!entry.hasNumeric){
        // Used but no numeric events → treat as perfect
        score = 10;
        label = 'Exceptional';
      } else {
        const denom = expectedKpis > 0 ? expectedKpis : 1;
        const avg   = entry.sum / denom;
        rateStr     = avg.toFixed(1);
        score       = scoreFromRate(avg);
        label       = SCORE_LABEL[score] || '';
      }

      let scoreHtml;
      if (score === 0){
        scoreHtml = `<span class="kpi-badge s0">0 — No function</span>`;
      } else if (typeof score === 'number'){
        scoreHtml = `<span class="kpi-badge s${score}">${score} — ${escapeHtml(label)}${rateStr !== '–' ? ` (${rateStr} /1000 km)` : ''}</span>`;
      } else {
        scoreHtml = `<span class="kpi-badge s0">N/A</span>`;
      }

      return `
        <tr>
          <td>${escapeHtml(fn)}</td>
          <td>${scoreHtml}</td>
        </tr>`;
    }).join('');

  return `
    <h2>Score per function</h2>
    <table class="report-table">
      <thead>
        <tr><th>Function</th><th>Score</th></tr>
      </thead>
      <tbody>${bodyRows}</tbody>
    </table>`;
}

// Parse KPI_buttons.csv once → total KPIs + per-function counts + Issue→Group map
function getKpiButtonsMeta(){
  if (window.__KPI_META__) return Promise.resolve(window.__KPI_META__);

  const relUrl   = 'KPI_buttons.csv';
  const azureUrl = `${BASE_URL}/KPI_buttons.csv?${SAS_TOKEN}`;

  const parseText = (txt) => {
    const lines = txt.split(/\r?\n/).filter(l => l.trim() !== '');
    if (!lines.length){
      const meta = { totalKpis: 0, groups: new Map(), issueToGroup: new Map() };
      window.__KPI_META__ = meta;
      return meta;
    }

    const headerLine = lines[0];
    const delim = headerLine.includes(';') ? ';' : ',';
    const headers = headerLine.split(delim).map(h => h.trim().toLowerCase());

    const groupIdx = headers.findIndex(h =>
      h === 'group' || /group/.test(h)
    );
    const issueIdx = headers.findIndex(h =>
      h === 'issue' || /issue/.test(h) || /^kpi ?id$/.test(h) || /kpi.*id/.test(h)
    );

    let totalKpis = 0;
    const groups = new Map();
    const issueToGroup = new Map();

    for (let i = 1; i < lines.length; i++){
      const line = lines[i];
      if (!line.trim()) continue;

      // original behaviour: a KPI row contains "redButton" text
      const isKpiRow = line.indexOf('redButton') !== -1;
      if (!isKpiRow) continue;

      const parts = line.split(delim);
      totalKpis++;

      if (groupIdx >= 0){
        const g = (parts[groupIdx] || '').trim();
        if (g){
          groups.set(g, (groups.get(g) || 0) + 1);
        }
      }

      if (groupIdx >= 0 && issueIdx >= 0){
        const g = (parts[groupIdx] || '').trim();
        const issue = (parts[issueIdx] || '').trim();
        if (g && issue){
          issueToGroup.set(issue, g);
        }
      }
    }

    const meta = { totalKpis, groups, issueToGroup };
    window.__KPI_META__ = meta;
    return meta;
  };

  const fetchAndParse = (url) =>
    fetch(nc(url), { cache: 'default' })
      .then(res => {
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.text();
      })
      .then(parseText);

  return fetchAndParse(relUrl)
    .catch(() => fetchAndParse(azureUrl))
    .catch(() => null);
}

// Count total KPIs from KPI_buttons.csv (cached after first load)
function getTotalKpis(){
  return getKpiButtonsMeta().then(meta => meta ? meta.totalKpis : null);
}

function buildTruePositiveDistancesTableHTML(wb){
  const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
  if (!samplingName) return '';

  const sheet = wb.Sheets[samplingName];
  const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
  if (!rows || rows.length < 2) return '';

  const hdr = rows[0].map(v => String(v ?? '').trim());

  // ---- helpers ----
  const toNum = v => {
    if (v == null) return null;
    const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
    const n = parseFloat(s);
    return Number.isFinite(n) ? n : null;
  };

  const isTrueCell = (v) => (
    v === true ||
    v === 1 || v === '1' ||
    (typeof v === 'string' && v.trim().toLowerCase() === 'true') ||
    v === 'TRUE'
  );

  // Pretty-name transform: drop trailing "correct" or "_correct", replace underscores with space
  const pretty = (raw) => String(raw || '')
    .replace(/_?correct\s*$/i, '')
    .replace(/_/g, ' ')
    .replace(/\s+/g, ' ')
    .trim();

  // ---- Distance column (E) detection ----
  let distIdx = 4; // E by default
  if (!hdr[distIdx]) {
    const guess = hdr.findIndex(h => /(^|[^a-z])dist(ance)?([^a-z]|$)|\bkm\b/i.test(h));
    if (guess >= 0) distIdx = guess;
  }

  // Raw values from distance column (could be cumulative OR per-row increments)
  const val = rows.map(r => toNum(r?.[distIdx])); // includes header row as val[0]
  const dataVal = val.slice(1); // data rows only

  // Heuristic: treat as cumulative if ≥70% of deltas are ≥0
  let nonneg = 0, totalD = 0;
  for (let i = 1; i < dataVal.length; i++){
    if (Number.isFinite(dataVal[i]) && Number.isFinite(dataVal[i-1])) {
      totalD++;
      if (dataVal[i] - dataVal[i-1] >= 0) nonneg++;
    }
  }
  const isCumulative = (totalD > 0) ? (nonneg / totalD >= 0.7) : true;

  const cum = [];
  const inc = [];

  if (isCumulative){
    let prev = null;
    for (let r = 1; r < rows.length; r++){
      const cur = dataVal[r-1];
      cum[r] = Number.isFinite(cur) ? cur : (Number.isFinite(cum[r-1]) ? cum[r-1] : null);
      if (Number.isFinite(cur) && Number.isFinite(prev)) inc[r] = Math.max(0, cur - prev);
      else if (Number.isFinite(cur) && !Number.isFinite(prev)) inc[r] = Math.max(0, cur);
      else inc[r] = 0;
      prev = Number.isFinite(cur) ? cur : prev;
    }
  } else {
    // per-row increments → build cumulative by summing
    let acc = 0;
    for (let r = 1; r < rows.length; r++){
      const v = dataVal[r-1];
      const add = Number.isFinite(v) ? Math.max(0, v) : 0;
      acc += add;
      cum[r] = acc;
      inc[r] = add;
    }
  }

  // last cumulative distance (session end)
  let lastCum = null;
  for (let r = rows.length - 1; r >= 1; r--){
    if (Number.isFinite(cum[r])) { lastCum = cum[r]; break; }
  }
  if (lastCum == null) return '';

  // ---- Road type indices (K,L,M) ----
  // Default to fixed columns K/L/M. If headers exist and match, prefer them.
  let kHigh = 10, kCountry = 11, kCity = 12; // 0-based indices for K/L/M

  // Optional header-based detection (nice if someone inserted columns)
  const hLower = hdr.map(h => String(h ?? '').toLowerCase());
  const hiGuess = hLower.findIndex(h => /road[_\s-]*type.*highway/.test(h) || /highway.*road[_\s-]*type/.test(h));
  const coGuess = hLower.findIndex(h => /road[_\s-]*type.*country/.test(h) || /country.*road[_\s-]*type/.test(h));
  const ciGuess = hLower.findIndex(h => /road[_\s-]*type.*city/.test(h) || /city.*road[_\s-]*type/.test(h));

  if (hiGuess >= 0) kHigh = hiGuess;
  if (coGuess >= 0) kCountry = coGuess;
  if (ciGuess >= 0) kCity = ciGuess;

  // Determine row road type: only if EXACTLY one of K/L/M is true
  function rowRoadType(r){
    const row = rows[r] || [];
    const a = isTrueCell(row[kHigh]);
    const b = isTrueCell(row[kCountry]);
    const c = isTrueCell(row[kCity]);
    const n = (a?1:0) + (b?1:0) + (c?1:0);
    if (n !== 1) return null; // ignore (none or multiple)
    if (a) return 'Highway';
    if (b) return 'Country';
    return 'City';
  }

  // ---- Find _correct columns (from I and right) ----
  const candidates = [];
  for (let c = 8; c < hdr.length; c++){
    const name = hdr[c];
    if (/_correct\s*$/i.test(String(name || ''))) candidates.push({ idx: c, name: String(name).trim() });
  }
  if (!candidates.length) return '';

  const results = [];

  for (const { idx, name } of candidates){
    // ===== overall (existing logic) =====
    let tpDist = 0;
    let firstTrueRow = null;

    for (let r = 1; r < rows.length; r++){
      const v = rows[r]?.[idx];
      const isTrue = isTrueCell(v);
      if (!isTrue) continue;
      if (firstTrueRow == null) firstTrueRow = r;
      tpDist += (inc[r] || 0);
    }

    if (firstTrueRow == null) continue;

    const distAtFirstTrue = cum[firstTrueRow];
    if (!Number.isFinite(distAtFirstTrue)) continue;

    const totalDist = Math.max(0, lastCum - distAtFirstTrue);
    if (totalDist <= 0) continue;

    const baseName = pretty(name);
    results.push({ name: `${baseName} — Total`, pct: (tpDist / totalDist) * 100 });

    // ===== per-road-type (NEW) =====
    const roadTypes = ['Highway', 'Country', 'City'];

    for (const rt of roadTypes){
      let firstTrueRowRT = null;

      // Find first row where KPI is true AND road type matches (and K/L/M is exclusive)
      for (let r = 1; r < rows.length; r++){
        if (rowRoadType(r) !== rt) continue;
        const v = rows[r]?.[idx];
        if (isTrueCell(v)) { firstTrueRowRT = r; break; }
      }
      if (firstTrueRowRT == null) continue;

      // Denominator: distance in that road type from firstTrueRowRT to end (exclusive K/L/M rows only)
      let denom = 0;
      let numer = 0;

      for (let r = firstTrueRowRT; r < rows.length; r++){
        if (rowRoadType(r) !== rt) continue; // ignore non-exclusive or other types
        const dInc = (inc[r] || 0);
        denom += dInc;

        const v = rows[r]?.[idx];
        if (isTrueCell(v)) numer += dInc;
      }

      if (denom > 0){
        results.push({
          name: `${baseName} — ${rt}`,
          pct: (numer / denom) * 100
        });
      }
    }
  }

  if (!results.length) return '';

  const rowsHtml = results
    .map(r => `<tr><td>${escapeHtml(r.name)}</td><td>${r.pct.toFixed(1)}%</td></tr>`)
    .join('');

  return `
    <h2>True positive distances</h2>
    <table class="report-table">
      <thead><tr><th>True positive KPI</th><th>Percentage</th></tr></thead>
      <tbody>${rowsHtml}</tbody>
    </table>
  `;
}

// ---------- SESSION VIEWER ----------

// Make a SheetJS-generated table look like our "TP distances" table:
// - add .report-table
// - ensure we have <thead> and header cells are <th> (not <td>)
function unifyReportTableStyle(tbl){
  if (!tbl || !(tbl instanceof HTMLTableElement)) return;

  tbl.classList.add('report-table');

  // If there is a header row but no THEAD, promote the first row to THEAD
  let headRow = tbl.tHead?.rows?.[0] || null;
  if (!headRow){
    const firstRow = tbl.querySelector('tr');
    if (firstRow){
      const thead = document.createElement('thead');
      headRow = document.createElement('tr');

      [...firstRow.cells].forEach((cell) => {
        const th = document.createElement('th');
        th.innerHTML = cell.innerHTML;
        headRow.appendChild(th);
      });

      thead.appendChild(headRow);
      tbl.insertBefore(thead, tbl.firstChild);
      firstRow.remove();

      // Wrap remaining rows in TBODY if needed
      if (!tbl.tBodies.length){
        const tbody = document.createElement('tbody');
        while (thead.nextSibling){
          tbody.appendChild(thead.nextSibling);
        }
        tbl.appendChild(tbody);
      }
    }
  } else {
    // Ensure header cells are TH, not TD
    [...headRow.cells].forEach((cell) => {
      if (cell.tagName.toLowerCase() === 'td'){
        const th = document.createElement('th');
        th.innerHTML = cell.innerHTML;
        cell.replaceWith(th);
      }
    });
  }
}

// --- Save "Additional comments" back into the XLSX on Azure --------------------
async function savePostHocCommentToXlsx(filename, wb, sheetName, commentText){
  // Get existing sheet or create a minimal one
  let sheet = wb.Sheets[sheetName];
  let rows = [];
  if (sheet){
    rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
  }
  if (!rows.length){
    rows = [['Label', 'Value']];
  }

  // Append a new row with timestamped label
  const label = `Additional comment (${formatTimestampForLabel()})`;
  rows.push([label, commentText]);

  // Write rows back into the sheet
  sheet = XLSX.utils.aoa_to_sheet(rows);
  wb.Sheets[sheetName] = sheet;
  if (!wb.SheetNames.includes(sheetName)) wb.SheetNames.push(sheetName);

  const out = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
  const blob = new Blob(
    [out],
    { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }
  );

  const url = `${BASE_URL}/${filename}?${SAS_TOKEN}`;
  const res = await fetch(url, {
    method: 'PUT',
    headers: {
      'x-ms-blob-type': 'BlockBlob',
      'Content-Type': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    },
    body: blob
  });

  if (!res.ok){
    throw new Error('Upload failed: ' + res.status + ' ' + res.statusText);
  }

  // Rebuild Test details table from updated sheet
  rerenderTestDetailsTable(wb);
}

// Inject UI under the Test details table
function injectPostHocCommentUI(filename, wb, sheetName, contentEl){
  const safeId    = cssSafeId(filename + '_posthoc');
  const taId      = 'phc_text_'   + safeId;
  const btnId     = 'phc_btn_'    + safeId;
  const statusId  = 'phc_status_' + safeId;

  const container = document.createElement('div');
  container.style.margin = '12px 0 24px';
  container.innerHTML = `
    <h3>Additional comment</h3>
    <textarea id="${taId}"
              rows="3"
              style="width:100%;max-width:800px;"
              placeholder="Add your comment here..."></textarea>
    <br>
    <button id="${btnId}" style="margin-top:6px;">Add comment</button>
    <span id="${statusId}" style="margin-left:10px;font-size:12px;color:#555;"></span>
  `;
  contentEl.appendChild(container);

  const textarea = document.getElementById(taId);
  const button   = document.getElementById(btnId);
  const status   = document.getElementById(statusId);

  button.addEventListener('click', async () => {
    const txt = (textarea.value || '').trim();
    if (!txt){
      status.textContent = 'Please write a comment before saving.';
      return;
    }

    status.textContent = 'Saving…';

    try{
      await savePostHocCommentToXlsx(filename, wb, sheetName, txt);

      // reset field → only ghost text from placeholder is visible
      textarea.value = '';

      status.textContent = 'Saved to XLSX.';
    } catch(err){
      console.error(err);
      status.textContent = 'Save failed: ' + err.message;
    }
  });
}

function buildRoadCategoryTableFromRoadTypesTable(tbl) {
  if (!tbl || tbl.dataset.hasCategoryTable === '1') return;
  tbl.dataset.hasCategoryTable = '1';   // prevent duplicates if loadFile is called again

  const rows = Array.from(tbl.querySelectorAll('tr'));
  if (rows.length < 2) return; // no data

  const catStats = new Map();  // "Highway" → { distanceKm, issues }
  let totalKm = 0;

  for (let i = 1; i < rows.length; i++) {
    const cells = rows[i].cells;
    if (cells.length < 4) continue;

    const type   = cells[0].textContent.trim();
    if (!type) continue;

    // Distance (km) is column 2
    const distKmRaw = cells[1].textContent || '';
    const distKm = parseFloat(
      distKmRaw.replace(/[^\d,.\-]/g, '').replace(',', '.')
    ) || 0;

    // No of issues is column 4
    const issuesRaw = cells[3].textContent || '';
    const issues = parseInt(issuesRaw.replace(/[^\d\-]/g, ''), 10) || 0;

    // Ignore rows that are completely empty
    if (distKm === 0 && issues === 0) continue;

    const cat = classifyRoadType(type);
    if (!catStats.has(cat)) {
      catStats.set(cat, { distanceKm: 0, issues: 0 });
    }
    const entry = catStats.get(cat);
    entry.distanceKm += distKm;
    entry.issues     += issues;
    totalKm          += distKm;
  }

  if (totalKm <= 0 || !catStats.size) return;

  // Create heading
  const heading = document.createElement('h2');
  heading.textContent = 'Road categories';

  // Create table
  const newTable = document.createElement('table');
  newTable.className = 'report-table';
  newTable.id = 'Road categories';

  const bodyRowsHtml = Array.from(catStats.entries())
    .sort(([a], [b]) => {
      const order = {
        'Highway': 0,
        'Country road': 1,
        'City road': 2,
        'Construction': 3,
        'Unclassified': 4
      };
      return (order[a] ?? 99) - (order[b] ?? 99);
    })
    .map(([cat, { distanceKm, issues }]) => {
      const pct = totalKm ? (distanceKm / totalKm) * 100 : 0;
      return `
        <tr>
          <td>${escapeHtml(cat)}</td>
          <td>${distanceKm.toFixed(1)}</td>
          <td>${pct.toFixed(1)}</td>
          <td>${issues}</td>
        </tr>`;
    }).join('');

  newTable.innerHTML = `
    <thead>
      <tr>
        <th>Road category</th>
        <th>Distance (km)</th>
        <th>Distance (%)</th>
        <th>No of issues</th>
      </tr>
    </thead>
    <tbody>
      ${bodyRowsHtml}
    </tbody>
  `;

  // Insert heading + new table *below* the original Road types table
  tbl.insertAdjacentElement('afterend', newTable);
  tbl.insertAdjacentElement('afterend', heading);
}   

// ---------- MODAL HELPERS FOR DELETE SESSION ----------

function createModal(innerHtml) {
  const overlay = document.createElement('div');
  overlay.className = 'modal-overlay';
  overlay.innerHTML = `<div class="modal-dialog">${innerHtml}</div>`;
  document.body.appendChild(overlay);
  return overlay;
}

function showDeleteAuthDialog(filename, filesToDelete) {
  const overlay = createModal(`
    <h3>Delete session</h3>
    <p>Enter admin credentials to delete this session.</p>
    <label>Username</label>
    <input type="text" name="username" autocomplete="off">
    <label>Password</label>
    <input type="password" name="password" autocomplete="off">
    <div class="modal-buttons">
      <button type="button" class="secondary-button cancel-btn">Cancel</button>
      <button type="button" class="danger-button auth-ok-btn">Continue</button>
    </div>
    <p class="modal-error" style="display:none;"></p>
  `);

  const dialog    = overlay.querySelector('.modal-dialog');
  const userInput = dialog.querySelector('input[name="username"]');
  const passInput = dialog.querySelector('input[name="password"]');
  const cancelBtn = dialog.querySelector('.cancel-btn');
  const okBtn     = dialog.querySelector('.auth-ok-btn');
  const errEl     = dialog.querySelector('.modal-error');

  cancelBtn.addEventListener('click', () => {
    document.body.removeChild(overlay);
  });

  okBtn.addEventListener('click', () => {
    const u = (userInput.value || '').trim();
    const p = passInput.value || '';

    if (u === 'admin' && p === 'password') {
      document.body.removeChild(overlay);
      showDeleteConfirmDialog(filename, filesToDelete);
    } else {
      errEl.textContent = 'Invalid username or password.';
      errEl.style.display = 'block';
    }
  });

  userInput.focus();
}

function showDeleteConfirmDialog(filename, filesToDelete) {
  const listHtml = filesToDelete
    .map(f => `<li>${escapeHtml(f)}</li>`)
    .join('');

  const overlay = createModal(`
    <h3>Confirm deletion</h3>
    <p>The following files will be permanently deleted from Azure:</p>
    <ul>${listHtml}</ul>
    <div class="modal-buttons">
      <button type="button" class="secondary-button cancel-btn">Cancel</button>
      <button type="button" class="danger-button confirm-delete-btn">Yes, OK to delete</button>
    </div>
    <p class="modal-error modal-status" style="display:none;"></p>
  `);

  const dialog    = overlay.querySelector('.modal-dialog');
  const cancelBtn = dialog.querySelector('.cancel-btn');
  const confirmBtn = dialog.querySelector('.confirm-delete-btn');
  const statusEl   = dialog.querySelector('.modal-status');

  cancelBtn.addEventListener('click', () => {
    document.body.removeChild(overlay);
  });

  confirmBtn.addEventListener('click', () => {
    confirmBtn.disabled = true;
    cancelBtn.disabled  = true;
    statusEl.style.display = 'block';
    statusEl.textContent   = 'Deleting...';

    const deleteOne = (blobName) =>
      fetch(`${BASE_URL}/${blobName}?${SAS_TOKEN}`, { method: 'DELETE' })
        .then(res => {
          // treat 404 as "already gone", not an error
          if (!res.ok && res.status !== 404) {
            throw new Error(`Failed to delete ${blobName} (HTTP ${res.status})`);
          }
        });

    Promise.all(filesToDelete.map(deleteOne))
      .then(() => {
        statusEl.textContent = 'Session deleted. Reloading...';
        setTimeout(() => {
          document.body.removeChild(overlay);
          // Reload to refresh blob list + sidebar
          location.reload();
        }, 800);
      })
      .catch(err => {
        console.error(err);
        statusEl.textContent = 'Delete failed: ' + err.message;
        confirmBtn.disabled = false;
        cancelBtn.disabled  = false;
      });
  });
}
    
function loadFile(filename) {
  setActiveSessionInSidebar(filename); 
  currentReportFileName = filename;
  const content = document.getElementById('content');
  content.innerHTML = '';

  let _activeSessionFilename = null;

  // 🔹 If this file is in a group, show the button
  const groupKey = fileToTestGroup.get(filename);
  if (groupKey) {
    const backToGroupBtn = document.createElement('button');
    backToGroupBtn.type = 'button';
    backToGroupBtn.className = 'download-button nav-button';
    backToGroupBtn.innerHTML = '← View test group';
    backToGroupBtn.style.marginRight = '12px';
    backToGroupBtn.addEventListener('click', () => openTestGroupViewByLabel(groupKey));
    content.appendChild(backToGroupBtn);
  }
  
  issueCoords = [];
  samplingCoords = [];
  mapRef = null;

  // Fallbacks if globals aren't defined
  const _scoreFromRate = (typeof scoreFromRate === 'function') ? scoreFromRate : function(rate){
    if (rate == null || !isFinite(rate)) return null;
    if (rate >= 100) return 1;
    if (rate >= 50)  return 2;
    if (rate >= 20)  return 3;
    if (rate >= 10)  return 4;
    if (rate >= 5)   return 5;
    if (rate >= 2)   return 6;
    if (rate >= 1.5) return 7;
    if (rate >= 0.5) return 8;
    if (rate >= 0)   return 9;
    return 10;
  };
  const _SCORE_LABEL = (typeof SCORE_LABEL === 'object' && SCORE_LABEL) ? SCORE_LABEL : {
    1:'Worst',2:'Too bad',3:'Bad',4:'Not good',5:'Unacceptable',
    6:'Marginal',7:'Acceptable',8:'Good',9:'Impressive',10:'Exceptional'
  };
  const _renderScoringLegend = (typeof renderScoringLegend === 'function')
    ? renderScoringLegend
    : function(selectedScore){
        const rows = [
          {n:1,  cls:'s1',  lbl:'Worst',        thr:'≥ 100'},
          {n:2,  cls:'s2',  lbl:'Too bad',      thr:'≥ 60'},
          {n:3,  cls:'s3',  lbl:'Bad',          thr:'≥ 40'},
          {n:4,  cls:'s4',  lbl:'Not good',     thr:'≥ 30'},
          {n:5,  cls:'s5',  lbl:'Unacceptable', thr:'≥ 20'},
          {n:6,  cls:'s6',  lbl:'Marginal',     thr:'≥ 15'},
          {n:7,  cls:'s7',  lbl:'Acceptable',   thr:'≥ 10'},
          {n:8,  cls:'s8',  lbl:'Good',         thr:'≥ 5'},
          {n:9,  cls:'s9',  lbl:'Impressive',   thr:'≥ 1'},
          {n:10, cls:'s10', lbl:'Exceptional',  thr:'< 1 (incl. 0)'},
        ];
        return '<div class="score-legend">' + rows.map(function(r){
          return '<div class="score-box ' + r.cls + (selectedScore===r.n?' sel':'') + '">' +
                   '<strong>' + r.n + '</strong><small>' + r.lbl + '</small><span class="score-th">' + r.thr + '</span>' +
                 '</div>';
        }).join('') + '</div>';
      };

  // Local helper: SUM of "Events per 1000 km" column from a KPI sheet
  function extractSumEventsPer1kFromSheet(sheet){
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, blankrows: false });
    if (!rows.length) return null;
    const isTargetHeader = h => /events?\s*(?:per|\/)\s*1000\s*km/i.test(String(h || ''));
    const hdr = rows[0];
    const colIdx = hdr.findIndex(isTargetHeader);
    if (colIdx < 0) return null;

    const toNum = v => {
      if (v == null) return null;
      const s = String(v).trim().replace(/[^\d,.\-]/g,'').replace(',', '.');
      const n = parseFloat(s);
      return Number.isFinite(n) ? n : null;
    };

    let sum = 0, have = false;
    for (let r = 1; r < rows.length; r++){
      const n = toNum(rows[r][colIdx]);
      if (n != null){ sum += n; have = true; }
    }
    return have ? sum : null;
  }

  const issueTableInfo = {
    sheetName: null,
    headerNames: { col1: '', col2: '', col3: '' },
    issueInfo: {}
  };

let issueMountainData = [];
let issueMountainInserted = false;
const issueMountainHostId = `issue_mountain_${cssSafeId(filename)}`;  
  
// Base name without extension, e.g. "Annotator_report_2025-12-17_091939"
const baseNoExt = filename.replace(/\.xlsx$/i, '');

// Files that belong to this session
const filesToDelete = [
  filename,                 // the .xlsx
  `${baseNoExt}.json`,      // parsed summary JSON
  `${baseNoExt}.zip`,       // issue images
  `${baseNoExt}_2.zip`,     // speed/accel plots
  `${baseNoExt}.txt`,       // AI summary text file
  `${baseNoExt}_route_infographic.png`
];

  // 🔴 Delete session button (before download links)
  const deleteBtn = document.createElement('button');
  deleteBtn.type = 'button';
  deleteBtn.textContent = 'Delete session';
  deleteBtn.className = 'download-button danger-button';
  deleteBtn.addEventListener('click', () => {
    showDeleteAuthDialog(filename, filesToDelete);
  });
  content.appendChild(deleteBtn);
  
  // Download XLSX
  const xlsxLink = document.createElement('a');
  xlsxLink.href = `${BASE_URL}/${filename}?${SAS_TOKEN}`;
  xlsxLink.textContent = 'Download XLSX';
  xlsxLink.className = 'download-button';
  xlsxLink.setAttribute('download', filename);
  content.appendChild(xlsxLink);

  // 1) Download issue images (always shown)
  const imgZipFilename = `${baseNoExt}.zip`;
  const imgZipLink = document.createElement('a');
  imgZipLink.href = `${BASE_URL}/${imgZipFilename}?${SAS_TOKEN}`;
  imgZipLink.textContent = 'Download images';
  imgZipLink.className = 'download-button';
  imgZipLink.setAttribute('download', imgZipFilename);
  content.appendChild(imgZipLink);

  // 2) Download issue speed/acceleration plots (always shown)
  const accelZipFilename = `${baseNoExt}_2.zip`;
  const accelZipLink = document.createElement('a');
  accelZipLink.href = `${BASE_URL}/${accelZipFilename}?${SAS_TOKEN}`;
  accelZipLink.textContent = 'Download speed/acceleration plots';
  accelZipLink.className = 'download-button';
  accelZipLink.setAttribute('download', accelZipFilename);
  content.appendChild(accelZipLink);

  // === Use cached workbook ===
  loadWorkbook(filename)
    .then(async ({ wb /*, buf*/ }) => {
      const samplingName = wb.SheetNames.find(n => n.toLowerCase() === 'sampling');
      if (samplingName) parseSamplingSheet(wb.Sheets[samplingName]);

      let nonSamplingCount = 0;
      let mapInserted = false;

      // Pre-fetch total KPIs once
      const totalKpisPromise = getTotalKpis();

      // Build once; we'll insert these right before the Statistics sheet
      const tpSectionHtml = buildTruePositiveDistancesTableHTML(wb);
      const scorePerFunctionHtml = await buildScorePerFunctionSection(wb);
      let extraSectionsInserted = false;

      wb.SheetNames.forEach(sheet => {
        if (sheet.toLowerCase() === 'sampling') return;

        // Insert [True positive distances] + [Score per function] BEFORE "Statistics" sheet
        if (!extraSectionsInserted && /statistics/i.test(sheet)) {
          let blockHtml = '';
          if (tpSectionHtml) blockHtml += tpSectionHtml;
          if (scorePerFunctionHtml) blockHtml += scorePerFunctionHtml;
          if (blockHtml){
            content.insertAdjacentHTML('beforeend', blockHtml);
            extraSectionsInserted = true;
          }
        }

        const html = XLSX.utils.sheet_to_html(wb.Sheets[sheet], { id: sheet });
        content.insertAdjacentHTML('beforeend', `<h2>${sheet}</h2>${html}`);

        // Style all tables EXCEPT "Test details"
        if (!/^\s*test\s*details\s*$/i.test(sheet)) {
          const tbl = document.getElementById(sheet);
          if (tbl) unifyReportTableStyle(tbl);
        }
        
        // For "Test details" sheet: add AI summary row + Additional comments editor
        if (/^\s*test\s*details\s*$/i.test(sheet)) {
          const tbl = document.getElementById(sheet);
          if (tbl) {
            addAiSummaryRow(tbl);  // <--- AI summary row
          }
          injectPostHocCommentUI(filename, wb, sheet, content);
        }

        // For "Road types" sheet: build aggregated Road categories table below it
        if (/^\s*road\s*types?\s*$/i.test(sheet)) {
          const tbl = document.getElementById(sheet);
          if (tbl) {
            buildRoadCategoryTableFromRoadTypesTable(tbl);
          }
        }
        
        // First sheet with lat/lon → collect issues + headers
        if (!issueTableInfo.sheetName) {
          const tbl = document.getElementById(sheet);
          const rows = Array.from(tbl.querySelectorAll('tr'));
          if (rows.length > 1) {
            const hdrs = Array.from(rows[0].querySelectorAll('th,td')).map(c => c.textContent.trim().toLowerCase());
            const latIdx = hdrs.findIndex(h => h.includes('lat'));
            const lonIdx = hdrs.findIndex(h => h.includes('lon'));
            if (latIdx >= 0 && lonIdx >= 0) {
              issueTableInfo.sheetName = sheet;
              const rawHdrs = Array.from(rows[0].querySelectorAll('th,td'));
              issueTableInfo.headerNames.col1 = (rawHdrs[0]?.textContent || '').trim();
              issueTableInfo.headerNames.col2 = (rawHdrs[1]?.textContent || '').trim();
              issueTableInfo.headerNames.col3 = (rawHdrs[12]?.textContent || '').trim();

              rows.slice(1).forEach(row => {
                const cells = Array.from(row.querySelectorAll('td'));
                const issueNo = (cells[0]?.textContent || '').trim();
                const col1 = issueNo;
                const col2 = (cells[1]?.textContent || '').trim();
                const col3 = (cells[12]?.textContent || '').trim();
                const lat = parseFloat((cells[latIdx]?.textContent || '').trim());
                const lon = parseFloat((cells[lonIdx]?.textContent || '').trim());
                if (!isNaN(lat) && !isNaN(lon)) {
                  issueCoords.push({ issueNo, lat, lon });
                }
                if (issueNo) {
                  issueTableInfo.issueInfo[issueNo] = { issueNo, col1, col2, col3, lat, lon };
                }
                // --- NEW: build mountain row ---
                const distKm = (distIdx >= 0) ? parseDistanceKmFromCell(cells[distIdx]?.textContent) : null;
                const timeMs = (timeIdx >= 0) ? parseTimeToMs(cells[timeIdx]?.textContent) : null;
                const phase  = (phaseIdx >= 0) ? normCat(cells[phaseIdx]?.textContent) : null;
                const weather= (weatherIdx >= 0) ? normCat(cells[weatherIdx]?.textContent) : null;
                const roadCat= (roadIdx >= 0) ? roadCatFromCell(cells[roadIdx]?.textContent) : null;

                if (distKm != null) {
                  issueMountainData.push({ distKm, timeMs, phase, weather, roadCat });
                }
              });
              // --- NEW: insert the Issue mountain right under this Issues table (once) ---
              if (!issueMountainInserted) {
                issueMountainInserted = true;

                const mountainHost = document.createElement('div');
                mountainHost.id = issueMountainHostId;
                // insert right under the issues table
                tbl.insertAdjacentElement('afterend', mountainHost);

                // render (after DOM insert)
                renderIssueMountain(issueMountainData, issueMountainHostId);
              }
            }
          }
        }

        // KPI sheet → compute average from SUM / total KPIs (1 decimal) + legend
        if (/kpi/i.test(sheet)) {
          const kpiTable = document.getElementById(sheet);
          if (kpiTable) {
            kpiTable.style.marginBottom = '6px'; // tighter gap

            totalKpisPromise.then(totalKpis => {
              const inserts = [];
              const sum = extractSumEventsPer1kFromSheet(wb.Sheets[sheet]);
              if (sum != null && typeof totalKpis === 'number' && totalKpis > 0) {
                const avg = sum / totalKpis;
                const avg1 = Math.round(avg * 10) / 10; // numeric 1-dec
                inserts.push(
                  `<div class="kpi-avg">Average <em>events per 1000 km</em>: <span class="v">${avg1.toFixed(1)}</span></div>`
                );
                const score = _scoreFromRate(avg1);
                inserts.push(_renderScoringLegend(score));
                inserts.push(
                  `<div class="score-legend-caption">Score: <strong>${score}</strong> — ${_SCORE_LABEL[score]} (sum ÷ total KPIs = ${(+sum).toLocaleString(undefined,{maximumFractionDigits:1})} ÷ ${totalKpis})</div>`
                );
              } else {
                inserts.push(_renderScoringLegend(null));
                inserts.push('<div class="score-legend-caption">Total KPIs unavailable — cannot compute average.</div>');
              }
              if (inserts.length) kpiTable.insertAdjacentHTML('afterend', inserts.join(''));
            });
          }
        }

        nonSamplingCount++;
        if (nonSamplingCount === 2 && !mapInserted) {
          const mapDiv = document.createElement('div');
          mapDiv.id = 'issue-map';
          mapDiv.style.width = '100%';
          mapDiv.style.height = '400px';
          mapDiv.style.margin = '20px 0';
          mapDiv.style.border = '1px solid #aaa';
          content.appendChild(mapDiv);
          mapInserted = true;
        }
      });
    })
    .then(() => {
      if (!document.getElementById('issue-map')) {
        const mapDiv = document.createElement('div');
        mapDiv.id = 'issue-map';
        mapDiv.style.width = '100%';
        mapDiv.style.height = '400px';
        mapDiv.style.margin = '20px 0';
        mapDiv.style.border = '1px solid #aaa';
        document.getElementById('content').appendChild(mapDiv);
      }
      if (issueCoords.length || samplingCoords.length) {
        initMap();
      } else {
        const ph = document.getElementById('issue-map');
        const err = document.createElement('div');
        err.className = 'error';
        err.innerHTML = `Need at least 1 issue or sampling point to plot a map (found ${issueCoords.length} issues, ${samplingCoords.length} sampling points).`;
        ph.replaceWith(err);
      }
    })
    .then(() => {
      // Issue snapshots LAST (below everything)
      const zipFilename = filename.replace(/\.xlsx$/i, '.zip');
      return fetch(`${BASE_URL}/${zipFilename}?${SAS_TOKEN}`, { cache:'default' })
        .then(resp => {
          if (!resp.ok) throw new Error('ZIP not found');
          return resp.arrayBuffer();
        })
        .then(buf => JSZip.loadAsync(buf))
        .then(zip => {
          const title = document.createElement('h2');
          title.textContent = 'Issue snapshots';

          const table = document.createElement('table');
          table.id = 'issue-snapshots';
          table.classList.add('report-table');        // unified look
          table.style.width = 'auto';
          table.style.marginBottom = '2em';
          table.style.borderCollapse = 'collapse';

const hdrRow = document.createElement('tr');
['col1','col2','col3','Location','Snapshot','Street/Map View'].forEach(txt => {
  const th = document.createElement('th');
  th.textContent = (txt.startsWith('col') ? ( {col1:'',col2:'',col3:''}[txt] = 1, issueTableInfo.headerNames[txt] ) : txt) || txt;
  th.style.backgroundColor = '#f5f5f5';
  th.style.padding = '8px';
  th.style.border = '1px solid #ccc';
  hdrRow.appendChild(th);
});
table.appendChild(hdrRow);

          zip.forEach((path, entry) => {
            if (entry.dir || !/\.(jpe?g|png|gif)$/i.test(path)) return;
            const issueNo = path.replace(/\.[^/.]+$/, '');
            const info = issueTableInfo.issueInfo[issueNo];
            if (!info) return;

            const row = document.createElement('tr');
[info.col1, info.col2, info.col3].forEach(val => {
  const td = document.createElement('td');
  td.textContent = val;
  td.style.padding = '8px';
  td.style.border = '1px solid #ccc';
  row.appendChild(td);
});

const tdMap = document.createElement('td');
tdMap.style.padding = '8px';
tdMap.style.border = '1px solid #ccc';
const miniDiv = document.createElement('div');
miniDiv.id = `snapshot-map-${cssSafeId(issueNo)}`;
miniDiv.style.width = '150px';
miniDiv.style.height = '150px';
tdMap.appendChild(miniDiv);
row.appendChild(tdMap);

const tdImg = document.createElement('td');
tdImg.style.padding = '8px';
tdImg.style.border = '1px solid ' + '#ccc';

// image + mini map creation stays the same
entry.async('blob').then(rawBlob => {
  let mime = 'application/octet-stream';
  if (/\.(jpe?g)$/i.test(path)) mime = 'image/jpeg';
  else if (/\.png$/i.test(path)) mime = 'image/png';
  else if (/\.gif$/i.test(path)) mime = 'image/gif';
  const blob = new Blob([rawBlob], { type: mime });
  const url  = URL.createObjectURL(blob);

  const link = document.createElement('a');
  link.href = url; link.target = '_blank'; link.rel = 'noopener noreferrer';

  const img = document.createElement('img');
  img.src = url; img.style.maxWidth = '200px'; img.style.maxHeight = '200px'; img.style.cursor = 'pointer';
  link.appendChild(img);
  tdImg.appendChild(link);

  const miniMap = L.map(miniDiv, { attributionControl:false, zoomControl:false }).setView([info.lat, info.lon], 17);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(miniMap);
  const badgeIcon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
  L.marker([info.lat, info.lon], { icon: badgeIcon }).addTo(miniMap);
  const circle = L.circle([info.lat, info.lon], { radius: 100 }).addTo(miniMap);
  miniMap.fitBounds(circle.getBounds(), { padding:[4,4] });
  miniMap.invalidateSize();
});

row.appendChild(tdImg);

// 🔹 NEW: Street View column
const tdSv = document.createElement('td');
tdSv.style.padding = '8px';
tdSv.style.border = '1px solid #ccc';

if (Number.isFinite(info.lat) && Number.isFinite(info.lon)) {
  const wrap = document.createElement('div');

  const svLink = document.createElement('a');
  svLink.href = `https://www.google.com/maps/@?api=1&map_action=pano&viewpoint=${info.lat},${info.lon}`;
  svLink.target = '_blank';
  svLink.rel = 'noopener noreferrer';
  svLink.textContent = 'Street View';
  wrap.appendChild(svLink);

  const sep = document.createTextNode(' · ');
  wrap.appendChild(sep);

  const mapLink = document.createElement('a');
  mapLink.href = `https://www.google.com/maps/search/?api=1&query=${info.lat},${info.lon}`;
  mapLink.target = '_blank';
  mapLink.rel = 'noopener noreferrer';
  mapLink.textContent = 'Map';
  wrap.appendChild(mapLink);

  tdSv.appendChild(wrap);
} else {
  tdSv.textContent = 'N/A';
}

row.appendChild(tdSv);
table.appendChild(row);
          });

          content.appendChild(title);
          content.appendChild(table);
        })
        .catch(() => { /* optional ZIP; ignore */ });
    })
    .catch(err => {
      console.error(err);
      document.getElementById('content').innerHTML += `<div class="error">Failed to load ${filename}: ${err}</div>`;
    });
}

    function parseSamplingSheet(sheet) {
      const raw = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      if (raw.length < 2) return;
      const headers = raw[0].map(h => String(h).trim().toLowerCase());
      const latIdx = headers.findIndex(h => h.includes('lat'));
      const lonIdx = headers.findIndex(h => h.includes('lon') || h.includes('lng') || h.includes('long'));
      if (latIdx < 0 || lonIdx < 0) return;
      for (let i = 1; i < raw.length; i++) {
        const row = raw[i];
        const lat = parseFloat(row[latIdx]);
        const lon = parseFloat(row[lonIdx]);
        if (!isNaN(lat) && !isNaN(lon)) samplingCoords.push({ lat, lon });
      }
    }

    function initMap() {
      mapRef = L.map('issue-map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(mapRef);

      const allPoints = [
        ...issueCoords.map(c => [c.lat, c.lon]),
        ...samplingCoords.map(c => [c.lat, c.lon]),
      ];
      if (allPoints.length > 0) mapRef.fitBounds(allPoints);

      issueCoords.forEach(c => {
        const icon = L.divIcon({ className: 'issue-label', html: `<div class="issue-badge">${c.issueNo}</div>`, iconSize: [24,24], iconAnchor: [12,12] });
        L.marker([c.lat, c.lon], { icon }).addTo(mapRef);
      });

      samplingLayerGroup = L.layerGroup(
        samplingCoords.map(c => L.circleMarker([c.lat, c.lon], { radius: 3, color: 'blue', fillOpacity: 0.6, weight: 1 }))
      ).addTo(mapRef);

      mapRef.whenReady(() => mapRef.invalidateSize());
    }

    function showError(message) {
      document.getElementById('sidebar').innerHTML = `<div class="error">${message}</div>`;
    }
  </script>
</body>
</html>
